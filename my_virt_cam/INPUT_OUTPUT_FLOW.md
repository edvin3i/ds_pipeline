# Документация: Входные данные и поток обработки плагина nvdsvirtualcam

## Обзор
Плагин **nvdsvirtualcam** - это GStreamer трансформирующий элемент, который принимает **панорамное изображение** и создаёт **виртуальную камеру** с возможностью управления углами обзора (yaw/pitch/roll) и зумом (FOV).

---

## 1. ЧТО ПРИНИМАЕТ ПЛАГИН НА ВХОД

### 1.1 Формат входных данных (SINK pad)

**Файл:** `gstnvdsvirtualcam.cpp:65-71`

```cpp
static GstStaticPadTemplate sink_template =
    GST_STATIC_PAD_TEMPLATE("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
                            GST_STATIC_CAPS("video/x-raw(memory:NVMM), "
                                          "format=RGBA, "
                                          "width=(int)[1,10000], "     // Динамическая ширина
                                          "height=(int)[1,3000], "     // Динамическая высота
                                          "framerate=(fraction)[0/1,MAX]"));
```

#### Требования к входному видео:

| Параметр | Значение | Описание |
|----------|----------|----------|
| **Тип памяти** | `memory:NVMM` | NVIDIA Multimedia Memory (GPU память) |
| **Формат пикселей** | `RGBA` | 4 канала (Red, Green, Blue, Alpha) |
| **Разрешение** | `1-10000 × 1-3000` | Динамическое (любой размер в этом диапазоне) |
| **Framerate** | Любой | От 0 fps до максимума |

#### Типы поддерживаемой памяти:

**Файл:** `gstnvdsvirtualcam.cpp:732-770`

1. **NVBUF_MEM_SURFACE_ARRAY** (предпочтительный для Jetson):
   - Используется EGL маппинг для доступа к GPU памяти
   - Кешируется для повторного использования
   - Автоматическая регистрация в CUDA

2. **NVBUF_MEM_CUDA_DEVICE**:
   - Нативная CUDA память
   - Прямой доступ без маппинга

3. **NVBUF_MEM_CUDA_UNIFIED**:
   - Unified Memory (доступна и с CPU, и с GPU)

**⚠️ НЕ поддерживаются:** CPU память (system memory), CUDA pinned memory

---

### 1.2 Обязательные Properties (параметры)

**Файл:** `gstnvdsvirtualcam.cpp:794-815`

Плагин **ТРЕБУЕТ** явного указания размеров панорамы через properties:

```python
pipeline:
    nvdsvirtualcam \
        panorama-width=5700 \      # ← ОБЯЗАТЕЛЬНО!
        panorama-height=1900 \     # ← ОБЯЗАТЕЛЬНО!
        ...
```

#### Полный список properties:

**Файл:** `gstnvdsvirtualcam.cpp:1502-1540` (getter), `1157-1254` (setter)

| Property | Тип | Диапазон | По умолчанию | Описание |
|----------|-----|----------|--------------|----------|
| **panorama-width** | uint | 1-10000 | 0 (требуется!) | Ширина входной панорамы |
| **panorama-height** | uint | 1-3000 | 0 (требуется!) | Высота входной панорамы |
| **yaw** | float | -90 до +90 | 0.0 | Поворот влево-вправо (градусы) |
| **pitch** | float | -27 до +27 | 5.0 | Наклон вверх-вниз (градусы) |
| **roll** | float | -28 до +28 | 0.0 | Наклон вбок (градусы) |
| **fov** | float | 40 до 68 | 68.0 | Угол обзора (Field of View, градусы) |
| **output-width** | uint | 640-3840 | 1920 | Ширина выходного видео |
| **output-height** | uint | 480-2160 | 1080 | Высота выходного видео |
| **gpu-id** | uint | 0-7 | 0 | ID GPU для обработки |
| **auto-follow** | boolean | true/false | false | Автослежение за мячом |
| **smooth-factor** | float | 0.0-1.0 | 0.3 | Плавность движения камеры |
| **s-target** | float | 0.001-1.0 | 0.035 | Целевой размер объекта на экране |
| **ball-x** | float | 0-панорама | - | X-координата мяча (пиксели) |
| **ball-y** | float | 0-панорама | - | Y-координата мяча (пиксели) |
| **ball-actual-radius** | float | 0-1000 | - | Радиус мяча в пикселях |
| **target-ball-size** | float | 0-1000 | - | Желаемый размер мяча |

#### Пример использования в Python:

```python
virtual_camera = Gst.ElementFactory.make("nvdsvirtualcam", "virtual-camera")
virtual_camera.set_property("panorama-width", 5700)
virtual_camera.set_property("panorama-height", 1900)
virtual_camera.set_property("yaw", 0.0)
virtual_camera.set_property("pitch", 5.0)
virtual_camera.set_property("fov", 68.0)
virtual_camera.set_property("auto-follow", True)
```

---

## 2. ЧТО ВЫДАЁТ ПЛАГИН НА ВЫХОД

### 2.1 Формат выходных данных (SRC pad)

**Файл:** `gstnvdsvirtualcam.cpp:73-80`

```cpp
static GstStaticPadTemplate src_template =
    GST_STATIC_PAD_TEMPLATE("src", GST_PAD_SRC, GST_PAD_ALWAYS,
                            GST_STATIC_CAPS("video/x-raw(memory:NVMM), "
                                          "format=RGBA, "
                                          "width=(int)1920, "       // Фиксированный размер
                                          "height=(int)1080, "      // Фиксированный размер
                                          "framerate=(fraction)[0/1,MAX]"));
```

#### Характеристики выходного видео:

| Параметр | Значение | Описание |
|----------|----------|----------|
| **Тип памяти** | `memory:NVMM` | NVIDIA Multimedia Memory |
| **Формат** | `RGBA` | Тот же формат что и на входе |
| **Разрешение** | `1920×1080` | Фиксированное (по умолчанию) |
| **Framerate** | Тот же что на входе | Сохраняется |

**Примечание:** Размер выхода можно изменить через properties `output-width` и `output-height`.

---

## 3. ПОТОК ОБРАБОТКИ ДАННЫХ

### 3.1 Главная функция обработки

**Функция:** `gst_nvds_virtual_cam_submit_input_buffer()`
**Файл:** `gstnvdsvirtualcam.cpp:612-934`

Эта функция вызывается **для каждого входящего кадра**.

### 3.2 Пошаговый процесс обработки

```
┌─────────────────────────────────────────────────────────────┐
│                    ВХОДНОЙ КАДР (NVMM)                      │
│            Панорама: 5700×1900, RGBA, GPU память            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 1: Проверка входного буфера                            │
│ - Буфер не NULL?                                            │
│ - Output pool инициализирован?                              │
│ (строки 629-638)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 2: Snapshot параметров камеры (thread-safe)            │
│ - Блокируем mutex                                           │
│ - Копируем yaw, pitch, roll, fov                            │
│ - Разблокируем mutex                                        │
│ (строки 650-655)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 3: Обновление позиции камеры                           │
│ Функция: update_camera_from_ball()                          │
│ - Если auto-follow включен:                                 │
│   → Преобразует ball_x, ball_y в target_yaw, target_pitch  │
│   → Добавляет смещение если мяч у края (±8° yaw, ±4° pitch)│
│ - Применяет границы с учётом сферической геометрии          │
│ - Вызывает smooth_camera_tracking() для плавности           │
│ (строки 658-675, функция в строках 1256-1533)              │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 4: Обновление LUT (Look-Up Table)                      │
│ Функция: update_lut_if_needed()                             │
│ - Проверяет изменились ли углы камеры > порога (0.1°)      │
│ - Если да → пересчитывает таблицы remap_u и remap_v        │
│ - LUT содержит для каждого пикселя выхода координаты входа │
│ - Вычисления на CPU, затем копирование в GPU память         │
│ (строки 677-682)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 5: Получение буфера из output pool                     │
│ - Берём следующий буфер из фиксированного пула (8-10 буф.) │
│ - Буферы переиспользуются (циклический буфер)               │
│ (строки 684-708)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 6: Маппинг входного буфера                             │
│ - Получаем NvBufSurface структуру                          │
│ - Если SURFACE_ARRAY → EGL mapping + кеш CUDA указателей   │
│ - Если CUDA память → используем напрямую                    │
│ - Валидация размеров (должны совпадать с properties!)       │
│ (строки 710-828)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 7: Настройка CUDA kernel конфигурации                  │
│ kernel_config:                                              │
│ - input_width, input_height (из NvBufSurface)              │
│ - input_pitch (выравнивание строк)                         │
│ - output_width, output_height                              │
│ - output_pitch                                             │
│ (строки 830-844)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 8: Вызов CUDA kernel (основная обработка!)             │
│ Функция: apply_virtual_camera_remap()                      │
│ Параметры:                                                  │
│ - input_ptr: указатель на панораму в GPU памяти            │
│ - output_ptr: указатель на выходной буфер в GPU            │
│ - remap_u_gpu, remap_v_gpu: LUT таблицы в GPU              │
│ - kernel_config: размеры и pitch                           │
│ - cuda_stream: CUDA поток для асинхронности                │
│                                                             │
│ Что делает kernel:                                          │
│ → Для КАЖДОГО пикселя выходного изображения:              │
│   1. Читает координаты (u, v) из LUT                       │
│   2. Делает билинейную интерполяцию из панорамы            │
│   3. Записывает RGBA пиксель в выходной буфер              │
│                                                             │
│ (строки 846-875, kernel в cuda_virtual_cam_kernel.cu)      │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 9: Синхронизация CUDA stream                           │
│ - Ждём завершения всех CUDA операций                       │
│ - cudaStreamSynchronize(vcam->cuda_stream)                  │
│ (строки 877-886)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 10: Копирование метаданных                             │
│ - Timestamps (PTS, DTS)                                     │
│ - Duration                                                  │
│ - Offset                                                    │
│ - Flags                                                     │
│ (строки 902-908)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 11: Измерение производительности                       │
│ - Вычисляет время обработки                                │
│ - Обновляет статистику (min/max/avg)                       │
│ (строки 890-900)                                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ ШАГ 12: Вывод буфера в pipeline                            │
│ - gst_pad_push() отправляет буфер дальше по pipeline       │
│ (строка 934)                                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                   ВЫХОДНОЙ КАДР (NVMM)                      │
│          Виртуальная камера: 1920×1080, RGBA, GPU           │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. CUDA KERNEL: Детальная обработка

### 4.1 Функция apply_virtual_camera_remap()

**Файл:** `cuda_virtual_cam_kernel.cu`

#### Входные данные для kernel:

```cpp
cudaError_t apply_virtual_camera_remap(
    const unsigned char* input,      // Панорама в GPU памяти (RGBA)
    unsigned char* output,            // Выходной буфер в GPU (RGBA)
    const float* remap_u_gpu,         // LUT для X координат (1920×1080 floats)
    const float* remap_v_gpu,         // LUT для Y координат (1920×1080 floats)
    const VirtualCameraKernelConfig* config,  // Размеры и pitch
    cudaStream_t stream               // CUDA поток
)
```

### 4.2 Что делает каждый CUDA thread:

```
┌──────────────────────────────────────────────┐
│ Thread (x, y) обрабатывает пиксель (x, y)   │
│ выходного изображения                        │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
┌──────────────────────────────────────────────┐
│ 1. Вычисляет индекс в LUT:                   │
│    lut_idx = y * output_width + x            │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
┌──────────────────────────────────────────────┐
│ 2. Читает координаты из LUT:                 │
│    u = remap_u_gpu[lut_idx]  // X в панораме │
│    v = remap_v_gpu[lut_idx]  // Y в панораме │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
┌──────────────────────────────────────────────┐
│ 3. Проверка границ:                          │
│    if (u < 0 || u >= pano_w ||              │
│        v < 0 || v >= pano_h)                │
│    → черный пиксель (0, 0, 0, 255)          │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
┌──────────────────────────────────────────────┐
│ 4. Билинейная интерполяция:                  │
│    x0 = floor(u), y0 = floor(v)             │
│    x1 = x0 + 1,   y1 = y0 + 1               │
│    fx = u - x0,   fy = v - y0               │
│                                              │
│    Читает 4 пикселя из панорамы:            │
│    p00 = pixel(x0, y0)                      │
│    p10 = pixel(x1, y0)                      │
│    p01 = pixel(x0, y1)                      │
│    p11 = pixel(x1, y1)                      │
│                                              │
│    Интерполирует:                            │
│    color = (1-fx)*(1-fy)*p00 +              │
│            fx*(1-fy)*p10 +                   │
│            (1-fx)*fy*p01 +                   │
│            fx*fy*p11                         │
└──────────────────┬───────────────────────────┘
                   │
                   ▼
┌──────────────────────────────────────────────┐
│ 5. Запись в выходной буфер:                 │
│    output[out_idx] = color.R                │
│    output[out_idx+1] = color.G              │
│    output[out_idx+2] = color.B              │
│    output[out_idx+3] = 255 (Alpha)          │
└──────────────────────────────────────────────┘
```

### 4.3 Конфигурация CUDA grid:

```cpp
dim3 block(32, 16);  // 32×16 = 512 threads на блок
dim3 grid(
    (output_width + block.x - 1) / block.x,   // Например (1920+31)/32 = 60
    (output_height + block.y - 1) / block.y   // Например (1080+15)/16 = 68
);
// Итого: 60×68 = 4080 блоков × 512 threads = ~2M threads параллельно
```

---

## 5. LUT (Look-Up Table): Как работает

### 5.1 Что такое LUT?

LUT - это **предварительно вычисленные таблицы**, которые содержат для **каждого пикселя выходного изображения** координаты соответствующего пикселя во входном изображении (панораме).

**Размер LUT:** `output_width × output_height × 2 floats`

Пример для 1920×1080:
- `remap_u`: 1920×1080 floats = 7.9 MB (X координаты в панораме)
- `remap_v`: 1920×1080 floats = 7.9 MB (Y координаты в панораме)

### 5.2 Зачем нужна LUT?

**Без LUT:**
- Каждый thread должен вычислять сферическую проекцию (sin, cos, atan2, sqrt)
- Это **ОЧЕНЬ медленно** (~100-200 математических операций на пиксель)

**С LUT:**
- Thread просто **читает готовые координаты** из памяти
- Это **БЫСТРО** (~2-3 операции на пиксель)

**Компромисс:** LUT пересчитывается только когда углы камеры изменяются > 0.1°

### 5.3 Когда обновляется LUT?

**Функция:** `update_lut_if_needed()`
**Файл:** `gstnvdsvirtualcam.cpp` (где-то в районе 250-600 строк)

**Условия пересчёта:**
```cpp
if (abs(yaw - last_yaw) > ANGLE_CHANGE_THRESHOLD ||      // 0.1°
    abs(pitch - last_pitch) > ANGLE_CHANGE_THRESHOLD ||  // 0.1°
    abs(roll - last_roll) > ANGLE_CHANGE_THRESHOLD ||    // 0.1°
    abs(fov - last_fov) > ANGLE_CHANGE_THRESHOLD)        // 0.1°
{
    // Пересчитываем LUT
    rebuild_lut();
}
```

**Процесс пересчёта:**
1. Вычисляет матрицу поворота камеры (yaw, pitch, roll)
2. Для каждого пикселя выхода (x, y):
   - Преобразует в 3D луч с учётом FOV
   - Применяет матрицу поворота
   - Проецирует на сферу
   - Вычисляет сферические координаты (lat, lon)
   - Преобразует в пиксельные координаты панорамы (u, v)
   - Сохраняет в remap_u[x,y] и remap_v[x,y]
3. Копирует remap_u и remap_v из CPU в GPU память

**Время пересчёта:** ~2-5 ms (на CPU)
**Частота:** Обычно раз в несколько кадров (при плавном движении камеры)

---

## 6. Производительность

### 6.1 Типичные времена обработки

| Операция | Время (мкс) | Частота |
|----------|-------------|---------|
| Snapshot параметров | ~1 | Каждый кадр |
| update_camera_from_ball() | ~5-10 | Каждый кадр |
| update_lut_if_needed() | 0 или 2000-5000 | При изменении углов |
| Маппинг буферов | ~50-100 | Каждый кадр |
| CUDA kernel | ~500-1500 | Каждый кадр |
| Синхронизация | ~100-300 | Каждый кадр |
| **ИТОГО** | **~700-2000 мкс** | **~500-1400 FPS** |

**Примечание:** Реальный FPS ограничен входным потоком (обычно 25-30 fps для видео).

### 6.2 Оптимизации

1. **Фиксированный buffer pool** (8-10 буферов):
   - Буферы переиспользуются
   - Нет динамических аллокаций
   - Нет фрагментации памяти

2. **Кеширование CUDA указателей**:
   - EGL mappings кешируются
   - Избегает повторных cudaGraphicsResourceGetMappedPointer()

3. **Асинхронный CUDA stream**:
   - CUDA операции не блокируют CPU
   - Возможен параллелизм с другими операциями

4. **LUT с порогом обновления**:
   - Пересчитывается только при значительных изменениях (> 0.1°)
   - При плавном движении (~0.05° за кадр) пересчёта нет

---

## 7. Пример использования в pipeline

### 7.1 Простой пример (без автослежения):

```bash
gst-launch-1.0 \
    filesrc location=panorama.mp4 ! \
    qtdemux ! h264parse ! nvv4l2decoder ! \
    nvvideoconvert ! "video/x-raw(memory:NVMM),format=RGBA" ! \
    nvdsvirtualcam \
        panorama-width=5700 \
        panorama-height=1900 \
        yaw=0.0 \
        pitch=5.0 \
        fov=68.0 ! \
    nvvideoconvert ! "video/x-raw(memory:NVMM),format=NV12" ! \
    nvv4l2h264enc ! h264parse ! qtmux ! \
    filesink location=output.mp4
```

### 7.2 С автослежением (из Python):

```python
# Создание элементов
virtual_camera = Gst.ElementFactory.make("nvdsvirtualcam", "vcam")
virtual_camera.set_property("panorama-width", 5700)
virtual_camera.set_property("panorama-height", 1900)
virtual_camera.set_property("auto-follow", True)
virtual_camera.set_property("smooth-factor", 0.3)

# Обновление позиции мяча (вызывается из коллбека)
def update_ball_position(ball_x, ball_y, ball_radius):
    virtual_camera.set_property("ball-x", ball_x)
    virtual_camera.set_property("ball-y", ball_y)
    virtual_camera.set_property("ball-actual-radius", ball_radius)
```

---

## 8. Ключевые файлы

| Файл | Описание |
|------|----------|
| `gstnvdsvirtualcam.cpp` | Основной файл плагина, обработка буферов |
| `cuda_virtual_cam_kernel.cu` | CUDA kernel для ремаппинга |
| `nvdsvirtualcam_config.h` | Конфигурация границ и параметров |
| `gstnvdsvirtualcam_allocator.cpp` | Аллокатор для NVMM памяти |

---

## 9. Типичные ошибки и решения

### Ошибка 1: "panorama-width и panorama-height ОБЯЗАТЕЛЬНЫ!"
**Причина:** Не указаны размеры панорамы
**Решение:** Добавить properties в pipeline

### Ошибка 2: "Invalid input buffer size"
**Причина:** Размер входного буфера не совпадает с panorama-width/height
**Решение:** Проверить размеры через `gst-inspect-1.0`

### Ошибка 3: "Unsupported input memory type"
**Причина:** Входное видео не в NVMM памяти
**Решение:** Добавить `nvvideoconvert` перед плагином

### Ошибка 4: Медленная обработка
**Причина:** LUT пересчитывается каждый кадр
**Решение:** Проверить что углы не дёргаются (добавить dead zone или smooth_factor)

---

## 10. Выводы

**Плагин nvdsvirtualcam:**

✅ Принимает **панорамное RGBA видео в NVMM памяти**
✅ Создаёт **виртуальную камеру** с управляемыми углами и зумом
✅ Использует **CUDA для быстрой обработки** (< 2 ms на кадр)
✅ Поддерживает **автослежение за объектом**
✅ Выдаёт **обычное видео** (1920×1080, RGBA, NVMM)
✅ Интегрируется в **GStreamer pipeline** как обычный элемент

**Основное преимущество:** Обработка на GPU без копирования в CPU память → **очень быстро!**
