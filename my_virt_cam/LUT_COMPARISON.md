# Сравнение LUT карт: Стичинг vs Виртуальная камера

## Краткий ответ

Да, LUT (Look-Up Table) карты используются **в обоих плагинах**, но они решают **разные задачи**:

| Аспект | my_stitch (стичинг) | nvdsvirtualcam (виртуальная камера) |
|--------|---------------------|-------------------------------------|
| **Задача** | Объединить 2 камеры → панорама | Панорама → виртуальная камера |
| **Создаются** | Заранее (калибровка) | Динамически (во время работы) |
| **Хранятся** | В файлах (.bin) | В GPU памяти |
| **Изменяются** | НЕТ (статичные) | ДА (при повороте камеры) |
| **Размер** | Для панорамы (5700×1900) | Для выхода (1920×1080) |

---

## 1. LUT В ПЛАГИНЕ СТИЧИНГА (my_stitch)

### Задача
Объединить изображения с **двух физических камер** (левая + правая) в **одну панораму**.

### Откуда берутся
**Создаются заранее** через процесс калибровки камер:

```python
# Пример процесса калибровки (один раз)
import cv2
import numpy as np

# 1. Калибровка камер (intrinsics + extrinsics)
left_camera_matrix, left_dist = calibrate_camera(left_images)
right_camera_matrix, right_dist = calibrate_camera(right_images)

# 2. Stereo калибровка (взаимное расположение)
R, T = stereo_calibrate(left_images, right_images)

# 3. Вычисление remap maps для каждой камеры
left_map_x, left_map_y = cv2.initUndistortRectifyMap(
    left_camera_matrix, left_dist, R_left, P_left, ...)

right_map_x, right_map_y = cv2.initUndistortRectifyMap(
    right_camera_matrix, right_dist, R_right, P_right, ...)

# 4. Сохранение в файлы
left_map_x.tofile("left_map_x.bin")
left_map_y.tofile("left_map_y.bin")
right_map_x.tofile("right_map_x.bin")
right_map_y.tofile("right_map_y.bin")
```

### Что содержат
Для **каждого пикселя панорамы** (например 5700×1900):
- **map_x[i,j]**: координата X в исходной камере
- **map_y[i,j]**: координата Y в исходной камере

```
Пример:
Пиксель панорамы (1000, 500) берётся из:
- left_map_x[1000, 500] = 645.3
- left_map_y[1000, 500] = 389.7
→ Читаем пиксель (645.3, 389.7) из левой камеры
```

### Размер файлов
Для панорамы 5700×1900:
- `left_map_x.bin`: 5700×1900×4 bytes = **41.2 MB**
- `left_map_y.bin`: 5700×1900×4 bytes = **41.2 MB**
- `right_map_x.bin`: **41.2 MB**
- `right_map_y.bin`: **41.2 MB**
- **ИТОГО: ~165 MB** на диске

### Как используются
```cpp
// Загружаются при инициализации плагина
load_maps("left_map_x.bin", &left_map_x_gpu);
load_maps("left_map_y.bin", &left_map_y_gpu);

// Используются в CUDA kernel (каждый кадр)
__global__ void stitch_kernel(...) {
    // Для каждого пикселя панорамы
    int pano_x = ...;
    int pano_y = ...;

    // Читаем координаты из LUT
    float src_x = left_map_x[pano_idx];
    float src_y = left_map_y[pano_idx];

    // Читаем пиксель из исходной камеры
    color = sample_camera(left_camera, src_x, src_y);
}
```

**Частота использования:** Каждый кадр, но **LUT не меняются**

---

## 2. LUT В ВИРТУАЛЬНОЙ КАМЕРЕ (nvdsvirtualcam)

### Задача
Из **панорамы** создать **виртуальную камеру** с настраиваемыми углами (yaw, pitch, roll) и зумом (FOV).

### Откуда берутся
**Создаются динамически** на GPU, **пересчитываются** когда камера поворачивается > 0.1°

**Файл:** `cuda_virtual_cam_kernel.cu:72-142`

```cpp
__global__ void generate_remap_lut_kernel(
    const float* rays_cam,      // Предвычисленные лучи камеры
    float* remap_u,             // Выходная LUT для X
    float* remap_v,             // Выходная LUT для Y
    float yaw_rad,              // Углы камеры (меняются!)
    float pitch_rad,
    float roll_rad,
    ...)
{
    // Для каждого пикселя выходного изображения (1920×1080)
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;

    int idx = y * width + x;

    // 1. Берём предвычисленный луч для этого пикселя
    float rx = rays_cam[idx * 3 + 0];
    float ry = rays_cam[idx * 3 + 1];
    float rz = rays_cam[idx * 3 + 2];

    // 2. Применяем вращения камеры (yaw, pitch, roll)
    //    ROLL -> PITCH -> YAW
    float rotated_x = apply_rotations(rx, ry, rz, yaw, pitch, roll);
    float rotated_y = ...;
    float rotated_z = ...;

    // 3. Преобразуем в сферические координаты
    float lambda = atan2f(rotated_x, rotated_z);  // Долгота
    float phi = asinf(rotated_y);                 // Широта

    // 4. Преобразуем в пиксельные координаты панорамы
    float u_norm = (lambda - LON_MIN) / (LON_MAX - LON_MIN);
    float v_norm = (phi - LAT_MIN) / (LAT_MAX - LAT_MIN);

    float u = u_norm * (pano_width - 1);   // X в панораме
    float v = v_norm * (pano_height - 1);  // Y в панораме

    // 5. Сохраняем в LUT
    remap_u[idx] = u;
    remap_v[idx] = v;
}
```

### Что содержат
Для **каждого пикселя выходного изображения** (1920×1080):
- **remap_u[i,j]**: координата X в панораме
- **remap_v[i,j]**: координата Y в панораме

```
Пример:
Пиксель выхода (960, 540) берётся из:
- remap_u[960, 540] = 2850.3
- remap_v[960, 540] = 950.7
→ Читаем пиксель (2850.3, 950.7) из панорамы
```

### Размер в памяти
Для выхода 1920×1080:
- `remap_u_gpu`: 1920×1080×4 bytes = **7.9 MB**
- `remap_v_gpu`: 1920×1080×4 bytes = **7.9 MB**
- **ИТОГО: ~16 MB** в GPU памяти

### Когда пересчитываются

**Файл:** `gstnvdsvirtualcam.cpp:~350-420`

```cpp
bool update_lut_if_needed(GstNvdsVirtualCam* vcam) {
    // Проверяем изменились ли углы камеры
    float yaw_diff = fabs(vcam->yaw - vcam->last_yaw);
    float pitch_diff = fabs(vcam->pitch - vcam->last_pitch);
    float roll_diff = fabs(vcam->roll - vcam->last_roll);
    float fov_diff = fabs(vcam->fov - vcam->last_fov);

    const float THRESHOLD = 0.1f;  // градусы

    if (yaw_diff > THRESHOLD ||
        pitch_diff > THRESHOLD ||
        roll_diff > THRESHOLD ||
        fov_diff > THRESHOLD)
    {
        // ПЕРЕСЧИТЫВАЕМ LUT!
        generate_remap_lut(
            vcam->rays_gpu,
            vcam->remap_u_gpu,
            vcam->remap_v_gpu,
            vcam->yaw,
            vcam->pitch,
            vcam->roll,
            ...
        );

        // Запоминаем новые значения
        vcam->last_yaw = vcam->yaw;
        vcam->last_pitch = vcam->pitch;
        vcam->last_roll = vcam->roll;
        vcam->last_fov = vcam->fov;

        return true;  // LUT обновлена
    }

    return false;  // LUT не изменилась, используем старую
}
```

**Частота пересчёта:**
- При **плавном движении** (~0.05° за кадр): **НЕ пересчитывается** (0.05 < 0.1)
- При **быстром движении** (~0.2° за кадр): **Пересчитывается** каждые 2-3 кадра
- При **ручном управлении** (клавиши): **Пересчитывается** каждый кадр

**Время пересчёта:** ~0.5-1.5 ms на GPU (очень быстро!)

### Как используются

**Файл:** `cuda_virtual_cam_kernel.cu:~198-259`

```cpp
__global__ void apply_remap_kernel(
    const unsigned char* panorama,   // Входная панорама
    unsigned char* output,           // Выходное изображение 1920×1080
    const float* remap_u,            // LUT для X
    const float* remap_v,            // LUT для Y
    ...)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;

    if (x >= out_width || y >= out_height) return;

    // 1. Читаем координаты из LUT
    int lut_idx = y * out_width + x;
    float u = remap_u[lut_idx];
    float v = remap_v[lut_idx];

    // 2. Проверяем границы
    if (u < 0 || u >= pano_width || v < 0 || v >= pano_height) {
        // Черный пиксель (вне панорамы)
        output[...] = 0;
        return;
    }

    // 3. Билинейная интерполяция из панорамы
    int x0 = (int)u;
    int y0 = (int)v;
    float fx = u - x0;
    float fy = v - y0;

    // Читаем 4 соседних пикселя
    pixel p00 = panorama[y0 * pano_pitch + x0 * 4];
    pixel p10 = panorama[y0 * pano_pitch + (x0+1) * 4];
    pixel p01 = panorama[(y0+1) * pano_pitch + x0 * 4];
    pixel p11 = panorama[(y0+1) * pano_pitch + (x0+1) * 4];

    // Интерполируем
    pixel result = (1-fx)*(1-fy)*p00 + fx*(1-fy)*p10 +
                   (1-fx)*fy*p01 + fx*fy*p11;

    // 4. Записываем результат
    output[out_idx] = result;
}
```

**Частота использования:** **Каждый кадр**, но LUT пересчитывается редко

---

## 3. НАГЛЯДНОЕ СРАВНЕНИЕ

### Направление маппинга

```
┌─────────────────────────────────────────────────────────────────┐
│                        СТИЧИНГ (my_stitch)                      │
└─────────────────────────────────────────────────────────────────┘

Левая камера                      LUT                      Панорама
  640×480           →    left_map_x, left_map_y    →      5700×1900
     ┌────┐                     ↓                           ┌──────┐
     │    │         Для каждого пикселя панорамы:          │      │
     │ 📷 │         "Откуда взять цвет из камеры?"         │ 🖼️  │
     └────┘                                                 └──────┘

Правая камера
  640×480           →    right_map_x, right_map_y  →
     ┌────┐
     │    │
     │ 📷 │
     └────┘

НАПРАВЛЕНИЕ: Камера → Панорама
LUT SIZE: 5700×1900 (размер ВЫХОДА - панорамы)


┌─────────────────────────────────────────────────────────────────┐
│                  ВИРТУАЛЬНАЯ КАМЕРА (nvdsvirtualcam)            │
└─────────────────────────────────────────────────────────────────┘

Панорама                          LUT                      Виртуальная камера
5700×1900          →     remap_u, remap_v         →          1920×1080
  ┌──────┐                       ↓                             ┌────┐
  │      │      Для каждого пикселя выхода:                   │    │
  │ 🖼️  │      "Откуда взять цвет из панорамы?"              │ 🎥 │
  └──────┘      (зависит от yaw, pitch, roll, FOV!)           └────┘

НАПРАВЛЕНИЕ: Панорама → Виртуальная камера
LUT SIZE: 1920×1080 (размер ВЫХОДА - виртуальной камеры)
```

### Процесс создания

```
┌──────────────────────────────────────────────────────────────┐
│                    СТИЧИНГ - ОДИН РАЗ                        │
└──────────────────────────────────────────────────────────────┘

1. Калибровка камер (offline, один раз):
   ├─ Снимаем шахматную доску с обеих камер
   ├─ OpenCV находит intrinsics (фокусное, дисторсия)
   ├─ OpenCV находит extrinsics (взаимное расположение)
   ├─ cv2.initUndistortRectifyMap() генерирует LUT
   └─ Сохраняем в .bin файлы

2. Во время работы:
   └─ Просто загружаем готовые LUT с диска
   └─ Используем их для каждого кадра
   └─ НЕ МЕНЯЮТСЯ!


┌──────────────────────────────────────────────────────────────┐
│              ВИРТУАЛЬНАЯ КАМЕРА - ДИНАМИЧЕСКИ                │
└──────────────────────────────────────────────────────────────┘

1. При инициализации:
   ├─ Создаём rays_gpu (лучи для каждого пикселя выхода)
   ├─ Аллоцируем remap_u_gpu и remap_v_gpu
   └─ rays_gpu НЕ МЕНЯЮТСЯ (зависят только от FOV и output размера)

2. Каждый раз когда камера поворачивается > 0.1°:
   ├─ Запускаем CUDA kernel generate_remap_lut_kernel()
   ├─ Для каждого пикселя выхода (1920×1080):
   │  ├─ Берём предвычисленный луч из rays_gpu
   │  ├─ Применяем ROLL -> PITCH -> YAW вращения
   │  ├─ Конвертируем в сферические координаты
   │  ├─ Конвертируем в пиксельные координаты панорамы
   │  └─ Сохраняем в remap_u[i], remap_v[i]
   └─ Занимает ~0.5-1.5 ms

3. Каждый кадр:
   └─ Используем текущие remap_u/remap_v для ремаппинга
```

---

## 4. КЛЮЧЕВЫЕ РАЗЛИЧИЯ

### Инициализация

| Аспект | Стичинг | Виртуальная камера |
|--------|---------|---------------------|
| **Когда создаются** | При калибровке (offline) | При инициализации плагина |
| **Где хранятся** | На диске (.bin файлы) | В GPU памяти |
| **Нужны файлы?** | ✅ ДА (map_x.bin, map_y.bin) | ❌ НЕТ (генерируются на лету) |
| **Время создания** | Минуты (калибровка) | Миллисекунды (GPU расчёт) |

### Во время работы

| Аспект | Стичинг | Виртуальная камера |
|--------|---------|---------------------|
| **Меняются?** | ❌ НЕТ (статичные) | ✅ ДА (при повороте камеры) |
| **Частота обновления** | Никогда | Когда углы меняются > 0.1° |
| **Стоимость обновления** | N/A | ~0.5-1.5 ms (GPU) |
| **Память** | ~165 MB | ~16 MB |

### Зависимости

**Стичинг LUT зависят от:**
- Параметров камер (focal length, distortion)
- Взаимного расположения камер (R, T)
- Желаемого размера панорамы

**Виртуальная камера LUT зависят от:**
- Углов камеры: yaw, pitch, roll (меняются!)
- FOV (угол обзора)
- Размера выхода (1920×1080)
- Границ панорамы (LON_MIN, LON_MAX, LAT_MIN, LAT_MAX)

---

## 5. ПОЧЕМУ ДВЕ РАЗНЫЕ LUT?

### Причина 1: Разные задачи

**Стичинг:**
- Исправляет геометрическую дисторсию камер
- Учитывает взаимное расположение
- Создаёт непрерывную панораму из двух изображений

**Виртуальная камера:**
- Эмулирует камеру с управляемым направлением
- Проецирует сферическую панораму на плоскость
- Позволяет динамически менять угол обзора

### Причина 2: Разные входы и выходы

```
Стичинг:      2 камеры (640×480) → 1 панорама (5700×1900)
Virt Camera:  1 панорама (5700×1900) → 1 виртуальная камера (1920×1080)
```

### Причина 3: Производительность

**Без LUT в виртуальной камере:**
```cpp
// Каждый пиксель должен вычислять:
for each pixel (x, y) in output:
    ray = compute_ray(x, y, fov)           // ~10 ops
    rotated = rotate(ray, yaw, pitch, roll) // ~50 ops (sin, cos)
    lambda = atan2(rotated.x, rotated.z)    // ~100 ops
    phi = asin(rotated.y)                   // ~100 ops
    u = map_to_panorama(lambda)             // ~5 ops
    v = map_to_panorama(phi)                // ~5 ops
    color = sample(panorama, u, v)          // ~10 ops
    // ИТОГО: ~280 операций на пиксель!
```

**С LUT:**
```cpp
for each pixel (x, y) in output:
    u = remap_u[x, y]      // 1 memory read
    v = remap_v[x, y]      // 1 memory read
    color = sample(panorama, u, v)  // ~10 ops
    // ИТОГО: ~12 операций на пиксель!
```

**Ускорение:** ~20-25x быстрее!

**Компромисс:** Нужно пересчитывать LUT при изменении углов (но это редко!)

---

## 6. ИТОГО

### Стичинг (my_stitch)
```
Задача: 2 камеры → 1 панорама
LUT: Статичные, загружаются с диска
Размер: ~165 MB (для панорамы 5700×1900)
Создаются: Калибровкой камер (один раз)
Используются: Каждый кадр, не меняются
```

### Виртуальная камера (nvdsvirtualcam)
```
Задача: Панорама → виртуальная камера с управлением
LUT: Динамические, генерируются на GPU
Размер: ~16 MB (для выхода 1920×1080)
Создаются: При изменении углов камеры > 0.1°
Используются: Каждый кадр, обновляются по необходимости
```

### Общая черта
Обе используют **технику remapping** для быстрой обработки на GPU вместо пересчёта сложных формул для каждого пикселя.

---

## 7. ВИЗУАЛИЗАЦИЯ ПОТОКА ДАННЫХ

```
┌──────────────────────────────────────────────────────────────┐
│              ПОЛНАЯ КАРТИНА: ОТ КАМЕР ДО ВЫХОДА              │
└──────────────────────────────────────────────────────────────┘

Левая камера         Правая камера
   640×480              640×480
      ↓                    ↓
      │                    │
      │  my_stitch плагин  │
      │  (использует       │
      │   left_map_x.bin,  │
      │   left_map_y.bin,  │
      │   right_map_x.bin, │
      │   right_map_y.bin) │
      │                    │
      └────────┬───────────┘
               ↓
         Панорама 5700×1900
               ↓
               │
      nvdsvirtualcam плагин
      (генерирует remap_u,
       remap_v динамически
       при изменении yaw/
       pitch/roll/fov)
               │
               ↓
    Виртуальная камера 1920×1080
               ↓
            К зрителю!
```

**Два уровня LUT для двух разных преобразований!**
