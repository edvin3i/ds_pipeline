/**
 * @file nvdsstitch_config.h
 * @brief Configuration constants and parameters for panorama stitching plugin
 *
 * Defines all compile-time constants, default values, and configuration structures
 * used by the nvdsstitch GStreamer plugin. This includes input/output parameters,
 * LUT file paths, color correction settings, and CUDA kernel launch parameters.
 *
 * All configuration values in this file are tuned for:
 * - Dual Sony IMX678 fisheye cameras (3840×2160 @ 30 FPS)
 * - NVIDIA Jetson Orin NX 16GB platform
 * - DeepStream 7.1 / CUDA 12.6
 * - Target panorama output: 5700×1900 RGBA (equirectangular projection)
 *
 * @author Polycube Development Team
 * @date 2025-11-21
 *
 * @see cuda_stitch_kernel.h for CUDA kernel API
 * @see gstnvdsstitch.h for plugin structure
 */

#ifndef __NVDSSTITCH_CONFIG_H__
#define __NVDSSTITCH_CONFIG_H__

#ifdef __cplusplus
#include <string>
#endif

/**
 * @brief Panorama stitching configuration namespace
 *
 * Contains all compile-time constants for input parameters, output format,
 * LUT file paths, color correction settings, and CUDA parameters.
 */
namespace NvdsStitchConfig {

    // ========== INPUT PARAMETERS ==========
    constexpr int INPUT_WIDTH = 3840;   /**< Input camera frame width (4K) */
    constexpr int INPUT_HEIGHT = 2160;  /**< Input camera frame height (4K) */
    constexpr int INPUT_FORMAT = 19;    /**< NVBUF_COLOR_FORMAT_RGBA */
    constexpr int LEFT_SOURCE_ID = 0;   /**< GStreamer source ID for left camera */
    constexpr int RIGHT_SOURCE_ID = 1;  /**< GStreamer source ID for right camera */

    // ========== PANORAMA PARAMETERS ==========
    // Output dimensions (width, height) configured via properties
    constexpr int OUTPUT_FORMAT = 19;    /**< NVBUF_COLOR_FORMAT_RGBA */

    // ========== LUT MAPS ==========
    // LUT dimensions match output dimensions (from properties)
    constexpr const char* WARP_MAPS_DIR = "warp_maps";  /**< Directory containing LUT binary files */

    /**
     * @name LUT Binary Files
     * @brief Precomputed Look-Up Table maps for panorama stitching
     *
     * These binary files are generated by pano_cuda_debug_stages.py calibration
     * script. Each file contains float32 values in row-major order, matching the
     * panorama output dimensions (e.g., 5700×1900).
     *
     * File sizes: ~21.66 MB each for 5700×1900 panorama
     * Total LUT data: ~130 MB (6 files)
     * @{
     */
    constexpr const char* WARP_LEFT_X_FILE = "lut_left_x.bin";      /**< Left camera X pixel coordinates */
    constexpr const char* WARP_LEFT_Y_FILE = "lut_left_y.bin";      /**< Left camera Y pixel coordinates */
    constexpr const char* WARP_RIGHT_X_FILE = "lut_right_x.bin";    /**< Right camera X pixel coordinates */
    constexpr const char* WARP_RIGHT_Y_FILE = "lut_right_y.bin";    /**< Right camera Y pixel coordinates */
    constexpr const char* WEIGHT_LEFT_FILE = "weight_left.bin";     /**< Left camera blending weights */
    constexpr const char* WEIGHT_RIGHT_FILE = "weight_right.bin";   /**< Right camera blending weights */
    /** @} */

    // Cropping parameters (zero for full panorama output)
    constexpr int DEFAULT_CROP_TOP = 0;      /**< Top crop pixels (0 = no cropping) */
    constexpr int DEFAULT_CROP_BOTTOM = 0;   /**< Bottom crop pixels (0 = no cropping) */
    constexpr int DEFAULT_CROP_SIDES = 0;    /**< Side crop pixels (0 = no cropping) */
    constexpr int OVERLAP = 0;               /**< Overlap blending handled via weight maps */

    // ========== COLOR CORRECTION (ASYNC) ==========
    /**
     * @brief Hardware-sync-aware color correction configuration
     *
     * 2-phase async color correction system tuned for Sony IMX678 camera ISP.
     * Based on camera ISP configuration: Gamma 2.4, AE target 120, AWB soft clamp.
     */
    namespace ColorCorrectionConfig {
        /**
         * @name Analysis Parameters (Configurable via Properties)
         * @brief Runtime-adjustable color correction parameters
         * @{
         */
        constexpr float DEFAULT_OVERLAP_SIZE = 10.0f;             /**< Overlap region size in degrees (5-15 range) */
        constexpr unsigned int DEFAULT_ANALYZE_INTERVAL = 30;     /**< Analysis interval in frames (0-120 range, 0=disable) */
        constexpr float DEFAULT_SMOOTHING_FACTOR = 0.15f;         /**< Temporal smoothing α (15% update per frame) */
        constexpr float DEFAULT_SPATIAL_FALLOFF = 2.0f;           /**< Vignetting compensation exponent */
        constexpr bool DEFAULT_ENABLE_GAMMA = true;               /**< Enable gamma correction */
        /** @} */

        /**
         * @name Overlap Analysis Region
         * @brief Geometric parameters for color analysis
         * @{
         */
        constexpr float OVERLAP_CENTER_X = 0.50f;                 /**< Center of panorama (50% normalized position) */
        constexpr float OVERLAP_MIN_SAMPLES = 10000.0f;           /**< Minimum valid pixels for reliable analysis */
        /** @} */

        /**
         * @name Gamma Correction Limits
         * @brief Safe clamping ranges based on ISP gamma 2.4
         * @{
         */
        constexpr float GAMMA_MIN = 0.8f;   /**< Darken by max 20% (underexposed camera) */
        constexpr float GAMMA_MAX = 1.2f;   /**< Brighten by max 20% (overexposed camera) */
        /** @} */

        /**
         * @name RGB Gain Limits
         * @brief Safe clamping ranges for AWB/CCM correction
         * @{
         */
        constexpr float GAIN_MIN = 0.5f;    /**< Minimum color channel gain */
        constexpr float GAIN_MAX = 2.0f;    /**< Maximum color channel gain */
        /** @} */
    }

    // ========== CUDA PARAMETERS ==========
    constexpr int GPU_ID = 0;               /**< CUDA device ID (0 = first GPU) */
    constexpr int BLOCK_SIZE_X = 32;        /**< CUDA block X dimension (threads) */
    constexpr int BLOCK_SIZE_Y = 8;         /**< CUDA block Y dimension (threads) */

    // ========== BUFFER POOL ==========
    constexpr int POOL_MIN_BUFFERS = 8;     /**< Minimum buffers in pool */
    constexpr int POOL_MAX_BUFFERS = 10;    /**< Maximum buffers in pool */
    constexpr int POOL_MEMTYPE = 4;         /**< NVBUF_MEM_SURFACE_ARRAY (EGL-compatible) */

#ifdef __cplusplus
    /**
     * @brief Construct full path to LUT file
     *
     * @param[in] filename LUT filename (e.g., "lut_left_x.bin")
     * @return std::string Full path (WARP_MAPS_DIR + "/" + filename)
     */
    inline std::string getWarpPath(const char* filename) {
        return std::string(WARP_MAPS_DIR) + "/" + filename;
    }

    /** @brief Get path to left camera X coordinate LUT */
    inline std::string getWarpLeftXPath() {
        return getWarpPath(WARP_LEFT_X_FILE);
    }

    /** @brief Get path to left camera Y coordinate LUT */
    inline std::string getWarpLeftYPath() {
        return getWarpPath(WARP_LEFT_Y_FILE);
    }

    /** @brief Get path to right camera X coordinate LUT */
    inline std::string getWarpRightXPath() {
        return getWarpPath(WARP_RIGHT_X_FILE);
    }

    /** @brief Get path to right camera Y coordinate LUT */
    inline std::string getWarpRightYPath() {
        return getWarpPath(WARP_RIGHT_Y_FILE);
    }

    /** @brief Get path to left camera blending weights */
    inline std::string getWeightLeftPath() {
        return getWarpPath(WEIGHT_LEFT_FILE);
    }

    /** @brief Get path to right camera blending weights */
    inline std::string getWeightRightPath() {
        return getWarpPath(WEIGHT_RIGHT_FILE);
    }
#endif

    /**
     * @brief Calculate 32-byte aligned pitch for NVMM buffers
     *
     * Computes row pitch/stride aligned to 32-byte boundary as required
     * by CUDA coalesced memory access and NVMM buffer allocation.
     *
     * @param[in] width Frame width in pixels
     * @param[in] bytes_per_pixel Bytes per pixel (default: 4 for RGBA)
     * @return int Aligned pitch in bytes
     *
     * @note Alignment formula: ((width * bpp + 31) / 32) * 32
     */
    inline int calculatePitch(int width, int bytes_per_pixel = 4) {
        int min_pitch = width * bytes_per_pixel;
        return ((min_pitch + 31) / 32) * 32;
    }

    /**
     * @brief Get input frame pitch for INPUT_WIDTH
     *
     * @return int Aligned pitch in bytes for 3840-pixel RGBA frames
     */
    inline int getInputPitch() {
        return calculatePitch(INPUT_WIDTH);
    }
}

/**
 * @brief Color correction factors structure
 *
 * Contains 8 correction factors applied during panorama stitching to balance
 * color and exposure differences between left and right cameras.
 *
 * Factors are computed by analyze_color_correction_async() + finalize_color_correction_factors()
 * and uploaded to GPU constant memory via update_color_correction_factors().
 *
 * Value ranges (enforced by finalize_color_correction_factors):
 * - RGB gains: 0.5 to 2.0 (GAIN_MIN/GAIN_MAX)
 * - Gamma: 0.8 to 1.2 (GAMMA_MIN/GAMMA_MAX)
 * - Identity (no correction): all values = 1.0
 *
 * @see analyze_color_correction_async
 * @see finalize_color_correction_factors
 * @see update_color_correction_factors
 */
typedef struct {
    float left_r;      /**< Red gain for left camera (1.0 = no correction) */
    float left_g;      /**< Green gain for left camera (1.0 = no correction) */
    float left_b;      /**< Blue gain for left camera (1.0 = no correction) */
    float left_gamma;  /**< Gamma correction for left camera (1.0 = no correction) */
    float right_r;     /**< Red gain for right camera (1.0 = no correction) */
    float right_g;     /**< Green gain for right camera (1.0 = no correction) */
    float right_b;     /**< Blue gain for right camera (1.0 = no correction) */
    float right_gamma; /**< Gamma correction for right camera (1.0 = no correction) */
} ColorCorrectionFactors;

#endif // __NVDSSTITCH_CONFIG_H__
