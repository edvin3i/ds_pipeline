/**
 * @file cuda_stitch_kernel.h
 * @brief CUDA kernel API for 360° panorama stitching with color correction
 *
 * This header defines the public API for GPU-accelerated panorama stitching
 * operations. The implementation uses LUT (Look-Up Table) based warping with
 * bilinear interpolation for real-time equirectangular projection from dual
 * fisheye camera inputs.
 *
 * Key features:
 * - Zero-copy NVMM (NVIDIA Multimedia Memory) processing
 * - 2-phase async color correction with hardware frame sync
 * - 51-55 FPS stitching performance on Jetson Orin NX
 * - Support for 4K input (3840×2160) to panorama output (e.g., 5700×1900)
 *
 * @author Polycube Development Team
 * @date 2025-11-21
 *
 * @see nvdsstitch_config.h for configuration constants
 * @see gstnvdsstitch.h for GStreamer plugin integration
 */

#ifndef __CUDA_STITCH_KERNEL_H__
#define __CUDA_STITCH_KERNEL_H__

#include <cuda_runtime.h>
#include "nvdsstitch_config.h"

/**
 * @brief Configuration structure for panorama stitching CUDA kernels
 *
 * Contains all parameters required for stitching kernel launch.
 * Dimensions and pitch values must match actual buffer allocations.
 */
typedef struct {
    int input_width;    /**< Input frame width in pixels (e.g., 3840) */
    int input_height;   /**< Input frame height in pixels (e.g., 2160) */
    int input_pitch;    /**< Input frame pitch/stride in bytes (32-byte aligned) */
    int output_width;   /**< Output panorama width in pixels (e.g., 5700) */
    int output_height;  /**< Output panorama height in pixels (e.g., 1900) */
    int output_pitch;   /**< Output frame pitch/stride in bytes (32-byte aligned) */
    int warp_width;     /**< LUT map width (matches output_width) */
    int warp_height;    /**< LUT map height (matches output_height) */
    int overlap;        /**< Reserved for future use */
    int crop_top;       /**< Reserved for future use */
    int crop_bottom;    /**< Reserved for future use */
    int crop_sides;     /**< Reserved for future use */
    int full_height;    /**< Reserved for future use */
    int full_width;     /**< Reserved for future use */
} StitchKernelConfig;

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Load LUT maps and blending weights for panorama stitching
 *
 * Loads 6 binary LUT files from disk into GPU memory. Each LUT file contains
 * float32 values in row-major order matching panorama output dimensions.
 * Total memory allocation: ~24 MB for 5700×1900 panorama (6 maps × 4 bytes).
 *
 * LUT files (generated by pano_cuda_debug_stages.py):
 * - lut_left_x.bin, lut_left_y.bin: Source pixel coordinates for left camera
 * - lut_right_x.bin, lut_right_y.bin: Source pixel coordinates for right camera
 * - weight_left.bin, weight_right.bin: Blending weights (sum = 1.0 per pixel)
 *
 * @param[in] left_x_path Path to left camera X coordinate LUT
 * @param[in] left_y_path Path to left camera Y coordinate LUT
 * @param[in] right_x_path Path to right camera X coordinate LUT
 * @param[in] right_y_path Path to right camera Y coordinate LUT
 * @param[in] weight_left_path Path to left camera blending weights
 * @param[in] weight_right_path Path to right camera blending weights
 * @param[out] lut_left_x_gpu Pointer to GPU memory for left X LUT (allocated by function)
 * @param[out] lut_left_y_gpu Pointer to GPU memory for left Y LUT (allocated by function)
 * @param[out] lut_right_x_gpu Pointer to GPU memory for right X LUT (allocated by function)
 * @param[out] lut_right_y_gpu Pointer to GPU memory for right Y LUT (allocated by function)
 * @param[out] weight_left_gpu Pointer to GPU memory for left weights (allocated by function)
 * @param[out] weight_right_gpu Pointer to GPU memory for right weights (allocated by function)
 * @param[in] lut_width Width of LUT maps in pixels (must match output panorama width)
 * @param[in] lut_height Height of LUT maps in pixels (must match output panorama height)
 *
 * @return cudaSuccess on success, CUDA error code on failure
 * @retval cudaSuccess All LUTs loaded successfully
 * @retval cudaErrorMemoryAllocation Failed to allocate GPU memory
 * @retval cudaErrorInvalidValue File size mismatch or read error
 *
 * @note Caller must call free_panorama_luts() to release GPU memory
 * @note Function performs comprehensive validation (file size, memory allocation)
 * @warning LUT dimensions must exactly match output panorama dimensions
 *
 * @see free_panorama_luts
 */
cudaError_t load_panorama_luts(
    const char* left_x_path,
    const char* left_y_path,
    const char* right_x_path,
    const char* right_y_path,
    const char* weight_left_path,
    const char* weight_right_path,
    float** lut_left_x_gpu,
    float** lut_left_y_gpu,
    float** lut_right_x_gpu,
    float** lut_right_y_gpu,
    float** weight_left_gpu,
    float** weight_right_gpu,
    int lut_width,
    int lut_height
);

/**
 * @brief Launch panorama stitching kernel on CUDA stream
 *
 * Performs GPU-accelerated panorama stitching using LUT-based warping with
 * bilinear interpolation. Blends left and right fisheye cameras into
 * equirectangular projection with per-pixel color correction.
 *
 * Algorithm:
 * 1. For each output pixel, read source coordinates from LUT
 * 2. Sample input frames with bilinear interpolation
 * 3. Apply color correction (gamma + RGB gains) per camera
 * 4. Blend cameras using pre-computed weights
 * 5. Write to output with vertical/horizontal flip
 *
 * Performance: ~10ms for 5700×1900 output @ 30 FPS (Jetson Orin NX)
 *
 * @param[in] input_left Left camera frame (RGBA, GPU memory, NVMM)
 * @param[in] input_right Right camera frame (RGBA, GPU memory, NVMM)
 * @param[out] output Stitched panorama output (RGBA, GPU memory, NVMM)
 * @param[in] lut_left_x Left camera X coordinate LUT (GPU memory)
 * @param[in] lut_left_y Left camera Y coordinate LUT (GPU memory)
 * @param[in] lut_right_x Right camera X coordinate LUT (GPU memory)
 * @param[in] lut_right_y Right camera Y coordinate LUT (GPU memory)
 * @param[in] weight_left Left camera blending weights (GPU memory)
 * @param[in] weight_right Right camera blending weights (GPU memory)
 * @param[in] config Kernel configuration (dimensions, pitch)
 * @param[in] stream CUDA stream for async execution (use 0 for default stream)
 *
 * @return cudaSuccess on kernel launch success, CUDA error code on failure
 * @retval cudaSuccess Kernel launched successfully (does NOT guarantee completion)
 * @retval cudaErrorInvalidConfiguration Invalid grid/block dimensions
 * @retval cudaErrorLaunchFailure Kernel launch failed
 *
 * @note Function is ASYNC - does not wait for kernel completion
 * @note Call cudaStreamSynchronize(stream) or cudaDeviceSynchronize() to wait
 * @note All pointers must be valid GPU memory addresses
 * @warning Input/output buffers must not overlap
 *
 * @see StitchKernelConfig
 * @see load_panorama_luts
 */
cudaError_t launch_panorama_kernel(
    const unsigned char* input_left,
    const unsigned char* input_right,
    unsigned char* output,
    const float* lut_left_x,
    const float* lut_left_y,
    const float* lut_right_x,
    const float* lut_right_y,
    const float* weight_left,
    const float* weight_right,
    const StitchKernelConfig* config,
    cudaStream_t stream
);

/**
 * @brief Free GPU memory allocated for LUT maps
 *
 * Releases all GPU memory allocated by load_panorama_luts().
 * Safe to call with NULL pointers (no-op).
 *
 * @param[in] lut_left_x GPU pointer to left X LUT (may be NULL)
 * @param[in] lut_left_y GPU pointer to left Y LUT (may be NULL)
 * @param[in] lut_right_x GPU pointer to right X LUT (may be NULL)
 * @param[in] lut_right_y GPU pointer to right Y LUT (may be NULL)
 * @param[in] weight_left GPU pointer to left weights (may be NULL)
 * @param[in] weight_right GPU pointer to right weights (may be NULL)
 *
 * @note Always call before plugin destruction to prevent memory leaks
 * @note Function is synchronous and waits for GPU operations to complete
 *
 * @see load_panorama_luts
 */
void free_panorama_luts(
    float* lut_left_x,
    float* lut_left_y,
    float* lut_right_x,
    float* lut_right_y,
    float* weight_left,
    float* weight_right
);

/**
 * @brief Legacy color correction update (simple version)
 *
 * Legacy function maintained for backward compatibility.
 * Use async color correction API for new code.
 *
 * @deprecated Use analyze_color_correction_async() and finalize_color_correction_factors() instead
 *
 * @param[in] left_frame Left camera frame (GPU memory)
 * @param[in] right_frame Right camera frame (GPU memory)
 * @param[in] weight_left Left camera weights (GPU memory)
 * @param[in] weight_right Right camera weights (GPU memory)
 * @param[in] width Frame width in pixels
 * @param[in] height Frame height in pixels
 * @param[in] pitch Frame pitch/stride in bytes
 * @param[in] stream CUDA stream for execution
 *
 * @return cudaSuccess on success, error code on failure
 */
cudaError_t update_color_correction_simple(
    const unsigned char* left_frame,
    const unsigned char* right_frame,
    const float* weight_left,
    const float* weight_right,
    int width,
    int height,
    int pitch,
    cudaStream_t stream
);

/**
 * @brief Initialize color correction subsystem
 *
 * Initializes internal state for color correction.
 * Must be called once before using color correction features.
 *
 * @return cudaSuccess on success, error code on failure
 *
 * @note Thread-safe, but call only once during plugin initialization
 */
cudaError_t init_color_correction(void);

// ========== ASYNC COLOR CORRECTION (Hardware-Sync-Aware) ==========

/**
 * @brief Analyze color differences in overlap region (async, non-blocking)
 *
 * Launches GPU kernel to analyze color mismatches between left and right
 * cameras in the panorama overlap region. Computes weighted RGB sums and
 * luma values for subsequent CPU-side correction factor calculation.
 *
 * CRITICAL: This function is NON-BLOCKING. It launches the kernel on the
 * provided stream and returns immediately. Caller must synchronize before
 * reading output_buffer.
 *
 * Algorithm:
 * 1. For each pixel in overlap region, read both camera pixels via LUT
 * 2. Compute spatial weight (vignetting compensation with falloff)
 * 3. Accumulate weighted RGB sums and luma for each camera
 * 4. Reduction results written to output_buffer (9 float values)
 *
 * Output buffer layout (9 floats):
 * - [0-2]: sum_L_R, sum_L_G, sum_L_B (left camera weighted RGB sums)
 * - [3]: sum_L_luma (left camera weighted luminance)
 * - [4-6]: sum_R_R, sum_R_G, sum_R_B (right camera weighted RGB sums)
 * - [7]: sum_R_luma (right camera weighted luminance)
 * - [8]: total_weight (sum of all spatial weights)
 *
 * @param[in] left_ptr Left camera frame pointer (GPU memory, RGBA)
 * @param[in] right_ptr Right camera frame pointer (GPU memory, RGBA)
 * @param[in] left_pitch Left camera frame pitch in bytes
 * @param[in] right_pitch Right camera frame pitch in bytes
 * @param[in] pano_width Panorama output width in pixels
 * @param[in] pano_height Panorama output height in pixels
 * @param[in] lut_left_x Left camera X coordinate LUT (GPU memory)
 * @param[in] lut_left_y Left camera Y coordinate LUT (GPU memory)
 * @param[in] lut_right_x Right camera X coordinate LUT (GPU memory)
 * @param[in] lut_right_y Right camera Y coordinate LUT (GPU memory)
 * @param[in] weight_left Left camera blending weights (GPU memory)
 * @param[in] weight_right Right camera blending weights (GPU memory)
 * @param[in] overlap_center_x Overlap region center X (normalized, 0.0-1.0, typically 0.5)
 * @param[in] overlap_width Overlap region width (normalized, 0.0-1.0, e.g., 0.1 for 10%)
 * @param[in] spatial_falloff Vignetting compensation exponent (typically 2.0)
 * @param[out] output_buffer GPU buffer for 9 floats (reduction results)
 * @param[in] stream CUDA stream for async execution
 *
 * @return cudaSuccess on kernel launch success, error code on failure
 * @retval cudaSuccess Kernel launched successfully
 * @retval cudaErrorInvalidValue NULL pointer in input/output
 * @retval cudaErrorLaunchFailure Kernel launch failed
 *
 * @note ASYNC function - does not wait for kernel completion
 * @note Synchronize stream before reading output_buffer
 * @note Typical usage: Launch on low-priority stream, check with cudaEventQuery()
 *
 * @see finalize_color_correction_factors
 * @see update_color_correction_factors
 */
cudaError_t analyze_color_correction_async(
    const unsigned char* left_ptr,
    const unsigned char* right_ptr,
    int left_pitch,
    int right_pitch,
    int pano_width,
    int pano_height,
    const float* lut_left_x,
    const float* lut_left_y,
    const float* lut_right_x,
    const float* lut_right_y,
    const float* weight_left,
    const float* weight_right,
    float overlap_center_x,
    float overlap_width,
    float spatial_falloff,
    float* output_buffer,      // Device buffer for 9 floats (reduction results)
    cudaStream_t stream
);

/**
 * @brief Finalize color correction factors (CPU-side post-processing)
 *
 * Computes color correction factors from GPU analysis results.
 * Performs weighted averaging, gain ratio calculation, and gamma correction
 * computation with safety clamping.
 *
 * Algorithm:
 * 1. Validate sufficient samples (total_weight > MIN_SAMPLES)
 * 2. Compute weighted RGB means for each camera
 * 3. Calculate gain ratios to balance colors between cameras
 * 4. Compute gamma correction from luma ratios (if enabled)
 * 5. Clamp to safe ranges (GAIN_MIN/MAX, GAMMA_MIN/MAX)
 *
 * Input array layout (9 floats from analyze_color_correction_async):
 * - [0-2]: sum_L_R, sum_L_G, sum_L_B
 * - [3]: sum_L_luma
 * - [4-6]: sum_R_R, sum_R_G, sum_R_B
 * - [7]: sum_R_luma
 * - [8]: total_weight
 *
 * Output structure (8 factors):
 * - left_r, left_g, left_b, left_gamma
 * - right_r, right_g, right_b, right_gamma
 *
 * @param[in] accumulated_sums Input array of 9 values from GPU reduction
 * @param[out] output Computed color correction factors (8 values)
 * @param[in] enable_gamma Enable gamma correction (true) or RGB gains only (false)
 *
 * @return Status code
 * @retval 0 Success - valid correction factors computed
 * @retval -1 Insufficient samples (total_weight < MIN_SAMPLES)
 * @retval -2 Invalid data (NaN or Inf detected in input)
 *
 * @note CPU-only function (no GPU synchronization needed)
 * @note Returns identity correction (1.0 for all factors) on error
 * @warning Caller must ensure GPU analysis completed before calling
 *
 * @see analyze_color_correction_async
 * @see update_color_correction_factors
 * @see ColorCorrectionFactors
 */
int finalize_color_correction_factors(
    const float* accumulated_sums,  // Input: 9 values from GPU
    ColorCorrectionFactors* output, // Output: 8 correction factors
    bool enable_gamma
);

/**
 * @brief Update color correction factors in device constant memory
 *
 * Copies color correction factors to GPU constant memory for use by
 * stitching kernels. Factors are applied during pixel blending to
 * correct color mismatches between cameras.
 *
 * @param[in] factors Pointer to ColorCorrectionFactors structure (8 float values)
 *
 * @return cudaSuccess on success, error code on failure
 * @retval cudaSuccess Factors copied to constant memory successfully
 * @retval cudaErrorInvalidValue NULL pointer
 * @retval cudaErrorInvalidMemcpyDirection Invalid memory transfer direction
 *
 * @note Function is synchronous (waits for memcpy completion)
 * @note Factors take effect immediately for subsequent kernel launches
 * @warning Must call init_color_correction() before first use
 *
 * @see finalize_color_correction_factors
 * @see ColorCorrectionFactors
 */
cudaError_t update_color_correction_factors(
    const ColorCorrectionFactors* factors
);

// ========== ERROR HANDLING ==========

/**
 * @brief Comprehensive CUDA error checking macro with custom error actions
 *
 * Wraps CUDA API calls with error checking and custom error handling.
 * Prints detailed error message to stderr and executes user-defined action.
 *
 * @param call CUDA API call to execute (e.g., cudaMalloc(...))
 * @param error_action Statement to execute on error (e.g., return GST_FLOW_ERROR)
 *
 * @note Error message includes file, line, error string, and error name
 * @warning Do not use with statements requiring cleanup before error_action
 *
 * Example usage:
 * @code
 * float* d_buffer = nullptr;
 * CUDA_CHECK_RETURN(cudaMalloc(&d_buffer, size), return GST_FLOW_ERROR);
 * CUDA_CHECK_RETURN(cudaMemcpy(d_buffer, h_buffer, size, cudaMemcpyHostToDevice), goto cleanup);
 * @endcode
 */
#define CUDA_CHECK_RETURN(call, error_action)                                \
do {                                                                          \
    cudaError_t err = call;                                                   \
    if (err != cudaSuccess) {                                                 \
        fprintf(stderr, "[CUDA ERROR] %s:%d: %s (%s)\n",                     \
                __FILE__, __LINE__,                                           \
                cudaGetErrorString(err), cudaGetErrorName(err));              \
        error_action;                                                         \
    }                                                                         \
} while(0)

#ifdef __cplusplus
}
#endif

#endif // __CUDA_STITCH_KERNEL_H__
