const searchData = {"envversion": {"sphinx.domains.c": 3, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 9, "sphinx.domains.index": 1, "sphinx.domains.javascript": 3, "sphinx.domains.math": 2, "sphinx.domains.python": 4, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.enhanced_search": 2, "sphinx": 62}, "data": [{"id": 0, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#behavior-tree-codelets", "display_name": "Behavior Tree Codelets", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "behavior-tree-codelets", "priority": -1, "content": "Each behavior tree codelet can have a set of parameters defining how it should behave. Note that in all the examples given below, the naming convention for configuring the children parameter for root codelets is [child_codelet_name\\child_codelet_scheduling_term] .", "keywords": []}, {"id": 1, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#constant-behavior", "display_name": "Constant Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "constant-behavior", "priority": -1, "content": "After each tick period, switches its own status to the configured desired constant status. Parameter Description s_term scheduling term used for scheduling the entity itself constant_status The desired status to switch to during each tick time. An example diagram depicting Constant behavior used in conjunction with a Sequence behavior defined for root entity is shown below Here, the child1 is configured to return a constant status of success (GXF_BEHAVIOR_SUCCESS) and child2 returns failure (GXF_BEHAVIOR_FAILURE), resulting into the root node (configured to exhibit sequence behavior) returning GXF_BEHAVIOR_FAILURE. The controller for each child can be configured to repeat the execution on failure. A code snippet of configuring the example described is shown below. name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_codelet type: nvidia::gxf::SequenceBehavior parameters: children: [ child1/child1_st, child2/child2_st ] s_term: root_st --- name: child2 components: - name: child2_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 3 return_behavior_running_if_failure_repeat: true - name: child2_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: false - name: child2_codelet type: nvidia::gxf::ConstantBehavior parameters: s_term: child2_st constant_status: 1", "keywords": []}, {"id": 2, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#general-concept", "display_name": "General Concept", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "general-concept", "priority": -1, "content": "Behavior trees consist of n-ary trees of entities that can have zero or more children. The conditional execution of parent entity is based on the status of execution of the children. A behavior tree is graphically represented as a directed tree in which the nodes are classified as root, control flow nodes, or execution nodes (tasks). For each pair of connected nodes, the outgoing node is called parent and the incoming node is called child. The execution of a behavior tree starts from the root which sends ticks with a certain frequency to its child. When the execution of a node in the behavior tree is allowed, it returns to the parent a status running if its execution has not finished yet, success if it has achieved its goal, or failure otherwise. The behavior tree also uses a controller component for controlling the entity\u2019s termination policy and the execution status. One of the controller behaviors currently implemented for Behavior Tree is EntityCountFailureRepeatController , which repeats the entity on failure up to repeat_count times before deactivating it. GXF supports several behavior tree codelets which are explained in the following section.", "keywords": []}, {"id": 3, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#parallel-behavior", "display_name": "Parallel Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "parallel-behavior", "priority": -1, "content": "Runs its child nodes in parallel. By default, succeeds when all child nodes succeed, and fails when all child nodes fail. This behavior can be customized using the parameters below. Parameter Description s_term scheduling term used for scheduling the entity itself children Child entities success_threshold Number of successful children required for success. A value of -1 means all children must succeed for this node to succeed. failure_threshold Number of failed children required for failure. A value of -1 means all children must fail for this node to fail. The diagram below shows a graphical representation of a parallel behavior configured with failure_threshold configured as -1. Hence, the root node returns GXF_BEHAVIOR_SUCCESS even if one child returns a failure status. A code snippet to configure the example described is shown below. name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_codelet type: nvidia::gxf::ParallelBehavior parameters: children: [ child1/child1_st, child2/child2_st ] s_term: root_st success_threshold: 1 failure_threshold: -1", "keywords": []}, {"id": 4, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#repeat-behavior", "display_name": "Repeat Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "repeat-behavior", "priority": -1, "content": "Repeats its only child entity. By default, won\u2019t repeat when the child entity fails. This can be customized using the parameters below. Parameter Description s_term scheduling term used for scheduling the entity itself repeat_after_failure Denotes whether to repeat the child after it has failed. The diagram below shows a graphical representation of a repeat behavior. The root entity can be configured to repeat the only child to repeat after failure. It succeeds when the child entity succeeds. A code snippet to configure a repeat behavior is as shown below - name: repeat_knock components: - name: repeat_knock_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: repeat_knock_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: false - name: repeat_codelet type: nvidia::gxf::RepeatBehavior parameters: s_term: repeat_knock_st children: [ knock_on_door/knock_on_door_st ] repeat_after_failure: true ---", "keywords": []}, {"id": 5, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#selector-behavior", "display_name": "Selector Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "selector-behavior", "priority": -1, "content": "Runs all child entities in sequence until one succeeds, then reports success. If all child entities fail (or no child entities are present), this codelet fails. Parameter Description s_term scheduling term used for scheduling the entity itself children Child entities The diagram below shows a graphical representation of a Selector behavior. The root entity starts child_1, child_2 and child_3 in a sequence. Although child_1 and child_2 fail, the root entity will return success since child_3 returns successfully. A code snippet to configure a selector behavior is as shown below - name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_sel_codelet type: nvidia::gxf::SelectorBehavior parameters: children: [ door_distance/door_distance_st, door_detected/door_detected_st, knock/knock_st ] s_term: root_st --- name: door_distance components: - name: door_distance_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: door_distance_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: false - name: door_dist type: nvidia::gxf::SequenceBehavior parameters: children: [] s_term: door_distance_st ---", "keywords": []}, {"id": 6, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#sequence-behavior", "display_name": "Sequence Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "sequence-behavior", "priority": -1, "content": "Runs its child entities in sequence, in the order in which they are defined. Succeeds when all child entities succeed or fails as soon as one child entity fails. Parameter Description s_term scheduling term used for scheduling the entity itself children Child entities The diagram below shows a graphical representation of a Sequence behavior. The root entity starts child_1, child_2 and child_3 in a sequence. Although child_1 and child_2 pass, the root entity will return failure since child_3 returns failure. A code snippet to configure a sequence behavior is as shown below - name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_codelet type: nvidia::gxf::SequenceBehavior parameters: children: [ child1/child1_st, child2/child2_st ] s_term: root_st", "keywords": []}, {"id": 7, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#switch-behavior", "display_name": "Switch Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "switch-behavior", "priority": -1, "content": "Runs the child entity with the index defined as desired_behavior. Parameter Description s_term scheduling term used for scheduling the entity itself children Child entities desired_behavior The index of child entity to switch to when this entity runs In the code snippet shown below, the desired behavior of the root entity is designated to be the the child at index 1. (scene). Hence, that is the entity that is run. name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_switch_codelet type: nvidia::gxf::SwitchBehavior parameters: children: [ scene/scene_st, ref/ref_st ] s_term: root_st desired_behavior: 0 --- name: scene components: - name: scene_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: scene_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: false - name: scene_seq type: nvidia::gxf::SequenceBehavior parameters: children: [ pose/pose_st, det/det_st, seg/seg_st ] s_term: scene_st ---", "keywords": []}, {"id": 8, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree#timer-behavior", "display_name": "Timer Behavior", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "timer-behavior", "priority": -1, "content": "Waits for a specified amount of time delay and switches to the configured result switch_status afterwards. Parameter Description s_term scheduling term used for scheduling the entity itself clock Clock switch_status Configured result to switch to after the specified delay delay Configured delay In the diagram shown below, the child entity switches to failure after a configured delay period. The root entity hence returns failure. A code snippet for the same shown below - name: knock_on_door components: - name: knock_on_door_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 10 - name: knock_on_door_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: false - name: knock type: nvidia::gxf::TimerBehavior parameters: switch_status: 1 clock: sched/clock delay: 1 s_term: knock_on_door_st ---", "keywords": []}, {"id": 9, "doc_id": 9, "filename": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "display_name": "Behavior Trees", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/Behavior_Tree", "anchor": "", "priority": -1, "content": "Behavior tree codelets are one of the mechanisms to control the flow of tasks in GXF. They follow the same general behavior as classical behavior trees, with some useful additions for robotics applications. This document gives an overview of the general concept, the available behavior tree node types, and some examples of how to use them individually or in conjunction with each other.", "keywords": []}, {"id": 10, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#benchmarkallocator", "display_name": "BenchmarkAllocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "benchmarkallocator", "priority": -1, "content": "Benchmarks allocator component Component ID: f559d7cc-bdf4-49b6-8ec0a-7b6ecb4b222 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 11, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "id2", "priority": -1, "content": "transmitter Benchmark publisher\u2019s transmitter. Transmitter to publish benchmark messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver entity_buffer Benchmark message entity buffer. Component that holds buffered benchmark message entities Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntityBuffer benchmark_publisher_async_scheduling_term Benchmark publisher execution control scheduling term. A async scheduling term to control execution of the benchmark publisher Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::AsynchronousSchedulingTerm", "keywords": []}, {"id": 12, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "id3", "priority": -1, "content": "data_source_boolean_scheduling_terms Boolean scheduling terms for perminately stopping data sources Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;gxf::BooleanSchedulingTerm&gt;&gt; data_source_async_scheduling_terms Scheduling terms to control execution of data source Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;gxf::AsynchronousSchedulingTerm&gt;&gt; benchmark_controller_boolean_scheduling_term A boolean scheduling term for perminately stopping this controller Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::BooleanSchedulingTerm&gt; benchmark_controller_target_time_scheduling_term A target time scheduling term for enforcing timeout during benchmarking Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::TargetTimeSchedulingTerm&gt; graph_boolean_scheduling_terms Boolean scheduling terms that will be disabled when benchmark ends Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;gxf::BooleanSchedulingTerm&gt;&gt; dependent_components A list of components whose states must be ready before starting to benchmark Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;gxf::Component&gt;&gt; data_replay_control_transmitter Transmitter to send replay command to the connected data replayer Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::Transmitter&gt; benchmark_publishers A list of benchmark publishers that buffer and publish benchmark messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;BenchmarkPublisher&gt;&gt; benchmark_sinks A list of benchmark sinks that record message arrival timestamps Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;BenchmarkSinkBase&gt;&gt; resource_profilers A list of associated resource profilers to generate resource profiling reports** Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;ResourceProfilerBase&gt;&gt; trial_run Enable a trial run when set to true Flags: GXF_PARAMETER_FLAGS_NONE (true = default) Type: GXF_PARAMETER_TYPE_BOOL kill_at_the_end Kill this process when the benchmark ends Flags: GXF_PARAMETER_FLAGS_NONE (false = default) Type: GXF_PARAMETER_TYPE_BOOL title Benchmark title to generate benchmark reports Flags: GXF_PARAMETER_FLAGS_NONE (\u201cUndefined Benchmark Title\u201d = default) Type: GXF_PARAMETER_TYPE_STRING exported_report File to store exported report Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::File&gt; entity_buffer_size The number of messages to be buffered in each entity buffer Flags: GXF_PARAMETER_FLAGS_NONE (5 = default) Type: GXF_PARAMETER_TYPE_SIZE_T benchmark_duration_ms The duration of each benchmark iteration in miliseconds Flags: GXF_PARAMETER_FLAGS_NONE (5000 = default) Type: GXF_PARAMETER_TYPE_UINT64_T benchmark_iterations The number of benchmark iterations to be conducted for each benchmark test case Flags: GXF_PARAMETER_FLAGS_NONE (5 = default) Type: GXF_PARAMETER_TYPE_SIZE_T benchmark_buffering_timeout_s The max wait time in seconds before stopping the benchmark buffering stage Flags: GXF_PARAMETER_FLAGS_NONE (5 = default) Type: GXF_PARAMETER_TYPE_UINT64_T post_trial_benchmark_iteration_delay_s The wait time in seconds after a trial benchmark iteration before summarizing results Flags: GXF_PARAMETER_FLAGS_NONE (2 = default) Type: GXF_PARAMETER_TYPE_UINT64_T post_benchmark_iteration_delay_s The wait time in seconds after each benchmark iteration before summarizing results Flags: GXF_PARAMETER_FLAGS_NONE (2 = default) Type: GXF_PARAMETER_TYPE_UINT64_T", "keywords": []}, {"id": 13, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "id4", "priority": -1, "content": "receiver A receiver for retrieving incoming messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::Receiver&gt; performance_calculators A list of associated performance calculators for the incoming message flow Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;PerformanceCalculatorBase&gt;&gt; benchmark_allocator Benchmark Allocator allocation and free calls Flags: GXF_PARAMETER_FLAGS_NONE (false = default) Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 14, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "id5", "priority": -1, "content": "storage_type Flags: GXF_PARAMETER_FLAGS_NONE (MemoryStorageType::kHost = default) Type: GXF_PARAMETER_TYPE_INT32_T clock Used to add timestamp in the messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;Clock&gt; output Transmitter channel publishing messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;Transmitter&gt; block_size The size of one block of memory in byte Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64_T number_of_blocks The total number of blocks which are allocated by the pool Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32_T number_of_iterations The total number of iterations for which allocation and free will be called Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32_T allocator Memory allocator for benchmarking Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;Allocator&gt; in The channel for incoming messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;Receiver&gt;", "keywords": []}, {"id": 15, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-allocatormetricscalculator", "display_name": "nvidia::gxf::benchmark::AllocatorMetricsCalculator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-allocatormetricscalculator", "priority": -1, "content": "Calculates performance outcomes for allocator metrics Component ID: 7a22ea90-af3f-4b2f-9a84-cbcae845eef2 Base Type: nvidia::gxf::benchmark::PerformanceCalculatorBase", "keywords": []}, {"id": 16, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-basicmetricscalculator", "display_name": "nvidia::gxf::benchmark::BasicMetricsCalculator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-basicmetricscalculator", "priority": -1, "content": "Calculates performance outcomes for basic metrics Component ID: 135cc602-9a18-437b-8d1d-d4e0a1fbd45d Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 17, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-benchmarkallocatorsink", "display_name": "nvidia::gxf::benchmark::BenchmarkAllocatorSink", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-benchmarkallocatorsink", "priority": -1, "content": "Records allocate/free duration for allocator component Component ID: 2c9a44d3-63f8-40f0-9225e-87e6fd1679d Base Type: nvidia::gxf::benchmark::BenchmarkSinkBase", "keywords": []}, {"id": 18, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-benchmarkcontroller", "display_name": "nvidia::gxf::benchmark::BenchmarkController", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-benchmarkcontroller", "priority": -1, "content": "Controls benchmark flow Component ID: 763b5541-5b65-4b84-a6ee8-37d9459e903 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 19, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-benchmarkpublisher", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-benchmarkpublisher", "priority": -1, "content": "Publishes buffered benchmark messages Component ID: 52d9e7c7-2a39-4dd6-9b10f-6242dc4c6d6 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 20, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-benchmarksink", "display_name": "nvidia::gxf::benchmark::BenchmarkSink", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-benchmarksink", "priority": -1, "content": "Records message arrival timestamps Component ID: 35885a99-e29a-4cdb-a08d7-b288ccf41f1 Base Type: nvidia::gxf::benchmark::BenchmarkSinkBase", "keywords": []}, {"id": 21, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#nvidia-gxf-benchmark-entitybuffer", "display_name": "nvidia::gxf::benchmark::EntityBuffer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "nvidia-gxf-benchmark-entitybuffer", "priority": -1, "content": "Buffers incoming message entities Component ID: a2e06c99-67d1-4f24-a393-dd3e0fb76242 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 22, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#parameter", "display_name": "Parameter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "parameter", "priority": -1, "content": "receiver A receiver for retrieving incoming messages Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver benchmark_publisher A benchmark publisher for retrieving published timestamps Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::BenchmarkPublisher performance_calculators A list of associated performance calculators for the incoming message flow Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: std::vector&lt;gxf::Handle&lt;PerformanceCalculatorBase&gt;&gt; use_received_acqtime_as_published Use acqtime from incoming messages as published message timestamps Flags: GXF_PARAMETER_FLAGS_NONE (false = default) Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 23, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "parameters", "priority": -1, "content": "receiver Entity buffer receiver. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 24, "doc_id": 24, "filename": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "display_name": "BenchmarkExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/BenchmarkExtension", "anchor": "", "priority": -1, "content": "Benchmark related components in GXF. UUID: b53ebe0c-e427-4485-8ca2-a4ddc8664bec Version: 0.0.1 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 25, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "id2", "priority": -1, "content": "rx Receiver to receive all messages carrying nvidia::gxf::CudaStreamId . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver tx Transmitter to send messages to downstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 26, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "id3", "priority": -1, "content": "gpu_device GPU device resource from which is used allocate CUDA memory. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::GPUDevice device_memory_initial_size The initial memory pool size used by device memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c16MB\u201d (non-Jetson machine) or \u201c8MB\u201d (Jetson machine) device_memory_max_size The maximum memory pool size used by device memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c32MB\u201d (non-Jetson machine) or \u201c16MB\u201d (Jetson machine) release_threshold The release threshold specifies the maximum amount of memory the pool caches. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 0", "keywords": []}, {"id": 27, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudaallocator", "display_name": "nvidia::gxf::CudaAllocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudaallocator", "priority": -1, "content": "Base class for RMMAllocator and StreamOrderedAllocator/ Component ID: cac15f93-6438-4ed3-bc61-b5dba25b6f91 Base Type: nvidia::gxf::Allocator Defined in: gxf/cuda/cuda_allocator.hpp", "keywords": []}, {"id": 28, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudaevent", "display_name": "nvidia::gxf::CudaEvent", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudaevent", "priority": -1, "content": "Holds and provides access to native cudaEvent_t handle. When a nvidia::gxf::CudaEvent is created, you\u2019ll need to initialize a native cudaEvent_t through init(flags, dev_id) , or set third party event through initWithEvent(event, dev_id, free_fnc) . The event keeps valid until deinit is called explicitly otherwise gets recycled in destructor. Component ID: f5388d5c-a709-47e7-86c4-171779bc64f3 Defined in: gxf/cuda/cuda_event.hpp", "keywords": []}, {"id": 29, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudastream", "display_name": "nvidia::gxf::CudaStream", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudastream", "priority": -1, "content": "Holds and provides access to native cudaStream_t . nvidia::gxf::CudaStream handle must be allocated by nvidia::gxf::CudaStreamPool . Its lifecycle is valid until explicitly recycled through nvidia::gxf::CudaStreamPool.releaseStream() or implicitly until nvidia::gxf::CudaStreamPool is deactivated. You may call stream() to get the native cudaStream_t handle, and to submit GPU operations. After the submission, GPU takes over the input tensors/buffers and keeps them in use. To prevent host carelessly releasing these in-use buffers, CUDA Codelet needs to call record(event, input_entity, sync_cb) to extend input_entity \u2019s lifecycle until GPU completely consumes it. Alternatively, you may call record(event, event_destroy_cb) for native cudaEvent_t operations and free in-use resource via event_destroy_cb . It is required to have a nvidia::gxf::CudaStreamSync in the graph pipeline after all the CUDA operations. See more details in nvidia::gxf::CudaStreamSync Component ID: 5683d692-7884-11eb-9338-c3be62d576be Defined in: gxf/cuda/cuda_stream.hpp", "keywords": []}, {"id": 30, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudastreamid", "display_name": "nvidia::gxf::CudaStreamId", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudastreamid", "priority": -1, "content": "Holds CUDA stream Id to deduce nvidia::gxf::CudaStream handle. stream_cid should be nvidia::gxf::CudaStream component id. Component ID: 7982aeac-37f1-41be-ade8-6f00b4b5d47c Defined in: gxf/cuda/cuda_stream_id.hpp", "keywords": []}, {"id": 31, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudastreampool", "display_name": "nvidia::gxf::CudaStreamPool", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudastreampool", "priority": -1, "content": "CudaStream allocation. You must explicitly call allocateStream() to get a valid nvidia::gxf::CudaStream handle. This component would hold all the its allocated nvidia::gxf::CudaStream entities until releaseStream(stream) is called explicitly or the CudaStreamPool component is deactivated. Component ID: 6733bf8b-ba5e-4fae-b596-af2d1269d0e7 Base Type: nvidia::gxf::Allocator", "keywords": []}, {"id": 32, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-cudastreamsync", "display_name": "nvidia::gxf::CudaStreamSync", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-cudastreamsync", "priority": -1, "content": "Synchronize all CUDA streams which are carried by message entities. This codelet is required to get connected in the graph pipeline after all CUDA ops codelets. When a message entity is received, it would find all of the nvidia::gxf::CudaStreamId in that message, and extract out each nvidia::gxf::CudaStream . With each CudaStream handle, it synchronizes all previous nvidia::gxf::CudaStream.record() events, along with all submitted GPU operations before this point. CudaStreamSync must be set in the graph when nvidia::gxf::CudaStream.record() is used, otherwise it may cause memory leak. Component ID: 0d1d8142-6648-485d-97d5-277eed00129c Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 33, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#nvidia-gxf-streamorderedallocator", "display_name": "nvidia::gxf::StreamOrderedAllocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "nvidia-gxf-streamorderedallocator", "priority": -1, "content": "Memory Allocator with stream order memory allocation on GPU device. Component ID: 63d1d168-13d7-11ef-931a-0be4a6378384 Base Type: nvidia::gxf::CudaAllocator", "keywords": []}, {"id": 34, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "parameters", "priority": -1, "content": "dev_id GPU device id. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default Value: 0 stream_flags Flag values to create CUDA streams. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default Value: 0 stream_priority Priority values to create CUDA streams. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default Value: 0 reserved_size User-specified file name without extension. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default Value: 1 max_size Maximum Stream Size. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default Value: 0, no limitation.", "keywords": []}, {"id": 35, "doc_id": 35, "filename": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "display_name": "CudaExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/CudaExtension", "anchor": "", "priority": -1, "content": "Extension for CUDA operations. UUID: d63a98fa-7882-11eb-a917-b38f664f399c Version: 2.6.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 36, "doc_id": 40, "filename": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "anchor": "id2", "priority": -1, "content": "port IPC server port to send request to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 50000 server_ip_address IPC server ip address to send request to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 0.0.0.0 enable_health_check Enable GRPC built in heath check stub. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false", "keywords": []}, {"id": 37, "doc_id": 40, "filename": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension#nvidia-gxf-grpcclient", "display_name": "nvidia::gxf::GrpcClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "anchor": "nvidia-gxf-grpcclient", "priority": -1, "content": "IPC Client implementation based on Grpc. Component ID: f05f8a46-b4ce-4e3d-bd9c-326680abea03 Base Type: nvidia::gxf::IPCClient", "keywords": []}, {"id": 38, "doc_id": 40, "filename": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension#nvidia-gxf-grpcserver", "display_name": "nvidia::gxf::GrpcServer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "anchor": "nvidia-gxf-grpcserver", "priority": -1, "content": "IPC Server implementation based on Grpc. Component ID: 0e6b2f6c-057a-8431-925b-fa476c3265b6 Base Type: nvidia::gxf::IPCServer", "keywords": []}, {"id": 39, "doc_id": 40, "filename": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "anchor": "parameters", "priority": -1, "content": "port GRPC port for listening. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 50000 remote_access Allow access from remote clients. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false", "keywords": []}, {"id": 40, "doc_id": 40, "filename": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "display_name": "GrpcExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/GrpcExtension", "anchor": "", "priority": -1, "content": "Extension for GRPC based communication tools. UUID: 62e7335c-c555-47c9-a2d2-21991b7fd250 Version: 0.5.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 41, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "id2", "priority": -1, "content": "port Http IPC server port to send request to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 50000 server_ip_address Http IPC server ip address to send request to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 0.0.0.0 use_https Use TLS(SSL). If true, protocol is https. Otherwise protocol is http. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false content-type content-type in Http. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 0.0.0.0", "keywords": []}, {"id": 42, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "id3", "priority": -1, "content": "server_ip_port Server IP and Port. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u2018\u2019 use_https Use TLS(SSL). If true, protocol is https. Otherwise protocol is http. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false", "keywords": []}, {"id": 43, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#nvidia-gxf-cppresthttpclient", "display_name": "nvidia::gxf::CppRestHttpClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "nvidia-gxf-cppresthttpclient", "priority": -1, "content": "A light-weight http client implementation. Component ID: 562dae41-5e70-4495-a7e8-d196cedf3f9f Base Type: nvidia::gxf::HttpClient", "keywords": []}, {"id": 44, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#nvidia-gxf-httpclient", "display_name": "nvidia::gxf::HttpClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "nvidia-gxf-httpclient", "priority": -1, "content": "Interface for basic http client that works with http server inherited from IPCServer Component ID: fb4e20e4-15c8-4cb4-ad87-9c161d326748 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 45, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#nvidia-gxf-httpipcclient", "display_name": "nvidia::gxf::HttpIPCClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "nvidia-gxf-httpipcclient", "priority": -1, "content": "IPC Client implementation based on Http Component ID: 695479d5-28db-4a4e-bbbd-a2b1af390297 Base Type: nvidia::gxf::IPCClient", "keywords": []}, {"id": 46, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#nvidia-gxf-httpserver", "display_name": "nvidia::gxf::HttpServer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "nvidia-gxf-httpserver", "priority": -1, "content": "A light-weight http API server Component ID: 70089546-8a59-442e-b91e-7708f2640fca Base Type: nvidia::gxf::IPCServer", "keywords": []}, {"id": 47, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "parameters", "priority": -1, "content": "port HTTP port for listening. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 8000 remote_access Allow access from a remote client. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false", "keywords": []}, {"id": 48, "doc_id": 48, "filename": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "display_name": "HttpExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/HttpExtension", "anchor": "", "priority": -1, "content": "Http protocol related components in Gxf. UUID: 22a21c97-f20b-4c03-b277-6e6f52303328 Version: 0.5.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 49, "doc_id": 52, "filename": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension#components", "display_name": "Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension", "anchor": "components", "priority": -1, "content": "This extension is implemented using the component: MISBParser", "keywords": []}, {"id": 50, "doc_id": 52, "filename": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension#nvidia-gxf-misbparser", "display_name": "nvidia::gxf::MISBParser", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension", "anchor": "nvidia-gxf-misbparser", "priority": -1, "content": "This codelet parses the MISB metadata and stores the parsed items in nvidia::gxf::MISBParsedData. Only the most commonly occuring items are parsed and does not provide support for parsing of full set of items in the metadata. Component ID: 1f3bf75b-6624-4f46-b5b5-5f8d88aa20eb Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 51, "doc_id": 52, "filename": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension", "anchor": "parameters", "priority": -1, "content": "input_metadata Receiver to get the input MISB metadata Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver output_parsed_metadata Transmit the parsed MISB items from KLV metadata Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter dump_klv_metadata Dump the received KLV metadata to file Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 52, "doc_id": 52, "filename": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension", "display_name": "MISBExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/MISBExtension", "anchor": "", "priority": -1, "content": "NVIDIA GXF component for MISB metadata parsing. MISB metadata will be present in the transport streams and the upstream demuxer gathers the metadata and feed to the MISB parser. GstTSDemux, which is a deepstream component is used to demux the MISB metadata from transport stream and is fed to the MISB parser with the help of Deepstream to GXF bridge. The MISB extension follows the standard MISB ST 0601.17. UUID: 1c1a2930-0768-455b-984d-aef97c5c1a52 Version: 0.3.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 53, "doc_id": 55, "filename": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension#nvidia-gxf-audiobuffer", "display_name": "nvidia::gxf::AudioBuffer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension", "anchor": "nvidia-gxf-audiobuffer", "priority": -1, "content": "AudioBuffer is similar to Tensor component in the standard extension and holds memory and metadata corresponding to an audio buffer. Component ID: a914cac6-5f19-449d-9ade-8c5cdcebe7c3 AudioBufferInfo structure captures the following metadata: Field Description channels Number of channels in an audio frame samples Number of samples in an audio frame sampling_rate sampling rate in Hz bytes_per_sample Number of bytes required per sample audio_format AudioFormat of an audio frame audio_layout AudioLayout of an audio frame Supported AudioFormat types: AudioFormat Description GXF_AUDIO_FORMAT_S16LE 16-bit signed PCM audio GXF_AUDIO_FORMAT_F32LE 32-bit floating-point audio Supported AudioLayout types: AudioLayout Description GXF_AUDIO_LAYOUT_INTERLEAVED Data from all the channels to be interleaved - LRLRLR GXF_AUDIO_LAYOUT_NON_INTERLEAVED Data from all the channels not to be interleaved - LLLRRR", "keywords": []}, {"id": 54, "doc_id": 55, "filename": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension#nvidia-gxf-videobuffer", "display_name": "nvidia::gxf::VideoBuffer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension", "anchor": "nvidia-gxf-videobuffer", "priority": -1, "content": "VideoBuffer is similar to Tensor component in the standard extension and holds memory and metadata corresponding to a video buffer. Component ID: 16ad58c8-b463-422c-b097-61a9acc5050e VideoBufferInfo structure captures the following metadata: Field Description width width of a video frame height height of a video frame color_format VideoFormat of a video frame color_planes ColorPlane(s) associated with the VideoFormat surface_layout SurfaceLayout of the video frame Supported VideoFormat types: VideoFormat Description GXF_VIDEO_FORMAT_YUV420 BT.601 multi planar 4:2:0 YUV GXF_VIDEO_FORMAT_YUV420_ER BT.601 multi planar 4:2:0 YUV ER GXF_VIDEO_FORMAT_YUV420_709 BT.709 multi planar 4:2:0 YUV GXF_VIDEO_FORMAT_YUV420_709_ER BT.709 multi planar 4:2:0 YUV ER GXF_VIDEO_FORMAT_NV12 BT.601 multi planar 4:2:0 YUV with interleaved UV GXF_VIDEO_FORMAT_NV12_ER BT.601 multi planar 4:2:0 YUV ER with interleaved UV GXF_VIDEO_FORMAT_NV12_709 BT.709 multi planar 4:2:0 YUV with interleaved UV GXF_VIDEO_FORMAT_NV12_709_ER BT.709 multi planar 4:2:0 YUV ER with interleaved UV GXF_VIDEO_FORMAT_RGBA RGBA-8-8-8-8 single plane GXF_VIDEO_FORMAT_BGRA BGRA-8-8-8-8 single plane GXF_VIDEO_FORMAT_ARGB ARGB-8-8-8-8 single plane GXF_VIDEO_FORMAT_ABGR ABGR-8-8-8-8 single plane GXF_VIDEO_FORMAT_RGBX RGBX-8-8-8-8 single plane GXF_VIDEO_FORMAT_BGRX BGRX-8-8-8-8 single plane GXF_VIDEO_FORMAT_XRGB XRGB-8-8-8-8 single plane GXF_VIDEO_FORMAT_XBGR XBGR-8-8-8-8 single plane GXF_VIDEO_FORMAT_RGB RGB-8-8-8 single plane GXF_VIDEO_FORMAT_BGR BGR-8-8-8 single plane GXF_VIDEO_FORMAT_R8_G8_B8 RGB - unsigned 8 bit multiplanar GXF_VIDEO_FORMAT_B8_G8_R8 BGR - unsigned 8 bit multiplanar GXF_VIDEO_FORMAT_GRAY 8 bit GRAY scale single plane GXF_VIDEO_FORMAT_GRAY16 16 bit GRAY scale single plane GXF_VIDEO_FORMAT_GRAY32 32 bit GRAY scale single plane GXF_VIDEO_FORMAT_GRAY32F float 32 bit GRAY scale single plane GXF_VIDEO_FORMAT_RGB16 RGB-16-16-16 single plane GXF_VIDEO_FORMAT_BGR16 BGR-16-16-16 single plane GXF_VIDEO_FORMAT_RGB32 RGB-32-32-32 single plane GXF_VIDEO_FORMAT_BGR32 BGR-32-32-32 single plane GXF_VIDEO_FORMAT_R16_G16_B16 RGB - signed 16 bit multiplanar GXF_VIDEO_FORMAT_B16_G16_R16 BGR - signed 16 bit multiplanar GXF_VIDEO_FORMAT_R32_G32_B32 RGB - signed 32 bit multiplanar GXF_VIDEO_FORMAT_B32_G32_R32 | BGR - signed 32 bit multiplanar GXF_VIDEO_FORMAT_NV24 | multi planar 4:4:4 YUV with interleaved UV GXF_VIDEO_FORMAT_NV24_ER multi planar 4:4:4 YUV ER with interleaved UV GXF_VIDEO_FORMAT_R8_G8_B8_D8 RGBD unsigned 8 bit multiplanar GXF_VIDEO_FORMAT_R16_G16_B16_D16 RGBD unsigned 16 bit multiplanar GXF_VIDEO_FORMAT_R32_G32_B32_D32 RGBD unsigned 32 bit multiplanar GXF_VIDEO_FORMAT_RGBD8 RGBD 8 bit unsigned single plane GXF_VIDEO_FORMAT_RGBD16 RGBD 16 bit unsigned single plane GXF_VIDEO_FORMAT_RGBD32 RGBD 32 bit unsigned single plane GXF_VIDEO_FORMAT_D32F Depth 32 bit float single plane GXF_VIDEO_FORMAT_D64F Depth 64 bit float single plane GXF_VIDEO_FORMAT_RAW16_RGGB RGGB-16-16-16-16 single plane GXF_VIDEO_FORMAT_RAW16_BGGR BGGR-16-16-16-16 single plane GXF_VIDEO_FORMAT_RAW16_GRBG GRBG-16-16-16-16 single plane GXF_VIDEO_FORMAT_RAW16_GBRG GBRG-16-16-16-16 single plane Supported SurfaceLayout types: SurfaceLayout Description GXF_SURFACE_LAYOUT_PITCH_LINEAR pitch linear surface memory GXF_SURFACE_LAYOUT_BLOCK_LINEAR block linear surface memory", "keywords": []}, {"id": 55, "doc_id": 55, "filename": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension", "display_name": "MultimediaExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/MultimediaExtension", "anchor": "", "priority": -1, "content": "Extension for multimedia related data types, interfaces and components in GXF Core. UUID: 6f2d1afc-1057-481a-9da6-a5f61fed178e Version: 2.6.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 56, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "id2", "priority": -1, "content": "rx_timestamp The incoming timestamp channel. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver clock Handle to application\u2019s synthetic clock component. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::SyntheticClock", "keywords": []}, {"id": 57, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "id3", "priority": -1, "content": "receivers List of receivers to receive entities from\u201d. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver transmitters List of transmitters to publish entities to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter entity_serializer Serializer for serializing entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntitySerializer address Address for TCP connection. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port Port for TCP connection. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 timeout_ms Time in milliseconds to wait before retrying connection. Deprecated - use timeout_period instead. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 timeout_period Time to wait before retrying connection. The period is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in nanoseconds. Supported units are: Hz, s, ms. Example: 10ms, 10000000, 0.2s, 50Hz. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 100ms maximum_attempts Maximum number of attempts for I/O operations before failing. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 10 async_scheduling_term Schedules execution when TCP socket or receivers have a message. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::AsynchronousSchedulingTerm max_msg_delay_ms Time in milliseconds to wait between messages before ending connection. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 max_duration_ms The maximum duration for which the component will run (in ms). If not specified the component will run indefinitely, unless another termination condition is specified. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 max_connection_attempts The maximum number of times the component will attempt to reconnect. If not specified the component will attempt reconnection indefinitely, unless another termination condition is specified. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 58, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "id4", "priority": -1, "content": "receivers List of receivers to receive entities from\u201d. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver transmitters List of transmitters to publish entities to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter entity_serializer Serializer for serializing entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntitySerializer address Address for TCP connection. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port Port for TCP connection. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 timeout_ms Time in milliseconds to wait before retrying connection. Deprecated - use timeout_period instead. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 timeout_period Time to wait before retrying connection. The period is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in nanoseconds. Supported units are: Hz, s, ms. Example: 10ms, 10000000, 0.2s, 50Hz. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: 100ms maximum_attempts Maximum number of attempts for I/O operations before failing. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 10 async_scheduling_term Schedules execution when TCP socket or receivers have a message. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::AsynchronousSchedulingTerm max_msg_delay_ms Time in milliseconds to wait between messages before ending connection. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 max_duration_ms The maximum duration for which the component will run (in ms). If not specified the component will run indefinitely, unless another termination condition is specified. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 max_connection_attempts The maximum number of times the component will attempt to reconnect. If not specified the component will attempt reconnection indefinitely, unless another termination condition is specified. Helpful for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 59, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#nvidia-gxf-clocksyncprimary", "display_name": "nvidia::gxf::ClockSyncPrimary", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "nvidia-gxf-clocksyncprimary", "priority": -1, "content": "Publishes application clock timestamp for use by other apps. Component ID: a61832d1-b0f9-42b3-97b2-ccec0e864e61 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 60, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#nvidia-gxf-clocksyncsecondary", "display_name": "nvidia::gxf::ClockSyncSecondary", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "nvidia-gxf-clocksyncsecondary", "priority": -1, "content": "Advances application SyntheticClock to received timestamp. Component ID: e84945fa-8630-4516-f7ce-7df2b05947c7 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 61, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#nvidia-gxf-tcpclient", "display_name": "nvidia::gxf::TcpClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "nvidia-gxf-tcpclient", "priority": -1, "content": "Codelet that functions as a client in a TCP connection. Component ID: 9d5955c7-8fda-22c7-f18f-ea5e2d195be9 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 62, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#nvidia-gxf-tcpcodelet", "display_name": "nvidia::gxf::TcpCodelet", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "nvidia-gxf-tcpcodelet", "priority": -1, "content": "Interface for a codelet for either end of a TCP connection. Component ID: 620c572c-f03d-11ed-8a22-8f9adbb0e784 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 63, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#nvidia-gxf-tcpserver", "display_name": "nvidia::gxf::TcpServer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "nvidia-gxf-tcpserver", "priority": -1, "content": "Codelet that functions as a server in a TCP connection. Component ID: a3e0e42d-e32e-73ab-ef83-fbb311310759 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 64, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "parameters", "priority": -1, "content": "tx_timestamp The outgoing timestamp channel. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter clock Handle to application\u2019s clock component. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock", "keywords": []}, {"id": 65, "doc_id": 65, "filename": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "display_name": "NetworkExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/NetworkExtension", "anchor": "", "priority": -1, "content": "Extension for communications external to a computation graph. UUID: f50665e5-ade2-f71b-de2a-2380614b1725 Version: 1.6.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 66, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "id1", "priority": -1, "content": "server Triton server. This optional handle must be specified if the inference_mode of this component is Direct . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::triton::TritonServer model_name Triton model name to run inference. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING model_version Triton model version of the model name to run inference. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 max_batch_size Max batch size to run inference. This should match the value in the Triton model repository. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 num_concurrent_requests Maximum number of concurrent inference requests for this model version. This is used to define a pool of requests. Flags: GXF_PARAMETER_FLAGS_NONE (1 = default) Type: GXF_PARAMETER_TYPE_UINT32 async_scheduling_term Asynchronous scheduling term that determines when a response is ready. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::AsynchronousSchedulingTerm inference_mode Triton inferencing mode. Valid values: Direct : This mode requires a TritonServer component handle to be passed to the optional server parameter. RemoteGrpc : This mode requires the optional server_endpoint point to an external Triton gRPC server URL. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING server_endpoint Server endpoint URL for an external Triton instance. This optional string must be specified if the inference_mode of this component is of the Remote variety. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 67, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "id2", "priority": -1, "content": "inferencer Handle to Triton inference implementation. This is used to request an inference. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::triton::TritonInferencerInterface rx List of receivers to take input tensors. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver input_tensor_names Names of input tensors that exist in the ordered receivers in rx . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING input_binding_names Names of input bindings corresponding to Triton\u2019s config inputs in the same order of what is provided in input_tensor_names . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 68, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "id3", "priority": -1, "content": "inferencer Handle to Triton inference implementation. This is used to request an inference. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::triton::TritonInferencerInterface output_tensor_names Names of output tensors in the order to be retrieved from the model. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING output_binding_names Names of output bindings in the model in the same order of of what is provided in output_tensor_names . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING tx Single transmitter to publish output tensors. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 69, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "id4", "priority": -1, "content": "inferencer Handle to Triton inference implementation. This is used to check the accecptability of a new request. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::triton::TritonInferencerInterface", "keywords": []}, {"id": 70, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritoninferencerequest", "display_name": "nvidia::triton::TritonInferenceRequest", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritoninferencerequest", "priority": -1, "content": "Generic codelet that requests a Triton Inference. This will use a handle to an InferencerImpl to interface with Triton. Component ID: 34395920-232c-446f-b5b7-46f642ce84df Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 71, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritoninferenceresponse", "display_name": "nvidia::triton::TritonInferenceResponse", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritoninferenceresponse", "priority": -1, "content": "Generic codelet that obtains a response from a Triton Inference. This will use a handle to an InferencerImpl to interface with Triton. Component ID: 4dd957a7-aa55-4117-90d3-9a98e31ee176 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 72, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritoninferencerimpl", "display_name": "nvidia::triton::TritonInferencerImpl", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritoninferencerimpl", "priority": -1, "content": "Component that implements the TritonInferencerInterface to obtain inferences from the TritonServer component or from an external Triton instance. Component ID: b84cf267-b223-4df5-ac82-752d9fae1014 Base Type: nvidia::triton::TritonInferencerInterface", "keywords": []}, {"id": 73, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritoninferencerinterface", "display_name": "nvidia::triton::TritonInferencerInterface", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritoninferencerinterface", "priority": -1, "content": "Helper component that provides an interface for Triton inferencing. Component ID: 1661c015-6b1c-422d-a6f0-248cdc197b1a Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 74, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritonoptions", "display_name": "nvidia::triton::TritonOptions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritonoptions", "priority": -1, "content": "Generic struct that represent Triton Inference Options for model control and sequence control. Component ID: 087696ed-229d-4199-876f-05b92d3887f0", "keywords": []}, {"id": 75, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritonrequestreceptiveschedulingterm", "display_name": "nvidia::triton::TritonRequestReceptiveSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritonrequestreceptiveschedulingterm", "priority": -1, "content": "Triton Scheduling Term that schedules Request Codelet when the inferencer can accept a new request. Component ID: f8602412-1242-4e43-9dbf-9c559d496b84 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 76, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#nvidia-triton-tritonserver", "display_name": "nvidia::triton::TritonServer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "nvidia-triton-tritonserver", "priority": -1, "content": "Triton inference server component using the Triton C API . Component ID: 26228984-ffc4-4162-9af5-6e3008aa2982 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 77, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "parameters", "priority": -1, "content": "log_level Logging level for Triton. Valid values: 0: Error 1: Warn 2: Info 3+: Verbose Flags: GXF_PARAMETER_FLAGS_NONE (1 = default) Type: GXF_PARAMETER_TYPE_UINT32 enable_strict_model_config Enables strict model configuration to enforce presence of config. If disabled, TensorRT, TensorFlow saved-model, and ONNX models do not require a model configuration file. Triton can derive all the required settings automatically. Flags: GXF_PARAMETER_FLAGS_NONE (true = default) Type: GXF_PARAMETER_TYPE_BOOL min_compute_capability Minimum Compute Capability for GPU. Refer to https://developer.nvidia.com/cuda-gpus . Flags: GXF_PARAMETER_FLAGS_NONE (6.0 = default) Type: GXF_PARAMETER_TYPE_FLOAT64 model_repository_paths List of Triton Model Repository Paths. Refer to bytedance/triton-inference-server Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING tf_gpu_memory_fraction The portion of GPU memory to be reserved for TensorFlow models. Flags: GXF_PARAMETER_FLAGS_NONE (0.0 = default) Type: GXF_PARAMETER_TYPE_FLOAT64 tf_disable_soft_placement_ Allow Tensorflow to use CPU operation when GPU implementation is not available. Flags: GXF_PARAMETER_FLAGS_NONE (true = default) Type: GXF_PARAMETER_TYPE_BOOL backend_directory_path Path to Triton backend directory. Flags: GXF_PARAMETER_FLAGS_NONE (\u201d\u201d = default) Type: GXF_PARAMETER_TYPE_STRING model_control_mode Triton model control mode. Valid values : \u201cnone\u201d: Load all models in the model repository at startup. \u201cexplicit\u201d: Allow models to load when needed. Flags: GXF_PARAMETER_FLAGS_NONE (\u201cexplicit\u201d = default) Type: GXF_PARAMETER_TYPE_STRING backend_configs Triton backend configurations in the format: backend,setting=value . Refer to Backend specific documentation: triton-inference-server/tensorflow_backend , triton-inference-server/python_backend \u2019. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 78, "doc_id": 78, "filename": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "display_name": "NvTritonExt", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/NvTritonExt", "anchor": "", "priority": -1, "content": "NVIDIA Triton Inference components. This extension is intended to be used with Triton 2.49.0 (x86_64) and 2.40.0 (Jetpack 6.1). Refer to the official NVIDIA Triton documentation for support matrix and more. UUID: a3c95d1c-c06c-4a4e-a2f9-8d9078ab645c Version: 0.5.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 79, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet#accessing-other-components", "display_name": "Accessing other Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "accessing-other-components", "priority": -1, "content": "Users can also access other components such as transmitter and receiver as follows: from gxf.std import Receiver class SampleCodelet(CodeletAdapter): &quot;&quot;&quot; Sample class to show how to access params &quot;&quot;&quot; def start(self): self.params = self.get_params() def tick(self): rx = Receiver.get(self.context(),\\ self.cid(),\\ self.params[&quot;receiver&quot;]) msg = rx.receive() def stop(self): return CodeletAdapter also implements the following utility methods: Method Description eid() returns the unique ID of the entity containing this codelet. cid() returns the unique ID of the codelet component. name() returns the name of the python codelet. get_execution_timestamp() returns the last timestamp in nanoseconds when the codelet was either started, ticked, or stopped. get_execution_time() same as get_execution_timestamp() returns a floating points with seconds as unit. get_delta_time() returns the time difference between the current call ( start() , tick() or stop() ) and the last call. get_execution_count() returns the number of times the codelet has been executed. is_first_tick() returns True if tick() is called for the first time after start() .", "keywords": []}, {"id": 80, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet#accessing-parameters", "display_name": "Accessing Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "accessing-parameters", "priority": -1, "content": "CodeletAdapter has a method called get_params which returns a dict of all the params mentioned in the yaml file. class SampleCodelet(CodeletAdapter): &quot;&quot;&quot; Sample class to show how to access params &quot;&quot;&quot; def start(self): self.params = self.get_params() def tick(self): print(self.params[&#x27;log_count&#x27;]) def stop(self): return", "keywords": []}, {"id": 81, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet#adding-python-codelet-to-the-graph", "display_name": "Adding Python Codelet to the Graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "adding-python-codelet-to-the-graph", "priority": -1, "content": "Adding a python codelet to the graph is different from adding a C++ codelet. Unlike C++ codelets, the type of python codelet is nvidia::gxf::PyCodeletV0 and not nvidia::gxf::Codelet . Linking the implementation of the codelet is done via params directly. Also, python codelets can obtain only parameters which have a corresponding python bindings. nvidia::gxf::PyCodeletV0 accepts the following parameters: Parameter Mandatory/Optional Description codelet_name Mandatory Name of the user\u2019s python codelet class which implements CodeletAdapter codelet_file Mandatory Absolute path to the file containing the implementation codelet_params Optional A string which the users can parse for setting additional params Following is an entity named rx which contains the following components: A python codelet called python_receiver A DoubleBufferReceiver called signal A nameless MessageAvailableSchedulingTerm The implementation of the python codelet is present in some/path/to/PythonCodelets.py file under the class called PingRx which should implement CodeletAdapter . The python codelet also accept two other parameters: receivers : A list containing single item, signal , which is a double buffer receiver component. codelet_params : a custom string which the user can parse in the start() , tick() or stop() method and use accordingly. --- name: rx components: - name: signal type: nvidia::gxf::DoubleBufferReceiver - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: signal min_size: 1 - name: python_receiver type: nvidia::gxf::PyCodeletV0 parameters: codelet_name: &quot;PingRx&quot; codelet_file: &quot;some/path/to/PingRx.py&quot; codelet_params: log_count: 5 receiver: signal", "keywords": []}, {"id": 82, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet#general-concepts", "display_name": "General Concepts", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "general-concepts", "priority": -1, "content": "Python enables users to add a lot of functionality with very less boiler plate code and hence is heavily used in the Machine Learning Community. For e.g. simulating a sensor for data, vizualizing the generated output or running various ML models on the data can be easily implemented in python. Python Codelets allow users to implement these functionalities in python. Unlike C++ codelets, python codelets are not registered individually. To create a python codelet users implement CodeletAdapter (a python base class) and all python codelets are registered in the registry as PyCodeletV0 which is a classic C++ codelet. This C++ codelet calls the start() , tick() and stop() methods of the python codelet implementation. PyCodeletV0 User\u2019s Python Codelet start() start() tick() tick() stop() stop()", "keywords": []}, {"id": 83, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet#implementing-class", "display_name": "Implementing Class", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "implementing-class", "priority": -1, "content": "To implement a python codelet, users implement CodeletAdapter . This is available in gxf.python_codelet.codelet . Specifically, users implement the following functions: start() - Setting up the codelet. Called once when the codelet starts. tick() - Business logic. Called based on Scheduling Terms. stop() - Clean up. Called when entity containing the python codelet is terminated.", "keywords": []}, {"id": 84, "doc_id": 84, "filename": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "display_name": "Python Codelets", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/Python_Codelet", "anchor": "", "priority": -1, "content": "Python Codelets allow users to build parts of their application in Python. This also allows users to add custom implementation without creating a custom Extension. This section gives an overview of the how to implement codelets in python and how to use them in an application. Codelets are user implemented units which can be run as part of the graph. Python codelets allow the users to implement this functionality in python. Like C++ codelets, python codelets have the following functions users have to implement: start() - called once when the codelet starts tick() - called on every tick stop() - called once when the codelet is stopped Unlike the C++ codelets, all the python codelets are registered via a same interface namely: nvidia::gxf::PyCodeletV0 . To implement a codelet in python, users have to implement the class CodeletAdapter . As explained above, the users implement start() , stop() and tick() methods in Python. Running an application containing a Python Codelet has to be done using gxe.py and not gxe binary. Graphs containing Python Codelets cannot run directly using the gxe binary because a python interpreter has to be started before running any Python code. A graph can also be run if graph-composer and registry are already installed. Use the following command to install the relevant extensions: registry graph install -g path/to/graph.yaml -m output/path/to/generated/manifest.yaml -d path/to/target.yaml --output-directory output/directory A sample target file can be found in /opt/nvidia/graph-composer/ . The above command will install the relevant extensions and other required files to output/directory . Copy the core extension and Run the following command: cp -r /opt/nvidia/graph-composer/core output/directory/gxf Finally add output/directory to PYTHONPATH using the following command: export PYTHONPATH=output/directory Running a graph using gxe.py : python3 output/directory/gxf/std/gxe.py --app path/to/graph.yaml --manifest path/to/manifest/file.yaml Following are some of the Python Codelet examples which can be found in gxf/python/tests : Ping Codelets demonstrate the basic usage of python codelets PingTx.py Constructs an empty message which is an Entity Transmits it on the first transmitter PingRx.py Receives a message on first transmitter Passes if it\u2019s non-null else raises an exception Obtaining tensor data in python VerifyEqual.py This codelet has two receivers. It receives two messages one from each receiver. Extracts tensor data from both the message. Copies the data on the host if the tensor is on the device. Asserts that the data on the tensors is equal. Generating tensor data from python StreamGenerator On every tick, this codelet generates four tensors: two on host and two on device. It uses TensorDescription object to reshape the tensor to desired shape. Creates a host message and a device message. Adds the device tensors to device messages and host tensors to host messages Publishes the host message on the first transmitter and the device message on the second transmitter. Please refer to the sample graph files present in the gxf/python/tests directory for examples on how to use the Python Codelets in an application.", "keywords": []}, {"id": 85, "doc_id": 87, "filename": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension#nvidia-gxf-rmmallocator", "display_name": "nvidia::gxf::RMMAllocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension", "anchor": "nvidia-gxf-rmmallocator", "priority": -1, "content": "Allocator which is used to allocate/deallocate memory using Rapids Memory Manager (RMM). This component enables efficient and stream-ordered memory allocation for GPU operations. This can be used to allocate pinned host memory. Component ID: 5a8ac4c2-1f83-11ef-8859-d710d3299dfa Base Type: nvidia::gxf::CudaAllocator", "keywords": []}, {"id": 86, "doc_id": 87, "filename": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension", "anchor": "parameters", "priority": -1, "content": "gpu_device GPU device resource from which is used allocate CUDA memory. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::GPUDevice device_memory_initial_size The initial memory pool size used by device memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c16MB\u201d (non-Jetson machine) or \u201c8MB\u201d (Jetson machine) host_memory_initial_size The initial memory pool size used by this pinned host memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c16MB\u201d (non-Jetson machine) or \u201c8MB\u201d (Jetson machine) device_memory_max_size The maximum memory pool size used by device memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c32MB\u201d (non-Jetson machine) or \u201c16MB\u201d (Jetson machine) host_memory_max_size The maximum memory pool size used by this pinned host memory resource. The size is specified as a string containing a number and an (optional) unit. If no unit is given the value is assumed to be in bytes. Supported units are: B, KB, MB, GB, TB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c32MB\u201d (non-Jetson machine) or \u201c16MB\u201d (Jetson machine)", "keywords": []}, {"id": 87, "doc_id": 87, "filename": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension", "display_name": "RMMExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/RMMExtension", "anchor": "", "priority": -1, "content": "Extension for RAPIDS memory managament operation. Also supports stream ordered memory allocations on device memory. UUID: 45fa2002-1f83-11ef-a380-ef5f83754f84 Version: 0.0.1 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 88, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "id2", "priority": -1, "content": "transmitter Transmitter channel for replaying entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter entity_serializer Serializer for serializing entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntitySerializer directory Directory path for storing files. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING batch_size Number of entities to read and publish for one tick. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 ignore_corrupted_entities If an entity could not be de-serialized, it is ignored by default; otherwise a failure is generated. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 89, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "id3", "priority": -1, "content": "allocator Memory allocator for tensor components. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator", "keywords": []}, {"id": 90, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#nvidia-gxf-componentserializer", "display_name": "nvidia::gxf::ComponentSerializer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "nvidia-gxf-componentserializer", "priority": -1, "content": "Interface for serializing components. Component ID: 8c76a828-2177-1484-f841-d39c3fa47613 Base Type: nvidia::gxf::Component Defined in: gxf/serialization/component_serializer.hpp", "keywords": []}, {"id": 91, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#nvidia-gxf-entityrecorder", "display_name": "nvidia::gxf::EntityRecorder", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "nvidia-gxf-entityrecorder", "priority": -1, "content": "Serializes incoming messages and writes them to a file. Component ID: 9d5955c7-8fda-22c7-f18f-ea5e2d195be9 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 92, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#nvidia-gxf-entityreplayer", "display_name": "nvidia::gxf::EntityReplayer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "nvidia-gxf-entityreplayer", "priority": -1, "content": "De-serializes and publishes messages from a file. Component ID: fe827c12-d360-c63c-8094-32b9244d83b6 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 93, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#nvidia-gxf-stdcomponentserializer", "display_name": "nvidia::gxf::StdComponentSerializer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "nvidia-gxf-stdcomponentserializer", "priority": -1, "content": "Serializer for Timestamp and Tensor components. Component ID: c0e6b36c-39ac-50ac-ce8d-702e18d8bff7 Base Type: nvidia::gxf::ComponentSerializer", "keywords": []}, {"id": 94, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "parameters", "priority": -1, "content": "receiver Receiver channel to log. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver entity_serializer Serializer for serializing entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntitySerializer directory Directory path for storing files. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING basename User specified file name without extension. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING flush_on_tick Flushes output buffer on every tick when true. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 95, "doc_id": 95, "filename": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "display_name": "SerializationExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/SerializationExtension", "anchor": "", "priority": -1, "content": "Extension for serializing messages. UUID: bc573c2f-89b3-d4b0-8061-2da8b11fe79a Version: 2.6.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 96, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#allocator", "display_name": "Allocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "allocator", "priority": -1, "content": "from gxf.std import Allocator The python binding for nvidia::gxf::Allocator to allocate memory on device, host, or system needed for gxf.std.Tensor.custom_reshape().", "keywords": []}, {"id": 97, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#bool", "display_name": "bool", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "bool", "priority": -1, "content": "Component ID: c02f9e93-d01b-1d29-f523-78d2a9195128", "keywords": []}, {"id": 98, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#clock", "display_name": "Clock", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "clock", "priority": -1, "content": "from gxf.std import Clock The python binding for nvidia::gxf::Clock . Methods: time() Returns: float The current time of the clock. Time is measured in seconds. timestamp() Returns: float The current timestamp of the clock. Timestamps are measured in nanoseconds.", "keywords": []}, {"id": 99, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#double", "display_name": "double", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "double", "priority": -1, "content": "Component ID: d57cee59-686f-e26d-95be-659c126b02ea", "keywords": []}, {"id": 100, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#float", "display_name": "float", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "float", "priority": -1, "content": "Component ID: a81bf295-421f-49ef-f24a-f59e9ea0d5d6", "keywords": []}, {"id": 101, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id10", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id10", "priority": -1, "content": "min_size The term permits execution if the receiver connected to the transmitter has at least the specified number of free slots in its back buffer. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 transmitter The term permits execution if this transmitter can publish a message, i.e. if the receiver which is connected to this transmitter can receive messages. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 102, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id11", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id11", "priority": -1, "content": "front_stage_max_size If set the scheduling term will only allow execution if the number of messages in the front stage does not exceed this count. It can for example be used in combination with codelets which do not clear the front stage in every tick. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 min_size The scheduling term permits execution if the given receiver has at least the given number of messages available. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 receiver The scheduling term permits execution if this channel has at least a given number of messages available. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 103, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id12", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id12", "priority": -1, "content": "min_size The scheduling term permits execution if all given receivers together have at least the given number of messages available. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 receivers The scheduling term permits execution if the given channels have at least a given number of messages available. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 104, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id13", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id13", "priority": -1, "content": "clock Clock to get time from. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock max_batch_size The maximum number of messages to be batched together. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 max_delay_ns The maximum delay from first message to wait before submitting workload anyway. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 receiver Receiver to watch on. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 105, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id14", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id14", "priority": -1, "content": "enable_tick The default initial condition for enabling tick. Flags: GXF_PARAMETER_FLAGS_DYNAMIC Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 106, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id15", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id15", "priority": -1, "content": "is_root If entity is a root node Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 107, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id16", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id16", "priority": -1, "content": "execution_frequency The recess period indicates the minimum amount of time which has to pass before the entity is permitted to execute again. The period is specified as a string containing of a number and an (optional) unit. If no unit is given the value is assumed to be in nanoseconds. Supported units are: Hz, s, ms. Example: 10ms, 10000000, 0.2s, 50Hz Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING receivers The scheduling term permits execution if the given channels have at least a given number of messages available. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_CUSTOM sampling_mode The sampling method to use when checking for messages in receiver queues. Option: SumOfAll,PerReceiver Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_CUSTOM min_sizes The scheduling term permits execution if all given receivers have at least the given number of messages available in this list. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_CUSTOM min_sum The scheduling term permits execution if the sum of message counts of all receivers have at least the given number of messages available. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 108, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id17", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id17", "priority": -1, "content": "allocator The allocator to wait on. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator min_bytes The minimum number of bytes that must be available for the codelet to get scheduled. Exclusive with min_blocks. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 min_blocks The minimum number of blocks that must be available for the codelet to get scheduled. On allocators that do not support block allocation, this behaves the same as min_bytes. Exclusive with min_bytes. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 109, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id18", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id18", "priority": -1, "content": "server GXF IPC server to handle the service callbacks in GraphWorker. Example server implementation can be nvidia::gxf::HttpServer Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::IPCServer client GXF IPC client to communicate with the IPC server. Example client implementation can be nvidia::gxf::HttpIPCClient Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::IPCClient graph-specs A dictionary of graph specs that are executed by this GraphWorker. The schema for each entry is: {user_given_segment_name: {app-path: , parameter-path: , manifest-path: , severity: }} Example: graph-specs: ucx_upstream: app-path: gxf/ucx/tests/test_ping_ucx_tx.yaml manifest-path: gxf/test/distributed/test_graph_worker_manifest.yaml severity: 4 ucx_downstream: app-path: gxf/ucx/tests/test_ping_ucx_rx.yaml manifest-path: gxf/test/distributed/test_graph_worker_manifest.yaml severity: 4 Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_CUSTOM driver-reconnection-times How many times to try to reconnect the GraphDriver at startup. Abandon the execution after the last try. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64", "keywords": []}, {"id": 110, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id19", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id19", "priority": -1, "content": "server GXF IPC server to handle the service callbacks in GraphDriver. Example server implementation can be nvidia::gxf::HttpServer Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::IPCServer client GXF IPC client to communicate with the IPC server. Example client implementation can be nvidia::gxf::HttpIPCClient Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::IPCClient connections A dictionary of graph segment connections. A segment connection consists of source field and target field. The schema for each entry is: {Connections: [source: , target: ]} The schema for source and target is: user_given_segment_name.entity_name.queue_name Example: connections: - source: ucx_upstream.tx.signal target: ucx_downstream.rx.signal Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_CUSTOM", "keywords": []}, {"id": 111, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id2", "priority": -1, "content": "initial_timestamp The initial timestamp on the clock (in nanoseconds). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64", "keywords": []}, {"id": 112, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id20", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id20", "priority": -1, "content": "clock The clock used by the scheduler to define flow of time. Typical choices are a RealtimeClock or a ManualClock . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 realtime This parameter is deprecated. Assign a clock directly. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL stop_on_deadlock If enabled the scheduler will stop when all entities are in a waiting state, but no periodic entity exists to break the dead end. Should be disabled when scheduling conditions can be changed by external actors, for example by clearing queues manually. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 113, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id21", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id21", "priority": -1, "content": "check_recession_perios_ms The maximum duration for which the scheduler would wait (in ms) when an entity is not ready to run yet. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 clock The clock used by the scheduler to define flow of time. Typical choices are a RealtimeClock or a ManualClock . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 stop_on_deadlock If enabled the scheduler will stop when all entities are in a waiting state, but no periodic entity exists to break the dead end. Should be disabled when scheduling conditions can be changed by external actors, for example by clearing queues manually. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL worker_thread_number Number of threads. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 1", "keywords": []}, {"id": 114, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id22", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id22", "priority": -1, "content": "clock The clock used by the scheduler to check maximum time budget. Typical choice is a RealtimeClock . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock", "keywords": []}, {"id": 115, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id23", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id23", "priority": -1, "content": "clock The clock used by the scheduler to define flow of time. Typical choices are a RealtimeClock or a ManualClock . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 stop_on_deadlock If enabled the scheduler will stop when all entities are in a waiting state, but no periodic entity exists to break the dead end. Should be disabled when scheduling conditions can be changed by external actors, for example by clearing queues manually. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: True worker_thread_number Number of threads. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 1 thread_pool_allocation_auto If enabled, only one thread pool will be created. If disabled, user should enumerate pools and priorities Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: True stop_on_deadlock_timeout Scheduler will wait this amount of time when stop_on_dead_lock indicates should stop. It will reset if a job comes in during the wait. Negative value means not stop on deadlock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 116, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id24", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id24", "priority": -1, "content": "block_size The size of one block of memory in byte. Allocation requests can only be fulfilled if they fit into one block. If less memory is requested still a full block is issued. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 do_not_use_cuda_malloc_host If enabled operator new will be used to allocate host memory instead of cudaMallocHost . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: True num_blocks The total number of blocks which are allocated by the pool. If more blocks are requested allocation requests will fail. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 storage_type The memory storage type used by this allocator. Can be kHost (0) or kDevice (1) or kSystem (2). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 0", "keywords": []}, {"id": 117, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id25", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id25", "priority": -1, "content": "do_not_use_cuda_malloc_host If enabled operator new will be used to allocate host memory instead of cudaMallocHost . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: True", "keywords": []}, {"id": 118, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id26", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id26", "priority": -1, "content": "initial_size Initial number of worker threads in the pool. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 0 priority Priority level for threads in the pool. Default is 0 (low). Can also be set to 1 (medium) or 2 (high). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 119, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id27", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id27", "priority": -1, "content": "dev_id Create CUDA Stream on which device. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 0", "keywords": []}, {"id": 120, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id28", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id28", "priority": -1, "content": "pin_entity Set the cpu_core to be pinned to a worker thread or not. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false", "keywords": []}, {"id": 121, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id29", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id29", "priority": -1, "content": "in The channel for incoming messages. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver out The channel for outgoing messages. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 122, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id3", "priority": -1, "content": "initial_timestamp The initial timestamp on the clock (in nanoseconds). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 123, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id30", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id30", "priority": -1, "content": "topic_name Topic name. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING transmitters Transmitters that will be added to this topic. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter receivers Receivers that will be added to this topic. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 124, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id31", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id31", "priority": -1, "content": "aggregation_policy Aggregation policy used to aggregate individual metric samples. Choices:{mean, min, max}. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING lower_threshold Lower threshold of the metric\u2019s expected range. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 upper_threshold Upper threshold of the metric\u2019s expected range. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64", "keywords": []}, {"id": 125, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id32", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id32", "priority": -1, "content": "clock The clock component instance to retrieve time from. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock codelet_statistics If set to true, JobStatistics component will collect performance statistics related to codelets. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL json_file_path If provided, all the collected performance statistics data will be dumped into a json file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 126, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id33", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id33", "priority": -1, "content": "mode The broadcast mode. Can be Broadcast or RoundRobin. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_CUSTOM source Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 127, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id34", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id34", "priority": -1, "content": "sink The output channel for gathered messages. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter tick_source_limit Maximum number of messages to take from each source in one tick. 0 means no limit. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64", "keywords": []}, {"id": 128, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id35", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id35", "priority": -1, "content": "allocator Memory allocator for tensor data Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator mode Configuration to select what tensors to copy: kCopyToDevice (0) - copies to device memory, ignores device allocation kCopyToHost (1) - copies to pinned host memory, ignores host allocation kCopyToSystem (2) - copies to system memory, ignores system allocation. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 receiver Receiver for incoming entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver transmitter Transmitter for outgoing entities. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 129, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id36", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id36", "priority": -1, "content": "execution_clock Clock on which the codelet is executed by the scheduler. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock receiver Channel to receive messages that need to be synchronized. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver scheduling_term Scheduling term for executing the codelet. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::TargetTimeSchedulingTerm throttling_clock Clock which the received entity timestamps are based on. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock transmitter Transmitter channel publishing messages at appropriate timesteps. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 130, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id37", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id37", "priority": -1, "content": "drop_waiting If too many messages are waiting the oldest ones are dropped. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL max_waiting_count The maximum number of waiting messages. If exceeded the codelet will stop pulling messages out of the input queue. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 source Receiver from which messages are taken and transferred to the vault. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 131, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id38", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id38", "priority": -1, "content": "location Yaml source of the subgraph. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 132, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id39", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id39", "priority": -1, "content": "inputs All the inputs for synchronization. Number of inputs must match that of the outputs. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver outputs All the outputs for synchronization. Number of outputs must match that of the inputs. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 133, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id4", "priority": -1, "content": "capacity Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 policy 0: pop, 1: reject, 2: fault. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 2", "keywords": []}, {"id": 134, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id5", "priority": -1, "content": "capacity Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 policy 0: pop, 1: reject, 2: fault Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 2", "keywords": []}, {"id": 135, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id6", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id6", "priority": -1, "content": "source Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter target Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 136, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id7", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id7", "priority": -1, "content": "recess_period The recess period indicates the minimum amount of time which has to pass before the entity is permitted to execute again. The period is specified as a string containing of a number and an (optional) unit. If no unit is given the value is assumed to be in nanoseconds. Supported units are: Hz, s, ms. Example: 10ms, 10000000, 0.2s, 50Hz. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 137, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id8", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id8", "priority": -1, "content": "count The total number of time this term will permit execution. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64", "keywords": []}, {"id": 138, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#id9", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "id9", "priority": -1, "content": "clock The clock used to define target time. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock", "keywords": []}, {"id": 139, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#int", "display_name": "int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "int", "priority": -1, "content": "Component ID: b557ec7f-49a5-08f7-a35e-086e9d1ea767", "keywords": []}, {"id": 140, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#long-int", "display_name": "long int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "long-int", "priority": -1, "content": "Component ID: c611627b-6393-365f-d234-1f26bfa8d28f", "keywords": []}, {"id": 141, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#long-unsigned-int", "display_name": "long unsigned int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "long-unsigned-int", "priority": -1, "content": "Component ID: c4385f5b-6e25-01d9-d7b5-6e7cadc704e8", "keywords": []}, {"id": 142, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#memorystoragetype", "display_name": "MemoryStorageType", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "memorystoragetype", "priority": -1, "content": "from gxf.std import MemoryStorageType A python enum which defines where the data is stored. Value Description kHost Data is stored on Host kDevice Data is stored on the Device (GPU) kSystem Data is stored on the System (TODO(sl)", "keywords": []}, {"id": 143, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-allocator", "display_name": "nvidia::gxf::Allocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-allocator", "priority": -1, "content": "Provides allocation and deallocation of memory. Component ID: 3cdd82d0-2326-4867-8de2-d565dbe28e03 Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/allocator.hpp", "keywords": []}, {"id": 144, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-asynchronousschedulingterm", "display_name": "nvidia::gxf::AsynchronousSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-asynchronousschedulingterm", "priority": -1, "content": "A component which is used to inform of that an entity is dependent upon an async event for its execution. Component ID: 56be1662-ff63-4179-9200-3fcd8dc38673 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 145, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-blockmemorypool", "display_name": "nvidia::gxf::BlockMemoryPool", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-blockmemorypool", "priority": -1, "content": "A memory pools which provides a maximum number of equally sized blocks of memory. Component ID: 92b627a3-5dd3-4c3c-976c-4700e8a3b96a Base Type: nvidia::gxf::Allocator", "keywords": []}, {"id": 146, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-booleanschedulingterm", "display_name": "nvidia::gxf::BooleanSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-booleanschedulingterm", "priority": -1, "content": "A component which acts as a boolean AND term that can be used to control the execution of the entity. Component ID: e07a0dc4-3908-4df8-8134-7ce38e60fbef Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 147, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-broadcast", "display_name": "nvidia::gxf::Broadcast", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-broadcast", "priority": -1, "content": "Messages arrived on the input channel are distributed to all transmitters. Component ID: 3daadb31-0bca-47e5-9924-342b9984a014 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 148, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-btschedulingterm", "display_name": "nvidia::gxf::BTSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-btschedulingterm", "priority": -1, "content": "A component which is used to control the execution of the behavior tree entities. Component ID: 0161ca51-2fed-4a8c-8f24-67cf1b5e330a Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 149, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-clock", "display_name": "nvidia::gxf::Clock", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-clock", "priority": -1, "content": "Interface for clock components which provide time. Component ID: 779e61c2-ae70-441d-a26c-8ca64b39f8e7 Base Type: nvidia::gxf::Component Defined in: gxf/std/clock.hpp", "keywords": []}, {"id": 150, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-codelet", "display_name": "nvidia::gxf::Codelet", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-codelet", "priority": -1, "content": "Interface for a component which can be executed to run custom code. Component ID: 5c6166fa-6eed-41e7-bbf0-bd48cd6e1014 Base Type: nvidia::gxf::Component Defined in: gxf/std/codelet.hpp", "keywords": []}, {"id": 151, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-connection", "display_name": "nvidia::gxf::Connection", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-connection", "priority": -1, "content": "A component which establishes a connection between two other components. Component ID: cc71afae-5ede-47e9-b267-60a5c750a89a Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 152, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-controller", "display_name": "nvidia::gxf::Controller", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-controller", "priority": -1, "content": "Controls entities\u2019 termination policy and tracks behavior status during execution. Component ID: c8e80475-3c79-43a4-9083-eaf294b0600d Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/controller.hpp", "keywords": []}, {"id": 153, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-countschedulingterm", "display_name": "nvidia::gxf::CountSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-countschedulingterm", "priority": -1, "content": "A component which specifies that an entity shall be executed exactly a given number of times. Component ID: f89da2e4-fddf-4aa2-9a80-1119ba3fde05 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 154, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-cputhread", "display_name": "nvidia::gxf::CPUThread", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-cputhread", "priority": -1, "content": "Component ID: 34f46728-496d-4d8b-b9c9-c5a54de5d3a0 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 155, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-doublebufferreceiver", "display_name": "nvidia::gxf::DoubleBufferReceiver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-doublebufferreceiver", "priority": -1, "content": "A receiver which uses a double-buffered queue where new messages are first pushed to a backstage. Component ID: ee45883d-bf84-4f99-8419-7c5e9deac6a5 Base Type: nvidia::gxf::Receiver", "keywords": []}, {"id": 156, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-doublebuffertransmitter", "display_name": "nvidia::gxf::DoubleBufferTransmitter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-doublebuffertransmitter", "priority": -1, "content": "A transmitter which uses a double-buffered queue where messages are pushed to a backstage after they are published. Component ID: 0c3c0ec7-77f1-4389-aef1-6bae85bddc13 Base Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 157, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-downstreamreceptiveschedulingterm", "display_name": "nvidia::gxf::DownstreamReceptiveSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-downstreamreceptiveschedulingterm", "priority": -1, "content": "A component which specifies that an entity shall be executed if receivers for a certain transmitter can accept new messages. Component ID: 9de75119-8d0f-4819-9a71-2aeaefd23f71 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 158, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-endofstream", "display_name": "nvidia::gxf::EndOfStream", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-endofstream", "priority": -1, "content": "A component which represents end-of-stream notification. Component ID: 8c42f7bf-7041-4626-9792-9eb20ce33cce Defined in: gxf/std/eos.hpp", "keywords": []}, {"id": 159, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-epochscheduler", "display_name": "nvidia::gxf::EpochScheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-epochscheduler", "priority": -1, "content": "A scheduler for running loads in externally managed threads. Component ID: 3d175ab4-2e0d-11ec-8d3d-0242ac130003 Base Type: nvidia::gxf::Scheduler", "keywords": []}, {"id": 160, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-eventbasedscheduler", "display_name": "nvidia::gxf::EventBasedScheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-eventbasedscheduler", "priority": -1, "content": "A multi thread event based scheduler that executes codelets for maximum throughput. Component ID: 99bef5a8-48bc-11ee-be56-0242ac120002 Base Type: nvidia::gxf::Scheduler", "keywords": []}, {"id": 161, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-expiringmessageavailableschedulingterm", "display_name": "nvidia::gxf::ExpiringMessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-expiringmessageavailableschedulingterm", "priority": -1, "content": "A component which tries to wait for specified number of messages in queue for at most specified time. Component ID: eb22280c-76ff-11eb-b341-cf6b417c95c9 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 162, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-forward", "display_name": "nvidia::gxf::Forward", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-forward", "priority": -1, "content": "Forwards incoming messages at the receiver to the transmitter. Component ID: 97cee543-8fb5-4541-8ff7-589318187ec0 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 163, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-gather", "display_name": "nvidia::gxf::Gather", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-gather", "priority": -1, "content": "All messages arriving on any input channel are published on the single output channel. Component ID: 85f64c84-8236-4035-9b9a-3843a6a2026f Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 164, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-gpudevice", "display_name": "nvidia::gxf::GPUDevice", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-gpudevice", "priority": -1, "content": "Component ID: 2036939f-a32a-43ee-83f8-826576d8f170 Base Type: nvidia::gxf::ResourceBase", "keywords": []}, {"id": 165, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-graphdriver", "display_name": "nvidia::gxf::GraphDriver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-graphdriver", "priority": -1, "content": "A GXF System component which coordinates the execution of GraphWorker, resolving graph segments UCX connection addresses. Listen to remote or local GraphWorkers that each runs one or more segments. Register all GraphWorkers until all segments are discovered Resolve connection address between each segment pair Send result address to each target segment via GraphWorker that manages the segment Component ID: 76ca3719-fcd1-4ae3-8e06-8ce161b0f881 Base Type: nvidia::gxf::GraphDriver", "keywords": []}, {"id": 166, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-graphworker", "display_name": "nvidia::gxf::GraphWorker", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-graphworker", "priority": -1, "content": "A GXF System component which governs the execution of one or multiple graph segments. The key ingredients are event based thread, IPC server, and IPC client. The graph segments can be provided by users via YAML config or C++ API. Component ID: 54b88529-2c91-436b-83b6-7f5c10369354 Base Type: nvidia::gxf::GraphWorker", "keywords": []}, {"id": 167, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-greedyscheduler", "display_name": "nvidia::gxf::GreedyScheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-greedyscheduler", "priority": -1, "content": "A simple poll-based single-threaded scheduler which executes codelets. Component ID: 869d30ca-a443-4619-b988-7a52e657f39b Base Type: nvidia::gxf::Scheduler", "keywords": []}, {"id": 168, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-ipcclient", "display_name": "nvidia::gxf::IPCClient", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-ipcclient", "priority": -1, "content": "Interface for a component which works as a API client to send remote requests. It\u2019s the counterpart to IPCServer Component ID: 6f3cf830-7628-49a6-b925-f94171b019da Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/ipc_client.hpp", "keywords": []}, {"id": 169, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-ipcserver", "display_name": "nvidia::gxf::IPCServer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-ipcserver", "priority": -1, "content": "Interface for a component which works as a API server to respond on remote requests. Component ID: 00e6f23d-0bf6-4c1c-ada5-630c711d3be1 Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/ipc_server.hpp", "keywords": []}, {"id": 170, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-jobstatistics", "display_name": "nvidia::gxf::JobStatistics", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-jobstatistics", "priority": -1, "content": "Collects runtime statistics. Component ID: 2093b91a-7c82-11eb-a92b-3f1304ecc959 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 171, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-manualclock", "display_name": "nvidia::gxf::ManualClock", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-manualclock", "priority": -1, "content": "A manual clock which is instrumented manually. Component ID: 52fa1f97-eba8-472a-a8ca-4cff1a2c440f Base Type: nvidia::gxf::Clock", "keywords": []}, {"id": 172, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-memoryavailableschedulingterm", "display_name": "nvidia::gxf::MemoryAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-memoryavailableschedulingterm", "priority": -1, "content": "A component waiting until a minimum amount of memory is available. Component ID: f976d23a-8220-74e2-a5d9-04ed71b2454a Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 173, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-messageavailablefrequencythrottler", "display_name": "nvidia::gxf::MessageAvailableFrequencyThrottler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-messageavailablefrequencythrottler", "priority": -1, "content": "A component which is used to execute an entity at specific frequency or sooner if there are a minimum number of incoming messages in its receivers. Component ID: 5ae1d56c-a196-11ed-8759-ef34a33d45a6 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 174, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-messageavailableschedulingterm", "display_name": "nvidia::gxf::MessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-messageavailableschedulingterm", "priority": -1, "content": "A scheduling term which specifies that an entity can be executed when the total number of messages over a set of input channels is at least a given number of messages. Component ID: fe799e65-f78b-48eb-beb6-e73083a12d5b Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 175, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-messagerouter", "display_name": "nvidia::gxf::MessageRouter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-messagerouter", "priority": -1, "content": "A router which sends transmitted messages to receivers. Component ID: 84fd5d56-fda6-4937-0b3c-c283252553d8 Base Type: nvidia::gxf::Router", "keywords": []}, {"id": 176, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-metric", "display_name": "nvidia::gxf::Metric", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-metric", "priority": -1, "content": "Collects, aggregates, and evaluates metric data. Component ID: f7cef803-5beb-46f1-186a-05d3919842ac Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 177, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-monitor", "display_name": "nvidia::gxf::Monitor", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-monitor", "priority": -1, "content": "Monitors entities during execution. Component ID: 9ccf9421-b35b-8c79-e1f0-97dc23bd38ea Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/monitor.hpp", "keywords": []}, {"id": 178, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-multimessageavailableschedulingterm", "display_name": "nvidia::gxf::MultiMessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-multimessageavailableschedulingterm", "priority": -1, "content": "A component which specifies that an entity shall be executed when a queue has at least a certain number of elements. Component ID: f15dbeaa-afd6-47a6-9ffc-7afd7e1b4c52 Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 179, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-multisourcetimestamp", "display_name": "nvidia::gxf::MultiSourceTimestamp", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-multisourcetimestamp", "priority": -1, "content": "Holds timestamps from various sources. Component ID: 872e77ec-bde8-11ed-afa1-0242ac120002 Defined in: gxf/std/timestamp.hpp", "keywords": []}, {"id": 180, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-multithreadscheduler", "display_name": "nvidia::gxf::MultiThreadScheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-multithreadscheduler", "priority": -1, "content": "A multi thread scheduler that executes codelets for maximum throughput. Component ID: de5e0646-7fa5-11eb-a5c4-330ebfa81bbf Base Type: nvidia::gxf::Scheduler", "keywords": []}, {"id": 181, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-networkrouter", "display_name": "nvidia::gxf::NetworkRouter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-networkrouter", "priority": -1, "content": "A router which sends transmitted messages to remote receivers. Component ID: a1e6c5d5-947d-40fd-b248-117dddc9f0ae Base Type: nvidia::gxf::Router", "keywords": []}, {"id": 182, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-periodicschedulingterm", "display_name": "nvidia::gxf::PeriodicSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-periodicschedulingterm", "priority": -1, "content": "A component which specifies that an entity shall be executed periodically. Component ID: d392c98a-9b08-49b4-a422-d5fe6cd72e3e Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 183, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-queue", "display_name": "nvidia::gxf::Queue", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-queue", "priority": -1, "content": "Interface for storing entities in a queue. Component ID: 792151bf-3138-4603-a912-5ca91828dea8 Base Type: nvidia::gxf::Component Defined in: gxf/std/queue.hpp", "keywords": []}, {"id": 184, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-realtimeclock", "display_name": "nvidia::gxf::RealtimeClock", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-realtimeclock", "priority": -1, "content": "A real-time clock which runs based off a system steady clock. Component ID: 7b170b7b-cf1a-4f3f-997c-bfea25342381 Base Type: nvidia::gxf::Clock", "keywords": []}, {"id": 185, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-receiver", "display_name": "nvidia::gxf::Receiver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-receiver", "priority": -1, "content": "Interface for receiving entities. Component ID: a47d2f62-245f-40fc-90b7-5dc78ff2437e Base Type: nvidia::gxf::Queue Defined in: gxf/std/receiver.hpp", "keywords": []}, {"id": 186, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-resourcebase", "display_name": "nvidia::gxf::ResourceBase", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-resourcebase", "priority": -1, "content": "A resource component base type. Component ID: 76b9234d-5eac-4c65-b1a1-0306d3f354e5 Base Type: nvidia::gxf::Component Defined in: nvidia/gxf/resources.hpp", "keywords": []}, {"id": 187, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-router", "display_name": "nvidia::gxf::Router", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-router", "priority": -1, "content": "Interface for classes which are routing messages in and out of entities. Component ID: 8b317aad-f55c-4c07-8520-8f66db92a19e Defined in: gxf/std/router.hpp", "keywords": []}, {"id": 188, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-routergroup", "display_name": "nvidia::gxf::RouterGroup", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-routergroup", "priority": -1, "content": "A group of routers. Component ID: ca64ee14-2280-4099-9f10-d4b501e09117 Base Type: nvidia::gxf::Router", "keywords": []}, {"id": 189, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-scheduler", "display_name": "nvidia::gxf::Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-scheduler", "priority": -1, "content": "A simple poll-based single-threaded scheduler which executes codelets. Component ID: f0103b75-d2e1-4d70-9b13-3fe5b40209be Base Type: nvidia::gxf::System Defined in: nvidia/gxf/system.hpp", "keywords": []}, {"id": 190, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-schedulingterm", "display_name": "nvidia::gxf::SchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-schedulingterm", "priority": -1, "content": "Interface for terms used by a scheduler to determine if codelets in an entity are ready to step. Component ID: 184d8e4e-086c-475a-903a-69d723f95d19 Base Type: nvidia::gxf::Component Defined in: gxf/std/scheduling_term.hpp", "keywords": []}, {"id": 191, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-subgraph", "display_name": "nvidia::gxf::Subgraph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-subgraph", "priority": -1, "content": "Helper component to import a subgraph. Component ID: 576eedd7-7c3f-4d2f-8c38-8baa79a3d231 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 192, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-synchronization", "display_name": "nvidia::gxf::Synchronization", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-synchronization", "priority": -1, "content": "Component to synchronize messages from multiple receivers based on the acq_time . Component ID: f1cb80d6-e5ec-4dba-9f9e-b06b0def4443 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 193, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-syntheticclock", "display_name": "nvidia::gxf::SyntheticClock", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-syntheticclock", "priority": -1, "content": "A synthetic clock used to inject simulated time. Component ID: 9a2bfd7b-2d84-79b4-bc71-f47eb53f28c8 Base Type: nvidia::gxf::Clock", "keywords": []}, {"id": 194, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-system", "display_name": "nvidia::gxf::System", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-system", "priority": -1, "content": "Component interface for systems which are run as part of the application run cycle. Component ID: d1febca1-80df-454e-a3f2-715f2b3c6e69 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 195, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-systemgroup", "display_name": "nvidia::gxf::SystemGroup", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-systemgroup", "priority": -1, "content": "A group of systems. Component ID: 3d23d470-0aed-41c6-ac92-685c1b5469a0 Base Type: nvidia::gxf::System", "keywords": []}, {"id": 196, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-targettimeschedulingterm", "display_name": "nvidia::gxf::TargetTimeSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-targettimeschedulingterm", "priority": -1, "content": "A component where the next execution time of the entity needs to be specified after every tick. Component ID: e4aaf5c3-2b10-4c9a-c463-ebf6084149bf Base Type: nvidia::gxf::SchedulingTerm", "keywords": []}, {"id": 197, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-tensor", "display_name": "nvidia::gxf::Tensor", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-tensor", "priority": -1, "content": "A component which holds a single tensor. Component ID: 377501d6-9abf-447c-a617-0114d4f33ab8 Defined in: gxf/std/tensor.hpp", "keywords": []}, {"id": 198, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-tensorcopier", "display_name": "nvidia::gxf::TensorCopier", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-tensorcopier", "priority": -1, "content": "Copies tensor either from host to device or from device to host. Component ID: c07680f4-75b3-189b-8886-4b5e448e7bb6 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 199, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-threadpool", "display_name": "nvidia::gxf::ThreadPool", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-threadpool", "priority": -1, "content": "Component ID: 4025b68b-206b-4b3d-a088-f4805fdf8703 Base Type: nvidia::gxf::ResourceBase", "keywords": []}, {"id": 200, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-timedthrottler", "display_name": "nvidia::gxf::TimedThrottler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-timedthrottler", "priority": -1, "content": "Publishes the received entity respecting the timestamp within the entity. Component ID: ccf7729c-f62c-4250-5cf7-f4f3ec80454b Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 201, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-timestamp", "display_name": "nvidia::gxf::Timestamp", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-timestamp", "priority": -1, "content": "Holds message publishing and acquisition related timing information. Component ID: d1095b10-5c90-4bbc-bc89-601134cb4e03 Defined in: gxf/std/timestamp.hpp", "keywords": []}, {"id": 202, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-topic", "display_name": "nvidia::gxf::Topic", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-topic", "priority": -1, "content": "Adds transmitters/receivers to a topic. Component ID: 70529494-8bca-49ef-51bf-44b08ecf460b Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 203, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-transmitter", "display_name": "nvidia::gxf::Transmitter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-transmitter", "priority": -1, "content": "Interface for publishing entities. Component ID: c30cc60f-0db2-409d-92b6-b2db92e02cce Base Type: nvidia::gxf::Queue Defined in: gxf/std/transmitter.hpp", "keywords": []}, {"id": 204, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-unboundedallocator", "display_name": "nvidia::gxf::UnboundedAllocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-unboundedallocator", "priority": -1, "content": "Allocator that uses dynamic memory allocation without an upper bound. Component ID: c3951b16-a01c-539f-d87e-1dc18d911ea0 Base Type: nvidia::gxf::Allocator", "keywords": []}, {"id": 205, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#nvidia-gxf-vault", "display_name": "nvidia::gxf::Vault", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "nvidia-gxf-vault", "priority": -1, "content": "Safely stores received entities for further processing. Component ID: 1108cb8d-85e4-4303-ba02-d27406ee9e65 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 206, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "parameters", "priority": -1, "content": "initial_time_offset The initial time offset used until time scale is changed manually. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FLOAT64 initial_time_scale The initial time scale used until time scale is changed manually. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FLOAT64 use_time_since_epoch If true, clock time is time since epoch + initial_time_offset at initialize() .Otherwise clock time is initial_time_offset at initialize() . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL", "keywords": []}, {"id": 207, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#primitivetype", "display_name": "PrimitiveType", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "primitivetype", "priority": -1, "content": "from gxf.std import PrimitiveType A python enum which defines types of data types. Value Description kCustom Custom data type kInt8 Signed Integer 8 bytes kUnsigned8 Unsigned Interger 8 bytes kInt16 Signed Integer 16 bytes kUnsigned16 Unsigned Integer 16 bytes kInt32 Signed Integer 32 bytes kUnsigned32 Unsigned Integer 32 bytes kInt64 Signed Integer 64 bytes kUnsigned64 Unsigned Integer 64 bytes kFloat32 Floating Point 32 bytes kFloat64 Floating point 64 bytes", "keywords": []}, {"id": 208, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#python-bindings", "display_name": "Python Bindings", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "python-bindings", "priority": -1, "content": "Python binings for the standard extension\u2019s components enable them to be used in python codelets. These python bindings are present in gxf.std and contain the following:", "keywords": []}, {"id": 209, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#receiver", "display_name": "Receiver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "receiver", "priority": -1, "content": "from gxf.std import Receiver The python binding for nvidia::gxf::Receiver component which connects with a transmitter and can receive a message. gxf.std.Receiver has the following methods: receive() Returns: gxf.std.Entity - Receives the next entity from the main stage. sync() Returns: None - Moves entities which recently arrived to the main stage. back_size() Returns: Integer - The total number of entities which have recently arrived but are not yet on the main stage. size() Returns: Integer - The total number of entities present in the main stage. capacity() Returns: Integer - The total number of entities the receiver can hold.", "keywords": []}, {"id": 210, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#shape", "display_name": "Shape", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "shape", "priority": -1, "content": "from gxf.std import Shape Shape of the tensor data. Shape(dims) Parameter Description dims List A list containing the size of each dimension Returns: gxf.std.Shape with set values. rank() Returns: Integer Rank of the tensor Dimension size() Returns: Integer Number of elements in the tensor dimension(index) Returns: Integer Size of the dimension at index", "keywords": []}, {"id": 211, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#short-int", "display_name": "short int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "short-int", "priority": -1, "content": "Component ID: 9e1dde79-3550-307d-e81a-b864890b3685", "keywords": []}, {"id": 212, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#short-unsigned-int", "display_name": "short unsigned int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "short-unsigned-int", "priority": -1, "content": "Component ID: 958cbdef-b505-bcc7-8a43-dc4b23f8cead", "keywords": []}, {"id": 213, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#signed-char", "display_name": "signed char", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "signed-char", "priority": -1, "content": "Component ID: 83905c6a-ca34-4f40-b474-cf2cde8274de", "keywords": []}, {"id": 214, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#tensor", "display_name": "Tensor", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "tensor", "priority": -1, "content": "from gxf.std import Tensor The python binding for nvidia::gxf::Tensor component which contains the tensor data which can be attached to messages. gxf.std.Tensor has the following methods: get_tensor_info() : Returns: Tuple Tuple Values Return Type Description buffer pointer pybind11 object Containing the buffer pointer size Integer Size of one element dtype String Description of the type of data rank Integer Rank of the tensor dims Integer Array of size rank containing the dimensions stride Integer Array of size rank containing the strides for each dimension shape() Returns: gxf.std.Shape - Shape of the tensor element_type() Returns: gxf.std.PrimitiveType - Element type of the data. storage_type() Returns: gxf.std.MemoryStorageType - The device on which the data is stored. reshape_custom(shape, element_type, bytes_per_element, strides, storage_type, allocator) Parameter Return Type Description shape gxf.std.Shape Shape of the tensor element_type PrimitiveType Type of elements bytes_per_element Integer Size of individual element strides Integer Array of size rank containing the strides for each dimension storage_type gxf.std.MemoryStorageType The deive on which the data is stored. allocator gxf.std.Allocator Allocator to provide memory for the tensor data. Returns: None gxf.std.add_to_entity(entity, name=nullptr) Parameter Return Type Description entity gxf.std.Entity A message entity to attach the tensor name String Name of the tensor Returns: gxf.std.Tensor Added Tensor gxf.std.get_from_entity(entity, name=nullptr) Parameter Return Type Description entity gxf.std.Entity A message entity to extract the tensor name String Name of the tensor Returns: gxf.std.Tensor Tensor, if present. Throws value_error if not. find_all_from_entity(entity) Parameter Return Type Description entity gxf.std.Entity A message entity to extract all the tensors Returns: List(Tensors) A list of tensors present in the message entity.", "keywords": []}, {"id": 215, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#transmitter", "display_name": "Transmitter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "transmitter", "priority": -1, "content": "from gxf.std import Transmitter The python binding for nvidia::gxf::Transmitter component which connects with a receiver and can transmit a message. gxf.std.Transmitter has the following methods: publish(message, acqtime) : Value Return Type Description message gxf.std.Entity A message entity. acqtime Integer Acqusition time of the message Returns: String - Error message or Success. back_size() Returns: Integer - The total number of entities which have recently arrived but are not yet on the main stage. size() Returns: Integer - The total number of entities present in the main stage. capacity() Returns: Integer - The total number of entities the transmitter can hold.", "keywords": []}, {"id": 216, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#unsigned-char", "display_name": "unsigned char", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "unsigned-char", "priority": -1, "content": "Component ID: d4299e15-0006-d0bf-8cbd-9b743575e155", "keywords": []}, {"id": 217, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension#unsigned-int", "display_name": "unsigned int", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "unsigned-int", "priority": -1, "content": "Component ID: d5506b68-5c86-fedb-a2a2-a7bae38ff3ef", "keywords": []}, {"id": 218, "doc_id": 218, "filename": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "display_name": "StandardExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/StandardExtension", "anchor": "", "priority": -1, "content": "Most commonly used interfaces and components in Gxf Core. UUID: 8ec2d5d6-b5df-48bf-8dee-0252606fdd7e Version: 2.6.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 219, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#at-the-signaler-codelet", "display_name": "At the Signaler codelet", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "at-the-signaler-codelet", "priority": -1, "content": "Add StreamSync handle to the mesage. Get the streamsync Handle. Initiatlize streamsync Allocate Sync Object based on the signaler and waiter Set cuda Stream for signaler and waiter Submit work of signaler codelet on CUDA stream. Signal Semaphore (Asynchronous call) Publish message", "keywords": []}, {"id": 220, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#at-the-waiter-codelet", "display_name": "At the Waiter Codelet", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "at-the-waiter-codelet", "priority": -1, "content": "Receive the message Find the streamsync handle Wait Semaphore (Asynchronous call) Submit the work of waiter codelet on CUDA stream. Now wait will happen on the GPU asynchronously", "keywords": []}, {"id": 221, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#example", "display_name": "Example", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "example", "priority": -1, "content": "Below example describes on how to make use of GXF Stream Sync in the application.", "keywords": []}, {"id": 222, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#gxf-stream-sync-workflow", "display_name": "GXF Stream Sync Workflow", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "gxf-stream-sync-workflow", "priority": -1, "content": "Cuda to Cuda codelet communication happens with the help of message.", "keywords": []}, {"id": 223, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#gxfstreamextension", "display_name": "GxfStreamExtension", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "gxfstreamextension", "priority": -1, "content": "Extension for synchronization across two CUDA modules without a CPU wait. UUID: 918e6ad7-8e1a-43aa-9b49-251d4b6072b0 Version: 0.5.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 224, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#nvidia-gxf-gxfstreamsync", "display_name": "nvidia::gxf::GxfStreamSync", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "nvidia-gxf-gxfstreamsync", "priority": -1, "content": "Component which helps to achieve synchronization across two CUDA codelets without involving CPU wait. Holds a synchronization object that can be used by the signaler and the waiter. Component ID: 0011bee7-5d53-43ee-aafa-61485a436bc4 Base Type: nvidia::gxf::Component Defined in: gxf/stream/stream_nvscisync.hpp", "keywords": []}, {"id": 225, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "parameters", "priority": -1, "content": "signaler Parameter indicating the type of signaler. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 waiter Parameter indicating the type of waiter. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 signaler_device_id Device id on which signaler is running. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 waiter_device_id Device id on which waiter is running. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32", "keywords": []}, {"id": 226, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#signaler", "display_name": "Signaler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "signaler", "priority": -1, "content": "The signaler codelet upon submitting all the work on a specific CUDA stream, will call the signalSemaphore API of synchronization object. Internally GXF stream sync will make use of a fence to track the completion of the tasks submitted on the CUDA stream. Signaling happens asynchronously on the GPU and the signalSemaphore API returns immediately. signalSemaphore will make use of the same CUDA stream on which the work was submitted. Signaler is also responsible for allocating the synchronization object and passes the same as message entity to the waiter.", "keywords": []}, {"id": 227, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#waiter", "display_name": "Waiter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "waiter", "priority": -1, "content": "The waiter codelet will issue a call to waitSemaphore and submit its own work to the same CUDA stream on which the signaler codelet submitted the work or it may make use of another CUDA stream. GXF stream sync will wait until the fence is signaled which ensures that the work submitted by the signaler codelet is complete. Waiting happens asynchronously on the GPU and the waitSemaphore API returns immediately. The below figure depicts concept of signaler and waiter Figure: Synchronization across two CUDA codelets", "keywords": []}, {"id": 228, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync#yaml-file", "display_name": "Yaml file", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "yaml-file", "priority": -1, "content": "--- name: global components: - name: cuda_dot_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 1 # cuda block_size: 16384 num_blocks: 10 - name: stream_sync_cuda_to_cuda type: nvidia::gxf::StreamSync parameters: signaler: 1 # Cuda signaler waiter: 3 # Cuda waiter --- name: stream_tensor_generator components: - name: cuda_out type: nvidia::gxf::DoubleBufferTransmitter - name: generator type: nvidia::gxf::stream::test::StreamTensorGeneratorNew parameters: cuda_tx: cuda_out cuda_tensor_pool: global/cuda_pool stream_sync: global/stream_sync_cuda_to_cuda - type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: cuda_out min_size: 1 - type: nvidia::gxf::CountSchedulingTerm parameters: count: 50 --- components: - type: nvidia::gxf::Connection parameters: source: stream_tensor_generator/cuda_out target: cuda_dotproduct/rx --- name: cuda_dotproduct components: - name: rx type: nvidia::gxf::DoubleBufferReceiver parameters: capacity: 2 - name: tx type: nvidia::gxf::DoubleBufferTransmitter - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: rx min_size: 1 - type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: tx min_size: 1 - type: nvidia::gxf::stream::test::CublasDotProductNew parameters: rx: rx tx: tx tensor_pool: global/cuda_dot_pool ---", "keywords": []}, {"id": 229, "doc_id": 229, "filename": "graphtools-docs/docs/text/ExtensionsManual/StreamSync.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "display_name": "GXF Stream Sync", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/StreamSync", "anchor": "", "priority": -1, "content": "GXF Stream Sync is responsible for synchronization across two CUDA codelets without involving CPU wait. When two CUDA codelets are used, the first CUDA codelet that generates the data or triggers the CUDA kernel is called as the signaler. The second CUDA codelet that waits for the data or for the CUDA job that was submitted by the upstream codelet is called as the waiter. Signaling and waiting is based on a single synchronization object. Signaler and waiter both make use of the same synchronization object. CUDA stream is associated with the signaler and the waiter. The synchronization object provides APIs for signaling and waiting mechanisms.", "keywords": []}, {"id": 230, "doc_id": 232, "filename": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension#nvidia-gxf-tensorrtinference", "display_name": "nvidia::gxf::TensorRtInference", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension", "anchor": "nvidia-gxf-tensorrtinference", "priority": -1, "content": "Codelet taking input tensors and feed them into TensorRT for inference. Component ID: 06a7f0e0-b9c0-11eb-8cd6-23c9c2070107 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 231, "doc_id": 232, "filename": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension", "anchor": "parameters", "priority": -1, "content": "model_file_path Model File Path. Path to ONNX model to be loaded. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING engine_file_path Engine File Path. Path to the generated engine to be serialized and loaded from. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING force_engine_update Force Engine Update. Always update engine regard less of existing engine file. Such conversion may take minutes. Default to false. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false input_tensor_names Input Tensor Names. Names of input tensors in the order to be fed into the model. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING input_binding_names Input Binding Names. Names of input bindings as in the model in the same order of what is provided in input_tensor_names. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING output_tensor_names Output Tensor Names. Names of output tensors in the order to be retrieved from the model. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING output_binding_names Output Binding Names. Names of output bindings in the model in the same order of of what is provided in output_tensor_names. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING pool Pool. Allocator instance for output tensors. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator cuda_stream_pool Cuda Stream Pool. Instance of gxf::CudaStreamPool to allocate CUDA stream. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::CudaStreamPool max_workspace_size Max Workspace Size. Size of working space in bytes. Default to 64MB. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 Default: 67108864 dla_core DLA Core to use. Fallback to GPU is always enabled. Default to use GPU only. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 max_batch_size Max Batch Size. Maximum possible batch size in case the first dimension is dynamic and used as batch size. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 1 enable_fp16 Enable FP16 Mode. Enable inference with FP16 and FP32 fallback. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false verbose Enable verbose logging on console. Default to false. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: false relaxed_dimension_check Relaxed Dimension Check. Ignore dimensions of 1 for input tensor dimension check. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: true clock Clock. Instance of clock for publish time. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Clock dev_id Device Id. Create CUDA Stream on which device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT32 Default: 0 rx RX. List of receivers to take input tensors. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver tx TX. Transmitter to publish output tensors. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter", "keywords": []}, {"id": 232, "doc_id": 232, "filename": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension", "display_name": "TensorRTExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/TensorrtExtension", "anchor": "", "priority": -1, "content": "Refer to the official NVIDIA Tensorrt documentation for support matrix and more. UUID: d43f23e4-b9bf-11eb-9d18-2b7be630552b Version: 2.7.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 233, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#description", "display_name": "Description", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "description", "priority": -1, "content": "The UCX extension leverages the Unified Communication X (UCX) library to disaggregate a graph in the GXF framework. This extension facilitates graph distribution across multiple hosts, enabling the utilization of distributed GPU resources. UCX, an open-source library, is known for its capability to speed up data across high-performance networks. It can tap into GPUDirect RDMA technology to optimize network latencies and maximize distributed GPU traffic throughput. As a result, users of this extension can harness the combined processing power of multiple GPUs across diverse hosts. This can lead to substantial improvements in the speed and efficiency of workflows. For more UCX details, visit https://openucx.org . For Example The subsequent diagram illustrates a disaggregated graph, composed of two tensor generators and a tensor comparator. This tensor comparator assesses the outputs produced by these tensor generators. The UcxExtension offers the capability to execute each entity on a distinct host. For this, every graph that uses the UCX extension needs a UcxContext component. This component hosts the UCP context and takes care of all connections, manages the data, and ensures that all operations close properly at deinitialization. When you\u2019re setting up your graph, replace your entity\u2019s standard transmitter and receiver with the UcxTransmitter and UcxReceiver components. Be sure to configure all the parameters, including the IP, port, and others, to establish the connection properly. Currently, UCX supports sending messages of same type of memory (host or device). This is the limitation of UCX not of the extension. UUID: 525f8a1a-dfb5-426b-8ddb-00c3ac839994 Version: 0.8.0 Author: NVIDIA License: LICENSE", "keywords": []}, {"id": 234, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#example", "display_name": "Example", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "example", "priority": -1, "content": "This section provides an example of utilizing the UCX extension within a simple graph. This graph comprises two subgraphs, interconnected through the UCX extension. The configuration details for both the server and client side are encapsulated in their respective YAML files, which are shared below for your reference. Server side - test_ping_rx.yaml file: name: rx components: - name: allocator type: nvidia::gxf::test::MockAllocator - name: serialization_buffer type: nvidia::gxf::UcxSerializationBuffer parameters: allocator: allocator - name: signal type: nvidia::gxf::UcxReceiver parameters: address: 5.5.5.5 port: 13337 buffer: serialization_buffer - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: signal min_size: 1 - type: nvidia::gxf::PingRx parameters: signal: signal - type: nvidia::gxf::test::StepCount parameters: expected_count: 10 - type: nvidia::gxf::CountSchedulingTerm parameters: count: 10 --- name: ucx components: - name: allocator type: nvidia::gxf::test::MockAllocator - name: component_serializer type: nvidia::gxf::UcxComponentSerializer parameters: allocator: allocator - name: entity_serializer type: nvidia::gxf::UcxEntitySerializer parameters: component_serializers: [ component_serializer ] - name: ucx_context type: nvidia::gxf::UcxContext parameters: serializer: entity_serializer --- name: scheduler components: - name: clock type: nvidia::gxf::RealtimeClock - type: nvidia::gxf::GreedyScheduler parameters: max_duration_ms: 1000000 clock: clock stop_on_deadlock: False --- name: gpu_resource_entity_0 components: - type: nvidia::gxf::GPUDevice name: gpu_resource_0 parameters: dev_id: 0 --- EntityGroups: - name: entity_group_0 target: - &quot;rx&quot; - &quot;ucx&quot; - &quot;gpu_resource_entity_0&quot; Client side - test_ping_tx.yaml file: name: tx components: - name: allocator type: nvidia::gxf::test::MockAllocator - name: serialization_buffer type: nvidia::gxf::UcxSerializationBuffer parameters: allocator: allocator - name: signal type: nvidia::gxf::UcxTransmitter parameters: receiver_address: 5.5.5.5 port: 13337 buffer: serialization_buffer - type: nvidia::gxf::PingTx parameters: signal: signal - type: nvidia::gxf::CountSchedulingTerm parameters: count: 10 - type: nvidia::gxf::test::StepCount parameters: expected_count: 10 --- name: ucx components: - name: allocator type: nvidia::gxf::test::MockAllocator - name: component_serializer type: nvidia::gxf::UcxComponentSerializer parameters: allocator: allocator - name: entity_serializer type: nvidia::gxf::UcxEntitySerializer parameters: component_serializers: [ component_serializer ] - name: ucx_context type: nvidia::gxf::UcxContext parameters: serializer: entity_serializer --- name: scheduler components: - name: clock type: nvidia::gxf::RealtimeClock - type: nvidia::gxf::GreedyScheduler parameters: stop_on_deadlock: false max_duration_ms: 1000000 clock: clock --- name: gpu_resource_entity_0 components: - type: nvidia::gxf::GPUDevice name: gpu_resource_0 parameters: dev_id: 0 --- EntityGroups: - name: entity_group_0 target: - &quot;tx&quot; - &quot;ucx&quot; - &quot;gpu_resource_entity_0&quot;", "keywords": []}, {"id": 235, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "id1", "priority": -1, "content": "capacity Queue\u2019s capacity of the transmitter. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 policy Queue\u2019s policy for handling data. Valid values: 0: pop 1: reject 2: fault Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 receiver_address Receiver address to connect to. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port Port of the receiver. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 buffer Serialization Buffer to hold serialized data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;UcxSerializationBuffer&gt; maximum_connection_retries Maximum retries for connection establishment. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 gpu_device Optional GPU device resource. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: Handle&lt;GPUDevice&gt;", "keywords": []}, {"id": 236, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "id2", "priority": -1, "content": "capacity Queue\u2019s capacity of the receiver. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 10 policy Queue\u2019s policy for handling data. 0: pop, 1: reject, 2: fault Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 Default: 2 address Listener address to receive data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: \u201c0.0.0.0\u201d port Listener\u2019s port for receiving data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 13337 buffer Serialization Buffer to hold serialized data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: UcxSerializationBuffer Optional GPU device resource Optional resource for GPU device. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::GPUDevice", "keywords": []}, {"id": 237, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "id3", "priority": -1, "content": "allocator Memory allocator for tensor components. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator", "keywords": []}, {"id": 238, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "id4", "priority": -1, "content": "component_serializers List of serializers for serializing and deserializing components. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: FixedVector&lt;nvidia::gxf::Handle&lt;nvidia::gxf::ComponentSerializer&gt;, kMaxTempComponents&gt; verbose_warning Whether or not to print verbose warning. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: true", "keywords": []}, {"id": 239, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "id5", "priority": -1, "content": "allocator Memory allocator for tensor components. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Handle&lt;nvidia::gxf::Allocator&gt; buffer_size Size of the buffer in bytes (4kB by default). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_SIZE Default: 4096 (4kB)", "keywords": []}, {"id": 240, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "parameters", "priority": -1, "content": "serializer The entity serializer used by the component. Should use UcxComponentSerializer type. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::EntitySerializer reconnect Try to reconnect if a connection is closed during run. For UcxReceiver it would wait for a new connect request to establish new connection. For UcxTransmitter it would send new connect request to the server to establish new connection. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_BOOL Default: true Optional GPU device resource Optional resource for GPU device. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::GPUDevice", "keywords": []}, {"id": 241, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#requirements", "display_name": "Requirements", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "requirements", "priority": -1, "content": "NVIDIA ConnectX6-DX NIC or later. For more information on installing and configuring NICs, see: https://docs.nvidia.com/networking/display/ConnectX6VPI/Introduction Mellanox Open Fabrics Enterprise Distribution (MLNX_OFED) - version 5.5 or later, see https://network.nvidia.com/products/infiniband-drivers/linux/mlnx_ofed/ For installation instructions, see https://docs.nvidia.com/networking/display/MLNXOFEDv551032/Installing+MLNX_OFED If installing the Mellanox OFED within a container: Make sure to install the kernel drivers in the host OS by passing the --all flag to mlnxofedinstall script. In the container you can only install the user space libraries using the --user-space-only flag to the mlnxofedinstall script. UCX - version 1.13 or later - needs to be compiled with CUDA support or use CUDA-enabled UCX packages from the git repository directly, see openucx/ucx For installation instructions, follow the Release build instructions from here: openucx/ucx . Note that UCX library should be compiled with CUDA as follows:: .. code-block:: bash $ ./contrib/configure-release \u2013prefix=/install/path \u2013enable-examples \u2013with-java=no \u2013with-cuda=/path/to/cuda \u2013enable-mt", "keywords": []}, {"id": 242, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxcomponentserializer", "display_name": "UcxComponentSerializer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxcomponentserializer", "priority": -1, "content": "Serializer for the components in the GXF UCX extension. Currently supports serializaing Timestamps, Tensors, Video Buffer, Audio Buffer and integer components. Valid for sharing data between devices with the same endianness. Component ID: 64994305-4260-4f5c-ac5f-69da6dd6cfa5 Base Type: nvidia::gxf::ComponentSerializer Defined in: extensions/ucx/ucx_component_serializer.hpp", "keywords": []}, {"id": 243, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxcontext", "display_name": "UcxContext", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxcontext", "priority": -1, "content": "UcxContext is essential within the GXF UCX extension. It\u2019s responsible for initializing the UCX context, running listeners, and managing connection requests and data receipts for UcxReceivers. UcxContext also sets up UcxTransmitter connections and resources. All connections - for both UcxReceivers and UcxTransmitter - are managed within UcxContext. Upon completion of the graph, UcxContext takes the lead in closing all connections and releasing all resources. Component ID: 755d20a5-d794-467d-a86c-290eb2c32052 Base Type: nvidia::gxf::NetworkContext Defined in: extensions/ucx/ucx_context.hpp", "keywords": []}, {"id": 244, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxentityserializer", "display_name": "UcxEntitySerializer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxentityserializer", "priority": -1, "content": "Serializer for the entities in the GXF UCX extension. Component ID: 14997aa4-4a01-4cd4-86ab-687f85a13f10 Base Type: nvidia::gxf::EntitySerializer Defined in: extensions/ucx/ucx_entity_serializer.hpp", "keywords": []}, {"id": 245, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxreceiver", "display_name": "UcxReceiver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxreceiver", "priority": -1, "content": "Receives data in the GXF UCX extension. This component replace a receiver of an entity. When an entity sends a message to this receiver, the UCXContext receives the message header, prompting the router to execute the SyncInbox function. The SyncInbox function subsequently triggers the sync_io method of the UcxReceiver. This method utilizes the UCX Active Message Rendezvous protocol to receive the data content of the message. Component ID: e961132b-45d5-48b8-ac5d-2bb1a4a42279 Base Type: nvidia::gxf::Receiver Defined in: extensions/ucx/ucx_receiver.hpp", "keywords": []}, {"id": 246, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxserializationbuffer", "display_name": "UcxSerializationBuffer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxserializationbuffer", "priority": -1, "content": "Serialization buffer for the GXF UCX extension. Component ID: 1d9fcaf7-1db1-4992-93ec-714979f7d78d Base Type: nvidia::gxf::Endpoint Defined in: extensions/ucx/ucx_serialization_buffer.hpp", "keywords": []}, {"id": 247, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension#ucxtransmitter", "display_name": "UcxTransmitter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "ucxtransmitter", "priority": -1, "content": "Transmitter component for the GXF UCX extension. This component is used as a transmitter of an entity. At the initilization stage it would send connect request for connection establishment. When the Network Router executes the SyncOutbox function, it invokes the sync_io method of the UcxTransmitter. This method, in turn, transmits the message leveraging the UCX Active Message Rendezvous protocol. Component ID: 58165d03-78b7-4696-b200-71621f90aee7 Base Type: nvidia::gxf::Transmitter Defined in: extensions/ucx/ucx_transmitter.hpp", "keywords": []}, {"id": 248, "doc_id": 248, "filename": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "display_name": "UCX Extension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/UcxExtension", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 249, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#components", "display_name": "Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "components", "priority": -1, "content": "This extension is implemented using three components: VideoDecoderRequest , VideoDecoderResponse and VideoDecoderContext", "keywords": []}, {"id": 250, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "id2", "priority": -1, "content": "output_transmitter Transmitter to publish the output yuv data(video buffer) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter pool Memory pool for allocating output data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator outbuf_storage_type Output buffer storage type Valid values: 0: Host memory 1: Device memory Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 1 videodecoder_context Handle to video decoder context component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;VideoDecoderContext&gt;", "keywords": []}, {"id": 251, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "id3", "priority": -1, "content": "None", "keywords": []}, {"id": 252, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#nvidia-gxf-videodecodercontext", "display_name": "nvidia::gxf::VideoDecoderContext", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "nvidia-gxf-videodecodercontext", "priority": -1, "content": "Component that implements the Video Decoder context Component ID: c69e604d9f1d-425e-ad5f121a7e9d-3456 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 253, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#nvidia-gxf-videodecoderrequest", "display_name": "nvidia::gxf::VideoDecoderRequest", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "nvidia-gxf-videodecoderrequest", "priority": -1, "content": "This codelet starts H.264 video decoding process by queueing the input buffer. Component ID: 39c030763a42-4927-9960-0072b4e1bc69 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 254, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#nvidia-gxf-videodecoderresponse", "display_name": "nvidia::gxf::VideoDecoderResponse", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "nvidia-gxf-videodecoderresponse", "priority": -1, "content": "This codelet completes the video decoding process by publishing decoded YUV buffer. Component ID: 6cc164db5db4-431e-8b63a45ea1e7-b8a6 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 255, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "parameters", "priority": -1, "content": "input_frame Receiver to get the input data(receive compressed data) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver inbuf_storage_type Input buffer storage type Valid values: 0: Host memory 1: Device memory Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 1 videodecoder_context Handle to video decoder context component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;VideoDecoderContext&gt; scheduling_term Handle to async scheduling term to get/set event state for VideoDecoderResponse codelet. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::AsynchronousSchedulingTerm&gt; codec Video codec to be used, only H.264 supported. Valid values: 0: H.264 codec Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 0 disableDPB Enable low latency decode, works only for IPPP case Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 0 output_format Output frame video format Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Valid values: nv12: NV12(YUV420, 2 planes: Y, UV interleaved) pitch linear format yuv420planar: YUV420 planar(3 planes:Y,U,V) pitch linear format", "keywords": []}, {"id": 256, "doc_id": 256, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "display_name": "VideoDecoderExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoDecoderExtension", "anchor": "", "priority": -1, "content": "NVIDIA GXF component for H.264 video decode. The video Decoder GXF extension is based on V4L2 APIs. It uses the hardware video Decode engine on the platform by interfacing with V4L2 APIs. It gives out decoded yuv frame. This extension is supported on Tegra and dGPU platforms. For x86+dGPU, the extension has a dependency on DeepStream. Please install nvidia DeepStream SDK (version 7.1) before running pipelines for x86+dGPU. UUID: edc99001-73bd-435c-af0c-e013dcda3439 Version: 1.3.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 257, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#components", "display_name": "Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "components", "priority": -1, "content": "This extension is implemented using three components: VideoEncoderRequest , VideoEncoderResponse and VideoEncoderContext", "keywords": []}, {"id": 258, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "id2", "priority": -1, "content": "output_transmitter Transmitter to publish the compressed data(output tensor) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter pool Memory pool for allocating output data(tensor). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator outbuf_storage_type Output buffer storage type Valid values: 0: Host memory 1: Device memory Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 1 videoencoder_context Handle to video encoder context component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;VideoEncoderContext&gt;", "keywords": []}, {"id": 259, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "id3", "priority": -1, "content": "None", "keywords": []}, {"id": 260, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#nvidia-gxf-videoencodercontext", "display_name": "nvidia::gxf::VideoEncoderContext", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "nvidia-gxf-videoencodercontext", "priority": -1, "content": "Component that implements the Video Encoder Context Component ID: c5bdaa9f4b15-43c7-8066-20195122a5b5 Base Type: nvidia::gxf::Component", "keywords": []}, {"id": 261, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#nvidia-gxf-videoencoderrequest", "display_name": "nvidia::gxf::VideoEncoderRequest", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "nvidia-gxf-videoencoderrequest", "priority": -1, "content": "This codelet starts H.264 video encoding process by queueing the input buffer. Component ID: 48251354-3a91-4033-9a0f-8ac2230f1c9c Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 262, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#nvidia-gxf-videoencoderresponse", "display_name": "nvidia::gxf::VideoEncoderResponse", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "nvidia-gxf-videoencoderresponse", "priority": -1, "content": "This codelet completes the video encoding process by publishing encoded bit stream(H.264 elementary bit stream). Component ID: c88585c4-bce0-48d1-9680-2309e63c1ff8 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 263, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "page", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "parameters", "priority": -1, "content": "input_frame Receiver to get the input video Buffer(input frame data) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver inbuf_storage_type Input buffer storage type Valid values: 0: Host memory 1: Device memory Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 1 scheduling_term Handle to async scheduling term to get/set event state for VideoEncoderResponse codelet. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;gxf::AsynchronousSchedulingTerm&gt; videoencoder_context Handle to video encoder context component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: gxf::Handle&lt;VideoEncoderContext&gt; codec Video codec to be used. Only H.264 supported. Valid values: 0: H.264 codec Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 0 input_height Input frame height Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 input_width Input frame width Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 input_format Input frame color format Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Valid values: nv12: NV12(YUV420, 2 planes: Y, UV interleaved) pitch linear format yuv420planar: YUV420 planar(3 planes:Y,U,V) pitch linear format profile Encode profile Valid values: 0: Baseline Profile 1: MainProfile 2: High Profile Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 2 bitrate Bitrate of the encoded stream, in bits per second. This parmaeter is used when rate_control_mode != 0. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 20000000 framerate Frame rate (frames per second) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 30 level H.264 level parameter(Maximum data rate and resolution). This parameter is supported on Tegra only. For dGPU, the level parameter is automatically set based on input resolution and data rate. Valid values: 0 - 14 0: Level 1.0 \u2026 14: Level 5.1 Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 14 hw_preset_type Encode hw preset type Valid values: Tegra Presets: 0-4 0: V4L2_ENC_HW_PRESET_ULTRAFAST 1: V4L2_ENC_HW_PRESET_FAST 2: V4L2_ENC_HW_PRESET_MEDIUM 3: V4L2_ENC_HW_PRESET_SLOW dGPU Presets: 0-7 0: p0 \u2026 7: p7 Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 1 iframe_interval Interval between two IDR frames. This parameter is supported on Tegra only. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 30 rate_control_mode Rate control mode. This parameter is supported on Tegra only. Valid values: 0:Constant QP mode(Rate control off) 1:CBR (Constant Bit Rate mode) 2:VBR (variable Bit Rate mode) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT32 Default: 1 qp H.264 Quantization Parameter(QP). This QP value is used in constant QP mode. This parameter is supported on Tegra only. Valid values: 0-51 Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT32 Default: 20 config Preset of encoder config parameters Valid values: pframe_cqp: This config uses P frames, rate_control_mode = 0(Constant QP), QP=20, iframe_interval = 5, Main profile, hw_preset_type = 0 iframe_cqp: This config uses all IDR frames(iframe_interval=1), rate_control_mode = 0(Constant QP), QP=20, Main profile, hw_preset_type = 0 custom: Use the parmaters set by the user Note: pframe_cqp,iframe_cqp configs are supported on Tegra only. For dGPU, use \u2018custom\u2019 config. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING Default: custom", "keywords": []}, {"id": 264, "doc_id": 264, "filename": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension.html", "domain_name": "std", "name": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "display_name": "VideoEncoderExtension", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/ExtensionsManual/VideoEncoderExtension", "anchor": "", "priority": -1, "content": "NVIDIA GXF component for H.264 video encode. The video encoder GXF extension is based on V4L2 APIs. It uses the hardware video encode engine on the platform by interfacing with V4L2 APIs. It gives out elimetary H.264 bit stream. This extension is supported on Tegra and dGPU platforms. For x86+dGPU, the extension has a dependency on DeepStream. Please install nvidia DeepStream SDK (version 7.1) before running pipelines for x86+dGPU. UUID: ea5c44e4-15db-4448-a3a6-f32004303338 Version: 1.3.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 265, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair", "display_name": "SegmentPortPair", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv415SegmentPortPair", "priority": 1, "content": "struct  SegmentPortPair A segment - segment connection specified using the segment port info SegmentPort name is in the format \u201c&lt;Entity Name&gt;.&lt;Queue Name&gt;\u201d where the queues are tx or rx components. tx - SegmentPort in the source segment rx - SegmentPort in the sink segment The queue names should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connection between the two segments", "keywords": []}, {"id": 266, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::SegmentPortPair", "display_name": "SegmentPortPair::SegmentPortPair", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N15SegmentPortPair15SegmentPortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "SegmentPortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a SegmentPortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 267, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::SegmentPortPair::source", "display_name": "SegmentPortPair::SegmentPortPair::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N15SegmentPortPair15SegmentPortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "SegmentPortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a SegmentPortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 268, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::SegmentPortPair::target", "display_name": "SegmentPortPair::SegmentPortPair::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N15SegmentPortPair15SegmentPortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "SegmentPortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a SegmentPortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 269, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::getSource", "display_name": "SegmentPortPair::getSource", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK15SegmentPortPair9getSourceEv", "priority": 1, "content": "SegmentPort  getSource  const Returns the source SegmentPort in the connection.", "keywords": []}, {"id": 270, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::getTarget", "display_name": "SegmentPortPair::getTarget", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK15SegmentPortPair9getTargetEv", "priority": 1, "content": "SegmentPort  getTarget  const Returns the target SegmentPort in the connection.", "keywords": []}, {"id": 271, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::source", "display_name": "SegmentPortPair::source", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N15SegmentPortPair6sourceE", "priority": 1, "content": "SegmentPort  source The source SegmentPort in the connection.", "keywords": []}, {"id": 272, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "SegmentPortPair::target", "display_name": "SegmentPortPair::target", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N15SegmentPortPair6targetE", "priority": 1, "content": "SegmentPort  target The target SegmentPort in the connection.", "keywords": []}, {"id": 273, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "applyArg", "display_name": "applyArg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv48applyArg6HandleI9ComponentERK3Arg", "priority": 1, "content": "Expected &lt; void &gt;  applyArg Handle &lt; Component &gt;  component const  Arg  &amp; arg Parameters component \u2013 Handle to a valid component arg \u2013 Arg to be applied on the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 274, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "applyArg::arg", "display_name": "applyArg::arg", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv48applyArg6HandleI9ComponentERK3Arg", "priority": 1, "content": "Expected &lt; void &gt;  applyArg Handle &lt; Component &gt;  component const  Arg  &amp; arg Parameters component \u2013 Handle to a valid component arg \u2013 Arg to be applied on the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 275, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "applyArg::component", "display_name": "applyArg::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv48applyArg6HandleI9ComponentERK3Arg", "priority": 1, "content": "Expected &lt; void &gt;  applyArg Handle &lt; Component &gt;  component const  Arg  &amp; arg Parameters component \u2013 Handle to a valid component arg \u2013 Arg to be applied on the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 276, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "findArg", "display_name": "findArg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv47findArgRKNSt6vectorI3ArgEERKNSt6stringEK20gxf_parameter_type_t", "priority": 1, "content": "Expected &lt; Arg &gt;  findArg const  std :: vector &lt; Arg &gt;  &amp; args const  std :: string  &amp; key const  gxf_parameter_type_t  type Parameters args \u2013 Input Arg list key \u2013 Arg key to search type \u2013 parameter type of the Arg Returns Expected&lt;Arg&gt; Arg object if found, error code on failure", "keywords": []}, {"id": 277, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "findArg::args", "display_name": "findArg::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv47findArgRKNSt6vectorI3ArgEERKNSt6stringEK20gxf_parameter_type_t", "priority": 1, "content": "Expected &lt; Arg &gt;  findArg const  std :: vector &lt; Arg &gt;  &amp; args const  std :: string  &amp; key const  gxf_parameter_type_t  type Parameters args \u2013 Input Arg list key \u2013 Arg key to search type \u2013 parameter type of the Arg Returns Expected&lt;Arg&gt; Arg object if found, error code on failure", "keywords": []}, {"id": 278, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "findArg::key", "display_name": "findArg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv47findArgRKNSt6vectorI3ArgEERKNSt6stringEK20gxf_parameter_type_t", "priority": 1, "content": "Expected &lt; Arg &gt;  findArg const  std :: vector &lt; Arg &gt;  &amp; args const  std :: string  &amp; key const  gxf_parameter_type_t  type Parameters args \u2013 Input Arg list key \u2013 Arg key to search type \u2013 parameter type of the Arg Returns Expected&lt;Arg&gt; Arg object if found, error code on failure", "keywords": []}, {"id": 279, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "findArg::type", "display_name": "findArg::type", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv47findArgRKNSt6vectorI3ArgEERKNSt6stringEK20gxf_parameter_type_t", "priority": 1, "content": "Expected &lt; Arg &gt;  findArg const  std :: vector &lt; Arg &gt;  &amp; args const  std :: string  &amp; key const  gxf_parameter_type_t  type Parameters args \u2013 Input Arg list key \u2013 Arg key to search type \u2013 parameter type of the Arg Returns Expected&lt;Arg&gt; Arg object if found, error code on failure", "keywords": []}, {"id": 280, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application", "display_name": "nvidia::gxf::Application", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ApplicationE", "priority": 1, "content": "class  nvidia :: gxf :: Application A class representing an application for GXF. This class provides a convenient way to create and manage GXF applications imperatively. Users implement a virtual compose() api where individual building blocks of an application is constructed, configured and connected with each other.", "keywords": []}, {"id": 281, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::Application", "display_name": "nvidia::gxf::Application::Application", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application11ApplicationERK11Application", "priority": 1, "content": "Application const  Application &amp;  =  delete Copy constructor for an application. This constructor is deleted to prevent copying of applications.", "keywords": []}, {"id": 282, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::Application", "display_name": "nvidia::gxf::Application::Application", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application11ApplicationERR11Application", "priority": 1, "content": "Application Application &amp; &amp;  =  delete Move constructor for an application. This constructor is deleted to prevent moving applications.", "keywords": []}, {"id": 283, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::Application", "display_name": "nvidia::gxf::Application::Application", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application11ApplicationEv", "priority": 1, "content": "Application Constructor for an application. This constructor initializes an application with no segments or entities.", "keywords": []}, {"id": 284, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::compose", "display_name": "nvidia::gxf::Application::compose", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application7composeEv", "priority": 1, "content": "virtual  void  compose A virtual function that is called to compose the application. This function is where the segments and entities of the application are created and configured.", "keywords": []}, {"id": 285, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::connect", "display_name": "nvidia::gxf::Application::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application7connectE10SegmentPtr10SegmentPtrNSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  connect SegmentPtr  source SegmentPtr  target std :: vector &lt; SegmentPortPair &gt;  port_maps This function connects two segments by mapping their ports. It adds a UCX connection between two entities with many : many tx and rx Ucx Transmitter and Ucx Receiver components are added to the source and target entities in both of the segments. Parameters source \u2013 Segment with the entity transmitting the message target \u2013 Segment with the entity receiving entity. A message available term is added along with the Ucx Receiver port_maps \u2013 Segment port map with entity and queue name to be used for connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 286, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::connect::port_maps", "display_name": "nvidia::gxf::Application::connect::port_maps", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application7connectE10SegmentPtr10SegmentPtrNSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  connect SegmentPtr  source SegmentPtr  target std :: vector &lt; SegmentPortPair &gt;  port_maps This function connects two segments by mapping their ports. It adds a UCX connection between two entities with many : many tx and rx Ucx Transmitter and Ucx Receiver components are added to the source and target entities in both of the segments. Parameters source \u2013 Segment with the entity transmitting the message target \u2013 Segment with the entity receiving entity. A message available term is added along with the Ucx Receiver port_maps \u2013 Segment port map with entity and queue name to be used for connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 287, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::connect::source", "display_name": "nvidia::gxf::Application::connect::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application7connectE10SegmentPtr10SegmentPtrNSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  connect SegmentPtr  source SegmentPtr  target std :: vector &lt; SegmentPortPair &gt;  port_maps This function connects two segments by mapping their ports. It adds a UCX connection between two entities with many : many tx and rx Ucx Transmitter and Ucx Receiver components are added to the source and target entities in both of the segments. Parameters source \u2013 Segment with the entity transmitting the message target \u2013 Segment with the entity receiving entity. A message available term is added along with the Ucx Receiver port_maps \u2013 Segment port map with entity and queue name to be used for connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 288, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::connect::target", "display_name": "nvidia::gxf::Application::connect::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application7connectE10SegmentPtr10SegmentPtrNSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  connect SegmentPtr  source SegmentPtr  target std :: vector &lt; SegmentPortPair &gt;  port_maps This function connects two segments by mapping their ports. It adds a UCX connection between two entities with many : many tx and rx Ucx Transmitter and Ucx Receiver components are added to the source and target entities in both of the segments. Parameters source \u2013 Segment with the entity transmitting the message target \u2013 Segment with the entity receiving entity. A message available term is added along with the Ucx Receiver port_maps \u2013 Segment port map with entity and queue name to be used for connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 289, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::createSegment", "display_name": "nvidia::gxf::Application::createSegment", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Segment ,  std :: decay_t &lt; SegmentT &gt; &gt; &gt; &gt; std :: shared_ptr &lt; SegmentT &gt;  createSegment const  char  * name Function to create a segment in the application. This function creates a new segment in the application with the specified name. The graph for the segment will be composed() after creation. SegmentT is a valid type segment type. Parameters name \u2013 Name of the segment Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 290, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::createSegment::SegmentT", "display_name": "nvidia::gxf::Application::createSegment::SegmentT", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Segment ,  std :: decay_t &lt; SegmentT &gt; &gt; &gt; &gt; std :: shared_ptr &lt; SegmentT &gt;  createSegment const  char  * name Function to create a segment in the application. This function creates a new segment in the application with the specified name. The graph for the segment will be composed() after creation. SegmentT is a valid type segment type. Parameters name \u2013 Name of the segment Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 291, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::createSegment::name", "display_name": "nvidia::gxf::Application::createSegment::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Segment ,  std :: decay_t &lt; SegmentT &gt; &gt; &gt; &gt; std :: shared_ptr &lt; SegmentT &gt;  createSegment const  char  * name Function to create a segment in the application. This function creates a new segment in the application with the specified name. The graph for the segment will be composed() after creation. SegmentT is a valid type segment type. Parameters name \u2013 Name of the segment Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 292, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::create_app", "display_name": "nvidia::gxf::Application::create_app", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11Application10create_appENSt10shared_ptrI1TEEDpRR4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; std :: shared_ptr &lt; T &gt;  create_app &lt; T ,  Args ... &gt; Args &amp; &amp; ...  args Function to create an application. This function creates a new application with the specified arguments. T is valid application type. Returns shared_ptr of the newly created application object", "keywords": []}, {"id": 293, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::create_app::Args", "display_name": "nvidia::gxf::Application::create_app::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11Application10create_appENSt10shared_ptrI1TEEDpRR4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; std :: shared_ptr &lt; T &gt;  create_app &lt; T ,  Args ... &gt; Args &amp; &amp; ...  args Function to create an application. This function creates a new application with the specified arguments. T is valid application type. Returns shared_ptr of the newly created application object", "keywords": []}, {"id": 294, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::create_app::T", "display_name": "nvidia::gxf::Application::create_app::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11Application10create_appENSt10shared_ptrI1TEEDpRR4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; std :: shared_ptr &lt; T &gt;  create_app &lt; T ,  Args ... &gt; Args &amp; &amp; ...  args Function to create an application. This function creates a new application with the specified arguments. T is valid application type. Returns shared_ptr of the newly created application object", "keywords": []}, {"id": 295, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::create_app::args", "display_name": "nvidia::gxf::Application::create_app::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11Application10create_appENSt10shared_ptrI1TEEDpRR4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; std :: shared_ptr &lt; T &gt;  create_app &lt; T ,  Args ... &gt; Args &amp; &amp; ...  args Function to create an application. This function creates a new application with the specified arguments. T is valid application type. Returns shared_ptr of the newly created application object", "keywords": []}, {"id": 296, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::interrupt", "display_name": "nvidia::gxf::Application::interrupt", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9interruptEv", "priority": 1, "content": "Expected &lt; void &gt;  interrupt A non blocking api to stop all running running segments or entities. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 297, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::loadExtensionManifest", "display_name": "nvidia::gxf::Application::loadExtensionManifest", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application21loadExtensionManifestEPKc", "priority": 1, "content": "Expected &lt; void &gt;  loadExtensionManifest const  char  * manifest Function to load an extension manifest. Parameters manifest \u2013 path to manifest file with list of extensions Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 298, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::loadExtensionManifest::manifest", "display_name": "nvidia::gxf::Application::loadExtensionManifest::manifest", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application21loadExtensionManifestEPKc", "priority": 1, "content": "Expected &lt; void &gt;  loadExtensionManifest const  char  * manifest Function to load an extension manifest. Parameters manifest \u2013 path to manifest file with list of extensions Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 299, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity", "display_name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application6nvidia3gxf11Application18setSegmentSeverityEPKc14gxf_severity_t", "priority": 1, "content": "gxf_result_t  nvidia :: gxf :: Application :: setSegmentSeverity const  char  * name gxf_severity_t  severity Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for a specific segment Parameters name \u2013 The name of the segment. severity \u2013 The severity level. Returns A gxf_result_t indicating success or failure.", "keywords": []}, {"id": 300, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity::name", "display_name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application6nvidia3gxf11Application18setSegmentSeverityEPKc14gxf_severity_t", "priority": 1, "content": "gxf_result_t  nvidia :: gxf :: Application :: setSegmentSeverity const  char  * name gxf_severity_t  severity Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for a specific segment Parameters name \u2013 The name of the segment. severity \u2013 The severity level. Returns A gxf_result_t indicating success or failure.", "keywords": []}, {"id": 301, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity::severity", "display_name": "nvidia::gxf::Application::nvidia::gxf::Application::setSegmentSeverity::severity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application6nvidia3gxf11Application18setSegmentSeverityEPKc14gxf_severity_t", "priority": 1, "content": "gxf_result_t  nvidia :: gxf :: Application :: setSegmentSeverity const  char  * name gxf_severity_t  severity Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for a specific segment Parameters name \u2013 The name of the segment. severity \u2013 The severity level. Returns A gxf_result_t indicating success or failure.", "keywords": []}, {"id": 302, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::operator=", "display_name": "nvidia::gxf::Application::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ApplicationaSERK11Application", "priority": 1, "content": "Application  &amp; operator = const  Application &amp;  =  delete Copy assignment operator for an application. This operator is deleted to prevent copying of applications.", "keywords": []}, {"id": 303, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::operator=", "display_name": "nvidia::gxf::Application::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ApplicationaSERR11Application", "priority": 1, "content": "Application  &amp; operator = Application &amp; &amp;  =  delete Move assignment operator for an application. This operator is deleted to prevent moving applications.", "keywords": []}, {"id": 304, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::run", "display_name": "nvidia::gxf::Application::run", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application3runEv", "priority": 1, "content": "Expected &lt; void &gt;  run A blocking api to run the graph. If the application contains multiple segments, each segment is launched asynchronously and this thread is blocked until each one of the segments have finished execution. If the graph contains multiple entities, then this thread is blocked until the graph execution is complete. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 305, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::runAsync", "display_name": "nvidia::gxf::Application::runAsync", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application8runAsyncEv", "priority": 1, "content": "Expected &lt; void &gt;  runAsync A non blocking api call to run an application. If the application contains multiple segments, each segment is launched asynchronously. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 306, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setConfig", "display_name": "nvidia::gxf::Application::setConfig", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9setConfigERKNSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  setConfig const  std :: string  &amp; file_path Function to set the configuration of the application. This function sets the configuration of the application by loading it from a file. Parameters file_path \u2013 Absolute path to the yaml config file for segments distributed execution Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 307, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setConfig", "display_name": "nvidia::gxf::Application::setConfig", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9setConfigEiPPc", "priority": 1, "content": "Expected &lt; void &gt;  setConfig int  argc char  * * argv Function to set the configuration of the application. This function sets the configuration of the application by parsing it from command line arguments. Parameters argc \u2013 CLI argument count argv \u2013 CLI argument array, the second is config file path for segments distributed execution Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 308, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setConfig::argc", "display_name": "nvidia::gxf::Application::setConfig::argc", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9setConfigEiPPc", "priority": 1, "content": "Expected &lt; void &gt;  setConfig int  argc char  * * argv Function to set the configuration of the application. This function sets the configuration of the application by parsing it from command line arguments. Parameters argc \u2013 CLI argument count argv \u2013 CLI argument array, the second is config file path for segments distributed execution Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 309, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setConfig::argv", "display_name": "nvidia::gxf::Application::setConfig::argv", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9setConfigEiPPc", "priority": 1, "content": "Expected &lt; void &gt;  setConfig int  argc char  * * argv Function to set the configuration of the application. This function sets the configuration of the application by parsing it from command line arguments. Parameters argc \u2013 CLI argument count argv \u2013 CLI argument array, the second is config file path for segments distributed execution Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 310, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setConfig::file_path", "display_name": "nvidia::gxf::Application::setConfig::file_path", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application9setConfigERKNSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  setConfig const  std :: string  &amp; file_path Function to set the configuration of the application. This function sets the configuration of the application by loading it from a file. Parameters file_path \u2013 Absolute path to the yaml config file for segments distributed execution Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 311, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setDriver", "display_name": "nvidia::gxf::Application::setDriver", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setDriverE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setDriver const  std :: string  &amp; name Args ...  args In-place add a GraphDriver Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphDriver. args \u2013 The parameter pack of arguments to pass to the GraphDriver constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 312, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setDriver::Args", "display_name": "nvidia::gxf::Application::setDriver::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setDriverE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setDriver const  std :: string  &amp; name Args ...  args In-place add a GraphDriver Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphDriver. args \u2013 The parameter pack of arguments to pass to the GraphDriver constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 313, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setDriver::args", "display_name": "nvidia::gxf::Application::setDriver::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setDriverE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setDriver const  std :: string  &amp; name Args ...  args In-place add a GraphDriver Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphDriver. args \u2013 The parameter pack of arguments to pass to the GraphDriver constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 314, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setDriver::name", "display_name": "nvidia::gxf::Application::setDriver::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setDriverE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setDriver const  std :: string  &amp; name Args ...  args In-place add a GraphDriver Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphDriver. args \u2013 The parameter pack of arguments to pass to the GraphDriver constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 315, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setWorker", "display_name": "nvidia::gxf::Application::setWorker", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setWorkerE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setWorker const  std :: string  &amp; name Args ...  args In-place add a GraphWorker Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphWorker. args \u2013 The parameter pack of arguments to pass to the GraphWorker constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 316, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setWorker::Args", "display_name": "nvidia::gxf::Application::setWorker::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setWorkerE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setWorker const  std :: string  &amp; name Args ...  args In-place add a GraphWorker Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphWorker. args \u2013 The parameter pack of arguments to pass to the GraphWorker constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 317, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setWorker::args", "display_name": "nvidia::gxf::Application::setWorker::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setWorkerE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setWorker const  std :: string  &amp; name Args ...  args In-place add a GraphWorker Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphWorker. args \u2013 The parameter pack of arguments to pass to the GraphWorker constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 318, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::setWorker::name", "display_name": "nvidia::gxf::Application::setWorker::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf11Application9setWorkerE8ExpectedIvERKNSt6stringEDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; Expected &lt; void &gt;  setWorker const  std :: string  &amp; name Args ...  args In-place add a GraphWorker Component into Application\u2019s root context, in which case Application\u2019s context should only hold and run GraphWorker or GraphDriver Parameters name \u2013 The name of the GraphWorker. args \u2013 The parameter pack of arguments to pass to the GraphWorker constructor. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 319, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::wait", "display_name": "nvidia::gxf::Application::wait", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11Application4waitEv", "priority": 1, "content": "Expected &lt; void &gt;  wait A blocking API to waits until the graph execution has completed Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 320, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Application::~Application", "display_name": "nvidia::gxf::Application::~Application", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ApplicationD0Ev", "priority": 1, "content": "~Application Destructor for an application. This destructor cleans up any resources that were allocated by the application.", "keywords": []}, {"id": 321, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg", "display_name": "nvidia::gxf::Arg", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3ArgE", "priority": 1, "content": "class  nvidia :: gxf :: Arg Argument interface to enable configuring parameters in GXF Components from the application layer. All parameter types from :cpp:enum:: gxf_parameter_type_t enum is supported.", "keywords": []}, {"id": 322, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key T  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a value.", "keywords": []}, {"id": 323, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key Handle &lt; T &gt;  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 324, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK1T", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  T  &amp; value Constructor for an argument with a given key and value.", "keywords": []}, {"id": 325, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  Handle &lt; T &gt;  &amp; value Constructor for an argument with a given key and handle to a component as value.", "keywords": []}, {"id": 326, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringE", "priority": 1, "content": "Arg const  std :: string  &amp; key Constructor for an argument with a given key.", "keywords": []}, {"id": 327, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringEPKc", "priority": 1, "content": "Arg const  std :: string  &amp; key const  char  * value Constructor for an argument with a given key and string literal value.", "keywords": []}, {"id": 328, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERK14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key const  ProxyComponent  &amp; value Constructor for an argument with a given key and a proxy component.", "keywords": []}, {"id": 329, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg", "display_name": "nvidia::gxf::Arg::Arg", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERR14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key ProxyComponent  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a proxy component.", "keywords": []}, {"id": 330, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::T", "display_name": "nvidia::gxf::Arg::Arg::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key T  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a value.", "keywords": []}, {"id": 331, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::T", "display_name": "nvidia::gxf::Arg::Arg::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key Handle &lt; T &gt;  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 332, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::T", "display_name": "nvidia::gxf::Arg::Arg::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK1T", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  T  &amp; value Constructor for an argument with a given key and value.", "keywords": []}, {"id": 333, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::T", "display_name": "nvidia::gxf::Arg::Arg::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  Handle &lt; T &gt;  &amp; value Constructor for an argument with a given key and handle to a component as value.", "keywords": []}, {"id": 334, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key T  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a value.", "keywords": []}, {"id": 335, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key Handle &lt; T &gt;  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 336, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK1T", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  T  &amp; value Constructor for an argument with a given key and value.", "keywords": []}, {"id": 337, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  Handle &lt; T &gt;  &amp; value Constructor for an argument with a given key and handle to a component as value.", "keywords": []}, {"id": 338, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringE", "priority": 1, "content": "Arg const  std :: string  &amp; key Constructor for an argument with a given key.", "keywords": []}, {"id": 339, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringEPKc", "priority": 1, "content": "Arg const  std :: string  &amp; key const  char  * value Constructor for an argument with a given key and string literal value.", "keywords": []}, {"id": 340, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERK14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key const  ProxyComponent  &amp; value Constructor for an argument with a given key and a proxy component.", "keywords": []}, {"id": 341, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::key", "display_name": "nvidia::gxf::Arg::Arg::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERR14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key ProxyComponent  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a proxy component.", "keywords": []}, {"id": 342, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key T  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a value.", "keywords": []}, {"id": 343, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3Arg3ArgERKNSt6stringERR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg const  std :: string  &amp; key Handle &lt; T &gt;  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 344, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK1T", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  T  &amp; value Constructor for an argument with a given key and value.", "keywords": []}, {"id": 345, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf3Arg3ArgERKNSt6stringERK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Arg const  std :: string  &amp; key const  Handle &lt; T &gt;  &amp; value Constructor for an argument with a given key and handle to a component as value.", "keywords": []}, {"id": 346, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringEPKc", "priority": 1, "content": "Arg const  std :: string  &amp; key const  char  * value Constructor for an argument with a given key and string literal value.", "keywords": []}, {"id": 347, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERK14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key const  ProxyComponent  &amp; value Constructor for an argument with a given key and a proxy component.", "keywords": []}, {"id": 348, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::Arg::value", "display_name": "nvidia::gxf::Arg::Arg::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3Arg3ArgERKNSt6stringERR14ProxyComponent", "priority": 1, "content": "Arg const  std :: string  &amp; key ProxyComponent  &amp; &amp; value Constructor for an argument with a given key and rvalue reference to a proxy component.", "keywords": []}, {"id": 349, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::arg_info", "display_name": "nvidia::gxf::Arg::arg_info", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg8arg_infoEv", "priority": 1, "content": "const  ArgInfo  arg_info  const Method to retrieve the argument info of the argument.", "keywords": []}, {"id": 350, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::arg_type_name", "display_name": "nvidia::gxf::Arg::arg_type_name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg13arg_type_nameEv", "priority": 1, "content": "const  std :: string  arg_type_name  const Method to retrieve the type name of the argument.", "keywords": []}, {"id": 351, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::as", "display_name": "nvidia::gxf::Arg::as", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00ENK6nvidia3gxf3Arg2asE1Tv", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; IsDefaultConstructible_v &lt; T &gt; &gt; &gt; T  as  const Method to retrieve the value of the argument as a given type.", "keywords": []}, {"id": 352, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::as::T", "display_name": "nvidia::gxf::Arg::as::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00ENK6nvidia3gxf3Arg2asE1Tv", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; IsDefaultConstructible_v &lt; T &gt; &gt; &gt; T  as  const Method to retrieve the value of the argument as a given type.", "keywords": []}, {"id": 353, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::handle_tid", "display_name": "nvidia::gxf::Arg::handle_tid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg10handle_tidEv", "priority": 1, "content": "const  gxf_tid_t  handle_tid  const Method to retrieve the handle TID of the argument.", "keywords": []}, {"id": 354, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::handle_uid", "display_name": "nvidia::gxf::Arg::handle_uid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg10handle_uidEv", "priority": 1, "content": "const  gxf_uid_t  handle_uid  const Method to retrieve the handle UID of the argument.", "keywords": []}, {"id": 355, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::has_value", "display_name": "nvidia::gxf::Arg::has_value", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg9has_valueEv", "priority": 1, "content": "bool  has_value  const Method to retrieve the argument has a value assigned", "keywords": []}, {"id": 356, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::key", "display_name": "nvidia::gxf::Arg::key", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg3keyEv", "priority": 1, "content": "const  char  * key  const Method to retrieve the key of the argument.", "keywords": []}, {"id": 357, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  T  &amp; value Assignment operator for an argument with a given value.", "keywords": []}, {"id": 358, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  Handle &lt; T &gt;  &amp; value Assignment operator for an argument with a given handle to a component as value.", "keywords": []}, {"id": 359, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = T  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a value.", "keywords": []}, {"id": 360, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; Handle &lt; T &gt; &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; Handle &lt; T &gt; &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = Handle &lt; T &gt;  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 361, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3ArgaSER14ProxyComponent", "priority": 1, "content": "Arg  &amp; operator = ProxyComponent  &amp; value Assignment operator for an argument with a given proxy component.", "keywords": []}, {"id": 362, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=", "display_name": "nvidia::gxf::Arg::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3ArgaSERR14ProxyComponent", "priority": 1, "content": "Arg  &amp; &amp; operator = ProxyComponent  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a proxy component.", "keywords": []}, {"id": 363, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::T", "display_name": "nvidia::gxf::Arg::operator=::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  T  &amp; value Assignment operator for an argument with a given value.", "keywords": []}, {"id": 364, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::T", "display_name": "nvidia::gxf::Arg::operator=::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  Handle &lt; T &gt;  &amp; value Assignment operator for an argument with a given handle to a component as value.", "keywords": []}, {"id": 365, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::T", "display_name": "nvidia::gxf::Arg::operator=::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = T  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a value.", "keywords": []}, {"id": 366, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::T", "display_name": "nvidia::gxf::Arg::operator=::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; Handle &lt; T &gt; &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; Handle &lt; T &gt; &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = Handle &lt; T &gt;  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 367, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  T  &amp; value Assignment operator for an argument with a given value.", "keywords": []}, {"id": 368, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSER3ArgRK6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt; &gt; &gt; Arg  &amp; operator = const  Handle &lt; T &gt;  &amp; value Assignment operator for an argument with a given handle to a component as value.", "keywords": []}, {"id": 369, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR1T", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; T &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; T &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = T  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a value.", "keywords": []}, {"id": 370, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf3ArgaSERR3ArgRR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T ,  typename  =  std :: enable_if_t &lt; ! std :: is_same_v &lt; Arg ,  std :: decay_t &lt; Handle &lt; T &gt; &gt; &gt;  &amp;&amp;  ! std :: is_lvalue_reference &lt; Handle &lt; T &gt; &gt; :: value &gt; &gt; Arg  &amp; &amp; operator = Handle &lt; T &gt;  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a handle to a component as value.", "keywords": []}, {"id": 371, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3ArgaSER14ProxyComponent", "priority": 1, "content": "Arg  &amp; operator = ProxyComponent  &amp; value Assignment operator for an argument with a given proxy component.", "keywords": []}, {"id": 372, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::operator=::value", "display_name": "nvidia::gxf::Arg::operator=::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf3ArgaSERR14ProxyComponent", "priority": 1, "content": "Arg  &amp; &amp; operator = ProxyComponent  &amp; &amp; value Move assignment operator for an argument with a given rvalue reference to a proxy component.", "keywords": []}, {"id": 373, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::parameter_type", "display_name": "nvidia::gxf::Arg::parameter_type", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg14parameter_typeEv", "priority": 1, "content": "const  gxf_parameter_type_t  parameter_type  const Method to retrieve the parameter type of the argument.", "keywords": []}, {"id": 374, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::rank", "display_name": "nvidia::gxf::Arg::rank", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg4rankEv", "priority": 1, "content": "const  int32_t  rank  const Method to retrieve the rank of the argument.", "keywords": []}, {"id": 375, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::shape", "display_name": "nvidia::gxf::Arg::shape", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg5shapeEv", "priority": 1, "content": "const  std :: array &lt; int32_t ,  ParameterInfo &lt; int32_t &gt; :: kMaxRank &gt;  shape  const Method to retrieve the shape of the argument.", "keywords": []}, {"id": 376, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::value", "display_name": "nvidia::gxf::Arg::value", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg5valueEv", "priority": 1, "content": "std :: any  value  const Method to retrieve the value of the argument in a std::any object", "keywords": []}, {"id": 377, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Arg::yaml_node", "display_name": "nvidia::gxf::Arg::yaml_node", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf3Arg9yaml_nodeEv", "priority": 1, "content": "const  YAML :: Node  yaml_node  const Method to retrieve the YAML node of the argument.", "keywords": []}, {"id": 378, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgInfo", "display_name": "nvidia::gxf::ArgInfo", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7ArgInfoE", "priority": 1, "content": "struct  nvidia :: gxf :: ArgInfo Holds type information of an Arg.", "keywords": []}, {"id": 379, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgInfo::rank", "display_name": "nvidia::gxf::ArgInfo::rank", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7ArgInfo4rankE", "priority": 1, "content": "int32_t  rank The rank of the Arg.", "keywords": []}, {"id": 380, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgInfo::shape", "display_name": "nvidia::gxf::ArgInfo::shape", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7ArgInfo5shapeE", "priority": 1, "content": "std :: array &lt; int32_t ,  ParameterInfo &lt; int32_t &gt; :: kMaxRank &gt;  shape The shape of the Arg.", "keywords": []}, {"id": 381, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgInfo::type", "display_name": "nvidia::gxf::ArgInfo::type", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7ArgInfo4typeE", "priority": 1, "content": "gxf_parameter_type_t  type The type of the Arg.", "keywords": []}, {"id": 382, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgInfo::type_name", "display_name": "nvidia::gxf::ArgInfo::type_name", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7ArgInfo9type_nameE", "priority": 1, "content": "std :: string  type_name The name of the Arg\u2019s type.", "keywords": []}, {"id": 383, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgOverride", "display_name": "nvidia::gxf::ArgOverride", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ArgOverrideE", "priority": 1, "content": "struct  nvidia :: gxf :: ArgOverride A template struct for overriding ArgInfo for various Arg types.", "keywords": []}, {"id": 384, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgOverride::apply", "display_name": "nvidia::gxf::ArgOverride::apply", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ArgOverride5applyER7ArgInfo", "priority": 1, "content": "static  Expected &lt; void &gt;  apply ArgInfo  &amp; info Applies the ArgOverride to the given ArgInfo. Parameters ArgInfo&amp; info \u2013 The ArgInfo to apply the override to. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 385, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgOverride::apply::info", "display_name": "nvidia::gxf::ArgOverride::apply::info", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ArgOverride5applyER7ArgInfo", "priority": 1, "content": "static  Expected &lt; void &gt;  apply ArgInfo  &amp; info Applies the ArgOverride to the given ArgInfo. Parameters ArgInfo&amp; info \u2013 The ArgInfo to apply the override to. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 386, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgOverride::wrap", "display_name": "nvidia::gxf::ArgOverride::wrap", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ArgOverride4wrapERK1T", "priority": 1, "content": "static  ExpectedYAML :: Node  wrap const  T  &amp; value Wraps the given arg value in a YAML node. Parameters const T&amp; value \u2013 The value to wrap. Returns An Expected with a YAML node on success, or an Unexpected with an error code on failure. The following template specializations have been implemented for the ArgOverride struct in arg.hpp: ArgOverride&lt;T&gt; ArgOverride&lt;Handle&lt;T&gt;&gt; ArgOverride&lt;std::vector&lt;T&gt;&gt; ArgOverride&lt;std::array&lt;T,N&gt;&gt; ArgOverride&lt;ProxyComponent&gt; These specializations cover a wide range of parameter types, including scalar types, handles, arrays, vectors, and proxy components.", "keywords": []}, {"id": 387, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::ArgOverride::wrap::value", "display_name": "nvidia::gxf::ArgOverride::wrap::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11ArgOverride4wrapERK1T", "priority": 1, "content": "static  ExpectedYAML :: Node  wrap const  T  &amp; value Wraps the given arg value in a YAML node. Parameters const T&amp; value \u2013 The value to wrap. Returns An Expected with a YAML node on success, or an Unexpected with an error code on failure. The following template specializations have been implemented for the ArgOverride struct in arg.hpp: ArgOverride&lt;T&gt; ArgOverride&lt;Handle&lt;T&gt;&gt; ArgOverride&lt;std::vector&lt;T&gt;&gt; ArgOverride&lt;std::array&lt;T,N&gt;&gt; ArgOverride&lt;ProxyComponent&gt; These specializations cover a wide range of parameter types, including scalar types, handles, arrays, vectors, and proxy components.", "keywords": []}, {"id": 388, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity", "display_name": "nvidia::gxf::GraphEntity", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntityE", "priority": 1, "content": "class  nvidia :: gxf :: GraphEntity A wrapper over nvidia::gxf::Entity to manage a programmable graph entity.", "keywords": []}, {"id": 389, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::activate", "display_name": "nvidia::gxf::GraphEntity::activate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity8activateEv", "priority": 1, "content": "Expected &lt; void &gt;  activate Activate the GraphEntity Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 390, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::addReceiver", "display_name": "nvidia::gxf::GraphEntity::addReceiver", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11addReceiverEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Receiver &gt;  addReceiver const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Receiver of the corresponding type_name. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the receiver. name \u2013 Name of the receiver. Default is nullptr. arg_list \u2013 Arguments for the receiver component. Default is an empty vector. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Receiver&gt; Handle to newly created receiver component.", "keywords": []}, {"id": 391, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::addReceiver::arg_list", "display_name": "nvidia::gxf::GraphEntity::addReceiver::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11addReceiverEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Receiver &gt;  addReceiver const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Receiver of the corresponding type_name. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the receiver. name \u2013 Name of the receiver. Default is nullptr. arg_list \u2013 Arguments for the receiver component. Default is an empty vector. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Receiver&gt; Handle to newly created receiver component.", "keywords": []}, {"id": 392, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::addReceiver::name", "display_name": "nvidia::gxf::GraphEntity::addReceiver::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11addReceiverEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Receiver &gt;  addReceiver const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Receiver of the corresponding type_name. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the receiver. name \u2013 Name of the receiver. Default is nullptr. arg_list \u2013 Arguments for the receiver component. Default is an empty vector. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Receiver&gt; Handle to newly created receiver component.", "keywords": []}, {"id": 393, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::addReceiver::omit_term", "display_name": "nvidia::gxf::GraphEntity::addReceiver::omit_term", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11addReceiverEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Receiver &gt;  addReceiver const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Receiver of the corresponding type_name. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the receiver. name \u2013 Name of the receiver. Default is nullptr. arg_list \u2013 Arguments for the receiver component. Default is an empty vector. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Receiver&gt; Handle to newly created receiver component.", "keywords": []}, {"id": 394, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::addReceiver::type_name", "display_name": "nvidia::gxf::GraphEntity::addReceiver::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11addReceiverEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Receiver &gt;  addReceiver const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Receiver of the corresponding type_name. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. If codelet parameter is a scalar, name of the receiver is also same as the parameter key Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the receiver. name \u2013 Name of the receiver. Default is nullptr. arg_list \u2013 Arguments for the receiver component. Default is an empty vector. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Receiver&gt; Handle to newly created receiver component.", "keywords": []}, {"id": 395, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configReceiver", "display_name": "nvidia::gxf::GraphEntity::configReceiver", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity14configReceiverEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configReceiver const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling term Parameters name \u2013 Name of the receiver component capacity \u2013 capacity of the receiver to be set policy \u2013 policy of the receiver to be set min_size \u2013 min size of the message available term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 396, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configReceiver::capacity", "display_name": "nvidia::gxf::GraphEntity::configReceiver::capacity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity14configReceiverEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configReceiver const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling term Parameters name \u2013 Name of the receiver component capacity \u2013 capacity of the receiver to be set policy \u2013 policy of the receiver to be set min_size \u2013 min size of the message available term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 397, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configReceiver::min_size", "display_name": "nvidia::gxf::GraphEntity::configReceiver::min_size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity14configReceiverEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configReceiver const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling term Parameters name \u2013 Name of the receiver component capacity \u2013 capacity of the receiver to be set policy \u2013 policy of the receiver to be set min_size \u2013 min size of the message available term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 398, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configReceiver::name", "display_name": "nvidia::gxf::GraphEntity::configReceiver::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity14configReceiverEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configReceiver const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling term Parameters name \u2013 Name of the receiver component capacity \u2013 capacity of the receiver to be set policy \u2013 policy of the receiver to be set min_size \u2013 min size of the message available term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 399, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configReceiver::policy", "display_name": "nvidia::gxf::GraphEntity::configReceiver::policy", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity14configReceiverEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configReceiver const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a receiver and its corresponding message available scheduling term Parameters name \u2013 Name of the receiver component capacity \u2013 capacity of the receiver to be set policy \u2013 policy of the receiver to be set min_size \u2013 min size of the message available term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 400, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configTransmitter", "display_name": "nvidia::gxf::GraphEntity::configTransmitter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity17configTransmitterEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configTransmitter const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling term Parameters name \u2013 Name of the transmitter component capacity \u2013 capacity of the transmitter to be set policy \u2013 policy of the transmitter to be set min_size \u2013 min size of the downstream receptive term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 401, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configTransmitter::capacity", "display_name": "nvidia::gxf::GraphEntity::configTransmitter::capacity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity17configTransmitterEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configTransmitter const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling term Parameters name \u2013 Name of the transmitter component capacity \u2013 capacity of the transmitter to be set policy \u2013 policy of the transmitter to be set min_size \u2013 min size of the downstream receptive term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 402, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configTransmitter::min_size", "display_name": "nvidia::gxf::GraphEntity::configTransmitter::min_size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity17configTransmitterEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configTransmitter const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling term Parameters name \u2013 Name of the transmitter component capacity \u2013 capacity of the transmitter to be set policy \u2013 policy of the transmitter to be set min_size \u2013 min size of the downstream receptive term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 403, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configTransmitter::name", "display_name": "nvidia::gxf::GraphEntity::configTransmitter::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity17configTransmitterEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configTransmitter const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling term Parameters name \u2013 Name of the transmitter component capacity \u2013 capacity of the transmitter to be set policy \u2013 policy of the transmitter to be set min_size \u2013 min size of the downstream receptive term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 404, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::configTransmitter::policy", "display_name": "nvidia::gxf::GraphEntity::configTransmitter::policy", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity17configTransmitterEPKc8uint64_t8uint64_t8uint64_t", "priority": 1, "content": "Expected &lt; void &gt;  configTransmitter const  char  * name uint64_t  capacity uint64_t  policy uint64_t  min_size Update the capacity and min_size parameter of a transmitter and its corresponding downstream receptive scheduling term Parameters name \u2013 Name of the transmitter component capacity \u2013 capacity of the transmitter to be set policy \u2013 policy of the transmitter to be set min_size \u2013 min size of the downstream receptive term to be set Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 405, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::context", "display_name": "nvidia::gxf::GraphEntity::context", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity7contextEv", "priority": 1, "content": "gxf_context_t  context  const Get the context of the GraphEntity Returns gxf_context_t The context of the GraphEntity", "keywords": []}, {"id": 406, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::deactivate", "display_name": "nvidia::gxf::GraphEntity::deactivate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity10deactivateEv", "priority": 1, "content": "Expected &lt; void &gt;  deactivate Deactivate the GraphEntity Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 407, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::eid", "display_name": "nvidia::gxf::GraphEntity::eid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity3eidEv", "priority": 1, "content": "gxf_uid_t  eid  const Get the entity ID of the GraphEntity Returns gxf_uid_t The entity ID of the GraphEntity", "keywords": []}, {"id": 408, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::formatRxName", "display_name": "nvidia::gxf::GraphEntity::formatRxName", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity12formatRxNameEPKc", "priority": 1, "content": "Expected &lt; std :: string &gt;  formatRxName const  char  * rx_name Given a name for a receiver to be connected to the codelet, return a formatted string back which can be used for a new receiver component creation. If the codelet\u2019s rx parameter is a scalar, the rx name is the same as the parameter key. If the codelet\u2019s rx parameter is a vector, the rx name would be \u201ckey_0\u201d, \u201ckey_1\u201d \u2026 Parameters rx_name \u2013 name of receiver component Returns Expected&lt;std::string&gt; formatted name of receiver component", "keywords": []}, {"id": 409, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::formatRxName::rx_name", "display_name": "nvidia::gxf::GraphEntity::formatRxName::rx_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity12formatRxNameEPKc", "priority": 1, "content": "Expected &lt; std :: string &gt;  formatRxName const  char  * rx_name Given a name for a receiver to be connected to the codelet, return a formatted string back which can be used for a new receiver component creation. If the codelet\u2019s rx parameter is a scalar, the rx name is the same as the parameter key. If the codelet\u2019s rx parameter is a vector, the rx name would be \u201ckey_0\u201d, \u201ckey_1\u201d \u2026 Parameters rx_name \u2013 name of receiver component Returns Expected&lt;std::string&gt; formatted name of receiver component", "keywords": []}, {"id": 410, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::formatTxName", "display_name": "nvidia::gxf::GraphEntity::formatTxName", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity12formatTxNameEPKc", "priority": 1, "content": "Expected &lt; std :: string &gt;  formatTxName const  char  * tx_name Given a name for a transmitter to be connected to the codelet, return a formatted string back which can be used for a new transmitter component creation. If the codelet\u2019s tx parameter is a scalar, the tx name is the same as the parameter key. If the codelet\u2019s tx parameter is a vector, the tx name would be \u201ckey_0\u201d, \u201ckey_1\u201d \u2026 Parameters tx_name \u2013 name of transmitter component Returns Expected&lt;std::string&gt; formatted name of transmitter component", "keywords": []}, {"id": 411, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::formatTxName::tx_name", "display_name": "nvidia::gxf::GraphEntity::formatTxName::tx_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity12formatTxNameEPKc", "priority": 1, "content": "Expected &lt; std :: string &gt;  formatTxName const  char  * tx_name Given a name for a transmitter to be connected to the codelet, return a formatted string back which can be used for a new transmitter component creation. If the codelet\u2019s tx parameter is a scalar, the tx name is the same as the parameter key. If the codelet\u2019s tx parameter is a vector, the tx name would be \u201ckey_0\u201d, \u201ckey_1\u201d \u2026 Parameters tx_name \u2013 name of transmitter component Returns Expected&lt;std::string&gt; formatted name of transmitter component", "keywords": []}, {"id": 412, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::getReceiver", "display_name": "nvidia::gxf::GraphEntity::getReceiver", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11getReceiverEPKc", "priority": 1, "content": "Handle &lt; Receiver &gt;  getReceiver const  char  * name Receiver component lookup using name Parameters name \u2013 name of a receiver component which has been previously created Returns Handle to the receiver component if found, Null handle if no such component.", "keywords": []}, {"id": 413, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::getReceiver::name", "display_name": "nvidia::gxf::GraphEntity::getReceiver::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11getReceiverEPKc", "priority": 1, "content": "Handle &lt; Receiver &gt;  getReceiver const  char  * name Receiver component lookup using name Parameters name \u2013 name of a receiver component which has been previously created Returns Handle to the receiver component if found, Null handle if no such component.", "keywords": []}, {"id": 414, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::get_codelet", "display_name": "nvidia::gxf::GraphEntity::get_codelet", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity11get_codeletEv", "priority": 1, "content": "Handle &lt; Codelet &gt;  get_codelet Get the Codelet associated with the GraphEntity Returns Handle&lt;Codelet&gt; The Codelet associated with the GraphEntity, or Null handle if none is set.", "keywords": []}, {"id": 415, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::is_null", "display_name": "nvidia::gxf::GraphEntity::is_null", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity7is_nullEv", "priority": 1, "content": "bool  is_null  const Check if the GraphEntity is null Returns bool True if the GraphEntity is null, false otherwise", "keywords": []}, {"id": 416, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::name", "display_name": "nvidia::gxf::GraphEntity::name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity4nameEv", "priority": 1, "content": "const  char  * name  const Get the name of the entity or an empty string if no name has been given to the entity. Returns const char* A pointer to the name of the entity.", "keywords": []}, {"id": 417, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name  =  nullptr Args ...  args Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component. Parameters name \u2013 Name of the component args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 418, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcNSt6vectorI3ArgEE", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name std :: vector &lt; Arg &gt;  arg_list Creates a generic component of type T and sets the parameter values from arg_list. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component Parameters name \u2013 Name of the component arg_list \u2013 vector of Arg used for initializing the component\u2019s parameters. Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 419, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name  =  nullptr Args ...  args Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component. Parameters name \u2013 Name of the component args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 420, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name  =  nullptr Args ...  args Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component. Parameters name \u2013 Name of the component args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 421, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcNSt6vectorI3ArgEE", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name std :: vector &lt; Arg &gt;  arg_list Creates a generic component of type T and sets the parameter values from arg_list. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component Parameters name \u2013 Name of the component arg_list \u2013 vector of Arg used for initializing the component\u2019s parameters. Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 422, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcNSt6vectorI3ArgEE", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name std :: vector &lt; Arg &gt;  arg_list Creates a generic component of type T and sets the parameter values from arg_list. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component Parameters name \u2013 Name of the component arg_list \u2013 vector of Arg used for initializing the component\u2019s parameters. Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 423, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name  =  nullptr Args ...  args Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component. Parameters name \u2013 Name of the component args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 424, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name  =  nullptr Args ...  args Creates a generic component of type T and sets the parameter values from Args pack of args. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component. Parameters name \u2013 Name of the component args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 425, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::add::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3addE6HandleI1TEPKcNSt6vectorI3ArgEE", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: add const  char  * name std :: vector &lt; Arg &gt;  arg_list Creates a generic component of type T and sets the parameter values from arg_list. Transmitters, Receivers, Clocks and Scheduling Term component names have to be unique. Type T must be derived from nvidia::gxf::Component Parameters name \u2013 Name of the component arg_list \u2013 vector of Arg used for initializing the component\u2019s parameters. Returns Handle&lt;T&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 426, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * name  =  nullptr Args ...  args Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::Clock Parameters name \u2013 Name of the clock args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 427, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a clock component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the clock name \u2013 Name of the clock arg_list \u2013 Arguments for the clock component Returns Handle&lt;Clock&gt; Handle to newly created clock", "keywords": []}, {"id": 428, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * name  =  nullptr Args ...  args Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::Clock Parameters name \u2013 Name of the clock args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 429, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * name  =  nullptr Args ...  args Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::Clock Parameters name \u2013 Name of the clock args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 430, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a clock component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the clock name \u2013 Name of the clock arg_list \u2013 Arguments for the clock component Returns Handle&lt;Clock&gt; Handle to newly created clock", "keywords": []}, {"id": 431, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * name  =  nullptr Args ...  args Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::Clock Parameters name \u2013 Name of the clock args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 432, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * name  =  nullptr Args ...  args Adds a component of Clock type T and sets the parameter values from Args. T must be derived from nvidia::gxf::Clock Parameters name \u2013 Name of the clock args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 433, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a clock component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the clock name \u2013 Name of the clock arg_list \u2013 Arguments for the clock component Returns Handle&lt;Clock&gt; Handle to newly created clock", "keywords": []}, {"id": 434, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addClock::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8addClockEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: addClock const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a clock component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the clock name \u2013 Name of the clock arg_list \u2013 Arguments for the clock component Returns Handle&lt;Clock&gt; Handle to newly created clock", "keywords": []}, {"id": 435, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * name  =  nullptr Args ...  args Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet. Parameters name \u2013 Name of the codelet args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created codelet. Null handle if component was not created.", "keywords": []}, {"id": 436, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Codelet &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a codelet with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the codelet component name \u2013 Name of the codelet arg_list \u2013 Arguments for the codelet Returns Handle&lt;Codelet&gt; Handle to newly created codelet component. Null handle if component was not created.", "keywords": []}, {"id": 437, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * name  =  nullptr Args ...  args Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet. Parameters name \u2013 Name of the codelet args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created codelet. Null handle if component was not created.", "keywords": []}, {"id": 438, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * name  =  nullptr Args ...  args Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet. Parameters name \u2013 Name of the codelet args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created codelet. Null handle if component was not created.", "keywords": []}, {"id": 439, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Codelet &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a codelet with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the codelet component name \u2013 Name of the codelet arg_list \u2013 Arguments for the codelet Returns Handle&lt;Codelet&gt; Handle to newly created codelet component. Null handle if component was not created.", "keywords": []}, {"id": 440, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * name  =  nullptr Args ...  args Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet. Parameters name \u2013 Name of the codelet args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created codelet. Null handle if component was not created.", "keywords": []}, {"id": 441, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * name  =  nullptr Args ...  args Adds a codelet of type T with given name and sets the parameter values from Args. T must be derived from nvidia::gxf::Codelet. Parameters name \u2013 Name of the codelet args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created codelet. Null handle if component was not created.", "keywords": []}, {"id": 442, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Codelet &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a codelet with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the codelet component name \u2013 Name of the codelet arg_list \u2013 Arguments for the codelet Returns Handle&lt;Codelet&gt; Handle to newly created codelet component. Null handle if component was not created.", "keywords": []}, {"id": 443, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addCodelet::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity10addCodeletEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Codelet &gt;  nvidia :: gxf :: GraphEntity :: addCodelet const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a codelet with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the codelet component name \u2013 Name of the codelet arg_list \u2013 Arguments for the codelet Returns Handle&lt;Codelet&gt; Handle to newly created codelet component. Null handle if component was not created.", "keywords": []}, {"id": 444, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity12addComponentEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: addComponent const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the component name \u2013 Name of the component arg_list \u2013 Arguments for the component Returns Handle&lt;Component&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 445, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity12addComponentEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: addComponent const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the component name \u2013 Name of the component arg_list \u2013 Arguments for the component Returns Handle&lt;Component&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 446, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity12addComponentEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: addComponent const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the component name \u2013 Name of the component arg_list \u2013 Arguments for the component Returns Handle&lt;Component&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 447, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addComponent::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity12addComponentEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: addComponent const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the component name \u2013 Name of the component arg_list \u2013 Arguments for the component Returns Handle&lt;Component&gt; Handle to newly created component. Null handle if component was not created.", "keywords": []}, {"id": 448, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 449, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 450, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 451, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 452, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 453, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::omit_term", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addReceiver::omit_term", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity11addReceiverE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addReceiver const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Receiver type T with name and sets the parameter values from Args. Name of the receiver should match the parameter name of the underlying codelet. The name of the receiver component is updated based on the parameter rank info. A Message available scheduling term is also added to monitor the receiver component. If codelet parameter is a scalar, name of the receiver is also same as the parameter key. Parameter&lt;Handle&lt;Receiver&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the receiver component is key_%d where \u2018d\u2019 is the index of this receiver in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Receiver&gt;&gt; | name - \u201c Type T must be derived from nvidia::gxf::Receiver. Parameters name \u2013 Name of the receiver component. omit_term \u2013 Boolean flag controlling whether or not a default message available scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created receiver component", "keywords": []}, {"id": 454, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * name  =  nullptr Args ...  args Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm. Parameters name \u2013 name of the scheduling term args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created scheduling term component", "keywords": []}, {"id": 455, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; SchedulingTerm &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a scheduling term component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the scheduling term name \u2013 Name of the scheduling term arg_list \u2013 Arguments for the scheduling term component Returns Handle&lt;SchedulingTerm&gt; Handle to newly created scheduling term", "keywords": []}, {"id": 456, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * name  =  nullptr Args ...  args Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm. Parameters name \u2013 name of the scheduling term args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created scheduling term component", "keywords": []}, {"id": 457, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * name  =  nullptr Args ...  args Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm. Parameters name \u2013 name of the scheduling term args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created scheduling term component", "keywords": []}, {"id": 458, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; SchedulingTerm &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a scheduling term component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the scheduling term name \u2013 Name of the scheduling term arg_list \u2013 Arguments for the scheduling term component Returns Handle&lt;SchedulingTerm&gt; Handle to newly created scheduling term", "keywords": []}, {"id": 459, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * name  =  nullptr Args ...  args Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm. Parameters name \u2013 name of the scheduling term args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created scheduling term component", "keywords": []}, {"id": 460, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermE6HandleI1TEPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * name  =  nullptr Args ...  args Adds a component of SchedulingTerm type T and sets the parameter values from Args. T must be derived from nvidia::gxf::SchedulingTerm. Parameters name \u2013 name of the scheduling term args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created scheduling term component", "keywords": []}, {"id": 461, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; SchedulingTerm &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a scheduling term component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the scheduling term name \u2013 Name of the scheduling term arg_list \u2013 Arguments for the scheduling term component Returns Handle&lt;SchedulingTerm&gt; Handle to newly created scheduling term", "keywords": []}, {"id": 462, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addSchedulingTerm::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity17addSchedulingTermEPKcPKcRKNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; SchedulingTerm &gt;  nvidia :: gxf :: GraphEntity :: addSchedulingTerm const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } Adds a scheduling term component with a given C++ type name. Parameters type_name \u2013 The fully qualified C++ type name of the scheduling term name \u2013 Name of the scheduling term arg_list \u2013 Arguments for the scheduling term component Returns Handle&lt;SchedulingTerm&gt; Handle to newly created scheduling term", "keywords": []}, {"id": 463, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 464, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Transmitter of the corresponding type_name. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the transmitter component name \u2013 Name of the transmitter component arg_list \u2013 Arguments for the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Transmitter&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 465, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::Args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 466, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 467, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::arg_list", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Transmitter of the corresponding type_name. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the transmitter component name \u2013 Name of the transmitter component arg_list \u2013 Arguments for the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Transmitter&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 468, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::args", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 469, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 470, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Transmitter of the corresponding type_name. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the transmitter component name \u2013 Name of the transmitter component arg_list \u2013 Arguments for the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Transmitter&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 471, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::omit_term", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::omit_term", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterE6HandleI1TEPKcbDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * name bool  omit_term  =  false Args ...  args Adds a component of Transmitter type T with name and sets the parameter values from Args. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Type T must be derived from nvidia::gxf::Transmitter. Parameters name \u2013 Name of the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. args \u2013 Args must be of type Arg Returns Handle&lt;T&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 472, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::omit_term", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::omit_term", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Transmitter of the corresponding type_name. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the transmitter component name \u2013 Name of the transmitter component arg_list \u2013 Arguments for the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Transmitter&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 473, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::addTransmitter::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14addTransmitterEPKcPKcRKNSt6vectorI3ArgEEb", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: addTransmitter const  char  * type_name const  char  * name  =  nullptr const  std :: vector &lt; Arg &gt;  &amp; arg_list  =  { } bool  omit_term  =  false Adds a component of Transmitter of the corresponding type_name. Name of the transmitter should match the parameter name of the underlying codelet. The name of the transmitter component is updated based on the parameter rank info. A Downstream receptive scheduling term is also added to monitor the transmitter component. If codelet parameter is a scalar, name of the transmitter is also same as the parameter key. Parameter&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey\u201d If codelet parameter is a vector/array, the name of the transmitter component is key_%d where \u2018d\u2019 is the index of this transmitter in the codelet parameter. Parameter&lt;Vector&lt;Handle&lt;Transmitter&gt;&gt; | name - \u201ckey_0\u201d, \u201ckey_1\u201d, \u201ckey_2\u201d Parameters type_name \u2013 The fully qualified C++ type name of the transmitter component name \u2013 Name of the transmitter component arg_list \u2013 Arguments for the transmitter component omit_term \u2013 Boolean flag controlling whether or not a default downstream receptive scheduling term is added. If true, no scheduling term is added. Returns Handle&lt;Transmitter&gt; Handle to newly created transmitter component", "keywords": []}, {"id": 474, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7findAllE11FixedVectorI6HandleI1TE1NEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt;  nvidia :: gxf :: GraphEntity :: findAll  const Finds all components of given type. Returns an empty vector if component is not found. Type T is a type of component to search for. Parameters N \u2013 Maximum number of components to return Returns FixedVector&lt;Handle&lt;T&gt;, N&gt; List of handles to components of the same type", "keywords": []}, {"id": 475, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll::N", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll::N", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7findAllE11FixedVectorI6HandleI1TE1NEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt;  nvidia :: gxf :: GraphEntity :: findAll  const Finds all components of given type. Returns an empty vector if component is not found. Type T is a type of component to search for. Parameters N \u2013 Maximum number of components to return Returns FixedVector&lt;Handle&lt;T&gt;, N&gt; List of handles to components of the same type", "keywords": []}, {"id": 476, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::findAll::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7findAllE11FixedVectorI6HandleI1TE1NEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt;  nvidia :: gxf :: GraphEntity :: findAll  const Finds all components of given type. Returns an empty vector if component is not found. Type T is a type of component to search for. Parameters N \u2013 Maximum number of components to return Returns FixedVector&lt;Handle&lt;T&gt;, N&gt; List of handles to components of the same type", "keywords": []}, {"id": 477, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getE6HandleI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Handle&lt;T&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 478, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getEPKcPKc", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * type_name const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Handle&lt;Component&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 479, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getE6HandleI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Handle&lt;T&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 480, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getE6HandleI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Handle &lt; T &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Handle&lt;T&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 481, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getEPKcPKc", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * type_name const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Handle&lt;Component&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 482, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::get::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity3getEPKcPKc", "priority": 1, "content": "Handle &lt; Component &gt;  nvidia :: gxf :: GraphEntity :: get const  char  * type_name const  char  * name  =  nullptr  const Gets a component by type and name. Returns null handle if no such component. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Handle&lt;Component&gt; Handle to component, if component is found. Null handle if no such component.", "keywords": []}, {"id": 483, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getClock", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getClock", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8getClockEPKc", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: getClock const  char  * name  =  nullptr Get the Clock object from a graph entity. Returns null handle if no clock component has been created yet. Returns the first clock if no component name is provided. If name is provided, exact instance of the clock is returned if found else a Null handle. Parameters name \u2013 Name of the clock component to lookup Returns Handle&lt;Clock&gt;", "keywords": []}, {"id": 484, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getClock::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getClock::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity8getClockEPKc", "priority": 1, "content": "Handle &lt; Clock &gt;  nvidia :: gxf :: GraphEntity :: getClock const  char  * name  =  nullptr Get the Clock object from a graph entity. Returns null handle if no clock component has been created yet. Returns the first clock if no component name is provided. If name is provided, exact instance of the clock is returned if found else a Null handle. Parameters name \u2013 Name of the clock component to lookup Returns Handle&lt;Clock&gt;", "keywords": []}, {"id": 485, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getTransmitter", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getTransmitter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14getTransmitterEPKc", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: getTransmitter const  char  * name Receiver component lookup using name Parameters name \u2013 name of a transmitter component which has been previously created Returns Handle&lt;Transmitter&gt; Handle to transmitter component if found, Null handle if no such component.", "keywords": []}, {"id": 486, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getTransmitter::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::getTransmitter::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity14getTransmitterEPKc", "priority": 1, "content": "Handle &lt; Transmitter &gt;  nvidia :: gxf :: GraphEntity :: getTransmitter const  char  * name Receiver component lookup using name Parameters name \u2013 name of a transmitter component which has been previously created Returns Handle&lt;Transmitter&gt; Handle to transmitter component if found, Null handle if no such component.", "keywords": []}, {"id": 487, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity5setupE13gxf_context_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: GraphEntity :: setup gxf_context_t  context const  char  * name Creates a programmable entity with the runtime context and sets its name. Parameters context \u2013 A valid GXF context name \u2013 Name of the graph entity Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 488, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup::context", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity5setupE13gxf_context_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: GraphEntity :: setup gxf_context_t  context const  char  * name Creates a programmable entity with the runtime context and sets its name. Parameters context \u2013 A valid GXF context name \u2013 Name of the graph entity Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 489, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::setup::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity5setupE13gxf_context_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: GraphEntity :: setup gxf_context_t  context const  char  * name Creates a programmable entity with the runtime context and sets its name. Parameters context \u2013 A valid GXF context name \u2013 Name of the graph entity Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 490, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 491, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * type_name const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 492, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 493, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::T", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * type_name const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 494, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 495, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * type_name const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 496, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::type_name", "display_name": "nvidia::gxf::GraphEntity::nvidia::gxf::GraphEntity::try_get::type_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf11GraphEntity6nvidia3gxf11GraphEntity7try_getE8ExpectedI6HandleI1TEEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  nvidia :: gxf :: GraphEntity :: try_get const  char  * type_name const  char  * name  =  nullptr  const Get a component by type and name. Returns an Unexpected in the case that the component is not found. Unlike get no error is logged if a component is not found. Type T is a type of component to search for. Parameters type_name \u2013 Fully qualified C++ type name of the component to search for name \u2013 Name of the component to look for Returns Expected&lt;Handle&lt;Component&gt;&gt; Handle to the component, if component is found. Otherwise, an Unexpected is returned.", "keywords": []}, {"id": 497, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::updatePort", "display_name": "nvidia::gxf::GraphEntity::updatePort", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity10updatePortEPKcNSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  updatePort const  char  * key std :: string  value Update the port with the given key and value. Parameters key \u2013 The key of the port to update value \u2013 The new value of the port Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 498, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::updatePort::key", "display_name": "nvidia::gxf::GraphEntity::updatePort::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity10updatePortEPKcNSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  updatePort const  char  * key std :: string  value Update the port with the given key and value. Parameters key \u2013 The key of the port to update value \u2013 The new value of the port Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 499, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::GraphEntity::updatePort::value", "display_name": "nvidia::gxf::GraphEntity::updatePort::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11GraphEntity10updatePortEPKcNSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  updatePort const  char  * key std :: string  value Update the port with the given key and value. Parameters key \u2013 The key of the port to update value \u2013 The new value of the port Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 500, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair", "display_name": "nvidia::gxf::PortPair", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPairE", "priority": 1, "content": "struct  nvidia :: gxf :: PortPair A entity - entity connection specified using tx and rx component names tx - transmitter component name rx - receiver component name The queue names should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connection between the two graph entities.", "keywords": []}, {"id": 501, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::PortPair", "display_name": "nvidia::gxf::PortPair::PortPair", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPair8PortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "PortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a PortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 502, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::PortPair::source", "display_name": "nvidia::gxf::PortPair::PortPair::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPair8PortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "PortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a PortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 503, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::PortPair::target", "display_name": "nvidia::gxf::PortPair::PortPair::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPair8PortPairERK11SegmentPortRK11SegmentPort", "priority": 1, "content": "PortPair const  SegmentPort  &amp; source const  SegmentPort  &amp; target Constructor for a PortPair with the given source and target SegmentPorts.", "keywords": []}, {"id": 504, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::getSource", "display_name": "nvidia::gxf::PortPair::getSource", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf8PortPair9getSourceEv", "priority": 1, "content": "SegmentPort  getSource  const Returns the source SegmentPort in the connection.", "keywords": []}, {"id": 505, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::getTarget", "display_name": "nvidia::gxf::PortPair::getTarget", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf8PortPair9getTargetEv", "priority": 1, "content": "SegmentPort  getTarget  const Returns the target SegmentPort in the connection.", "keywords": []}, {"id": 506, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::source", "display_name": "nvidia::gxf::PortPair::source", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPair6sourceE", "priority": 1, "content": "SegmentPort  source The source SegmentPort in the connection.", "keywords": []}, {"id": 507, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::PortPair::target", "display_name": "nvidia::gxf::PortPair::target", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8PortPair6targetE", "priority": 1, "content": "SegmentPort  target The target SegmentPort in the connection.", "keywords": []}, {"id": 508, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType", "display_name": "nvidia::gxf::SchedulerType", "type": "enum", "display_type": "C++ enum", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerTypeE", "priority": 1, "content": "enum  nvidia :: gxf :: SchedulerType Enum representing the type of scheduler to be used in the application. This enum is primarily used as an input to setScheduler api.", "keywords": []}, {"id": 509, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::EventBased", "display_name": "nvidia::gxf::SchedulerType::EventBased", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType10EventBasedE", "priority": 1, "content": "constexpr  const  SchedulerType  EventBased  =  SchedulerType :: KEventBased", "keywords": []}, {"id": 510, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::Greedy", "display_name": "nvidia::gxf::SchedulerType::Greedy", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType6GreedyE", "priority": 1, "content": "constexpr  const  SchedulerType  Greedy  =  SchedulerType :: kGreedy", "keywords": []}, {"id": 511, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::MultiThread", "display_name": "nvidia::gxf::SchedulerType::MultiThread", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType11MultiThreadE", "priority": 1, "content": "constexpr  const  SchedulerType  MultiThread  =  SchedulerType :: kMultiThread", "keywords": []}, {"id": 512, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::SchedulerType::KEventBased", "display_name": "nvidia::gxf::SchedulerType::SchedulerType::KEventBased", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType13SchedulerType11KEventBasedE", "priority": 1, "content": "enumerator  SchedulerType :: KEventBased A scheduler that uses an event-based model to schedule entities. SchedulerType Enumeration Constants", "keywords": []}, {"id": 513, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::SchedulerType::kGreedy", "display_name": "nvidia::gxf::SchedulerType::SchedulerType::kGreedy", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType13SchedulerType7kGreedyE", "priority": 1, "content": "enumerator  SchedulerType :: kGreedy A single threaded scheduler that assigns resources to entities in a greedy manner, without considering fairness or priorities.", "keywords": []}, {"id": 514, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulerType::SchedulerType::kMultiThread", "display_name": "nvidia::gxf::SchedulerType::SchedulerType::kMultiThread", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13SchedulerType13SchedulerType12kMultiThreadE", "priority": 1, "content": "enumerator  SchedulerType :: kMultiThread A scheduler that uses multiple threads to execute entities concurrently.", "keywords": []}, {"id": 515, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment", "display_name": "nvidia::gxf::Segment", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7SegmentE", "priority": 1, "content": "class  nvidia :: gxf :: Segment Segment is a group of graph entities created in a single GXF runtime context. A segment will have its own scheduler. Graph entities in a segment are connected with each other via double buffer transmitter and receiver components. A segment can also be connected other segments via ucx transmitters and receivers. Segments are created and managed by the :cpp:class:: nvidia::gxf::Application class.", "keywords": []}, {"id": 516, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::Segment", "display_name": "nvidia::gxf::Segment::Segment", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7SegmentERR7Segment", "priority": 1, "content": "Segment Segment &amp; &amp;  =  default Default move constructor.", "keywords": []}, {"id": 517, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::Segment", "display_name": "nvidia::gxf::Segment::Segment", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7SegmentEv", "priority": 1, "content": "Segment Default constructor.", "keywords": []}, {"id": 518, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::activate", "display_name": "nvidia::gxf::Segment::activate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment8activateEv", "priority": 1, "content": "Expected &lt; void &gt;  activate Activates all the graph entities in the segment. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 519, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::compose", "display_name": "nvidia::gxf::Segment::compose", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7composeEv", "priority": 1, "content": "void  compose A virtual function that is called to compose the segment. This function is where the entities are created, connected and configured.", "keywords": []}, {"id": 520, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect", "display_name": "nvidia::gxf::Segment::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target Adds a double buffer queue based connection between two entities with 1:1 tx and rx connectivity. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 521, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect", "display_name": "nvidia::gxf::Segment::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr8PortPair", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target PortPair  port_pair Adds a single double buffer queue based connection between two entities with a port pair specified. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. PortPair port_pair \u2013 The port pair containing information of the connection to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 522, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect::port_pair", "display_name": "nvidia::gxf::Segment::connect::port_pair", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr8PortPair", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target PortPair  port_pair Adds a single double buffer queue based connection between two entities with a port pair specified. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. PortPair port_pair \u2013 The port pair containing information of the connection to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 523, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect::source", "display_name": "nvidia::gxf::Segment::connect::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target Adds a double buffer queue based connection between two entities with 1:1 tx and rx connectivity. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 524, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect::source", "display_name": "nvidia::gxf::Segment::connect::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr8PortPair", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target PortPair  port_pair Adds a single double buffer queue based connection between two entities with a port pair specified. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. PortPair port_pair \u2013 The port pair containing information of the connection to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 525, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect::target", "display_name": "nvidia::gxf::Segment::connect::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target Adds a double buffer queue based connection between two entities with 1:1 tx and rx connectivity. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 526, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::connect::target", "display_name": "nvidia::gxf::Segment::connect::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtr8PortPair", "priority": 1, "content": "Expected &lt; void &gt;  connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target PortPair  port_pair Adds a single double buffer queue based connection between two entities with a port pair specified. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. PortPair port_pair \u2013 The port pair containing information of the connection to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 527, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::context", "display_name": "nvidia::gxf::Segment::context", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7contextEv", "priority": 1, "content": "gxf_context_t  context Fetch the context of a segment. Returns The context of the segment as a gxf_context_t.", "keywords": []}, {"id": 528, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::createFromProxy", "display_name": "nvidia::gxf::Segment::createFromProxy", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment15createFromProxyER14ProxyComponentR14GraphEntityPtr", "priority": 1, "content": "Handle &lt; Component &gt;  createFromProxy ProxyComponent  &amp; component GraphEntityPtr  &amp; entity Creates a component in graph entity based on the type information from the ProxyComponent Parameters ProxyComponent&amp; component \u2013 A proxy component object GraphEntityPtr&amp; entity \u2013 A pointer to graph entity to be used for creating the component Returns Handle&lt;Component&gt; Handle to newly created component or null handle on failure", "keywords": []}, {"id": 529, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::createFromProxy::component", "display_name": "nvidia::gxf::Segment::createFromProxy::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment15createFromProxyER14ProxyComponentR14GraphEntityPtr", "priority": 1, "content": "Handle &lt; Component &gt;  createFromProxy ProxyComponent  &amp; component GraphEntityPtr  &amp; entity Creates a component in graph entity based on the type information from the ProxyComponent Parameters ProxyComponent&amp; component \u2013 A proxy component object GraphEntityPtr&amp; entity \u2013 A pointer to graph entity to be used for creating the component Returns Handle&lt;Component&gt; Handle to newly created component or null handle on failure", "keywords": []}, {"id": 530, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::createFromProxy::entity", "display_name": "nvidia::gxf::Segment::createFromProxy::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment15createFromProxyER14ProxyComponentR14GraphEntityPtr", "priority": 1, "content": "Handle &lt; Component &gt;  createFromProxy ProxyComponent  &amp; component GraphEntityPtr  &amp; entity Creates a component in graph entity based on the type information from the ProxyComponent Parameters ProxyComponent&amp; component \u2013 A proxy component object GraphEntityPtr&amp; entity \u2013 A pointer to graph entity to be used for creating the component Returns Handle&lt;Component&gt; Handle to newly created component or null handle on failure", "keywords": []}, {"id": 531, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::createNetworkContext", "display_name": "nvidia::gxf::Segment::createNetworkContext", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment20createNetworkContextEv", "priority": 1, "content": "Expected &lt; void &gt;  createNetworkContext Creates a Network Context in the segment which can be used by UCX Connections added in the application. A new graph entity with the name \u201cNetworkContext\u201d will be added to the segment context with a UcxContext component and a corresponding entity and component serializers Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 532, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::deactivate", "display_name": "nvidia::gxf::Segment::deactivate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment10deactivateEv", "priority": 1, "content": "Expected &lt; void &gt;  deactivate Deactivates all the graph entities in the segment. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 533, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::interrupt", "display_name": "nvidia::gxf::Segment::interrupt", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment9interruptEv", "priority": 1, "content": "Expected &lt; void &gt;  interrupt A non blocking api to stop a previously running segment. Segment is not guaranteed to have stopped when this api returns. wait() can be used to wait until the execution has finished. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 534, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::loadParameterFile", "display_name": "nvidia::gxf::Segment::loadParameterFile", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment17loadParameterFileEPKc", "priority": 1, "content": "Expected &lt; void &gt;  loadParameterFile const  char  * filepath Loads parameters for graph entities composed in the segment / application. YAML file follows the GXF graph specification. Parameters const char* filepath \u2013 path to a valid parameters file Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 535, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::loadParameterFile::filepath", "display_name": "nvidia::gxf::Segment::loadParameterFile::filepath", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment17loadParameterFileEPKc", "priority": 1, "content": "Expected &lt; void &gt;  loadParameterFile const  char  * filepath Loads parameters for graph entities composed in the segment / application. YAML file follows the GXF graph specification. Parameters const char* filepath \u2013 path to a valid parameters file Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 536, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity", "display_name": "nvidia::gxf::Segment::makeEntity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  CodeletT ,  typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg &amp; ProxyComponent. The codelet component will be used to auto populate connection queues and their corresponding scheduling terms. Args can be used to specify a variable list of components to be created along with the codelet in the graph entity. Args can also be used to specify a variable list of Arg type to update any parameter values of the codelet Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 537, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity", "display_name": "nvidia::gxf::Segment::makeEntity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity without a codelet and with a parameter pack of Arg &amp; ProxyComponent. Args can be used to specify a variable list of components to be created along with the graph entity. Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 538, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::Args", "display_name": "nvidia::gxf::Segment::makeEntity::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  CodeletT ,  typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg &amp; ProxyComponent. The codelet component will be used to auto populate connection queues and their corresponding scheduling terms. Args can be used to specify a variable list of components to be created along with the codelet in the graph entity. Args can also be used to specify a variable list of Arg type to update any parameter values of the codelet Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 539, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::Args", "display_name": "nvidia::gxf::Segment::makeEntity::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity without a codelet and with a parameter pack of Arg &amp; ProxyComponent. Args can be used to specify a variable list of components to be created along with the graph entity. Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 540, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::CodeletT", "display_name": "nvidia::gxf::Segment::makeEntity::CodeletT", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  CodeletT ,  typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg &amp; ProxyComponent. The codelet component will be used to auto populate connection queues and their corresponding scheduling terms. Args can be used to specify a variable list of components to be created along with the codelet in the graph entity. Args can also be used to specify a variable list of Arg type to update any parameter values of the codelet Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 541, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::args", "display_name": "nvidia::gxf::Segment::makeEntity::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  CodeletT ,  typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg &amp; ProxyComponent. The codelet component will be used to auto populate connection queues and their corresponding scheduling terms. Args can be used to specify a variable list of components to be created along with the codelet in the graph entity. Args can also be used to specify a variable list of Arg type to update any parameter values of the codelet Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 542, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::args", "display_name": "nvidia::gxf::Segment::makeEntity::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity without a codelet and with a parameter pack of Arg &amp; ProxyComponent. Args can be used to specify a variable list of components to be created along with the graph entity. Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 543, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::name", "display_name": "nvidia::gxf::Segment::makeEntity::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  CodeletT ,  typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity with a codelet of type CodeletT along with a parameter pack of Arg &amp; ProxyComponent. The codelet component will be used to auto populate connection queues and their corresponding scheduling terms. Args can be used to specify a variable list of components to be created along with the codelet in the graph entity. Args can also be used to specify a variable list of Arg type to update any parameter values of the codelet Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 544, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeEntity::name", "display_name": "nvidia::gxf::Segment::makeEntity::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4IDpEN6nvidia3gxf7Segment10makeEntityE14GraphEntityPtrPKcDp4Args", "priority": 1, "content": "template &lt; typename  ... Args &gt; GraphEntityPtr  makeEntity const  char  * name Args ...  args Creates a graph entity without a codelet and with a parameter pack of Arg &amp; ProxyComponent. Args can be used to specify a variable list of components to be created along with the graph entity. Parameters const char* name \u2013 The name of the graph entity. Args... args \u2013 A parameter pack of Arg or ProxyComponent objects. Returns A newly created graph entity object with the requested components.", "keywords": []}, {"id": 545, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeResource", "display_name": "nvidia::gxf::Segment::makeResource", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment12makeResourceE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeResource const  char  * name Args ...  args Creates a resource of requested type and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this resource. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 546, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeResource::Args", "display_name": "nvidia::gxf::Segment::makeResource::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment12makeResourceE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeResource const  char  * name Args ...  args Creates a resource of requested type and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this resource. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 547, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeResource::T", "display_name": "nvidia::gxf::Segment::makeResource::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment12makeResourceE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeResource const  char  * name Args ...  args Creates a resource of requested type and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this resource. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 548, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeResource::args", "display_name": "nvidia::gxf::Segment::makeResource::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment12makeResourceE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeResource const  char  * name Args ...  args Creates a resource of requested type and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this resource. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 549, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeResource::name", "display_name": "nvidia::gxf::Segment::makeResource::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment12makeResourceE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeResource const  char  * name Args ...  args Creates a resource of requested type and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this resource. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::ResourceBase type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 550, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeTerm", "display_name": "nvidia::gxf::Segment::makeTerm", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8makeTermE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeTerm const  char  * name Args ...  args Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this scheduling term. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 551, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeTerm::Args", "display_name": "nvidia::gxf::Segment::makeTerm::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8makeTermE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeTerm const  char  * name Args ...  args Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this scheduling term. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 552, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeTerm::T", "display_name": "nvidia::gxf::Segment::makeTerm::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8makeTermE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeTerm const  char  * name Args ...  args Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this scheduling term. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 553, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeTerm::args", "display_name": "nvidia::gxf::Segment::makeTerm::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8makeTermE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeTerm const  char  * name Args ...  args Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this scheduling term. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 554, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::makeTerm::name", "display_name": "nvidia::gxf::Segment::makeTerm::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8makeTermE14ProxyComponentPKcDp4Args", "priority": 1, "content": "template &lt; typename  T ,  typename  ... Args &gt; ProxyComponent  makeTerm const  char  * name Args ...  args Creates a scheduling term of requested type T and applies parameter component values from a parameter pack of arguments. This api does not create the requested gxf native component. A Proxy component value is returned which has the type info and arg list needed to create this scheduling term. createFromProxy() api is used to create this component given any specific GraphEntity. Type T must be derived from nvidia::gxf::SchedulingTerm type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the component. Returns A ProxyComponent object.", "keywords": []}, {"id": 555, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::name", "display_name": "nvidia::gxf::Segment::name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf7Segment4nameEv", "priority": 1, "content": "const  char  * name  const Fetch the name of the segment. Returns The name of the segment as a const char*.", "keywords": []}, {"id": 556, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect", "display_name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtrNSt6vectorI8PortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: Segment :: connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target std :: vector &lt; PortPair &gt;  port_pairs Adds multiple double buffer queue based connections between two entities with many : many tx and rx. Connections between two graph entities are created sequentially. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. std::vector&lt;PortPair&gt; port_pairs \u2013 The list of port pairs containing information of the connections to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 557, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::port_pairs", "display_name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::port_pairs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtrNSt6vectorI8PortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: Segment :: connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target std :: vector &lt; PortPair &gt;  port_pairs Adds multiple double buffer queue based connections between two entities with many : many tx and rx. Connections between two graph entities are created sequentially. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. std::vector&lt;PortPair&gt; port_pairs \u2013 The list of port pairs containing information of the connections to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 558, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::source", "display_name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtrNSt6vectorI8PortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: Segment :: connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target std :: vector &lt; PortPair &gt;  port_pairs Adds multiple double buffer queue based connections between two entities with many : many tx and rx. Connections between two graph entities are created sequentially. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. std::vector&lt;PortPair&gt; port_pairs \u2013 The list of port pairs containing information of the connections to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 559, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::target", "display_name": "nvidia::gxf::Segment::nvidia::gxf::Segment::connect::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment6nvidia3gxf7Segment7connectER14GraphEntityPtrR14GraphEntityPtrNSt6vectorI8PortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  nvidia :: gxf :: Segment :: connect GraphEntityPtr  &amp; source GraphEntityPtr  &amp; target std :: vector &lt; PortPair &gt;  port_pairs Adds multiple double buffer queue based connections between two entities with many : many tx and rx. Connections between two graph entities are created sequentially. Parameters GraphEntityPtr&amp; source \u2013 The origin graph entity for the connection. GraphEntityPtr&amp; target \u2013 The destination graph entity for the connection. std::vector&lt;PortPair&gt; port_pairs \u2013 The list of port pairs containing information of the connections to be created. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 560, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::operator=", "display_name": "nvidia::gxf::Segment::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7SegmentaSERR7Segment", "priority": 1, "content": "Segment  &amp; operator = Segment &amp; &amp;  =  default Default move assignment operator.", "keywords": []}, {"id": 561, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::run", "display_name": "nvidia::gxf::Segment::run", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment3runEv", "priority": 1, "content": "Expected &lt; void &gt;  run A blocking api to run the segment. This thread is blocked (sleeping) until the segment execution is complete. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 562, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::runAsync", "display_name": "nvidia::gxf::Segment::runAsync", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment8runAsyncEv", "priority": 1, "content": "Expected &lt; void &gt;  runAsync A non blocking api to execute a segment. API returns immediately after starting the segment execution. wait() can be used to wait until execution has finished. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 563, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::saveToFile", "display_name": "nvidia::gxf::Segment::saveToFile", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment10saveToFileEPKc", "priority": 1, "content": "Expected &lt; void &gt;  saveToFile const  char  * filepath Saves the segment information containing entities, components and their corresponding parameter values in a yaml representation. Parameters const char* filepath \u2013 path to save the resulting graph yaml file Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 564, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::saveToFile::filepath", "display_name": "nvidia::gxf::Segment::saveToFile::filepath", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment10saveToFileEPKc", "priority": 1, "content": "Expected &lt; void &gt;  saveToFile const  char  * filepath Saves the segment information containing entities, components and their corresponding parameter values in a yaml representation. Parameters const char* filepath \u2013 path to save the resulting graph yaml file Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 565, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setClock", "display_name": "nvidia::gxf::Segment::setClock", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8setClockE6HandleI5ClockEPKcDp4Args", "priority": 1, "content": "template &lt; typename  ClockT ,  typename  ... Args &gt; Handle &lt; Clock &gt;  setClock const  char  * name Args ...  args Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the clock component. Returns Handle&lt;Clock&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 566, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setClock::Args", "display_name": "nvidia::gxf::Segment::setClock::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8setClockE6HandleI5ClockEPKcDp4Args", "priority": 1, "content": "template &lt; typename  ClockT ,  typename  ... Args &gt; Handle &lt; Clock &gt;  setClock const  char  * name Args ...  args Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the clock component. Returns Handle&lt;Clock&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 567, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setClock::ClockT", "display_name": "nvidia::gxf::Segment::setClock::ClockT", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8setClockE6HandleI5ClockEPKcDp4Args", "priority": 1, "content": "template &lt; typename  ClockT ,  typename  ... Args &gt; Handle &lt; Clock &gt;  setClock const  char  * name Args ...  args Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the clock component. Returns Handle&lt;Clock&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 568, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setClock::args", "display_name": "nvidia::gxf::Segment::setClock::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8setClockE6HandleI5ClockEPKcDp4Args", "priority": 1, "content": "template &lt; typename  ClockT ,  typename  ... Args &gt; Handle &lt; Clock &gt;  setClock const  char  * name Args ...  args Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the clock component. Returns Handle&lt;Clock&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 569, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setClock::name", "display_name": "nvidia::gxf::Segment::setClock::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I0DpEN6nvidia3gxf7Segment8setClockE6HandleI5ClockEPKcDp4Args", "priority": 1, "content": "template &lt; typename  ClockT ,  typename  ... Args &gt; Handle &lt; Clock &gt;  setClock const  char  * name Args ...  args Adds a clock component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Clock type. Args is a parameter pack of arguments / parameter values to be applied to the component. Parameters const char* name \u2013 The name of the clock component. Returns Handle&lt;Clock&gt; Handle to newly created clock component. Null handle if component was not created.", "keywords": []}, {"id": 570, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setName", "display_name": "nvidia::gxf::Segment::setName", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7setNameEPKc", "priority": 1, "content": "Expected &lt; void &gt;  setName const  char  * name Sets the name of the segment Parameters const char* name \u2013 A valid name for the segment Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 571, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setName::name", "display_name": "nvidia::gxf::Segment::setName::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment7setNameEPKc", "priority": 1, "content": "Expected &lt; void &gt;  setName const  char  * name Sets the name of the segment Parameters const char* name \u2013 A valid name for the segment Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 572, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler", "display_name": "nvidia::gxf::Segment::setScheduler", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I_13SchedulerTypeDpEN6nvidia3gxf7Segment12setSchedulerE6HandleI9SchedulerEDp4Args", "priority": 1, "content": "template &lt; SchedulerType  schedulerType ,  typename  ... Args &gt; Handle &lt; Scheduler &gt;  setScheduler Args ...  args Adds a scheduler component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Scheduler type. Args is a parameter pack of arguments / parameter values to be applied to the component. Returns Handle&lt;Scheduler&gt; Handle to newly created scheduler component. Null handle if component was not created.", "keywords": []}, {"id": 573, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler", "display_name": "nvidia::gxf::Segment::setScheduler", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment12setSchedulerERK13SchedulerTypeNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Scheduler &gt;  setScheduler const  SchedulerType  &amp; scheduler std :: vector &lt; Arg &gt;  arg_list  =  { } Add a scheduler to the segment based on the input SchedulerType enum. If the segment contains a clock component, the same component will be reused to configure the scheduler. If no clock components are found in the segment, a new RealTimeClock component will be added to the segment. Parameters const SchedulerType&amp; scheduler \u2013 Type of the scheduler to be added. One of kGreedy, kMultithread or kEventBased. std::vector&lt;Arg&gt; arg_list \u2013 A vector of Arg to apply to the component. Returns A Handle to the newly created scheduler component.", "keywords": []}, {"id": 574, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler::Args", "display_name": "nvidia::gxf::Segment::setScheduler::Args", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I_13SchedulerTypeDpEN6nvidia3gxf7Segment12setSchedulerE6HandleI9SchedulerEDp4Args", "priority": 1, "content": "template &lt; SchedulerType  schedulerType ,  typename  ... Args &gt; Handle &lt; Scheduler &gt;  setScheduler Args ...  args Adds a scheduler component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Scheduler type. Args is a parameter pack of arguments / parameter values to be applied to the component. Returns Handle&lt;Scheduler&gt; Handle to newly created scheduler component. Null handle if component was not created.", "keywords": []}, {"id": 575, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler::arg_list", "display_name": "nvidia::gxf::Segment::setScheduler::arg_list", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment12setSchedulerERK13SchedulerTypeNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Scheduler &gt;  setScheduler const  SchedulerType  &amp; scheduler std :: vector &lt; Arg &gt;  arg_list  =  { } Add a scheduler to the segment based on the input SchedulerType enum. If the segment contains a clock component, the same component will be reused to configure the scheduler. If no clock components are found in the segment, a new RealTimeClock component will be added to the segment. Parameters const SchedulerType&amp; scheduler \u2013 Type of the scheduler to be added. One of kGreedy, kMultithread or kEventBased. std::vector&lt;Arg&gt; arg_list \u2013 A vector of Arg to apply to the component. Returns A Handle to the newly created scheduler component.", "keywords": []}, {"id": 576, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler::args", "display_name": "nvidia::gxf::Segment::setScheduler::args", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I_13SchedulerTypeDpEN6nvidia3gxf7Segment12setSchedulerE6HandleI9SchedulerEDp4Args", "priority": 1, "content": "template &lt; SchedulerType  schedulerType ,  typename  ... Args &gt; Handle &lt; Scheduler &gt;  setScheduler Args ...  args Adds a scheduler component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Scheduler type. Args is a parameter pack of arguments / parameter values to be applied to the component. Returns Handle&lt;Scheduler&gt; Handle to newly created scheduler component. Null handle if component was not created.", "keywords": []}, {"id": 577, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler::scheduler", "display_name": "nvidia::gxf::Segment::setScheduler::scheduler", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment12setSchedulerERK13SchedulerTypeNSt6vectorI3ArgEE", "priority": 1, "content": "Handle &lt; Scheduler &gt;  setScheduler const  SchedulerType  &amp; scheduler std :: vector &lt; Arg &gt;  arg_list  =  { } Add a scheduler to the segment based on the input SchedulerType enum. If the segment contains a clock component, the same component will be reused to configure the scheduler. If no clock components are found in the segment, a new RealTimeClock component will be added to the segment. Parameters const SchedulerType&amp; scheduler \u2013 Type of the scheduler to be added. One of kGreedy, kMultithread or kEventBased. std::vector&lt;Arg&gt; arg_list \u2013 A vector of Arg to apply to the component. Returns A Handle to the newly created scheduler component.", "keywords": []}, {"id": 578, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setScheduler::schedulerType", "display_name": "nvidia::gxf::Segment::setScheduler::schedulerType", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I_13SchedulerTypeDpEN6nvidia3gxf7Segment12setSchedulerE6HandleI9SchedulerEDp4Args", "priority": 1, "content": "template &lt; SchedulerType  schedulerType ,  typename  ... Args &gt; Handle &lt; Scheduler &gt;  setScheduler Args ...  args Adds a scheduler component to the segment and applies parameter component values from a parameter pack of arguments. Type T must be derived from nvidia::gxf::Scheduler type. Args is a parameter pack of arguments / parameter values to be applied to the component. Returns Handle&lt;Scheduler&gt; Handle to newly created scheduler component. Null handle if component was not created.", "keywords": []}, {"id": 579, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setSeverity", "display_name": "nvidia::gxf::Segment::setSeverity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment11setSeverityE14gxf_severity_t", "priority": 1, "content": "gxf_result_t  setSeverity gxf_severity_t  severity Sets the severity level of the logs (corresponding to GXF_LOG* logging macros) for a segment Parameters gxf_severity_t severity \u2013 A valid severity level as defined in gxf_severity_t. Logs corresponding to any level &lt;= severity will be logged. Returns gxf_result_t On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 580, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setSeverity::severity", "display_name": "nvidia::gxf::Segment::setSeverity::severity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment11setSeverityE14gxf_severity_t", "priority": 1, "content": "gxf_result_t  setSeverity gxf_severity_t  severity Sets the severity level of the logs (corresponding to GXF_LOG* logging macros) for a segment Parameters gxf_severity_t severity \u2013 A valid severity level as defined in gxf_severity_t. Logs corresponding to any level &lt;= severity will be logged. Returns gxf_result_t On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 581, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setup", "display_name": "nvidia::gxf::Segment::setup", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment5setupE13gxf_context_tPKcNSt10shared_ptrI16DefaultExtensionEE", "priority": 1, "content": "Expected &lt; void &gt;  setup gxf_context_t  segment_context const  char  * name std :: shared_ptr &lt; DefaultExtension &gt;  runtime_ext This function is expected to be called by the application layer to assign a context to the segment and a runtime extension for on the fly registration of components Parameters gxf_context_t segment_context \u2013 A valid GXF context to be assigned to the segment const char* name \u2013 A valid name for the segment std::shared_ptr&lt;DefaultExtension&gt; runtime_ext \u2013 Pointer to a GXF extension which can be used to register any components at runtime Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 582, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setup::name", "display_name": "nvidia::gxf::Segment::setup::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment5setupE13gxf_context_tPKcNSt10shared_ptrI16DefaultExtensionEE", "priority": 1, "content": "Expected &lt; void &gt;  setup gxf_context_t  segment_context const  char  * name std :: shared_ptr &lt; DefaultExtension &gt;  runtime_ext This function is expected to be called by the application layer to assign a context to the segment and a runtime extension for on the fly registration of components Parameters gxf_context_t segment_context \u2013 A valid GXF context to be assigned to the segment const char* name \u2013 A valid name for the segment std::shared_ptr&lt;DefaultExtension&gt; runtime_ext \u2013 Pointer to a GXF extension which can be used to register any components at runtime Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 583, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setup::runtime_ext", "display_name": "nvidia::gxf::Segment::setup::runtime_ext", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment5setupE13gxf_context_tPKcNSt10shared_ptrI16DefaultExtensionEE", "priority": 1, "content": "Expected &lt; void &gt;  setup gxf_context_t  segment_context const  char  * name std :: shared_ptr &lt; DefaultExtension &gt;  runtime_ext This function is expected to be called by the application layer to assign a context to the segment and a runtime extension for on the fly registration of components Parameters gxf_context_t segment_context \u2013 A valid GXF context to be assigned to the segment const char* name \u2013 A valid name for the segment std::shared_ptr&lt;DefaultExtension&gt; runtime_ext \u2013 Pointer to a GXF extension which can be used to register any components at runtime Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 584, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::setup::segment_context", "display_name": "nvidia::gxf::Segment::setup::segment_context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment5setupE13gxf_context_tPKcNSt10shared_ptrI16DefaultExtensionEE", "priority": 1, "content": "Expected &lt; void &gt;  setup gxf_context_t  segment_context const  char  * name std :: shared_ptr &lt; DefaultExtension &gt;  runtime_ext This function is expected to be called by the application layer to assign a context to the segment and a runtime extension for on the fly registration of components Parameters gxf_context_t segment_context \u2013 A valid GXF context to be assigned to the segment const char* name \u2013 A valid name for the segment std::shared_ptr&lt;DefaultExtension&gt; runtime_ext \u2013 Pointer to a GXF extension which can be used to register any components at runtime Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 585, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::wait", "display_name": "nvidia::gxf::Segment::wait", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7Segment4waitEv", "priority": 1, "content": "Expected &lt; void &gt;  wait A blocking API to wait until the segment execution has completed. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 586, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Segment::~Segment", "display_name": "nvidia::gxf::Segment::~Segment", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf7SegmentD0Ev", "priority": 1, "content": "virtual  ~Segment Default Destructor.", "keywords": []}, {"id": 587, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SegmentPort", "display_name": "nvidia::gxf::SegmentPort", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11SegmentPortE", "priority": 1, "content": "struct  nvidia :: gxf :: SegmentPort An open port in an segment is specified using entity and queue component names. SegmentPort name is in the format \u201c&lt;Entity Name&gt;.&lt;Queue Name&gt;\u201d Entity Name - name of a graph entity created in the segment Queue Name - tx or rx component name which should match the parameter keys of the codelet in the corresponding GraphEntity for a successful connection", "keywords": []}, {"id": 588, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SegmentPort::entity_name", "display_name": "nvidia::gxf::SegmentPort::entity_name", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11SegmentPort11entity_nameE", "priority": 1, "content": "std :: string  entity_name The name of the entity associated with the SegmentPort.", "keywords": []}, {"id": 589, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SegmentPort::name", "display_name": "nvidia::gxf::SegmentPort::name", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11SegmentPort4nameE", "priority": 1, "content": "std :: string  name The name of the SegmentPort, which is a concatenation of the entity name and queue name.", "keywords": []}, {"id": 590, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::SegmentPort::queue_name", "display_name": "nvidia::gxf::SegmentPort::queue_name", "type": "member", "display_type": "C++ member", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf11SegmentPort10queue_nameE", "priority": 1, "content": "std :: string  queue_name The name of the queue (tx or rx) associated with the SegmentPort.", "keywords": []}, {"id": 591, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType", "display_name": "parseArgsOfType", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 592, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType::First", "display_name": "parseArgsOfType::First", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 593, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType::Rest", "display_name": "parseArgsOfType::Rest", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 594, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType::T", "display_name": "parseArgsOfType::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 595, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType::first", "display_name": "parseArgsOfType::first", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 596, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "parseArgsOfType::rest", "display_name": "parseArgsOfType::rest", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "_CPPv4I00DpE15parseArgsOfTypeNSt6vectorI1TEERK5FirstDpRK4Rest", "priority": 1, "content": "template &lt; typename  T ,  typename  First ,  typename  ... Rest &gt; std :: vector &lt; T &gt;  parseArgsOfType const  First  &amp; first const  Rest &amp; ...  rest Parses the incoming parameter pack of arguments for objects of type T Parameters T \u2013 Type of parameter to be filtered from the parameter pack Returns std::vector&lt;T&gt; List of objects of type T", "keywords": []}, {"id": 597, "doc_id": 597, "filename": "graphtools-docs/docs/text/GXF_App_C%2B%2B_APIs.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_App_C++_APIs", "display_name": "GXF App C++ APIs", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_App_C++_APIs", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 598, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component", "display_name": "Component", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component", "priority": 1, "content": "class  Component Base class for components. Each component from different extensions inherits this class, and overrides: gxf_native_type to its fully qualified C++ type name _validation_info_parameters to its parameter info", "keywords": []}, {"id": 599, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.__init__", "display_name": "Component.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.__init__", "priority": 1, "content": "__init__ type name ** params Initialize the Component object. Parameters type ( str ) \u2013 The type of the component. name ( str ) \u2013 The name of the component. params ( dict ) \u2013 The parameters for the component.", "keywords": []}, {"id": 600, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component._validation_info_parameters", "display_name": "Component._validation_info_parameters", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component._validation_info_parameters", "priority": 1, "content": "_validation_info_parameters :  dict Base class variable to be override by the child parameter info.", "keywords": []}, {"id": 601, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.add_to", "display_name": "Component.add_to", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.add_to", "priority": 1, "content": "add_to entity Add the component to an entity. Parameters entity ( Entity ) \u2013 The entity to add the component to.", "keywords": []}, {"id": 602, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.cid", "display_name": "Component.cid", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.cid", "priority": 1, "content": "cid :  int The unique identifier of the component.", "keywords": []}, {"id": 603, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.context", "display_name": "Component.context", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.context", "priority": 1, "content": "context :  int The context associated with the component\u2019s entity.", "keywords": []}, {"id": 604, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.entity", "display_name": "Component.entity", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.entity", "priority": 1, "content": "entity :  Entity The entity associated with the component.", "keywords": []}, {"id": 605, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.get_gxf_type", "display_name": "Component.get_gxf_type", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.get_gxf_type", "priority": 1, "content": "classmethod  get_gxf_type Get the native GXF type of the component. Returns The native GXF type. Return type str", "keywords": []}, {"id": 606, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.get_param", "display_name": "Component.get_param", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.get_param", "priority": 1, "content": "get_param param Get the value of a parameter for the component. Parameters param ( str ) \u2013 The parameter to get. Returns The value of the parameter. Raises ValueError \u2013 If the parameter is not found.", "keywords": []}, {"id": 607, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.gxf_native_type", "display_name": "Component.gxf_native_type", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.gxf_native_type", "priority": 1, "content": "gxf_native_type :  str Base class variable to be override by the child fully qualified C++ type name.", "keywords": []}, {"id": 608, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.name", "display_name": "Component.name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.name", "priority": 1, "content": "name :  str The name of the component.", "keywords": []}, {"id": 609, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.params", "display_name": "Component.params", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.params", "priority": 1, "content": "params :  dict The parameters of the component.", "keywords": []}, {"id": 610, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.set_entity", "display_name": "Component.set_entity", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.set_entity", "priority": 1, "content": "set_entity entity Set the entity associated with the component. Parameters entity ( Entity ) \u2013 The entity to associate with the component. Raises RuntimeError \u2013 If the component is already associated with an entity.", "keywords": []}, {"id": 611, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.set_param", "display_name": "Component.set_param", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.set_param", "priority": 1, "content": "set_param param value Set a parameter for the component. Parameters param ( str ) \u2013 The parameter to set. value \u2013 The value to set for the parameter. Raises ValueError \u2013 If the parameter is not found.", "keywords": []}, {"id": 612, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.set_params", "display_name": "Component.set_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.set_params", "priority": 1, "content": "set_params Set the parameters for the component.", "keywords": []}, {"id": 613, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.tid", "display_name": "Component.tid", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.tid", "priority": 1, "content": "tid :  int The type identifier of the component.", "keywords": []}, {"id": 614, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.type", "display_name": "Component.type", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.type", "priority": 1, "content": "type :  str The type of the component.", "keywords": []}, {"id": 615, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Component.validate_params", "display_name": "Component.validate_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Component.validate_params", "priority": 1, "content": "validate_params params Validate the component\u2019s parameters. Parameters params ( dict ) \u2013 The parameters to validate. Returns True if the parameters are valid, False otherwise. Return type bool", "keywords": []}, {"id": 616, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity", "display_name": "ComputeEntity", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity", "priority": 1, "content": "class  ComputeEntity Entity Compute Entity adds an entity in the graph with basic scheduling terms. A codelet can be added to insert custom user code.", "keywords": []}, {"id": 617, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity.__init__", "display_name": "ComputeEntity.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity.__init__", "priority": 1, "content": "__init__ self name :  str  =  &#x27;&#x27; count :  int  =  -1 recess_period :  int  =  0 ** kwargs Initialize a ComputeEntity object. If count &gt;= 0 , add CountSchedulingTerm with param count ; If recess_period &gt; 0 , add PeriodicSchedulingTerm with param recess_period ; Parameters name ( str ) \u2013 The name of the compute entity. count ( int ) \u2013 The count parameter of PeriodicSchedulingTerm . A value of -1 indicates the entity can execute indefinitely. recess_period ( int ) \u2013 The recess_period parameter of PeriodicSchedulingTerm . The duration in nanoseconds before the entity is permitted to execute. **kwargs \u2013 Additional keyword arguments to be passed to the entity.", "keywords": []}, {"id": 618, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity._count", "display_name": "ComputeEntity._count", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity._count", "priority": 1, "content": "_count :  int", "keywords": []}, {"id": 619, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity._kwargs", "display_name": "ComputeEntity._kwargs", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity._kwargs", "priority": 1, "content": "_kwargs :  dict", "keywords": []}, {"id": 620, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity._recess_period", "display_name": "ComputeEntity._recess_period", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity._recess_period", "priority": 1, "content": "_recess_period :  int", "keywords": []}, {"id": 621, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "ComputeEntity.add_codelet", "display_name": "ComputeEntity.add_codelet", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "ComputeEntity.add_codelet", "priority": 1, "content": "add_codelet self codelet min_message_available = 1 min_message_reception = 1 rx_capacity :  int  =  1 tx_capacity :  int  =  1 Component Adds a codelet to the compute entity; Automatically adds Transmitter queue DoubleBufferTransmitter and DownstreamReceptiveSchedulingTerm if the codelet parameter has nvidia::gxf::Transmitter ; Automatically adds Receiver queue DoubleBufferReceiver and MessageAvailableSchedulingTerm if the codelet parameter has nvidia::gxf::Receiver . Parameters codelet ( Component ) \u2013 The codelet to be added to the compute entity. min_message_available ( int ) \u2013 The minimum number of messages receiver queue received, only then permit codelet to execute. Skipped if codelet does not have receiver param. min_message_reception ( int ) \u2013 The minimum number of messages transmitter queue can send to downstream, only then permit codelet to execute. Skipped if codelet does not have transmitter param. rx_capacity ( int ) \u2013 The maximum number of messages allowed in the receiver queue. Skipped if codelet does not have receiver param. tx_capacity ( int ) \u2013 The maximum number of messages allowed in the transmitter queue. Skipped if codelet does not have transmitter param. Returns The added codelet. Return type Component", "keywords": []}, {"id": 622, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity", "display_name": "Entity", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity", "priority": 1, "content": "class  Entity Node Entity class wrapping the nvidia::gxf::Entity.", "keywords": []}, {"id": 623, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.__init__", "display_name": "Entity.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.__init__", "priority": 1, "content": "__init__ name :  str  =  &#x27;&#x27; is_system_entity :  bool  =  False Initialize the Entity object. Parameters name ( str ) \u2013 The name of the entity. is_system_entity ( bool ) \u2013 Whether the entity is a system entity or not.", "keywords": []}, {"id": 624, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.activate", "display_name": "Entity.activate", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.activate", "priority": 1, "content": "activate Activate the entity and its components.", "keywords": []}, {"id": 625, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.add", "display_name": "Entity.add", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.add", "priority": 1, "content": "add component visible_as = None Add a component to the entity. Parameters component ( Component ) \u2013 The component to add. visible_as ( str , optional ) \u2013 An alias to make the component visible in the graph. Returns The added component. Raises Exception \u2013 If the input is not a Component object.", "keywords": []}, {"id": 626, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.components", "display_name": "Entity.components", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.components", "priority": 1, "content": "components :  list A list of components associated with the entity.", "keywords": []}, {"id": 627, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.context", "display_name": "Entity.context", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.context", "priority": 1, "content": "context :  int The context associated with the entity\u2019s graph.", "keywords": []}, {"id": 628, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.eid", "display_name": "Entity.eid", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.eid", "priority": 1, "content": "eid :  int The unique identifier of the entity.", "keywords": []}, {"id": 629, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.is_system_entity", "display_name": "Entity.is_system_entity", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.is_system_entity", "priority": 1, "content": "is_system_entity :  bool Whether the entity is a system entity or not.", "keywords": []}, {"id": 630, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.name", "display_name": "Entity.name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.name", "priority": 1, "content": "name :  str The name of the entity.", "keywords": []}, {"id": 631, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.named_components", "display_name": "Entity.named_components", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.named_components", "priority": 1, "content": "named_components :  dict A dictionary of named components associated with the entity.", "keywords": []}, {"id": 632, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.qualified_name", "display_name": "Entity.qualified_name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.qualified_name", "priority": 1, "content": "qualified_name :  str The qualified name of the entity, including the graph\u2019s name.", "keywords": []}, {"id": 633, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.set_graph", "display_name": "Entity.set_graph", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.set_graph", "priority": 1, "content": "set_graph value Set the graph associated with the entity. Parameters value ( Graph ) \u2013 The graph.", "keywords": []}, {"id": 634, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.set_params", "display_name": "Entity.set_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.set_params", "priority": 1, "content": "set_params Set parameters for the entity\u2019s components.", "keywords": []}, {"id": 635, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Entity.set_system_entity_flag", "display_name": "Entity.set_system_entity_flag", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Entity.set_system_entity_flag", "priority": 1, "content": "set_system_entity_flag is_system_entity Set the system entity flag for the entity. Parameters is_system_entity ( bool ) \u2013 Whether the entity is a system entity or not.", "keywords": []}, {"id": 636, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup", "display_name": "EntityGroup", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup", "priority": 1, "content": "class  EntityGroup Node Entity group class wrapping the nvidia::gxf::Entity.", "keywords": []}, {"id": 637, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.__init__", "display_name": "EntityGroup.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.__init__", "priority": 1, "content": "__init__ name :  str  =  &#x27;&#x27; Initialize the EntityGroup object. Parameters name ( str ) \u2013 The name of the entity group.", "keywords": []}, {"id": 638, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.activate", "display_name": "EntityGroup.activate", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.activate", "priority": 1, "content": "activate Activate the entity group and its entities.", "keywords": []}, {"id": 639, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.add", "display_name": "EntityGroup.add", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.add", "priority": 1, "content": "add entities Add entities to the group. Parameters entities ( Entity or iterable of Entities ) \u2013 The entities to add.", "keywords": []}, {"id": 640, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.context", "display_name": "EntityGroup.context", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.context", "priority": 1, "content": "context :  int The context associated with the entity group\u2019s graph.", "keywords": []}, {"id": 641, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.graph", "display_name": "EntityGroup.graph", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.graph", "priority": 1, "content": "graph :  Graph The graph associated with the entity group.", "keywords": []}, {"id": 642, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.name", "display_name": "EntityGroup.name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.name", "priority": 1, "content": "name :  str The name of the entity group.", "keywords": []}, {"id": 643, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.qualified_name", "display_name": "EntityGroup.qualified_name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.qualified_name", "priority": 1, "content": "qualified_name :  str The qualified name of the entity group, including the graph\u2019s name.", "keywords": []}, {"id": 644, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.set_graph", "display_name": "EntityGroup.set_graph", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.set_graph", "priority": 1, "content": "set_graph value Set the graph associated with the entity group. Parameters value ( Graph ) \u2013 The graph.", "keywords": []}, {"id": 645, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "EntityGroup.set_params", "display_name": "EntityGroup.set_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "EntityGroup.set_params", "priority": 1, "content": "set_params Set parameters for the entity group.", "keywords": []}, {"id": 646, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph", "display_name": "Graph", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph", "priority": 1, "content": "class  Graph Node Python class wrapping the nvidia::gxf::Graph.", "keywords": []}, {"id": 647, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.__init__", "display_name": "Graph.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.__init__", "priority": 1, "content": "__init__ name :  str  =  &#x27;&#x27; Initialize the Graph object. Parameters name ( str ) \u2013 The name of the graph.", "keywords": []}, {"id": 648, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.activate", "display_name": "Graph.activate", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.activate", "priority": 1, "content": "activate Activate the graph and its components.", "keywords": []}, {"id": 649, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.add", "display_name": "Graph.add", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.add", "priority": 1, "content": "add node Add a node (Entity, EntityGroup, or Graph) to the graph. Parameters node ( Entity , EntityGroup , or Graph ) \u2013 The node to add. Returns The added node. Raises RuntimeError \u2013 If the node type is not supported.", "keywords": []}, {"id": 650, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.aliases", "display_name": "Graph.aliases", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.aliases", "priority": 1, "content": "aliases :  dict A dictionary of aliases for components in the graph.", "keywords": []}, {"id": 651, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.as_subgraph_of", "display_name": "Graph.as_subgraph_of", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.as_subgraph_of", "priority": 1, "content": "as_subgraph_of parent Make the current graph a subgraph of the given parent graph. Parameters parent ( Graph ) \u2013 The parent graph.", "keywords": []}, {"id": 652, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.context", "display_name": "Graph.context", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.context", "priority": 1, "content": "context :  int The context associated with the graph. If the graph is a subgraph, returns the parent\u2019s context.", "keywords": []}, {"id": 653, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.destroy", "display_name": "Graph.destroy", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.destroy", "priority": 1, "content": "destroy Destroy the graph and its context.", "keywords": []}, {"id": 654, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.get", "display_name": "Graph.get", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.get", "priority": 1, "content": "get alias Get the value of an alias. Parameters alias ( str ) \u2013 The alias to retrieve. Returns The value associated with the alias. Raises ValueError \u2013 If the alias is not marked visible.", "keywords": []}, {"id": 655, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.interrupt", "display_name": "Graph.interrupt", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.interrupt", "priority": 1, "content": "interrupt Interrupt the graph.", "keywords": []}, {"id": 656, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.is_subgraph", "display_name": "Graph.is_subgraph", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.is_subgraph", "priority": 1, "content": "is_subgraph :  bool Whether the graph is a subgraph or not.", "keywords": []}, {"id": 657, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.load_extensions", "display_name": "Graph.load_extensions", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.load_extensions", "priority": 1, "content": "load_extensions extension_filenames = None manifest_files = None workspace = &#x27;&#x27; Load GXF extensions for the graph. Uses env variable GXF_WORKSPACE as workspace Generates extension_filenames based on the extensions used in the graph if no extension_filenames and manifest_files are passed Parameters extension_filenames ( list , optional ) \u2013 List of extension library file paths ( .so files) manifest_files ( list , optional ) \u2013 List of manifest file paths. workspace ( str , optional ) \u2013 Base directory for extensions and manifests.", "keywords": []}, {"id": 658, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.make_visible", "display_name": "Graph.make_visible", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.make_visible", "priority": 1, "content": "make_visible alias component Mark a component as visible with an alias. Parameters alias ( str ) \u2013 The alias to associate with the component. component \u2013 The component to make visible. Raises RuntimeError \u2013 If the alias already exists.", "keywords": []}, {"id": 659, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.name", "display_name": "Graph.name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.name", "priority": 1, "content": "name :  str The name of the graph.", "keywords": []}, {"id": 660, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.parent", "display_name": "Graph.parent", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.parent", "priority": 1, "content": "parent :  Graph The parent graph, if the current graph is a subgraph.", "keywords": []}, {"id": 661, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.qualified_name", "display_name": "Graph.qualified_name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.qualified_name", "priority": 1, "content": "qualified_name :  str The qualified name of the graph, including the parent\u2019s name if the graph is a subgraph.", "keywords": []}, {"id": 662, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.run", "display_name": "Graph.run", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.run", "priority": 1, "content": "run Run the graph.", "keywords": []}, {"id": 663, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.run_async", "display_name": "Graph.run_async", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.run_async", "priority": 1, "content": "run_async Run the graph asynchronously.", "keywords": []}, {"id": 664, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.save", "display_name": "Graph.save", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.save", "priority": 1, "content": "save filename Save the graph to a file. Parameters filename ( str ) \u2013 The path to save the graph file.", "keywords": []}, {"id": 665, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.set_name", "display_name": "Graph.set_name", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.set_name", "priority": 1, "content": "set_name value Set the name of the graph. Parameters value ( str ) \u2013 The new name for the graph.", "keywords": []}, {"id": 666, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.set_params", "display_name": "Graph.set_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.set_params", "priority": 1, "content": "set_params Set parameters for the graph.", "keywords": []}, {"id": 667, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.set_parent", "display_name": "Graph.set_parent", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.set_parent", "priority": 1, "content": "set_parent value Set the parent graph, making the current graph a subgraph. Parameters value ( Graph ) \u2013 The parent graph.", "keywords": []}, {"id": 668, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.set_severity", "display_name": "Graph.set_severity", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.set_severity", "priority": 1, "content": "set_severity log_level = logging.INFO Set the severity level for GXF logging. Parameters log_level ( optional , int or above enum from python logging package ) \u2013 The logging level to set. Can be one of the following: logging.NOTSET (0): No logging. logging.ERROR (40): Log only error messages. logging.WARN (30): Log warning and error messages. logging.INFO (20): Log informational, warning, and error messages. logging.DEBUG (10): Log debug, informational, warning, and error messages. &quot;VERBOSE&quot; (5): Log all messages, including verbose debug messages. Raises RuntimeError \u2013 If an incorrect log level is provided.", "keywords": []}, {"id": 669, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.update_alias", "display_name": "Graph.update_alias", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.update_alias", "priority": 1, "content": "update_alias alias value Update the value of an alias. Parameters alias ( str ) \u2013 The alias to update. value \u2013 The new value for the alias. Raises ValueError \u2013 If the alias is not set.", "keywords": []}, {"id": 670, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Graph.wait", "display_name": "Graph.wait", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Graph.wait", "priority": 1, "content": "wait Wait for the graph to complete.", "keywords": []}, {"id": 671, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Node", "display_name": "Node", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Node", "priority": 1, "content": "class  Node ABC Abstract base class for Graph, Entity, EntityGroup", "keywords": []}, {"id": 672, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Node.activate", "display_name": "Node.activate", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Node.activate", "priority": 1, "content": "abstract  activate Activate the node and its components.", "keywords": []}, {"id": 673, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Node.set_params", "display_name": "Node.set_params", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Node.set_params", "priority": 1, "content": "abstract  set_params Set parameters for the node and its components.", "keywords": []}, {"id": 674, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity", "display_name": "PyComputeEntity", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity", "priority": 1, "content": "class  PyComputeEntity Entity Compute Entity to contain codelet implemented in python. It adds an entity in the graph with basic scheduling terms. A codelet implemented in python can be added.", "keywords": []}, {"id": 675, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity.__init__", "display_name": "PyComputeEntity.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity.__init__", "priority": 1, "content": "__init__ self name :  str  =  &#x27;&#x27; count :  int  =  100 recess_period :  int  =  0 ** kwargs Initialize a PyComputeEntity object. If count &gt;= 0 , add CountSchedulingTerm with param count ; If recess_period &gt; 0 , add PeriodicSchedulingTerm with param recess_period ; Parameters name ( str ) \u2013 The name of the entity. count ( int ) \u2013 The count parameter of PeriodicSchedulingTerm . A value of -1 indicates the entity can execute indefinitely. recess_period ( int ) \u2013 The recess_period parameter of PeriodicSchedulingTerm . The duration in nanoseconds before the entity is permitted to execute. **kwargs \u2013 Additional keyword arguments to be passed to the entity.", "keywords": []}, {"id": 676, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity._count", "display_name": "PyComputeEntity._count", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity._count", "priority": 1, "content": "_count :  int", "keywords": []}, {"id": 677, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity._kwargs", "display_name": "PyComputeEntity._kwargs", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity._kwargs", "priority": 1, "content": "_kwargs :  dict", "keywords": []}, {"id": 678, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity._recess_period", "display_name": "PyComputeEntity._recess_period", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity._recess_period", "priority": 1, "content": "_recess_period :  int", "keywords": []}, {"id": 679, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "PyComputeEntity.add_codelet", "display_name": "PyComputeEntity.add_codelet", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "PyComputeEntity.add_codelet", "priority": 1, "content": "add_codelet self name codelet min_message_available = 1 min_message_reception = 1 rx_capacity :  int  =  1 tx_capacity :  int  =  1 ** params Component Adds a codelet implemented in python to the python compute entity; Automatically adds Transmitter queue DoubleBufferTransmitter and DownstreamReceptiveSchedulingTerm if the codelet parameter has nvidia::gxf::Transmitter ; Automatically adds Receiver queue DoubleBufferReceiver and MessageAvailableSchedulingTerm if the codelet parameter has nvidia::gxf::Receiver . Parameters name ( str ) \u2013 The name of the python codelet. codelet ( Component ) \u2013 The python codelet to be added to the compute entity. min_message_available ( int ) \u2013 The minimum number of messages receiver queue received, only then permit codelet to execute. Skipped if codelet does not have receiver param. min_message_reception ( int ) \u2013 The minimum number of messages transmitter queue can send to downstream, only then permit codelet to execute. Skipped if codelet does not have transmitter param. rx_capacity ( int ) \u2013 The maximum number of messages allowed in the receiver queue. Skipped if codelet does not have receiver param. tx_capacity ( int ) \u2013 The maximum number of messages allowed in the transmitter queue. Skipped if codelet does not have transmitter param. Returns The added python codelet. Return type Component", "keywords": []}, {"id": 680, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor", "display_name": "Tensor", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor", "priority": 1, "content": "class  Tensor The Tensor class represents a multi-dimensional array of elements of the same data type. Protocols implemented: * DLPack * array_interface and cuda_array_interface", "keywords": []}, {"id": 681, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.__dlpack__", "display_name": "Tensor.__dlpack__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.__dlpack__", "priority": 1, "content": "__dlpack__ stream = None Parameters stream ( object ) \u2013 An optional stream object wrapping cuda stream for the DLPack protocol. Returns A PyCapsule object wrapping DLPack representation of the Tensor .", "keywords": []}, {"id": 682, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.__dlpack_device__", "display_name": "Tensor.__dlpack_device__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.__dlpack_device__", "priority": 1, "content": "__dlpack_device__ Returns A PyCapsule object wrapping DLPack device representation of the Tensor .", "keywords": []}, {"id": 683, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.__init__", "display_name": "Tensor.__init__", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.__init__", "priority": 1, "content": "__init__ Construct a new empty Tensor .", "keywords": []}, {"id": 684, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.add_to_entity", "display_name": "Tensor.add_to_entity", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.add_to_entity", "priority": 1, "content": "static  add_to_entity entity tensor = None name = None Parameters entity \u2013 The Entity to which the Tensor should be added. tensor ( Tensor , optional ) \u2013 An optional Tensor instance to be added to the Entity . If not provided, a new empty Tensor will be created. name ( str , optional ) \u2013 An optional name for the Tensor component in the Entity . Returns The Tensor instance added to the Entity . Return type Tensor", "keywords": []}, {"id": 685, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.as_tensor", "display_name": "Tensor.as_tensor", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.as_tensor", "priority": 1, "content": "static  as_tensor obj Parameters obj ( object ) \u2013 The input object to be converted to GXF Tensor. Returns A new Tensor instance initialized with the data from the input object, zero-copy. Return type Tensor Create a new GXF Tensor instances from various other deep leanring frameworks, with data zero-copy if the tensor object support the DLPack protocol, NumPy\u2019s array interface protocol, or the CUDA array interface protocol. Example: &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; arr = np.random.rand(3, 4) &gt;&gt;&gt; from gxf.std import Tensor &gt;&gt;&gt; tensor = Tensor.as_tensor(arr)", "keywords": []}, {"id": 686, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.element_type", "display_name": "Tensor.element_type", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.element_type", "priority": 1, "content": "element_type Returns The element data type of the Tensor . Return type PrimitiveType Get the element data type of the Tensor .", "keywords": []}, {"id": 687, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.find_all_from_entity", "display_name": "Tensor.find_all_from_entity", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.find_all_from_entity", "priority": 1, "content": "find_all_from_entity entity Parameters entity \u2013 The Entity from which to retrieve all Tensor instances. Returns A list of Tensor instances retrieved from the Entity . Return type list [ Tensor ] Find all Tensor instances in an Entity .", "keywords": []}, {"id": 688, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.from_dlpack", "display_name": "Tensor.from_dlpack", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.from_dlpack", "priority": 1, "content": "static  from_dlpack obj Parameters obj ( object ) \u2013 An object supporting the DLPack protocol. Returns A new Tensor instance initialized with the data from the input DLPack object, zero-copy. Return type Tensor Create a new Tensor instance from an object supporting the DLPack protocol. Example: &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; arr = np.random.rand(3, 4) &gt;&gt;&gt; from gxf.std import Tensor &gt;&gt;&gt; tensor = Tensor.from_dlpack(arr)", "keywords": []}, {"id": 689, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.get_from_entity", "display_name": "Tensor.get_from_entity", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.get_from_entity", "priority": 1, "content": "static  get_from_entity entity name = None Parameters entity \u2013 The Entity from which to retrieve the Tensor . name ( str , optional ) \u2013 The name of the Tensor component in the Entity . Returns The Tensor instance retrieved from the Entity . Return type Tensor Get a Tensor from an Entity .", "keywords": []}, {"id": 690, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.get_tensor_description", "display_name": "Tensor.get_tensor_description", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.get_tensor_description", "priority": 1, "content": "get_tensor_description Returns A TensorDescription object describing the current Tensor . Return type gxf.std.TensorDescription Get a TensorDescription object describing the current Tensor .", "keywords": []}, {"id": 691, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.get_tensor_info", "display_name": "Tensor.get_tensor_info", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.get_tensor_info", "priority": 1, "content": "get_tensor_info Returns A tuple containing information about the Tensor (pointer, size, data type, rank, dimensions, and strides). Get detailed information about the Tensor in a tuple format.", "keywords": []}, {"id": 692, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.reshape", "display_name": "Tensor.reshape", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.reshape", "priority": 1, "content": "reshape tensor_description allocator Parameters tensor_description ( gxf.std.TensorDescription ) \u2013 A TensorDescription object describing the new shape and data type. allocator ( Allocator ) \u2013 An Allocator instance for memory allocation. Reshape the Tensor according to the provided TensorDescription .", "keywords": []}, {"id": 693, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.reshape_custom", "display_name": "Tensor.reshape_custom", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.reshape_custom", "priority": 1, "content": "reshape_custom shape element_type bytes_per_element strides storage_type allocator Parameters shape ( gxf.std.Shape ) \u2013 The new shape for the Tensor . element_type ( gxf.std.PrimitiveType ) \u2013 The new element data type for the Tensor . bytes_per_element ( int ) \u2013 The number of bytes per element in the new data type. strides ( list [ int ] ) \u2013 The strides for the new shape. storage_type ( gxf.std.MemoryStorageType ) \u2013 The new storage type for the Tensor (host or device). allocator ( Allocator ) \u2013 An Allocator instance for memory allocation. Reshape the Tensor with custom parameters.", "keywords": []}, {"id": 694, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.shape", "display_name": "Tensor.shape", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.shape", "priority": 1, "content": "shape Returns The shape of the Tensor . Return type Shape Get the shape of the Tensor .", "keywords": []}, {"id": 695, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "Tensor.storage_type", "display_name": "Tensor.storage_type", "type": "method", "display_type": "Python method", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "Tensor.storage_type", "priority": 1, "content": "storage_type Returns The storage type of the Tensor (kHost or kDevice or kSystem). Return type MemoryStorageType Get the storage type of the Tensor .", "keywords": []}, {"id": 696, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "_generate_name", "display_name": "_generate_name", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "generate_name", "priority": 1, "content": "_generate_name base_name extra_length = GXF_NAME_EXTRA_LENGTH Module gxf.std.standard_methods Generate a random name with base_name as prefix, {base_name}_* . Parameters base_name ( str ) \u2013 The name prefix. extra_length ( int ) \u2013 The length of postfix. Returns The generate random name. Return type str", "keywords": []}, {"id": 697, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "connect", "display_name": "connect", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "connect", "priority": 1, "content": "connect src :  Component target :  Component graph :  Graph  =  None Module gxf.std.standard_methods Connects two queue components within a graph. Parameters src ( Component ) \u2013 The source queue component. src \u2013 The target queue component. graph ( Graph ) \u2013 The graph that has above two components.", "keywords": []}, {"id": 698, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "enable_job_statistics", "display_name": "enable_job_statistics", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "enable_job_statistics", "priority": 1, "content": "enable_job_statistics g :  Graph name :  str  =  &#x27;__job_stats&#x27; ** kwargs Component Module gxf.std.standard_methods Add a JobStatistics to a graph. Parameters g ( Graph ) \u2013 The graph to enable job statistics. name ( str ) \u2013 The name of JobStatistics . **kwargs \u2013 Additional keyword arguments to be passed to the JobStatistics . Returns The added JobStatistics . Return type Component", "keywords": []}, {"id": 699, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "set_clock", "display_name": "set_clock", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "set_clock", "priority": 1, "content": "set_clock g :  Graph clock :  Component Component Module gxf.std.standard_methods Set a clock component to the graph, so that the components need a clock in the graph can use that clock. Parameters g ( Graph ) \u2013 The graph to set clock. clock ( Component ) \u2013 The clock to set to the graph. Returns The added clock. Return type Component GXF_NAME_EXTRA_LENGTH = 7 Module gxf.std.standard_methods", "keywords": []}, {"id": 700, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "py", "name": "set_scheduler", "display_name": "set_scheduler", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "set_scheduler", "priority": 1, "content": "set_scheduler g :  Graph sch :  Component Component Module gxf.std.standard_methods Set a Scheduler component to the graph. Parameters g ( Graph ) \u2013 The graph to set Scheduler . sch ( Component ) \u2013 The Scheduler to set to the graph. Returns The added Scheduler . Return type Component", "keywords": []}, {"id": 701, "doc_id": 701, "filename": "graphtools-docs/docs/text/GXF_App_Python_APIs.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_App_Python_APIs", "display_name": "GXF App Python APIs", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_App_Python_APIs", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 702, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator", "display_name": "nvidia::gxf::Allocator", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9AllocatorE", "priority": 1, "content": "class  nvidia :: gxf :: Allocator Provides allocation and deallocation of memory.", "keywords": []}, {"id": 703, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate", "display_name": "nvidia::gxf::Allocator::allocate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator8allocateE8uint64_t17MemoryStorageType", "priority": 1, "content": "Expected &lt; byte * &gt;  allocate uint64_t  size MemoryStorageType  type Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure.", "keywords": []}, {"id": 704, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate::size", "display_name": "nvidia::gxf::Allocator::allocate::size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator8allocateE8uint64_t17MemoryStorageType", "priority": 1, "content": "Expected &lt; byte * &gt;  allocate uint64_t  size MemoryStorageType  type Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure.", "keywords": []}, {"id": 705, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate::type", "display_name": "nvidia::gxf::Allocator::allocate::type", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator8allocateE8uint64_t17MemoryStorageType", "priority": 1, "content": "Expected &lt; byte * &gt;  allocate uint64_t  size MemoryStorageType  type Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure.", "keywords": []}, {"id": 706, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate_abi", "display_name": "nvidia::gxf::Allocator::allocate_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator12allocate_abiE8uint64_t7int32_tPPv", "priority": 1, "content": "virtual  gxf_result_t  allocate_abi uint64_t  size int32_t  type void  * * pointer  =  0 Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. pointer \u2013 A pointer to the allocated memory block. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 707, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate_abi::pointer", "display_name": "nvidia::gxf::Allocator::allocate_abi::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator12allocate_abiE8uint64_t7int32_tPPv", "priority": 1, "content": "virtual  gxf_result_t  allocate_abi uint64_t  size int32_t  type void  * * pointer  =  0 Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. pointer \u2013 A pointer to the allocated memory block. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 708, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate_abi::size", "display_name": "nvidia::gxf::Allocator::allocate_abi::size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator12allocate_abiE8uint64_t7int32_tPPv", "priority": 1, "content": "virtual  gxf_result_t  allocate_abi uint64_t  size int32_t  type void  * * pointer  =  0 Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. pointer \u2013 A pointer to the allocated memory block. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 709, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocate_abi::type", "display_name": "nvidia::gxf::Allocator::allocate_abi::type", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator12allocate_abiE8uint64_t7int32_tPPv", "priority": 1, "content": "virtual  gxf_result_t  allocate_abi uint64_t  size int32_t  type void  * * pointer  =  0 Allocates a memory block of the given size and type. Parameters size \u2013 The size of the memory block. type \u2013 The type of memory to allocate. pointer \u2013 A pointer to the allocated memory block. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 710, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocator_stage_str", "display_name": "nvidia::gxf::Allocator::allocator_stage_str", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf9Allocator19allocator_stage_strE14AllocatorStage", "priority": 1, "content": "const  char  * allocator_stage_str AllocatorStage  stage  const Returns the string value of the allocator stage. Parameters stage \u2013 The allocator stage. Returns The string value of the allocator stage.", "keywords": []}, {"id": 711, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::allocator_stage_str::stage", "display_name": "nvidia::gxf::Allocator::allocator_stage_str::stage", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf9Allocator19allocator_stage_strE14AllocatorStage", "priority": 1, "content": "const  char  * allocator_stage_str AllocatorStage  stage  const Returns the string value of the allocator stage. Parameters stage \u2013 The allocator stage. Returns The string value of the allocator stage.", "keywords": []}, {"id": 712, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::block_size_abi", "display_name": "nvidia::gxf::Allocator::block_size_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf9Allocator14block_size_abiEv", "priority": 1, "content": "virtual  uint64_t  block_size_abi  const  =  0 Returns the block size of the allocator. Returns The block size of the allocator.", "keywords": []}, {"id": 713, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::free", "display_name": "nvidia::gxf::Allocator::free", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator4freeEP4byte", "priority": 1, "content": "Expected &lt; void &gt;  free byte  * pointer Frees a previously allocated memory block. Parameters pointer \u2013 A pointer to the memory block to be freed. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 714, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::free::pointer", "display_name": "nvidia::gxf::Allocator::free::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator4freeEP4byte", "priority": 1, "content": "Expected &lt; void &gt;  free byte  * pointer Frees a previously allocated memory block. Parameters pointer \u2013 A pointer to the memory block to be freed. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 715, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::free_abi", "display_name": "nvidia::gxf::Allocator::free_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator8free_abiEPv", "priority": 1, "content": "virtual  gxf_result_t  free_abi void  * pointer  =  0 Frees a previously allocated memory block. Parameters pointer \u2013 A pointer to the memory block to be freed. Returns GXF_SUCCESS if the memory block was freed successfully, an error code otherwise.", "keywords": []}, {"id": 716, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::free_abi::pointer", "display_name": "nvidia::gxf::Allocator::free_abi::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator8free_abiEPv", "priority": 1, "content": "virtual  gxf_result_t  free_abi void  * pointer  =  0 Frees a previously allocated memory block. Parameters pointer \u2013 A pointer to the memory block to be freed. Returns GXF_SUCCESS if the memory block was freed successfully, an error code otherwise.", "keywords": []}, {"id": 717, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::is_available_abi", "display_name": "nvidia::gxf::Allocator::is_available_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator16is_available_abiE8uint64_t", "priority": 1, "content": "virtual  gxf_result_t  is_available_abi uint64_t  size  =  0 Returns whether the allocator can provide a memory block of the given size. Parameters size \u2013 The size of the memory block. Returns GXF_SUCCESS if the memory block can be provided, an error code otherwise.", "keywords": []}, {"id": 718, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::is_available_abi::size", "display_name": "nvidia::gxf::Allocator::is_available_abi::size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Allocator16is_available_abiE8uint64_t", "priority": 1, "content": "virtual  gxf_result_t  is_available_abi uint64_t  size  =  0 Returns whether the allocator can provide a memory block of the given size. Parameters size \u2013 The size of the memory block. Returns GXF_SUCCESS if the memory block can be provided, an error code otherwise.", "keywords": []}, {"id": 719, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Allocator::~Allocator", "display_name": "nvidia::gxf::Allocator::~Allocator", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9AllocatorD0Ev", "priority": 1, "content": "virtual  ~Allocator  =  default Destructor.", "keywords": []}, {"id": 720, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::AllocatorStage", "display_name": "nvidia::gxf::AllocatorStage", "type": "enum", "display_type": "C++ enum", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14AllocatorStageE", "priority": 1, "content": "enum  nvidia :: gxf :: AllocatorStage Specifies the stage of the allocator.", "keywords": []}, {"id": 721, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::AllocatorStage::AllocatorStage::kDeinitializationInProgress", "display_name": "nvidia::gxf::AllocatorStage::AllocatorStage::kDeinitializationInProgress", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14AllocatorStage14AllocatorStage27kDeinitializationInProgressE", "priority": 1, "content": "enumerator  AllocatorStage :: kDeinitializationInProgress", "keywords": []}, {"id": 722, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::AllocatorStage::AllocatorStage::kInitializationInProgress", "display_name": "nvidia::gxf::AllocatorStage::AllocatorStage::kInitializationInProgress", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14AllocatorStage14AllocatorStage25kInitializationInProgressE", "priority": 1, "content": "enumerator  AllocatorStage :: kInitializationInProgress", "keywords": []}, {"id": 723, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::AllocatorStage::AllocatorStage::kInitialized", "display_name": "nvidia::gxf::AllocatorStage::AllocatorStage::kInitialized", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14AllocatorStage14AllocatorStage12kInitializedE", "priority": 1, "content": "enumerator  AllocatorStage :: kInitialized", "keywords": []}, {"id": 724, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::AllocatorStage::AllocatorStage::kUninitialized", "display_name": "nvidia::gxf::AllocatorStage::AllocatorStage::kUninitialized", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14AllocatorStage14AllocatorStage14kUninitializedE", "priority": 1, "content": "enumerator  AllocatorStage :: kUninitialized", "keywords": []}, {"id": 725, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock", "display_name": "nvidia::gxf::Clock", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf5ClockE", "priority": 1, "content": "class  nvidia :: gxf :: Clock A class for keeping track of time", "keywords": []}, {"id": 726, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::sleepFor", "display_name": "nvidia::gxf::Clock::sleepFor", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf5Clock8sleepForE7int64_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  sleepFor int64_t  duration_ns  =  0 Waits until the given duration has elapsed on the clock Parameters duration_ns \u2013 sleep duration in nanoseconds Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 727, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::sleepFor::duration_ns", "display_name": "nvidia::gxf::Clock::sleepFor::duration_ns", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf5Clock8sleepForE7int64_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  sleepFor int64_t  duration_ns  =  0 Waits until the given duration has elapsed on the clock Parameters duration_ns \u2013 sleep duration in nanoseconds Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 728, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::sleepUntil", "display_name": "nvidia::gxf::Clock::sleepUntil", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf5Clock10sleepUntilE7int64_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  sleepUntil int64_t  target_ns  =  0 Waits until the given target time has elapsed on the clock Parameters target_ns \u2013 target time duration to wait until in nanoseconds Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 729, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::sleepUntil::target_ns", "display_name": "nvidia::gxf::Clock::sleepUntil::target_ns", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf5Clock10sleepUntilE7int64_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  sleepUntil int64_t  target_ns  =  0 Waits until the given target time has elapsed on the clock Parameters target_ns \u2013 target time duration to wait until in nanoseconds Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 730, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::time", "display_name": "nvidia::gxf::Clock::time", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf5Clock4timeEv", "priority": 1, "content": "virtual  double  time  const  =  0 The current time of the clock. Time is measured in seconds. Returns The current time in seconds.", "keywords": []}, {"id": 731, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Clock::timestamp", "display_name": "nvidia::gxf::Clock::timestamp", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf5Clock9timestampEv", "priority": 1, "content": "virtual  int64_t  timestamp  const  =  0 The current timestamp of the clock. Timestamps are measured in nanoseconds. Returns The current timestamp in nanoseconds.", "keywords": []}, {"id": 732, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet", "display_name": "nvidia::gxf::Codelet", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7CodeletE", "priority": 1, "content": "class  nvidia :: gxf :: Codelet Codelets are special components which allow the execution of custom code. The user can create her own codelets by deriving from this class and overriding the functions initialize() , start() , tick() , stop() , and deinitialize() .", "keywords": []}, {"id": 733, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::beforeStart", "display_name": "nvidia::gxf::Codelet::beforeStart", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet11beforeStartE7int64_t", "priority": 1, "content": "void  beforeStart int64_t  timestamp Called by EntityExecutor before each \u2018start\u2019 Parameters timestamp \u2013 The current timestamp from the clock. Timestamps are measured in nanoseconds.", "keywords": []}, {"id": 734, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::beforeStart::timestamp", "display_name": "nvidia::gxf::Codelet::beforeStart::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet11beforeStartE7int64_t", "priority": 1, "content": "void  beforeStart int64_t  timestamp Called by EntityExecutor before each \u2018start\u2019 Parameters timestamp \u2013 The current timestamp from the clock. Timestamps are measured in nanoseconds.", "keywords": []}, {"id": 735, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::beforeStop", "display_name": "nvidia::gxf::Codelet::beforeStop", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet10beforeStopEv", "priority": 1, "content": "void  beforeStop Called by EntityExecutor before each \u2018stop\u2019", "keywords": []}, {"id": 736, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::beforeTick", "display_name": "nvidia::gxf::Codelet::beforeTick", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet10beforeTickE7int64_t", "priority": 1, "content": "void  beforeTick int64_t  timestamp Called by EntityExecutor before each \u2018tick\u2019 :param timestamp: The current timestamp from the clock. Timestamps are measured in nanoseconds.", "keywords": []}, {"id": 737, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::beforeTick::timestamp", "display_name": "nvidia::gxf::Codelet::beforeTick::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet10beforeTickE7int64_t", "priority": 1, "content": "void  beforeTick int64_t  timestamp Called by EntityExecutor before each \u2018tick\u2019 :param timestamp: The current timestamp from the clock. Timestamps are measured in nanoseconds.", "keywords": []}, {"id": 738, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::getDeltaTime", "display_name": "nvidia::gxf::Codelet::getDeltaTime", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf7Codelet12getDeltaTimeEv", "priority": 1, "content": "double  getDeltaTime  const The delta between the current execution time and the execution time of the previous execution. During the start function this will return 0. Returns The delta time in seconds.", "keywords": []}, {"id": 739, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::getExecutionCount", "display_name": "nvidia::gxf::Codelet::getExecutionCount", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf7Codelet17getExecutionCountEv", "priority": 1, "content": "int64_t  getExecutionCount  const Returns the number of times a codelet is executed. This will return 0 during start and 1 during the first tick. Returns The execution count.", "keywords": []}, {"id": 740, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::getExecutionTime", "display_name": "nvidia::gxf::Codelet::getExecutionTime", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf7Codelet16getExecutionTimeEv", "priority": 1, "content": "double  getExecutionTime  const Similar to getExecutionTimestamp() but returns time as a floating point number and using seconds as unit. Equivalent to \u2018ToSeconds(getExecutionCount())\u2019. Returns The execution time in seconds.", "keywords": []}, {"id": 741, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::getExecutionTimestamp", "display_name": "nvidia::gxf::Codelet::getExecutionTimestamp", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf7Codelet21getExecutionTimestampEv", "priority": 1, "content": "int64_t  getExecutionTimestamp  const Timestamp (in nanoseconds) of the beginning of the start, tick or stop function. The execution timestamp does not change during the start, tick or stop function. Returns The execution timestamp in nanoseconds.", "keywords": []}, {"id": 742, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::isFirstTick", "display_name": "nvidia::gxf::Codelet::isFirstTick", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf7Codelet11isFirstTickEv", "priority": 1, "content": "bool  isFirstTick  const Returns true if this is the first time tick is called after start. Returns True if this is the first tick, false otherwise.", "keywords": []}, {"id": 743, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::start", "display_name": "nvidia::gxf::Codelet::start", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet5startEv", "priority": 1, "content": "virtual  gxf_result_t  start This function is called during the start phase of the codelet. It allows derived classes to execute custom code during the start phase. This is a good place to obtain resources which are necessary for ticking the codelet. This function is guaranteed to be called before the first call to tick() . Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 744, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::stop", "display_name": "nvidia::gxf::Codelet::stop", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet4stopEv", "priority": 1, "content": "virtual  gxf_result_t  stop This function is called during the stop phase of the codelet. It allows derived classes to execute custom code during the stop phase. This is a good place to clean up any resources which where obtained during \u2018start\u2019. After the codelet is stopped it should be in the same state as it was before \u2018start\u2019 was called. Be careful to not leave any unintended left overs as \u2018start\u2019 might be called again afterwards. It is guaranteed that stop is called after the last call to tick. When start was called stop will be called, too. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 745, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::tick", "display_name": "nvidia::gxf::Codelet::tick", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7Codelet4tickEv", "priority": 1, "content": "virtual  gxf_result_t  tick  =  0 This function is called whenever the codelet is expected to do work, e.g. when an event was received or periodically. The tick() method can be specified with various other member functions. This function is the main work horse of the codelet. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 746, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Codelet::~Codelet", "display_name": "nvidia::gxf::Codelet::~Codelet", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf7CodeletD0Ev", "priority": 1, "content": "virtual  ~Codelet  =  default Destructor.", "keywords": []}, {"id": 747, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator", "display_name": "nvidia::gxf::CudaAllocator", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocatorE", "priority": 1, "content": "class  nvidia :: gxf :: CudaAllocator  :  public  Allocator Provides allocation and deallocation of memory with Stream order memory allocators.", "keywords": []}, {"id": 748, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate", "display_name": "nvidia::gxf::CudaAllocator::allocate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator8allocateE8uint64_t12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; byte * &gt;  allocate uint64_t  size cudaStream_t  stream  =  0 Allocates a memory block of the specified size and type on the given CUDA stream. It performs the allocation on the CUDA device asynchronously, meaning it does not synchronize the CUDA stream following the allocation. This is used to allocate memory on device. Parameters size \u2013 The size of the memory block. stream \u2013 Cuda stream which is used to allocate memory. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure", "keywords": []}, {"id": 749, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate::size", "display_name": "nvidia::gxf::CudaAllocator::allocate::size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator8allocateE8uint64_t12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; byte * &gt;  allocate uint64_t  size cudaStream_t  stream  =  0 Allocates a memory block of the specified size and type on the given CUDA stream. It performs the allocation on the CUDA device asynchronously, meaning it does not synchronize the CUDA stream following the allocation. This is used to allocate memory on device. Parameters size \u2013 The size of the memory block. stream \u2013 Cuda stream which is used to allocate memory. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure", "keywords": []}, {"id": 750, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate::stream", "display_name": "nvidia::gxf::CudaAllocator::allocate::stream", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator8allocateE8uint64_t12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; byte * &gt;  allocate uint64_t  size cudaStream_t  stream  =  0 Allocates a memory block of the specified size and type on the given CUDA stream. It performs the allocation on the CUDA device asynchronously, meaning it does not synchronize the CUDA stream following the allocation. This is used to allocate memory on device. Parameters size \u2013 The size of the memory block. stream \u2013 Cuda stream which is used to allocate memory. Returns Expected&lt;byte*&gt; pointer to the newly created memory or error code on failure", "keywords": []}, {"id": 751, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate_async_abi", "display_name": "nvidia::gxf::CudaAllocator::allocate_async_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator18allocate_async_abiE8uint64_tPPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  allocate_async_abi uint64_t  size void  * * pointer cudaStream_t  stream Allocates a memory block of the specified size and type on the given CUDA stream. Parameters size \u2013 The size of the memory block. pointer \u2013 A pointer to the allocated memory block. stream \u2013 Cuda stream which on which memory is allocated. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 752, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate_async_abi::pointer", "display_name": "nvidia::gxf::CudaAllocator::allocate_async_abi::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator18allocate_async_abiE8uint64_tPPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  allocate_async_abi uint64_t  size void  * * pointer cudaStream_t  stream Allocates a memory block of the specified size and type on the given CUDA stream. Parameters size \u2013 The size of the memory block. pointer \u2013 A pointer to the allocated memory block. stream \u2013 Cuda stream which on which memory is allocated. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 753, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate_async_abi::size", "display_name": "nvidia::gxf::CudaAllocator::allocate_async_abi::size", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator18allocate_async_abiE8uint64_tPPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  allocate_async_abi uint64_t  size void  * * pointer cudaStream_t  stream Allocates a memory block of the specified size and type on the given CUDA stream. Parameters size \u2013 The size of the memory block. pointer \u2013 A pointer to the allocated memory block. stream \u2013 Cuda stream which on which memory is allocated. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 754, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::allocate_async_abi::stream", "display_name": "nvidia::gxf::CudaAllocator::allocate_async_abi::stream", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator18allocate_async_abiE8uint64_tPPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  allocate_async_abi uint64_t  size void  * * pointer cudaStream_t  stream Allocates a memory block of the specified size and type on the given CUDA stream. Parameters size \u2013 The size of the memory block. pointer \u2013 A pointer to the allocated memory block. stream \u2013 Cuda stream which on which memory is allocated. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 755, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free", "display_name": "nvidia::gxf::CudaAllocator::free", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator4freeEPv12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  free void  * pointer cudaStream_t  stream  =  0 Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 756, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free::pointer", "display_name": "nvidia::gxf::CudaAllocator::free::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator4freeEPv12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  free void  * pointer cudaStream_t  stream  =  0 Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 757, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free::stream", "display_name": "nvidia::gxf::CudaAllocator::free::stream", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator4freeEPv12cudaStream_t", "priority": 1, "content": "virtual  Expected &lt; void &gt;  free void  * pointer cudaStream_t  stream  =  0 Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 758, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free_async_abi", "display_name": "nvidia::gxf::CudaAllocator::free_async_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator14free_async_abiEPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  free_async_abi void  * pointer cudaStream_t  stream Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 759, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free_async_abi::pointer", "display_name": "nvidia::gxf::CudaAllocator::free_async_abi::pointer", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator14free_async_abiEPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  free_async_abi void  * pointer cudaStream_t  stream Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 760, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::free_async_abi::stream", "display_name": "nvidia::gxf::CudaAllocator::free_async_abi::stream", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocator14free_async_abiEPv12cudaStream_t", "priority": 1, "content": "gxf_result_t  free_async_abi void  * pointer cudaStream_t  stream Frees a previously allocated memory block on given cuda stream asynchronously. Parameters pointer \u2013 A pointer to the memory block to be freed. stream \u2013 The CUDA stream that requires memory deallocation. Returns GXF_SUCCESS if the memory block was allocated successfully, an error code otherwise.", "keywords": []}, {"id": 761, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::get_pool_size", "display_name": "nvidia::gxf::CudaAllocator::get_pool_size", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf13CudaAllocator13get_pool_sizeE17MemoryStorageType", "priority": 1, "content": "Expected &lt; size_t &gt;  get_pool_size MemoryStorageType  type  const Retrieve the current size of the memory pool for the specified type. Parameters type \u2013 The memory type from which we derive the pool size. Returns Expected&lt;size_t&gt; current memory pool size of specified type or error code on failure.", "keywords": []}, {"id": 762, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::get_pool_size::type", "display_name": "nvidia::gxf::CudaAllocator::get_pool_size::type", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf13CudaAllocator13get_pool_sizeE17MemoryStorageType", "priority": 1, "content": "Expected &lt; size_t &gt;  get_pool_size MemoryStorageType  type  const Retrieve the current size of the memory pool for the specified type. Parameters type \u2013 The memory type from which we derive the pool size. Returns Expected&lt;size_t&gt; current memory pool size of specified type or error code on failure.", "keywords": []}, {"id": 763, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::CudaAllocator::~CudaAllocator", "display_name": "nvidia::gxf::CudaAllocator::~CudaAllocator", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf13CudaAllocatorD0Ev", "priority": 1, "content": "virtual  ~CudaAllocator  =  default Destructor.", "keywords": []}, {"id": 764, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::MemoryStorageType", "display_name": "nvidia::gxf::MemoryStorageType", "type": "enum", "display_type": "C++ enum", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf17MemoryStorageTypeE", "priority": 1, "content": "enum  nvidia :: gxf :: MemoryStorageType Enum representing the type of memory storage.", "keywords": []}, {"id": 765, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kDevice", "display_name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kDevice", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf17MemoryStorageType17MemoryStorageType7kDeviceE", "priority": 1, "content": "enumerator  MemoryStorageType :: kDevice Memory allocated on the device / GPU", "keywords": []}, {"id": 766, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kHost", "display_name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kHost", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf17MemoryStorageType17MemoryStorageType5kHostE", "priority": 1, "content": "enumerator  MemoryStorageType :: kHost Page locked / Pinned memory allocated on the host", "keywords": []}, {"id": 767, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kSystem", "display_name": "nvidia::gxf::MemoryStorageType::MemoryStorageType::kSystem", "type": "enumerator", "display_type": "C++ enumerator", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf17MemoryStorageType17MemoryStorageType7kSystemE", "priority": 1, "content": "enumerator  MemoryStorageType :: kSystem Memory allocated on the Heap", "keywords": []}, {"id": 768, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver", "display_name": "nvidia::gxf::Receiver", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8ReceiverE", "priority": 1, "content": "class  nvidia :: gxf :: Receiver Interface for receiving entities.", "keywords": []}, {"id": 769, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::back_size", "display_name": "nvidia::gxf::Receiver::back_size", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver9back_sizeEv", "priority": 1, "content": "size_t  back_size The total number of entities which have recently arrived but are not yet on the main stage. Returns The number of entities in the back stage.", "keywords": []}, {"id": 770, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::back_size_abi", "display_name": "nvidia::gxf::Receiver::back_size_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver13back_size_abiEv", "priority": 1, "content": "virtual  size_t  back_size_abi  =  0 The total number of entities which have recently arrived but are not yet on the main stage. Returns The number of entities in the back stage.", "keywords": []}, {"id": 771, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::peekBack", "display_name": "nvidia::gxf::Receiver::peekBack", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver8peekBackE7int32_t", "priority": 1, "content": "Expected &lt; Entity &gt;  peekBack int32_t  index  =  0 Peeks into back stage at a specific index. Parameters index \u2013 The index of the entity to peek. Returns The peeked entity.", "keywords": []}, {"id": 772, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::peekBack::index", "display_name": "nvidia::gxf::Receiver::peekBack::index", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver8peekBackE7int32_t", "priority": 1, "content": "Expected &lt; Entity &gt;  peekBack int32_t  index  =  0 Peeks into back stage at a specific index. Parameters index \u2013 The index of the entity to peek. Returns The peeked entity.", "keywords": []}, {"id": 773, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::peek_back_abi", "display_name": "nvidia::gxf::Receiver::peek_back_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver13peek_back_abiEP9gxf_uid_t7int32_t", "priority": 1, "content": "virtual  gxf_result_t  peek_back_abi gxf_uid_t  * uid int32_t  index  =  0 Peeks into back stage at a specific index. Parameters uid \u2013 The UID of the entity at the index. index \u2013 The index of the entity to peek. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 774, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::peek_back_abi::index", "display_name": "nvidia::gxf::Receiver::peek_back_abi::index", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver13peek_back_abiEP9gxf_uid_t7int32_t", "priority": 1, "content": "virtual  gxf_result_t  peek_back_abi gxf_uid_t  * uid int32_t  index  =  0 Peeks into back stage at a specific index. Parameters uid \u2013 The UID of the entity at the index. index \u2013 The index of the entity to peek. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 775, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::peek_back_abi::uid", "display_name": "nvidia::gxf::Receiver::peek_back_abi::uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver13peek_back_abiEP9gxf_uid_t7int32_t", "priority": 1, "content": "virtual  gxf_result_t  peek_back_abi gxf_uid_t  * uid int32_t  index  =  0 Peeks into back stage at a specific index. Parameters uid \u2013 The UID of the entity at the index. index \u2013 The index of the entity to peek. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 776, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::receive", "display_name": "nvidia::gxf::Receiver::receive", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver7receiveEv", "priority": 1, "content": "Expected &lt; Entity &gt;  receive Receives the next entity from the main stage. Returns The received entity.", "keywords": []}, {"id": 777, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::receive_abi", "display_name": "nvidia::gxf::Receiver::receive_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver11receive_abiEP9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  receive_abi gxf_uid_t  * uid  =  0 Receives the next entity from the main stage. Parameters uid \u2013 The UID of the received entity. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 778, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::receive_abi::uid", "display_name": "nvidia::gxf::Receiver::receive_abi::uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver11receive_abiEP9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  receive_abi gxf_uid_t  * uid  =  0 Receives the next entity from the main stage. Parameters uid \u2013 The UID of the received entity. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 779, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::setTransmitter", "display_name": "nvidia::gxf::Receiver::setTransmitter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver14setTransmitterE6HandleI11TransmitterE", "priority": 1, "content": "Expected &lt; void &gt;  setTransmitter Handle &lt; Transmitter &gt;  tx Sets the transmitter to form a connection Parameters tx \u2013 Handle to a transmitter to connect to. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 780, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::setTransmitter::tx", "display_name": "nvidia::gxf::Receiver::setTransmitter::tx", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver14setTransmitterE6HandleI11TransmitterE", "priority": 1, "content": "Expected &lt; void &gt;  setTransmitter Handle &lt; Transmitter &gt;  tx Sets the transmitter to form a connection Parameters tx \u2013 Handle to a transmitter to connect to. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 781, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::sync", "display_name": "nvidia::gxf::Receiver::sync", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver4syncEv", "priority": 1, "content": "Expected &lt; void &gt;  sync Moves entities which recently arrived to the main stage. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 782, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::sync_abi", "display_name": "nvidia::gxf::Receiver::sync_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver8sync_abiEv", "priority": 1, "content": "virtual  gxf_result_t  sync_abi  =  0 Moves entities which recently arrived to the main stage. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 783, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::sync_io", "display_name": "nvidia::gxf::Receiver::sync_io", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver7sync_ioEv", "priority": 1, "content": "Expected &lt; void &gt;  sync_io Sync I/O. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 784, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::sync_io_abi", "display_name": "nvidia::gxf::Receiver::sync_io_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver11sync_io_abiEv", "priority": 1, "content": "virtual  gxf_result_t  sync_io_abi Syncs I/O. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 785, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::wait", "display_name": "nvidia::gxf::Receiver::wait", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver4waitEv", "priority": 1, "content": "Expected &lt; void &gt;  wait Wait for entities to arrive. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 786, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Receiver::wait_abi", "display_name": "nvidia::gxf::Receiver::wait_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf8Receiver8wait_abiEv", "priority": 1, "content": "virtual  gxf_result_t  wait_abi Waits for entities to arrive. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 787, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router", "display_name": "nvidia::gxf::Router", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6RouterE", "priority": 1, "content": "class  nvidia :: gxf :: Router A base class for objects which are routing messages in and out of entities.", "keywords": []}, {"id": 788, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::addNetworkContext", "display_name": "nvidia::gxf::Router::addNetworkContext", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router17addNetworkContextE6HandleI14NetworkContextE", "priority": 1, "content": "virtual  Expected &lt; void &gt;  addNetworkContext Handle &lt; NetworkContext &gt;  context  =  0 Sets the network context to be used by network router Parameters context \u2013 The network context to set. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 789, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::addNetworkContext::context", "display_name": "nvidia::gxf::Router::addNetworkContext::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router17addNetworkContextE6HandleI14NetworkContextE", "priority": 1, "content": "virtual  Expected &lt; void &gt;  addNetworkContext Handle &lt; NetworkContext &gt;  context  =  0 Sets the network context to be used by network router Parameters context \u2013 The network context to set. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 790, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::addRoutes", "display_name": "nvidia::gxf::Router::addRoutes", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router9addRoutesERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  addRoutes const  Entity  &amp; entity  =  0 Notifies the router about a new entity. This function is called when a new entity is added to the system. The router uses this function to set up any necessary routing for the entity\u2019s inbox and outbox. Parameters entity \u2013 The entity to add routes for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 791, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::addRoutes::entity", "display_name": "nvidia::gxf::Router::addRoutes::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router9addRoutesERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  addRoutes const  Entity  &amp; entity  =  0 Notifies the router about a new entity. This function is called when a new entity is added to the system. The router uses this function to set up any necessary routing for the entity\u2019s inbox and outbox. Parameters entity \u2013 The entity to add routes for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 792, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::removeRoutes", "display_name": "nvidia::gxf::Router::removeRoutes", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router12removeRoutesERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  removeRoutes const  Entity  &amp; entity  =  0 Notifies the router about the removal of an entity. This function is called when an entity is removed from the system. The router uses this function to clean up any routing that was set up for the entity\u2019s inbox and outbox. Parameters entity \u2013 The entity to remove routes for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 793, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::removeRoutes::entity", "display_name": "nvidia::gxf::Router::removeRoutes::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router12removeRoutesERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  removeRoutes const  Entity  &amp; entity  =  0 Notifies the router about the removal of an entity. This function is called when an entity is removed from the system. The router uses this function to clean up any routing that was set up for the entity\u2019s inbox and outbox. Parameters entity \u2013 The entity to remove routes for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 794, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::setClock", "display_name": "nvidia::gxf::Router::setClock", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router8setClockE6HandleI5ClockE", "priority": 1, "content": "virtual  Expected &lt; void &gt;  setClock Handle &lt; Clock &gt;  clock  =  0 Sets the clock to be used to for updating the pubtime while publishing messages Parameters clock \u2013 The clock to set. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 795, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::setClock::clock", "display_name": "nvidia::gxf::Router::setClock::clock", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router8setClockE6HandleI5ClockE", "priority": 1, "content": "virtual  Expected &lt; void &gt;  setClock Handle &lt; Clock &gt;  clock  =  0 Sets the clock to be used to for updating the pubtime while publishing messages Parameters clock \u2013 The clock to set. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 796, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::syncInbox", "display_name": "nvidia::gxf::Router::syncInbox", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router9syncInboxERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  syncInbox const  Entity  &amp; entity  =  0 Synchronizes the inbox of an entity and prepares it for execution. This function is called when an entity is scheduled for execution. The router uses this function to synchronize the entity\u2019s inbox, ensuring that any new messages are available for processing. Parameters entity \u2013 The entity to synchronize the inbox for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 797, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::syncInbox::entity", "display_name": "nvidia::gxf::Router::syncInbox::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router9syncInboxERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  syncInbox const  Entity  &amp; entity  =  0 Synchronizes the inbox of an entity and prepares it for execution. This function is called when an entity is scheduled for execution. The router uses this function to synchronize the entity\u2019s inbox, ensuring that any new messages are available for processing. Parameters entity \u2013 The entity to synchronize the inbox for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 798, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::syncOutbox", "display_name": "nvidia::gxf::Router::syncOutbox", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router10syncOutboxERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  syncOutbox const  Entity  &amp; entity  =  0 Synchronizes the outbox of an entity after successful execution Parameters entity \u2013 The entity to synchronize the outbox for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 799, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::syncOutbox::entity", "display_name": "nvidia::gxf::Router::syncOutbox::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router10syncOutboxERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  syncOutbox const  Entity  &amp; entity  =  0 Synchronizes the outbox of an entity after successful execution Parameters entity \u2013 The entity to synchronize the outbox for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 800, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::wait", "display_name": "nvidia::gxf::Router::wait", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router4waitERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  wait const  Entity  &amp; entity This function causes the router to wait until the entity\u2019s inbox has new messages. Parameters entity \u2013 The entity to wait for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 801, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Router::wait::entity", "display_name": "nvidia::gxf::Router::wait::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6Router4waitERK6Entity", "priority": 1, "content": "virtual  Expected &lt; void &gt;  wait const  Entity  &amp; entity This function causes the router to wait until the entity\u2019s inbox has new messages. Parameters entity \u2013 The entity to wait for. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 802, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Scheduler", "display_name": "nvidia::gxf::Scheduler", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9SchedulerE", "priority": 1, "content": "class  nvidia :: gxf :: Scheduler  :  public  System An interface which extends the nvidia::gxf::System interface to create schedulers which can execute codelets.", "keywords": []}, {"id": 803, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Scheduler::prepare_abi", "display_name": "nvidia::gxf::Scheduler::prepare_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Scheduler11prepare_abiEP14EntityExecutor", "priority": 1, "content": "virtual  gxf_result_t  prepare_abi EntityExecutor  * executor  =  0 Prepares the scheduler for execution by providing access to the entity executor Parameters executor \u2013 The entity executor to prepare for. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 804, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Scheduler::prepare_abi::executor", "display_name": "nvidia::gxf::Scheduler::prepare_abi::executor", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9Scheduler11prepare_abiEP14EntityExecutor", "priority": 1, "content": "virtual  gxf_result_t  prepare_abi EntityExecutor  * executor  =  0 Prepares the scheduler for execution by providing access to the entity executor Parameters executor \u2013 The entity executor to prepare for. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 805, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm", "display_name": "nvidia::gxf::SchedulingTerm", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTermE", "priority": 1, "content": "class  nvidia :: gxf :: SchedulingTerm Base class for scheduling terms. Scheduling terms are used by a scheduler to determine if codelets in an entity are ready for execution.", "keywords": []}, {"id": 806, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check", "display_name": "nvidia::gxf::SchedulingTerm::check", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm5checkE7int64_t", "priority": 1, "content": "Expected &lt; SchedulingCondition &gt;  check int64_t  timestamp Checks the scheduling condition and returns the result. Parameters timestamp \u2013 The current timestamp. Returns An expected scheduling condition if the function was executed successfully, an unexpected error otherwise.", "keywords": []}, {"id": 807, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check::timestamp", "display_name": "nvidia::gxf::SchedulingTerm::check::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm5checkE7int64_t", "priority": 1, "content": "Expected &lt; SchedulingCondition &gt;  check int64_t  timestamp Checks the scheduling condition and returns the result. Parameters timestamp \u2013 The current timestamp. Returns An expected scheduling condition if the function was executed successfully, an unexpected error otherwise.", "keywords": []}, {"id": 808, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check_abi", "display_name": "nvidia::gxf::SchedulingTerm::check_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf14SchedulingTerm9check_abiE7int64_tP23SchedulingConditionTypeP7int64_t", "priority": 1, "content": "virtual  gxf_result_t  check_abi int64_t  timestamp SchedulingConditionType  * type int64_t  * target_timestamp  const  =  0 Get the condition on which the scheduling waits before allowing execution. If the term is waiting for a time event, target_timestamp will contain the target timestamp. Parameters timestamp \u2013 The current timestamp. type \u2013 A pointer to a variable that will contain the scheduling condition type. target_timestamp \u2013 A pointer to a variable that will contain the target timestamp if the scheduling condition is waiting for a time event. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 809, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check_abi::target_timestamp", "display_name": "nvidia::gxf::SchedulingTerm::check_abi::target_timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf14SchedulingTerm9check_abiE7int64_tP23SchedulingConditionTypeP7int64_t", "priority": 1, "content": "virtual  gxf_result_t  check_abi int64_t  timestamp SchedulingConditionType  * type int64_t  * target_timestamp  const  =  0 Get the condition on which the scheduling waits before allowing execution. If the term is waiting for a time event, target_timestamp will contain the target timestamp. Parameters timestamp \u2013 The current timestamp. type \u2013 A pointer to a variable that will contain the scheduling condition type. target_timestamp \u2013 A pointer to a variable that will contain the target timestamp if the scheduling condition is waiting for a time event. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 810, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check_abi::timestamp", "display_name": "nvidia::gxf::SchedulingTerm::check_abi::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf14SchedulingTerm9check_abiE7int64_tP23SchedulingConditionTypeP7int64_t", "priority": 1, "content": "virtual  gxf_result_t  check_abi int64_t  timestamp SchedulingConditionType  * type int64_t  * target_timestamp  const  =  0 Get the condition on which the scheduling waits before allowing execution. If the term is waiting for a time event, target_timestamp will contain the target timestamp. Parameters timestamp \u2013 The current timestamp. type \u2013 A pointer to a variable that will contain the scheduling condition type. target_timestamp \u2013 A pointer to a variable that will contain the target timestamp if the scheduling condition is waiting for a time event. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 811, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::check_abi::type", "display_name": "nvidia::gxf::SchedulingTerm::check_abi::type", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4NK6nvidia3gxf14SchedulingTerm9check_abiE7int64_tP23SchedulingConditionTypeP7int64_t", "priority": 1, "content": "virtual  gxf_result_t  check_abi int64_t  timestamp SchedulingConditionType  * type int64_t  * target_timestamp  const  =  0 Get the condition on which the scheduling waits before allowing execution. If the term is waiting for a time event, target_timestamp will contain the target timestamp. Parameters timestamp \u2013 The current timestamp. type \u2013 A pointer to a variable that will contain the scheduling condition type. target_timestamp \u2013 A pointer to a variable that will contain the target timestamp if the scheduling condition is waiting for a time event. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 812, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::onExecute", "display_name": "nvidia::gxf::SchedulingTerm::onExecute", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm9onExecuteE7int64_t", "priority": 1, "content": "Expected &lt; void &gt;  onExecute int64_t  timestamp Called each time after the entity of this term was executed. Parameters timestamp \u2013 The current timestamp. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 813, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::onExecute::timestamp", "display_name": "nvidia::gxf::SchedulingTerm::onExecute::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm9onExecuteE7int64_t", "priority": 1, "content": "Expected &lt; void &gt;  onExecute int64_t  timestamp Called each time after the entity of this term was executed. Parameters timestamp \u2013 The current timestamp. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 814, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::onExecute_abi", "display_name": "nvidia::gxf::SchedulingTerm::onExecute_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm13onExecute_abiE7int64_t", "priority": 1, "content": "virtual  gxf_result_t  onExecute_abi int64_t  dt  =  0 Called each time after the entity of this term was executed. Parameters dt \u2013 The current timestamp. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 815, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::onExecute_abi::dt", "display_name": "nvidia::gxf::SchedulingTerm::onExecute_abi::dt", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm13onExecute_abiE7int64_t", "priority": 1, "content": "virtual  gxf_result_t  onExecute_abi int64_t  dt  =  0 Called each time after the entity of this term was executed. Parameters dt \u2013 The current timestamp. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 816, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::update_state_abi", "display_name": "nvidia::gxf::SchedulingTerm::update_state_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm16update_state_abiE7int64_t", "priority": 1, "content": "virtual  gxf_result_t  update_state_abi int64_t  timestamp Checks if the state of the scheduling term can be updated and updates it. Parameters timestamp \u2013 The current timestamp. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 817, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::update_state_abi::timestamp", "display_name": "nvidia::gxf::SchedulingTerm::update_state_abi::timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTerm16update_state_abiE7int64_t", "priority": 1, "content": "virtual  gxf_result_t  update_state_abi int64_t  timestamp Checks if the state of the scheduling term can be updated and updates it. Parameters timestamp \u2013 The current timestamp. Returns GXF_SUCCESS if the function was executed successfully, an error code otherwise.", "keywords": []}, {"id": 818, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::SchedulingTerm::~SchedulingTerm", "display_name": "nvidia::gxf::SchedulingTerm::~SchedulingTerm", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf14SchedulingTermD0Ev", "priority": 1, "content": "virtual  ~SchedulingTerm  =  default Destructor.", "keywords": []}, {"id": 819, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System", "display_name": "nvidia::gxf::System", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6SystemE", "priority": 1, "content": "class  nvidia :: gxf :: System Component interface for systems which are run as part of the application run cycle.", "keywords": []}, {"id": 820, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify", "display_name": "nvidia::gxf::System::event_notify", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12event_notifyE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 821, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify::eid", "display_name": "nvidia::gxf::System::event_notify::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12event_notifyE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 822, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify::event", "display_name": "nvidia::gxf::System::event_notify::event", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12event_notifyE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 823, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify_abi", "display_name": "nvidia::gxf::System::event_notify_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System16event_notify_abiE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify_abi gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 824, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify_abi::eid", "display_name": "nvidia::gxf::System::event_notify_abi::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System16event_notify_abiE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify_abi gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 825, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::event_notify_abi::event", "display_name": "nvidia::gxf::System::event_notify_abi::event", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System16event_notify_abiE9gxf_uid_t11gxf_event_t", "priority": 1, "content": "Expected &lt; void &gt;  event_notify_abi gxf_uid_t  eid gxf_event_t  event Notifies the system of an event. Parameters eid \u2013 The UID of the entity associated with the event. event \u2013 The event to notify the system of. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 826, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::runAsync", "display_name": "nvidia::gxf::System::runAsync", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System8runAsyncEv", "priority": 1, "content": "Expected &lt; void &gt;  runAsync Runs the system asynchronously. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 827, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::runAsync_abi", "display_name": "nvidia::gxf::System::runAsync_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12runAsync_abiEv", "priority": 1, "content": "virtual  gxf_result_t  runAsync_abi  =  0 Runs the system asynchronously. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 828, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::schedule", "display_name": "nvidia::gxf::System::schedule", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System8scheduleERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  schedule const  Entity  &amp; entity Schedules the given entity. Parameters entity \u2013 The entity to schedule. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 829, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::schedule::entity", "display_name": "nvidia::gxf::System::schedule::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System8scheduleERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  schedule const  Entity  &amp; entity Schedules the given entity. Parameters entity \u2013 The entity to schedule. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 830, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::schedule_abi", "display_name": "nvidia::gxf::System::schedule_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12schedule_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  schedule_abi gxf_uid_t  eid  =  0 Schedules the entity with the given UID. Parameters eid \u2013 The UID of the entity to schedule. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 831, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::schedule_abi::eid", "display_name": "nvidia::gxf::System::schedule_abi::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System12schedule_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  schedule_abi gxf_uid_t  eid  =  0 Schedules the entity with the given UID. Parameters eid \u2013 The UID of the entity to schedule. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 832, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::stop", "display_name": "nvidia::gxf::System::stop", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System4stopEv", "priority": 1, "content": "Expected &lt; void &gt;  stop Stops the system. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 833, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::stop_abi", "display_name": "nvidia::gxf::System::stop_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System8stop_abiEv", "priority": 1, "content": "virtual  gxf_result_t  stop_abi  =  0 Stops the system. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 834, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::unschedule", "display_name": "nvidia::gxf::System::unschedule", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System10unscheduleERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  unschedule const  Entity  &amp; entity Unschedules the given entity. Parameters entity \u2013 The entity to unschedule. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 835, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::unschedule::entity", "display_name": "nvidia::gxf::System::unschedule::entity", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System10unscheduleERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  unschedule const  Entity  &amp; entity Unschedules the given entity. Parameters entity \u2013 The entity to unschedule. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 836, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::unschedule_abi", "display_name": "nvidia::gxf::System::unschedule_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System14unschedule_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  unschedule_abi gxf_uid_t  eid  =  0 Unschedules the entity with the given UID. Parameters eid \u2013 The UID of the entity to unschedule. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 837, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::unschedule_abi::eid", "display_name": "nvidia::gxf::System::unschedule_abi::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System14unschedule_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  unschedule_abi gxf_uid_t  eid  =  0 Unschedules the entity with the given UID. Parameters eid \u2013 The UID of the entity to unschedule. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 838, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::wait", "display_name": "nvidia::gxf::System::wait", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System4waitEv", "priority": 1, "content": "Expected &lt; void &gt;  wait Waits for the system to complete. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 839, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::System::wait_abi", "display_name": "nvidia::gxf::System::wait_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf6System8wait_abiEv", "priority": 1, "content": "virtual  gxf_result_t  wait_abi  =  0 Waits for the system to complete execution. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 840, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter", "display_name": "nvidia::gxf::Transmitter", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11TransmitterE", "priority": 1, "content": "class  nvidia :: gxf :: Transmitter Interface for publishing entities.", "keywords": []}, {"id": 841, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::back_size", "display_name": "nvidia::gxf::Transmitter::back_size", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter9back_sizeEv", "priority": 1, "content": "size_t  back_size The total number of entities which have been published but are not yet on the main stage. Returns The number of entities in the back stage.", "keywords": []}, {"id": 842, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::back_size_abi", "display_name": "nvidia::gxf::Transmitter::back_size_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter13back_size_abiEv", "priority": 1, "content": "virtual  size_t  back_size_abi  =  0 The total number of entities which have previously been published and were moved out of the main stage. Returns The number of entities in the back stage.", "keywords": []}, {"id": 843, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::pop", "display_name": "nvidia::gxf::Transmitter::pop", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter3popEv", "priority": 1, "content": "Expected &lt; Entity &gt;  pop Pops the next entity. Returns The popped entity.", "keywords": []}, {"id": 844, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::pop_io", "display_name": "nvidia::gxf::Transmitter::pop_io", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter6pop_ioEv", "priority": 1, "content": "Expected &lt; void &gt;  pop_io Pops the next entity. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 845, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::pop_io_abi", "display_name": "nvidia::gxf::Transmitter::pop_io_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter10pop_io_abiEP9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  pop_io_abi gxf_uid_t  * uid Pops the next entity. Parameters uid \u2013 The UID of the popped entity. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 846, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::pop_io_abi::uid", "display_name": "nvidia::gxf::Transmitter::pop_io_abi::uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter10pop_io_abiEP9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  pop_io_abi gxf_uid_t  * uid Pops the next entity. Parameters uid \u2013 The UID of the popped entity. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 847, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish", "display_name": "nvidia::gxf::Transmitter::publish", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7publishER6EntityK7int64_t", "priority": 1, "content": "Expected &lt; void &gt;  publish Entity  &amp; other const  int64_t  acq_timestamp Publishes the given entity with the specified acquisition timestamp. Parameters other \u2013 The entity to publish. acq_timestamp \u2013 The acquisition timestamp of the entity. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 848, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish", "display_name": "nvidia::gxf::Transmitter::publish", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7publishERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  publish const  Entity  &amp; other Publishes the given entity. Parameters other \u2013 The entity to publish. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 849, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish::acq_timestamp", "display_name": "nvidia::gxf::Transmitter::publish::acq_timestamp", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7publishER6EntityK7int64_t", "priority": 1, "content": "Expected &lt; void &gt;  publish Entity  &amp; other const  int64_t  acq_timestamp Publishes the given entity with the specified acquisition timestamp. Parameters other \u2013 The entity to publish. acq_timestamp \u2013 The acquisition timestamp of the entity. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 850, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish::other", "display_name": "nvidia::gxf::Transmitter::publish::other", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7publishER6EntityK7int64_t", "priority": 1, "content": "Expected &lt; void &gt;  publish Entity  &amp; other const  int64_t  acq_timestamp Publishes the given entity with the specified acquisition timestamp. Parameters other \u2013 The entity to publish. acq_timestamp \u2013 The acquisition timestamp of the entity. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 851, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish::other", "display_name": "nvidia::gxf::Transmitter::publish::other", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7publishERK6Entity", "priority": 1, "content": "Expected &lt; void &gt;  publish const  Entity  &amp; other Publishes the given entity. Parameters other \u2013 The entity to publish. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 852, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish_abi", "display_name": "nvidia::gxf::Transmitter::publish_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter11publish_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  publish_abi gxf_uid_t  uid  =  0 Publishes the entity with the given UID. Parameters uid \u2013 The UID of the entity to publish. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 853, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::publish_abi::uid", "display_name": "nvidia::gxf::Transmitter::publish_abi::uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter11publish_abiE9gxf_uid_t", "priority": 1, "content": "virtual  gxf_result_t  publish_abi gxf_uid_t  uid  =  0 Publishes the entity with the given UID. Parameters uid \u2013 The UID of the entity to publish. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 854, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::sync", "display_name": "nvidia::gxf::Transmitter::sync", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter4syncEv", "priority": 1, "content": "Expected &lt; void &gt;  sync Moves entities which have been published to the main stage. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 855, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::sync_abi", "display_name": "nvidia::gxf::Transmitter::sync_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter8sync_abiEv", "priority": 1, "content": "virtual  gxf_result_t  sync_abi  =  0 Moves entities which have been published to the main stage. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 856, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::sync_io", "display_name": "nvidia::gxf::Transmitter::sync_io", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter7sync_ioEv", "priority": 1, "content": "Expected &lt; void &gt;  sync_io Syncs I/O. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 857, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::Transmitter::sync_io_abi", "display_name": "nvidia::gxf::Transmitter::sync_io_abi", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf11Transmitter11sync_io_abiEv", "priority": 1, "content": "virtual  gxf_result_t  sync_io_abi Sync I/O. Returns GXF_SUCCESS if successful, an error code otherwise.", "keywords": []}, {"id": 858, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkController", "display_name": "nvidia::gxf::benchmark::BenchmarkController", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark19BenchmarkControllerE", "priority": 1, "content": "class  nvidia :: gxf :: benchmark :: BenchmarkController A benchmark controller that governs the entire benchmark flow", "keywords": []}, {"id": 859, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisherE", "priority": 1, "content": "class  nvidia :: gxf :: benchmark :: BenchmarkPublisher A benchmark publisher that publishes buffered benchmark messages", "keywords": []}, {"id": 860, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::clearRecordedTimestamps", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::clearRecordedTimestamps", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher23clearRecordedTimestampsEv", "priority": 1, "content": "void  clearRecordedTimestamps ; Clear the runtime state. Calling this fucntion is sufficient to reset state for a new benchmark iteration", "keywords": []}, {"id": 861, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::getAsyncSchedulingterm", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::getAsyncSchedulingterm", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher22getAsyncSchedulingtermEv", "priority": 1, "content": "gxf :: Handle &lt; gxf :: AsynchronousSchedulingTerm &gt;  getAsyncSchedulingterm ; Getter of the associated async scheduling term Returns gxf::Handle&lt;gxf::AsynchronousSchedulingTerm&gt; Valid handle or error code on failure", "keywords": []}, {"id": 862, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::getEntityBuffer", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::getEntityBuffer", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher15getEntityBufferEv", "priority": 1, "content": "gxf :: Handle &lt; EntityBuffer &gt;  getEntityBuffer Getter of the underlying entity buffer component Returns gxf::Handle&lt;EntityBuffer&gt; Valid handle or error code on failure", "keywords": []}, {"id": 863, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::getPublishedTimestamps", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::getPublishedTimestamps", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher22getPublishedTimestampsEv", "priority": 1, "content": "std :: vector &lt; std :: chrono :: nanoseconds &gt;  &amp; getPublishedTimestamps ; Getter of the recorded published timestamps Returns std::vector&lt;std::chrono::nanoseconds&gt; Vector of published timestamps", "keywords": []}, {"id": 864, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::setNumOfMessagesToPublish", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::setNumOfMessagesToPublish", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher25setNumOfMessagesToPublishE8uint64_t", "priority": 1, "content": "void  setNumOfMessagesToPublish uint64_t  num_of_messages_to_publish ; Setter of the number of benchmark messages to publish Parameters num_of_messages_to_publish \u2013 No of messages to publish. 0 means no limit", "keywords": []}, {"id": 865, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkPublisher::setNumOfMessagesToPublish::num_of_messages_to_publish", "display_name": "nvidia::gxf::benchmark::BenchmarkPublisher::setNumOfMessagesToPublish::num_of_messages_to_publish", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark18BenchmarkPublisher25setNumOfMessagesToPublishE8uint64_t", "priority": 1, "content": "void  setNumOfMessagesToPublish uint64_t  num_of_messages_to_publish ; Setter of the number of benchmark messages to publish Parameters num_of_messages_to_publish \u2013 No of messages to publish. 0 means no limit", "keywords": []}, {"id": 866, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink", "display_name": "nvidia::gxf::benchmark::BenchmarkSink", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSinkE", "priority": 1, "content": "class  nvidia :: gxf :: benchmark :: BenchmarkSink A benchmark sink that records message arrival timestamps", "keywords": []}, {"id": 867, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::begin", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::begin", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink5beginEv", "priority": 1, "content": "gxf :: Expected &lt; void &gt;  begin  override ; Signal the start of a benchmark iteration Return", "keywords": []}, {"id": 868, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::clearRecordedTimestamps", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::clearRecordedTimestamps", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink23clearRecordedTimestampsEv", "priority": 1, "content": "void  clearRecordedTimestamps  override ; Clear the runtime state Calling this fucntion is sufficient to reset state for a new benchmark iteration", "keywords": []}, {"id": 869, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::compute", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::compute", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink7computeEv", "priority": 1, "content": "gxf :: Expected &lt; nlohmann :: json &gt;  compute  override ; Compute performance outcome for the recorded timestamps. The results are expected to be buffered in the associated perf calculators. Return", "keywords": []}, {"id": 870, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::conclude", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::conclude", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink8concludeEv", "priority": 1, "content": "nlohmann :: json  conclude  override ; Conclude the performance results from the associated perf calculators Return", "keywords": []}, {"id": 871, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::end", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::end", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink3endEv", "priority": 1, "content": "gxf :: Expected &lt; void &gt;  end  override ; Signal the end of a benchmark iteration Return", "keywords": []}, {"id": 872, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::getPerformanceCalculators", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::getPerformanceCalculators", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink25getPerformanceCalculatorsEv", "priority": 1, "content": "gxf :: Expected &lt; std :: vector &lt; gxf :: Handle &lt; PerformanceCalculatorBase &gt; &gt; &gt;  getPerformanceCalculators  override ; Getter of the associated performance calculator component handles Return gxf::Expected&lt;std::vector&lt;gxf::Handle&lt;PerformanceCalculatorBase&gt;&gt;&gt;", "keywords": []}, {"id": 873, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::getReceivedTimestamps", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::getReceivedTimestamps", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink21getReceivedTimestampsEv", "priority": 1, "content": "std :: vector &lt; std :: chrono :: nanoseconds &gt;  &amp; getReceivedTimestamps  override ; Getter of the recorded received timestamps Return", "keywords": []}, {"id": 874, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "cpp", "name": "nvidia::gxf::benchmark::BenchmarkSink::reset", "display_name": "nvidia::gxf::benchmark::BenchmarkSink::reset", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "_CPPv4N6nvidia3gxf9benchmark13BenchmarkSink5resetEv", "priority": 1, "content": "gxf :: Expected &lt; void &gt;  reset  override ; Reset states of the benchmark sink and the associated perf calculators Return", "keywords": []}, {"id": 875, "doc_id": 875, "filename": "graphtools-docs/docs/text/GXF_Component_Interfaces.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_Component_Interfaces", "display_name": "GXF Component Interfaces", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_Component_Interfaces", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 876, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter", "display_name": "Parameter", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0E9Parameter", "priority": 1, "content": "template &lt; typename  T &gt; class  Parameter A parameter is a value that can be configured and accessed by a component. It provides a type-safe and convenient way to manage component attributes.", "keywords": []}, {"id": 877, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::Parameter", "display_name": "Parameter::Parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter9ParameterERK9Parameter", "priority": 1, "content": "Parameter const  Parameter  &amp; other Copy constructor. Parameters other \u2013 The parameter to copy. Returns A copy of the other parameter.", "keywords": []}, {"id": 878, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::Parameter", "display_name": "Parameter::Parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter9ParameterEv", "priority": 1, "content": "Parameter Default constructor. Creates an uninitialized parameter. Returns An uninitialized parameter.", "keywords": []}, {"id": 879, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::Parameter::other", "display_name": "Parameter::Parameter::other", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter9ParameterERK9Parameter", "priority": 1, "content": "Parameter const  Parameter  &amp; other Copy constructor. Parameters other \u2013 The parameter to copy. Returns A copy of the other parameter.", "keywords": []}, {"id": 880, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::T", "display_name": "Parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0E9Parameter", "priority": 1, "content": "template &lt; typename  T &gt; class  Parameter A parameter is a value that can be configured and accessed by a component. It provides a type-safe and convenient way to manage component attributes.", "keywords": []}, {"id": 881, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::connect", "display_name": "Parameter::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter7connectEP16ParameterBackendI1TE", "priority": 1, "content": "void  connect ParameterBackend &lt; T &gt;  * backend Connects the parameter to a backend. The backend is responsible for managing the parameter value and providing access to it. Parameters backend \u2013 The backend to connect to.", "keywords": []}, {"id": 882, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::connect::backend", "display_name": "Parameter::connect::backend", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter7connectEP16ParameterBackendI1TE", "priority": 1, "content": "void  connect ParameterBackend &lt; T &gt;  * backend Connects the parameter to a backend. The backend is responsible for managing the parameter value and providing access to it. Parameters backend \u2013 The backend to connect to.", "keywords": []}, {"id": 883, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::get", "display_name": "Parameter::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK9Parameter3getEv", "priority": 1, "content": "const  T  &amp; get  const Gets the current parameter value. Only valid if the parameter is marked as \u2018mandatory\u2019 in the parameter interface. Otherwise an assert will be raised. Returns A const reference to the current value of the parameter.", "keywords": []}, {"id": 884, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::key", "display_name": "Parameter::key", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK9Parameter3keyEv", "priority": 1, "content": "const  char  * key  const Returns the key of the parameter. The key is a string that identifies the parameter and is used to look it up in the parameter storage. Returns The key of the parameter.", "keywords": []}, {"id": 885, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::operator const T&", "display_name": "Parameter::operator const T&", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK9ParametercvRK1TEv", "priority": 1, "content": "operator  const  T &amp;  const Convenience function for accessing a mandatory parameter as a const reference. Returns A const reference to the current value of the parameter.", "keywords": []}, {"id": 886, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::set", "display_name": "Parameter::set", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter3setE1T", "priority": 1, "content": "Expected &lt; void &gt;  set T  value Sets the current value of the parameter. If the value is invalid, returns an Unexpected with an error code. Parameters value \u2013 The new value of the parameter. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 887, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::set::value", "display_name": "Parameter::set::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter3setE1T", "priority": 1, "content": "Expected &lt; void &gt;  set T  value Sets the current value of the parameter. If the value is invalid, returns an Unexpected with an error code. Parameters value \u2013 The new value of the parameter. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 888, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::set_without_propagate", "display_name": "Parameter::set_without_propagate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter21set_without_propagateE1T", "priority": 1, "content": "Expected &lt; void &gt;  set_without_propagate T  value Sets the current value of the parameter without propagating the change to the backend. This function should only be used by the ParameterBackend class. Parameters value \u2013 The new value of the parameter. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 889, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::set_without_propagate::value", "display_name": "Parameter::set_without_propagate::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N9Parameter21set_without_propagateE1T", "priority": 1, "content": "Expected &lt; void &gt;  set_without_propagate T  value Sets the current value of the parameter without propagating the change to the backend. This function should only be used by the ParameterBackend class. Parameters value \u2013 The new value of the parameter. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 890, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "Parameter::try_get", "display_name": "Parameter::try_get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK9Parameter7try_getEv", "priority": 1, "content": "Expected &lt; T &gt;  try_get  const Tries to get the current value of the parameter. If the parameter is not set or has an error value, returns an Unexpected with an error code. Returns The current value of the parameter, or an Unexpected with an error code.", "keywords": []}, {"id": 891, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser", "display_name": "ParameterParser", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv415ParameterParser", "priority": 1, "content": "struct  ParameterParser", "keywords": []}, {"id": 892, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse", "display_name": "ParameterParser::Parse", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 893, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::T", "display_name": "ParameterParser::Parse::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 894, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::V", "display_name": "ParameterParser::Parse::V", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 895, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::component_uid", "display_name": "ParameterParser::Parse::component_uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 896, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::context", "display_name": "ParameterParser::Parse::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 897, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::key", "display_name": "ParameterParser::Parse::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 898, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::node", "display_name": "ParameterParser::Parse::node", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 899, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterParser::Parse::prefix", "display_name": "ParameterParser::Parse::prefix", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN15ParameterParser5ParseE8ExpectedI1TE13gxf_context_t9gxf_uid_tPKcRKN4YAML4NodeERKNSt6stringE", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  Expected &lt; T &gt;  Parse gxf_context_t  context gxf_uid_t  component_uid const  char  * key const  YAML :: Node  &amp; node const  std :: string  &amp; prefix Parses a parameter of type T from a YAML node. Parameters context \u2013 The GXF context. component_uid \u2013 The unique identifier of the component. key \u2013 The key of the parameter. node \u2013 The YAML node to parse. prefix \u2013 The prefix to use when looking up entities. Returns An Expected containing the parsed parameter or an error code.", "keywords": []}, {"id": 900, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper", "display_name": "ParameterWrapper", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv416ParameterWrapper", "priority": 1, "content": "struct  ParameterWrapper", "keywords": []}, {"id": 901, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper::Wrap", "display_name": "ParameterWrapper::Wrap", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN16ParameterWrapper4WrapEN12ExpectedYAML4NodeE13gxf_context_tRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  ExpectedYAML :: Node  Wrap gxf_context_t  context const  T  &amp; value Wraps a value of type T in a YAML node. Parameters context \u2013 The GXF context. value \u2013 The value to wrap. Returns An Expected containing the YAML node or an error code. Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameter Example // Mode switch enum struct MyEnum { kValue0 = 0, kValue1 = 1, }; // Custom parameter parser for MyEnum template &lt;&gt; struct ParameterParser&lt;MyEnum&gt; { static Expected&lt;MyEnum&gt; Parse(gxf_context_t context, gxf_uid_t component_uid, const char* key, const YAML::Node&amp; node, const std::string&amp; prefix) { const std::string value = node.as&lt;std::string&gt;(); if (strcmp(value.c_str(), &quot;Value0&quot;) == 0) { return MyEnum::kValue0; } if (strcmp(value.c_str(), &quot;Value1&quot;) == 0) { return MyEnum::kValue1; } return Unexpected{GXF_ARGUMENT_OUT_OF_RANGE}; } }; // Custom parameter wrapper for MyEnum template&lt;&gt; struct ParameterWrapper&lt;MyEnum&gt; { static Expected&lt;YAML::Node&gt; Wrap(gxf_context_t context, const MyEnum&amp; value) { YAML::Node node(YAML::NodeType::Scalar); switch (value) { case MyEnum::kValue0: { node = std::string(&quot;Value0&quot;); break; } case MyEnum::kValue1: { node = std::string(&quot;Value1&quot;); break; } default: return Unexpected{GXF_PARAMETER_OUT_OF_RANGE}; } return node; } };", "keywords": []}, {"id": 902, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper::Wrap::T", "display_name": "ParameterWrapper::Wrap::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN16ParameterWrapper4WrapEN12ExpectedYAML4NodeE13gxf_context_tRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  ExpectedYAML :: Node  Wrap gxf_context_t  context const  T  &amp; value Wraps a value of type T in a YAML node. Parameters context \u2013 The GXF context. value \u2013 The value to wrap. Returns An Expected containing the YAML node or an error code. Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameter Example // Mode switch enum struct MyEnum { kValue0 = 0, kValue1 = 1, }; // Custom parameter parser for MyEnum template &lt;&gt; struct ParameterParser&lt;MyEnum&gt; { static Expected&lt;MyEnum&gt; Parse(gxf_context_t context, gxf_uid_t component_uid, const char* key, const YAML::Node&amp; node, const std::string&amp; prefix) { const std::string value = node.as&lt;std::string&gt;(); if (strcmp(value.c_str(), &quot;Value0&quot;) == 0) { return MyEnum::kValue0; } if (strcmp(value.c_str(), &quot;Value1&quot;) == 0) { return MyEnum::kValue1; } return Unexpected{GXF_ARGUMENT_OUT_OF_RANGE}; } }; // Custom parameter wrapper for MyEnum template&lt;&gt; struct ParameterWrapper&lt;MyEnum&gt; { static Expected&lt;YAML::Node&gt; Wrap(gxf_context_t context, const MyEnum&amp; value) { YAML::Node node(YAML::NodeType::Scalar); switch (value) { case MyEnum::kValue0: { node = std::string(&quot;Value0&quot;); break; } case MyEnum::kValue1: { node = std::string(&quot;Value1&quot;); break; } default: return Unexpected{GXF_PARAMETER_OUT_OF_RANGE}; } return node; } };", "keywords": []}, {"id": 903, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper::Wrap::V", "display_name": "ParameterWrapper::Wrap::V", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN16ParameterWrapper4WrapEN12ExpectedYAML4NodeE13gxf_context_tRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  ExpectedYAML :: Node  Wrap gxf_context_t  context const  T  &amp; value Wraps a value of type T in a YAML node. Parameters context \u2013 The GXF context. value \u2013 The value to wrap. Returns An Expected containing the YAML node or an error code. Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameter Example // Mode switch enum struct MyEnum { kValue0 = 0, kValue1 = 1, }; // Custom parameter parser for MyEnum template &lt;&gt; struct ParameterParser&lt;MyEnum&gt; { static Expected&lt;MyEnum&gt; Parse(gxf_context_t context, gxf_uid_t component_uid, const char* key, const YAML::Node&amp; node, const std::string&amp; prefix) { const std::string value = node.as&lt;std::string&gt;(); if (strcmp(value.c_str(), &quot;Value0&quot;) == 0) { return MyEnum::kValue0; } if (strcmp(value.c_str(), &quot;Value1&quot;) == 0) { return MyEnum::kValue1; } return Unexpected{GXF_ARGUMENT_OUT_OF_RANGE}; } }; // Custom parameter wrapper for MyEnum template&lt;&gt; struct ParameterWrapper&lt;MyEnum&gt; { static Expected&lt;YAML::Node&gt; Wrap(gxf_context_t context, const MyEnum&amp; value) { YAML::Node node(YAML::NodeType::Scalar); switch (value) { case MyEnum::kValue0: { node = std::string(&quot;Value0&quot;); break; } case MyEnum::kValue1: { node = std::string(&quot;Value1&quot;); break; } default: return Unexpected{GXF_PARAMETER_OUT_OF_RANGE}; } return node; } };", "keywords": []}, {"id": 904, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper::Wrap::context", "display_name": "ParameterWrapper::Wrap::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN16ParameterWrapper4WrapEN12ExpectedYAML4NodeE13gxf_context_tRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  ExpectedYAML :: Node  Wrap gxf_context_t  context const  T  &amp; value Wraps a value of type T in a YAML node. Parameters context \u2013 The GXF context. value \u2013 The value to wrap. Returns An Expected containing the YAML node or an error code. Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameter Example // Mode switch enum struct MyEnum { kValue0 = 0, kValue1 = 1, }; // Custom parameter parser for MyEnum template &lt;&gt; struct ParameterParser&lt;MyEnum&gt; { static Expected&lt;MyEnum&gt; Parse(gxf_context_t context, gxf_uid_t component_uid, const char* key, const YAML::Node&amp; node, const std::string&amp; prefix) { const std::string value = node.as&lt;std::string&gt;(); if (strcmp(value.c_str(), &quot;Value0&quot;) == 0) { return MyEnum::kValue0; } if (strcmp(value.c_str(), &quot;Value1&quot;) == 0) { return MyEnum::kValue1; } return Unexpected{GXF_ARGUMENT_OUT_OF_RANGE}; } }; // Custom parameter wrapper for MyEnum template&lt;&gt; struct ParameterWrapper&lt;MyEnum&gt; { static Expected&lt;YAML::Node&gt; Wrap(gxf_context_t context, const MyEnum&amp; value) { YAML::Node node(YAML::NodeType::Scalar); switch (value) { case MyEnum::kValue0: { node = std::string(&quot;Value0&quot;); break; } case MyEnum::kValue1: { node = std::string(&quot;Value1&quot;); break; } default: return Unexpected{GXF_PARAMETER_OUT_OF_RANGE}; } return node; } };", "keywords": []}, {"id": 905, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "ParameterWrapper::Wrap::value", "display_name": "ParameterWrapper::Wrap::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN16ParameterWrapper4WrapEN12ExpectedYAML4NodeE13gxf_context_tRK1T", "priority": 1, "content": "template &lt; typename  T ,  typename  V  =  void &gt; static  ExpectedYAML :: Node  Wrap gxf_context_t  context const  T  &amp; value Wraps a value of type T in a YAML node. Parameters context \u2013 The GXF context. value \u2013 The value to wrap. Returns An Expected containing the YAML node or an error code. Here is an example to adapt ParameterParser and ParameterWrapper to create an enum parameter Example // Mode switch enum struct MyEnum { kValue0 = 0, kValue1 = 1, }; // Custom parameter parser for MyEnum template &lt;&gt; struct ParameterParser&lt;MyEnum&gt; { static Expected&lt;MyEnum&gt; Parse(gxf_context_t context, gxf_uid_t component_uid, const char* key, const YAML::Node&amp; node, const std::string&amp; prefix) { const std::string value = node.as&lt;std::string&gt;(); if (strcmp(value.c_str(), &quot;Value0&quot;) == 0) { return MyEnum::kValue0; } if (strcmp(value.c_str(), &quot;Value1&quot;) == 0) { return MyEnum::kValue1; } return Unexpected{GXF_ARGUMENT_OUT_OF_RANGE}; } }; // Custom parameter wrapper for MyEnum template&lt;&gt; struct ParameterWrapper&lt;MyEnum&gt; { static Expected&lt;YAML::Node&gt; Wrap(gxf_context_t context, const MyEnum&amp; value) { YAML::Node node(YAML::NodeType::Scalar); switch (value) { case MyEnum::kValue0: { node = std::string(&quot;Value0&quot;); break; } case MyEnum::kValue1: { node = std::string(&quot;Value1&quot;); break; } default: return Unexpected{GXF_PARAMETER_OUT_OF_RANGE}; } return node; } };", "keywords": []}, {"id": 906, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component", "display_name": "nvidia::gxf::Component", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentE", "priority": 1, "content": "class  nvidia :: gxf :: Component Components are parts of an entity and provide their functionality. The Component class is the base class of all GXF components. It provides a common interface for creating and managing components in a GXF entity.", "keywords": []}, {"id": 907, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::Component", "display_name": "nvidia::gxf::Component::Component", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component9ComponentERK9Component", "priority": 1, "content": "Component const  Component  &amp; component  =  delete ; Delete copy constructor. This constructor is deleted to prevent copying of Components.", "keywords": []}, {"id": 908, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::Component", "display_name": "nvidia::gxf::Component::Component", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component9ComponentERR9Component", "priority": 1, "content": "Component Component  &amp; &amp; component  =  delete ; Delete move constructor. This constructor is deleted to prevent moving Components.", "keywords": []}, {"id": 909, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::Component::component", "display_name": "nvidia::gxf::Component::Component::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component9ComponentERK9Component", "priority": 1, "content": "Component const  Component  &amp; component  =  delete ; Delete copy constructor. This constructor is deleted to prevent copying of Components.", "keywords": []}, {"id": 910, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::Component::component", "display_name": "nvidia::gxf::Component::Component::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component9ComponentERR9Component", "priority": 1, "content": "Component Component  &amp; &amp; component  =  delete ; Delete move constructor. This constructor is deleted to prevent moving Components.", "keywords": []}, {"id": 911, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::cid", "display_name": "nvidia::gxf::Component::cid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component3cidEv", "priority": 1, "content": "gxf_uid_t  cid  const  noexcept ; Get the component ID of the component.", "keywords": []}, {"id": 912, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::context", "display_name": "nvidia::gxf::Component::context", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component7contextEv", "priority": 1, "content": "gxf_context_t  context  const  noexcept ; Get the context of the component.", "keywords": []}, {"id": 913, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::deinitialize", "display_name": "nvidia::gxf::Component::deinitialize", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component12deinitializeEv", "priority": 1, "content": "virtual  gxf_result_t  deinitialize  =  0 ; Use to end the lifetime of a component and should be used instead of the deconstructor. The order in which components within the same entity are deinitialized is undefined.", "keywords": []}, {"id": 914, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::eid", "display_name": "nvidia::gxf::Component::eid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component3eidEv", "priority": 1, "content": "gxf_uid_t  eid  const  noexcept ; Get the entity ID of the component.", "keywords": []}, {"id": 915, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::entity", "display_name": "nvidia::gxf::Component::entity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component6entityEv", "priority": 1, "content": "Entity  entity  const  noexcept ; Get the entity which owns this component.", "keywords": []}, {"id": 916, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParameter", "display_name": "nvidia::gxf::Component::getParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12getParameterE8ExpectedI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; T &gt;  getParameter const  char  * key ; Query the value of a component parameter with the given \u201ckey\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration Returns A value of type T for valid key or error code on failure", "keywords": []}, {"id": 917, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParameter::T", "display_name": "nvidia::gxf::Component::getParameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12getParameterE8ExpectedI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; T &gt;  getParameter const  char  * key ; Query the value of a component parameter with the given \u201ckey\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration Returns A value of type T for valid key or error code on failure", "keywords": []}, {"id": 918, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParameter::key", "display_name": "nvidia::gxf::Component::getParameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12getParameterE8ExpectedI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; T &gt;  getParameter const  char  * key ; Query the value of a component parameter with the given \u201ckey\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration Returns A value of type T for valid key or error code on failure", "keywords": []}, {"id": 919, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParameterInfo", "display_name": "nvidia::gxf::Component::getParameterInfo", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component16getParameterInfoEPKc", "priority": 1, "content": "Expected &lt; ParameterRegistrar :: ComponentParameterInfo &gt;  getParameterInfo const  char  * key ; Query ComponentParameterInfo of parameter \u201ckey\u201d.", "keywords": []}, {"id": 920, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParameterInfo::key", "display_name": "nvidia::gxf::Component::getParameterInfo::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component16getParameterInfoEPKc", "priority": 1, "content": "Expected &lt; ParameterRegistrar :: ComponentParameterInfo &gt;  getParameterInfo const  char  * key ; Query ComponentParameterInfo of parameter \u201ckey\u201d.", "keywords": []}, {"id": 921, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParametersOfType", "display_name": "nvidia::gxf::Component::getParametersOfType", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component19getParametersOfTypeE8ExpectedINSt6vectorIN18ParameterRegistrar22ComponentParameterInfoEEEEv", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; std :: vector &lt; ParameterRegistrar :: ComponentParameterInfo &gt; &gt;  getParametersOfType ; Query all parameters in the component of type T and return their ComponentParameterInfo struct. Returns A vector of ComponentParameterInfo of parameters of given type", "keywords": []}, {"id": 922, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::getParametersOfType::T", "display_name": "nvidia::gxf::Component::getParametersOfType::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component19getParametersOfTypeE8ExpectedINSt6vectorIN18ParameterRegistrar22ComponentParameterInfoEEEEv", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; std :: vector &lt; ParameterRegistrar :: ComponentParameterInfo &gt; &gt;  getParametersOfType ; Query all parameters in the component of type T and return their ComponentParameterInfo struct. Returns A vector of ComponentParameterInfo of parameters of given type", "keywords": []}, {"id": 923, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::initialize", "display_name": "nvidia::gxf::Component::initialize", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component10initializeEv", "priority": 1, "content": "virtual  gxf_result_t  initialize  =  0 ; Use to start the lifetime of a component and should be used instead of the constructor. Called after all components of an entity are created. The order in which components within the same entity are initialized is undefined.", "keywords": []}, {"id": 924, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::internalSetup", "display_name": "nvidia::gxf::Component::internalSetup", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13internalSetupE13gxf_context_t9gxf_uid_t9gxf_uid_tP9Registrar", "priority": 1, "content": "void  internalSetup gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid Registrar  * registrar ; This function shall only be called by GXF and is used to setup the component.", "keywords": []}, {"id": 925, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::internalSetup::cid", "display_name": "nvidia::gxf::Component::internalSetup::cid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13internalSetupE13gxf_context_t9gxf_uid_t9gxf_uid_tP9Registrar", "priority": 1, "content": "void  internalSetup gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid Registrar  * registrar ; This function shall only be called by GXF and is used to setup the component.", "keywords": []}, {"id": 926, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::internalSetup::context", "display_name": "nvidia::gxf::Component::internalSetup::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13internalSetupE13gxf_context_t9gxf_uid_t9gxf_uid_tP9Registrar", "priority": 1, "content": "void  internalSetup gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid Registrar  * registrar ; This function shall only be called by GXF and is used to setup the component.", "keywords": []}, {"id": 927, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::internalSetup::eid", "display_name": "nvidia::gxf::Component::internalSetup::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13internalSetupE13gxf_context_t9gxf_uid_t9gxf_uid_tP9Registrar", "priority": 1, "content": "void  internalSetup gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid Registrar  * registrar ; This function shall only be called by GXF and is used to setup the component.", "keywords": []}, {"id": 928, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::internalSetup::registrar", "display_name": "nvidia::gxf::Component::internalSetup::registrar", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13internalSetupE13gxf_context_t9gxf_uid_t9gxf_uid_tP9Registrar", "priority": 1, "content": "void  internalSetup gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid Registrar  * registrar ; This function shall only be called by GXF and is used to setup the component.", "keywords": []}, {"id": 929, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::name", "display_name": "nvidia::gxf::Component::name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component4nameEv", "priority": 1, "content": "const  char  * name  const  noexcept ; Get the name of the component.", "keywords": []}, {"id": 930, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::operator=", "display_name": "nvidia::gxf::Component::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentaSERK9Component", "priority": 1, "content": "Component  &amp; operator = const  Component  &amp; component  =  delete ; Delete copy assignment operator. This operator is deleted to prevent copying of Components.", "keywords": []}, {"id": 931, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::operator=", "display_name": "nvidia::gxf::Component::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentaSERR9Component", "priority": 1, "content": "Component  &amp; operator = Component  &amp; &amp; component  =  delete ; Delete move assignment operator. This operator is deleted to prevent moving Components.", "keywords": []}, {"id": 932, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::operator=::component", "display_name": "nvidia::gxf::Component::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentaSERK9Component", "priority": 1, "content": "Component  &amp; operator = const  Component  &amp; component  =  delete ; Delete copy assignment operator. This operator is deleted to prevent copying of Components.", "keywords": []}, {"id": 933, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::operator=::component", "display_name": "nvidia::gxf::Component::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentaSERR9Component", "priority": 1, "content": "Component  &amp; operator = Component  &amp; &amp; component  =  delete ; Delete move assignment operator. This operator is deleted to prevent moving Components.", "keywords": []}, {"id": 934, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::parseParameter", "display_name": "nvidia::gxf::Component::parseParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component14parseParameterEPKcRKN4YAML4NodeENSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  parseParameter const  char  * key const  YAML :: Node  &amp; node std :: string  prefix  =  &quot;&quot; ; Set the parameter \u201ckey\u201d with the value in yaml node. Parameters key \u2013 A unique string value used during component registration node \u2013 A yaml node with parameter value prefix \u2013 entity prefix string Returns Success or error code on failure", "keywords": []}, {"id": 935, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::parseParameter::key", "display_name": "nvidia::gxf::Component::parseParameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component14parseParameterEPKcRKN4YAML4NodeENSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  parseParameter const  char  * key const  YAML :: Node  &amp; node std :: string  prefix  =  &quot;&quot; ; Set the parameter \u201ckey\u201d with the value in yaml node. Parameters key \u2013 A unique string value used during component registration node \u2013 A yaml node with parameter value prefix \u2013 entity prefix string Returns Success or error code on failure", "keywords": []}, {"id": 936, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::parseParameter::node", "display_name": "nvidia::gxf::Component::parseParameter::node", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component14parseParameterEPKcRKN4YAML4NodeENSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  parseParameter const  char  * key const  YAML :: Node  &amp; node std :: string  prefix  =  &quot;&quot; ; Set the parameter \u201ckey\u201d with the value in yaml node. Parameters key \u2013 A unique string value used during component registration node \u2013 A yaml node with parameter value prefix \u2013 entity prefix string Returns Success or error code on failure", "keywords": []}, {"id": 937, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::parseParameter::prefix", "display_name": "nvidia::gxf::Component::parseParameter::prefix", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component14parseParameterEPKcRKN4YAML4NodeENSt6stringE", "priority": 1, "content": "Expected &lt; void &gt;  parseParameter const  char  * key const  YAML :: Node  &amp; node std :: string  prefix  =  &quot;&quot; ; Set the parameter \u201ckey\u201d with the value in yaml node. Parameters key \u2013 A unique string value used during component registration node \u2013 A yaml node with parameter value prefix \u2013 entity prefix string Returns Success or error code on failure", "keywords": []}, {"id": 938, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::registerInterface", "display_name": "nvidia::gxf::Component::registerInterface", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component17registerInterfaceEP9Registrar", "priority": 1, "content": "virtual  gxf_result_t  registerInterface Registrar  * registrar  =  0 ; Used to register all parameters of the components. Do not use this function for other purposes as it might be called at anytime by the runtime. Example class Foo : public Component { public: gxf_result_t registerInterface(Registrar* registrar) override { registrar-&gt;parameter(count_, &quot;count&quot;, 1); } Parameter&lt;int&gt; count_; }; The registerInterface() function is used to register the parameters of a component. It takes a pointer to a Registrar object as an argument and registers all the parameters of the component using one of the overloaded parameter api\u2019s. The api supports multiple arguments which include the name of the parameter, unique key identifier, strings for headline and description of the parameter and also its default value.", "keywords": []}, {"id": 939, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::registerInterface::registrar", "display_name": "nvidia::gxf::Component::registerInterface::registrar", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component17registerInterfaceEP9Registrar", "priority": 1, "content": "virtual  gxf_result_t  registerInterface Registrar  * registrar  =  0 ; Used to register all parameters of the components. Do not use this function for other purposes as it might be called at anytime by the runtime. Example class Foo : public Component { public: gxf_result_t registerInterface(Registrar* registrar) override { registrar-&gt;parameter(count_, &quot;count&quot;, 1); } Parameter&lt;int&gt; count_; }; The registerInterface() function is used to register the parameters of a component. It takes a pointer to a Registrar object as an argument and registers all the parameters of the component using one of the overloaded parameter api\u2019s. The api supports multiple arguments which include the name of the parameter, unique key identifier, strings for headline and description of the parameter and also its default value.", "keywords": []}, {"id": 940, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter", "display_name": "nvidia::gxf::Component::setParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKc1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key T  value ; Set the parameter \u201ckey\u201d with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 An object of type T Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 941, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter", "display_name": "nvidia::gxf::Component::setParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKcR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key Handle &lt; T &gt;  &amp; value ; Set a parameter \u201ckey\u201d of handle type with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 Handle to a component object of type T Returns Success or error code on failure", "keywords": []}, {"id": 942, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::T", "display_name": "nvidia::gxf::Component::setParameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKc1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key T  value ; Set the parameter \u201ckey\u201d with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 An object of type T Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 943, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::T", "display_name": "nvidia::gxf::Component::setParameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKcR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key Handle &lt; T &gt;  &amp; value ; Set a parameter \u201ckey\u201d of handle type with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 Handle to a component object of type T Returns Success or error code on failure", "keywords": []}, {"id": 944, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::key", "display_name": "nvidia::gxf::Component::setParameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKc1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key T  value ; Set the parameter \u201ckey\u201d with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 An object of type T Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 945, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::key", "display_name": "nvidia::gxf::Component::setParameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKcR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key Handle &lt; T &gt;  &amp; value ; Set a parameter \u201ckey\u201d of handle type with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 Handle to a component object of type T Returns Success or error code on failure", "keywords": []}, {"id": 946, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::value", "display_name": "nvidia::gxf::Component::setParameter::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKc1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key T  value ; Set the parameter \u201ckey\u201d with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 An object of type T Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 947, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::setParameter::value", "display_name": "nvidia::gxf::Component::setParameter::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Component12setParameterE8ExpectedIvEPKcR6HandleI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  setParameter const  char  * key Handle &lt; T &gt;  &amp; value ; Set a parameter \u201ckey\u201d of handle type with \u201cvalue\u201d where T is a valid parameter type. Parameters key \u2013 A unique string value used during component registration value \u2013 Handle to a component object of type T Returns Success or error code on failure", "keywords": []}, {"id": 948, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::tid", "display_name": "nvidia::gxf::Component::tid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component3tidEv", "priority": 1, "content": "gxf_tid_t  tid  const  noexcept ; Get the type ID of the component.", "keywords": []}, {"id": 949, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::type_name", "display_name": "nvidia::gxf::Component::type_name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf9Component9type_nameEv", "priority": 1, "content": "const  char  * type_name  const  noexcept ; Get the type name of the component.", "keywords": []}, {"id": 950, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::wrapParameter", "display_name": "nvidia::gxf::Component::wrapParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13wrapParameterEPKc", "priority": 1, "content": "Expected &lt; YAML :: Node &gt;  wrapParameter const  char  * key ; Wrap the current value of the parameter \u201ckey\u201d in a yaml node. Parameters key \u2013 A unique string value used during component registration Returns A yaml node with the parameter value", "keywords": []}, {"id": 951, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::wrapParameter::key", "display_name": "nvidia::gxf::Component::wrapParameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Component13wrapParameterEPKc", "priority": 1, "content": "Expected &lt; YAML :: Node &gt;  wrapParameter const  char  * key ; Wrap the current value of the parameter \u201ckey\u201d in a yaml node. Parameters key \u2013 A unique string value used during component registration Returns A yaml node with the parameter value", "keywords": []}, {"id": 952, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Component::~Component", "display_name": "nvidia::gxf::Component::~Component", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9ComponentD0Ev", "priority": 1, "content": "virtual  ~Component  =  default ; Destructor.", "keywords": []}, {"id": 953, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity", "display_name": "nvidia::gxf::Entity", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6EntityE", "priority": 1, "content": "class  nvidia :: gxf :: Entity An entity owns multiple components which define the functionality of the entity. Entities themselves are nothing more than a unique identifier. Entities created using the C++ type is ref counted. The ref count is automatically decreased when the entity object is destructed or goes out of scope.", "keywords": []}, {"id": 954, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Entity", "display_name": "nvidia::gxf::Entity::Entity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6EntityERK6Entity", "priority": 1, "content": "Entity const  Entity  &amp; other Construct a new entity object by copying from another entity object.", "keywords": []}, {"id": 955, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Entity", "display_name": "nvidia::gxf::Entity::Entity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6EntityERR6Entity", "priority": 1, "content": "Entity Entity  &amp; &amp; other Construct a new entity object by moving the contents from an existing entity object.", "keywords": []}, {"id": 956, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Entity", "display_name": "nvidia::gxf::Entity::Entity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6EntityEv", "priority": 1, "content": "Entity Construct a new entity object using default constructor. This is a null entity without a valid context of entity ID.", "keywords": []}, {"id": 957, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Entity::other", "display_name": "nvidia::gxf::Entity::Entity::other", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6EntityERK6Entity", "priority": 1, "content": "Entity const  Entity  &amp; other Construct a new entity object by copying from another entity object.", "keywords": []}, {"id": 958, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Entity::other", "display_name": "nvidia::gxf::Entity::Entity::other", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6EntityERR6Entity", "priority": 1, "content": "Entity Entity  &amp; &amp; other Construct a new entity object by moving the contents from an existing entity object.", "keywords": []}, {"id": 959, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::New", "display_name": "nvidia::gxf::Entity::New", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3NewE13gxf_context_tPKc", "priority": 1, "content": "static  Expected &lt; Entity &gt;  New gxf_context_t  context const  char  * name  =  nullptr Creates a new entity using the given context and optionally set the given name. The caller of this api own\u2019s the object. The reference count is set to 1 and it is automatically reduced when this object is destroyed or goes out of scope. Parameters context \u2013 The GXF context. name \u2013 The name of the entity. Returns A new entity or an error.", "keywords": []}, {"id": 960, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::New::context", "display_name": "nvidia::gxf::Entity::New::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3NewE13gxf_context_tPKc", "priority": 1, "content": "static  Expected &lt; Entity &gt;  New gxf_context_t  context const  char  * name  =  nullptr Creates a new entity using the given context and optionally set the given name. The caller of this api own\u2019s the object. The reference count is set to 1 and it is automatically reduced when this object is destroyed or goes out of scope. Parameters context \u2013 The GXF context. name \u2013 The name of the entity. Returns A new entity or an error.", "keywords": []}, {"id": 961, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::New::name", "display_name": "nvidia::gxf::Entity::New::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3NewE13gxf_context_tPKc", "priority": 1, "content": "static  Expected &lt; Entity &gt;  New gxf_context_t  context const  char  * name  =  nullptr Creates a new entity using the given context and optionally set the given name. The caller of this api own\u2019s the object. The reference count is set to 1 and it is automatically reduced when this object is destroyed or goes out of scope. Parameters context \u2013 The GXF context. name \u2013 The name of the entity. Returns A new entity or an error.", "keywords": []}, {"id": 962, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Own", "display_name": "nvidia::gxf::Entity::Own", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3OwnE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Own gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and takes ownership. Reference count is not increased. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. item_ptr \u2013 An optional entity item pointer Returns A new entity handle or an error.", "keywords": []}, {"id": 963, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Own::context", "display_name": "nvidia::gxf::Entity::Own::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3OwnE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Own gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and takes ownership. Reference count is not increased. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. item_ptr \u2013 An optional entity item pointer Returns A new entity handle or an error.", "keywords": []}, {"id": 964, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Own::eid", "display_name": "nvidia::gxf::Entity::Own::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3OwnE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Own gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and takes ownership. Reference count is not increased. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. item_ptr \u2013 An optional entity item pointer Returns A new entity handle or an error.", "keywords": []}, {"id": 965, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Own::item_ptr", "display_name": "nvidia::gxf::Entity::Own::item_ptr", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3OwnE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Own gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and takes ownership. Reference count is not increased. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. item_ptr \u2013 An optional entity item pointer Returns A new entity handle or an error.", "keywords": []}, {"id": 966, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Shared", "display_name": "nvidia::gxf::Entity::Shared", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6SharedE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Shared gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and shares ownership. Reference count is increased by one. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. Returns A new entity handle or an error.", "keywords": []}, {"id": 967, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Shared::context", "display_name": "nvidia::gxf::Entity::Shared::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6SharedE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Shared gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and shares ownership. Reference count is increased by one. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. Returns A new entity handle or an error.", "keywords": []}, {"id": 968, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Shared::eid", "display_name": "nvidia::gxf::Entity::Shared::eid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6SharedE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Shared gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and shares ownership. Reference count is increased by one. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. Returns A new entity handle or an error.", "keywords": []}, {"id": 969, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::Shared::item_ptr", "display_name": "nvidia::gxf::Entity::Shared::item_ptr", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6SharedE13gxf_context_t9gxf_uid_tPv", "priority": 1, "content": "static  Expected &lt; Entity &gt;  Shared gxf_context_t  context gxf_uid_t  eid void  * item_ptr  =  nullptr Creates an entity handle based on an existing ID and shares ownership. Reference count is increased by one. Parameters context \u2013 The GXF context. eid \u2013 The entity ID. Returns A new entity handle or an error.", "keywords": []}, {"id": 970, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::activate", "display_name": "nvidia::gxf::Entity::activate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity8activateEv", "priority": 1, "content": "Expected &lt; void &gt;  activate Activates the entity. GxfEntityActivate in gxf.h", "keywords": []}, {"id": 971, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add", "display_name": "nvidia::gxf::Entity::add", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity3addE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  add const  char  * name  =  nullptr Adds a component of type T, where T is a registered component type. Parameters name \u2013 Name to be given to the newly created component instance Returns A new component handle or an error.", "keywords": []}, {"id": 972, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add", "display_name": "nvidia::gxf::Entity::add", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3addE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  add gxf_tid_t  tid const  char  * name  =  nullptr Adds a component with given type ID Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 973, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add::T", "display_name": "nvidia::gxf::Entity::add::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity3addE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  add const  char  * name  =  nullptr Adds a component of type T, where T is a registered component type. Parameters name \u2013 Name to be given to the newly created component instance Returns A new component handle or an error.", "keywords": []}, {"id": 974, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add::name", "display_name": "nvidia::gxf::Entity::add::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity3addE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  add const  char  * name  =  nullptr Adds a component of type T, where T is a registered component type. Parameters name \u2013 Name to be given to the newly created component instance Returns A new component handle or an error.", "keywords": []}, {"id": 975, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add::name", "display_name": "nvidia::gxf::Entity::add::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3addE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  add gxf_tid_t  tid const  char  * name  =  nullptr Adds a component with given type ID Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 976, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::add::tid", "display_name": "nvidia::gxf::Entity::add::tid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity3addE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  add gxf_tid_t  tid const  char  * name  =  nullptr Adds a component with given type ID Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 977, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::clone", "display_name": "nvidia::gxf::Entity::clone", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity5cloneEv", "priority": 1, "content": "Expected &lt; Entity &gt;  clone  const Clone an entity from an existing entity object. The returned entity shares the ownership with the entity being cloned from. Reference count is increased by one.", "keywords": []}, {"id": 978, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::context", "display_name": "nvidia::gxf::Entity::context", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity7contextEv", "priority": 1, "content": "gxf_context_t  context  const Returns the GXF context of the entity.", "keywords": []}, {"id": 979, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::deactivate", "display_name": "nvidia::gxf::Entity::deactivate", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity10deactivateEv", "priority": 1, "content": "Expected &lt; void &gt;  deactivate Deactivates the entity. See GxfEntityDeactivate in gxf.h", "keywords": []}, {"id": 980, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::eid", "display_name": "nvidia::gxf::Entity::eid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity3eidEv", "priority": 1, "content": "gxf_uid_t  eid  const Returns the unique object ID (UID) of the entity", "keywords": []}, {"id": 981, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::entity_item_ptr", "display_name": "nvidia::gxf::Entity::entity_item_ptr", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity15entity_item_ptrEv", "priority": 1, "content": "void  * entity_item_ptr  const Returns the pointer to Entity Item for the entity Returns void * entity item ptr", "keywords": []}, {"id": 982, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAll", "display_name": "nvidia::gxf::Entity::findAll", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf6Entity7findAllE8ExpectedI11FixedVectorI6HandleI1TE1NEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt; &gt;  findAll  const Finds all components of a given type, where T is a valid type of a registered component and N is the capacity of the FixedVector. Returns A fixed-size vector of handles of type T allocated on stack or an error.", "keywords": []}, {"id": 983, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAll", "display_name": "nvidia::gxf::Entity::findAll", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I_6size_tENK6nvidia3gxf6Entity7findAllE8ExpectedI11FixedVectorI13UntypedHandle1NEEv", "priority": 1, "content": "template &lt; size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; UntypedHandle ,  N &gt; &gt;  findAll  const Finds all components in an entity. A list of untyped handles of all the components are returned. N is the capacity of the FixedVector. Returns A fixed-size vector of untyped component handles allocated on stack or an error.", "keywords": []}, {"id": 984, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAll::N", "display_name": "nvidia::gxf::Entity::findAll::N", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf6Entity7findAllE8ExpectedI11FixedVectorI6HandleI1TE1NEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt; &gt;  findAll  const Finds all components of a given type, where T is a valid type of a registered component and N is the capacity of the FixedVector. Returns A fixed-size vector of handles of type T allocated on stack or an error.", "keywords": []}, {"id": 985, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAll::N", "display_name": "nvidia::gxf::Entity::findAll::N", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I_6size_tENK6nvidia3gxf6Entity7findAllE8ExpectedI11FixedVectorI13UntypedHandle1NEEv", "priority": 1, "content": "template &lt; size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; UntypedHandle ,  N &gt; &gt;  findAll  const Finds all components in an entity. A list of untyped handles of all the components are returned. N is the capacity of the FixedVector. Returns A fixed-size vector of untyped component handles allocated on stack or an error.", "keywords": []}, {"id": 986, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAll::T", "display_name": "nvidia::gxf::Entity::findAll::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tENK6nvidia3gxf6Entity7findAllE8ExpectedI11FixedVectorI6HandleI1TE1NEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; ,  N &gt; &gt;  findAll  const Finds all components of a given type, where T is a valid type of a registered component and N is the capacity of the FixedVector. Returns A fixed-size vector of handles of type T allocated on stack or an error.", "keywords": []}, {"id": 987, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAllHeap", "display_name": "nvidia::gxf::Entity::findAllHeap", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tEN6nvidia3gxf6Entity11findAllHeapE8ExpectedI11FixedVectorI6HandleI1TEEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; &gt; &gt;  findAllHeap Finds all components of type T in an entity. A fixed-size vector of typed handles of all the components are returned. Returns Expected&lt;FixedVector&lt;Handle&lt;T&gt;&gt;&gt; A fixed-size vector of typed handles of given component type allocated on heap", "keywords": []}, {"id": 988, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAllHeap", "display_name": "nvidia::gxf::Entity::findAllHeap", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I_6size_tENK6nvidia3gxf6Entity11findAllHeapE8ExpectedI11FixedVectorI13UntypedHandleEEv", "priority": 1, "content": "template &lt; size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; UntypedHandle &gt; &gt;  findAllHeap  const Finds all components in an entity. A fixed-size vector of untyped handles of all the components are returned. Returns Expected&lt;FixedVector&lt;UntypedHandle, N&gt;&gt; A fixed-size vector of untyped handles of all the components allocated on heap", "keywords": []}, {"id": 989, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAllHeap::N", "display_name": "nvidia::gxf::Entity::findAllHeap::N", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tEN6nvidia3gxf6Entity11findAllHeapE8ExpectedI11FixedVectorI6HandleI1TEEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; &gt; &gt;  findAllHeap Finds all components of type T in an entity. A fixed-size vector of typed handles of all the components are returned. Returns Expected&lt;FixedVector&lt;Handle&lt;T&gt;&gt;&gt; A fixed-size vector of typed handles of given component type allocated on heap", "keywords": []}, {"id": 990, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAllHeap::N", "display_name": "nvidia::gxf::Entity::findAllHeap::N", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I_6size_tENK6nvidia3gxf6Entity11findAllHeapE8ExpectedI11FixedVectorI13UntypedHandleEEv", "priority": 1, "content": "template &lt; size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; UntypedHandle &gt; &gt;  findAllHeap  const Finds all components in an entity. A fixed-size vector of untyped handles of all the components are returned. Returns Expected&lt;FixedVector&lt;UntypedHandle, N&gt;&gt; A fixed-size vector of untyped handles of all the components allocated on heap", "keywords": []}, {"id": 991, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::findAllHeap::T", "display_name": "nvidia::gxf::Entity::findAllHeap::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0_6size_tEN6nvidia3gxf6Entity11findAllHeapE8ExpectedI11FixedVectorI6HandleI1TEEEv", "priority": 1, "content": "template &lt; typename  T ,  size_t  N  =  kMaxComponents &gt; Expected &lt; FixedVector &lt; Handle &lt; T &gt; &gt; &gt;  findAllHeap Finds all components of type T in an entity. A fixed-size vector of typed handles of all the components are returned. Returns Expected&lt;FixedVector&lt;Handle&lt;T&gt;&gt;&gt; A fixed-size vector of typed handles of given component type allocated on heap", "keywords": []}, {"id": 992, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get", "display_name": "nvidia::gxf::Entity::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf6Entity3getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  get const  char  * name  =  nullptr  const Gets a component of type T with given name. Asserts if no such component. Parameters name \u2013 Name of the component to lookup Returns Typed Handle to the component instance or error on failure", "keywords": []}, {"id": 993, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get", "display_name": "nvidia::gxf::Entity::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity3getE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  get gxf_tid_t  tid const  char  * name  =  nullptr  const Gets a component by type ID. Asserts if no such component. Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name of the component to lookup Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 994, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get::T", "display_name": "nvidia::gxf::Entity::get::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf6Entity3getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  get const  char  * name  =  nullptr  const Gets a component of type T with given name. Asserts if no such component. Parameters name \u2013 Name of the component to lookup Returns Typed Handle to the component instance or error on failure", "keywords": []}, {"id": 995, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get::name", "display_name": "nvidia::gxf::Entity::get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0ENK6nvidia3gxf6Entity3getE8ExpectedI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; Handle &lt; T &gt; &gt;  get const  char  * name  =  nullptr  const Gets a component of type T with given name. Asserts if no such component. Parameters name \u2013 Name of the component to lookup Returns Typed Handle to the component instance or error on failure", "keywords": []}, {"id": 996, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get::name", "display_name": "nvidia::gxf::Entity::get::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity3getE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  get gxf_tid_t  tid const  char  * name  =  nullptr  const Gets a component by type ID. Asserts if no such component. Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name of the component to lookup Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 997, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::get::tid", "display_name": "nvidia::gxf::Entity::get::tid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity3getE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; UntypedHandle &gt;  get gxf_tid_t  tid const  char  * name  =  nullptr  const Gets a component by type ID. Asserts if no such component. Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name of the component to lookup Returns An untyped handle to component or error code on failure", "keywords": []}, {"id": 998, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::is_null", "display_name": "nvidia::gxf::Entity::is_null", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity7is_nullEv", "priority": 1, "content": "bool  is_null  const Checks if an entity object is null (empty)", "keywords": []}, {"id": 999, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::name", "display_name": "nvidia::gxf::Entity::name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Entity4nameEv", "priority": 1, "content": "const  char  * name  const The name of the entity or empty string if no name has been given to the entity.", "keywords": []}, {"id": 1000, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove", "display_name": "nvidia::gxf::Entity::remove", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity6removeE8ExpectedIvEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  remove const  char  * name  =  nullptr Removes a component with given template component type and name Parameters name \u2013 Name of the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1001, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove", "display_name": "nvidia::gxf::Entity::remove", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6removeE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  remove gxf_tid_t  tid const  char  * name  =  nullptr Removes a component with given type id and name Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1002, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove", "display_name": "nvidia::gxf::Entity::remove", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6removeER9gxf_uid_t", "priority": 1, "content": "Expected &lt; void &gt;  remove gxf_uid_t  &amp; cid Removes a component with given uid Parameters cid \u2013 A valid uid of the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1003, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove::T", "display_name": "nvidia::gxf::Entity::remove::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity6removeE8ExpectedIvEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  remove const  char  * name  =  nullptr Removes a component with given template component type and name Parameters name \u2013 Name of the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1004, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove::cid", "display_name": "nvidia::gxf::Entity::remove::cid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6removeER9gxf_uid_t", "priority": 1, "content": "Expected &lt; void &gt;  remove gxf_uid_t  &amp; cid Removes a component with given uid Parameters cid \u2013 A valid uid of the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1005, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove::name", "display_name": "nvidia::gxf::Entity::remove::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Entity6removeE8ExpectedIvEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  remove const  char  * name  =  nullptr Removes a component with given template component type and name Parameters name \u2013 Name of the component Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1006, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove::name", "display_name": "nvidia::gxf::Entity::remove::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6removeE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  remove gxf_tid_t  tid const  char  * name  =  nullptr Removes a component with given type id and name Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1007, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::remove::tid", "display_name": "nvidia::gxf::Entity::remove::tid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Entity6removeE9gxf_tid_tPKc", "priority": 1, "content": "Expected &lt; void &gt;  remove gxf_tid_t  tid const  char  * name  =  nullptr Removes a component with given type id and name Parameters tid \u2013 A valid type ID of a registered component name \u2013 Name to be given to the newly created component instance Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1008, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Entity::~Entity", "display_name": "nvidia::gxf::Entity::~Entity", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6EntityD0Ev", "priority": 1, "content": "~Entity Destroy the Entity object. Reduces the reference count by 1.", "keywords": []}, {"id": 1009, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected", "display_name": "nvidia::gxf::Expected", "type": "type", "display_type": "C++ type", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8ExpectedE", "priority": 1, "content": "template &lt; typename  T &gt; using  nvidia :: gxf :: Expected  =  nvidia :: Expected &lt; T ,  gxf_result_t &gt; The Expected type is a template that represents a value that either contains a result of type T or an error code of type gxf_result_t . It is used throughout the GXF framework to represent the result of functions that can either succeed and return a value or fail and return an error code.", "keywords": []}, {"id": 1010, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::T", "display_name": "nvidia::gxf::Expected::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8ExpectedE", "priority": 1, "content": "template &lt; typename  T &gt; using  nvidia :: gxf :: Expected  =  nvidia :: Expected &lt; T ,  gxf_result_t &gt; The Expected type is a template that represents a value that either contains a result of type T or an error code of type gxf_result_t . It is used throughout the GXF framework to represent the result of functions that can either succeed and return a value or fail and return an error code.", "keywords": []}, {"id": 1011, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE12gxf_result_t12gxf_result_t12gxf_result_t", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; gxf_result_t  nvidia :: gxf :: AccumulateError gxf_result_t  previous gxf_result_t  current Accumulates the error codes of two nvidia::gxf::gxf_result_t objects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous code", "keywords": []}, {"id": 1012, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE8ExpectedIvE8ExpectedIvE", "priority": 1, "content": "nvidia :: gxf :: Expected &lt; void &gt;  nvidia :: gxf :: AccumulateError Expected &lt; void &gt;  previous Expected &lt; void &gt;  current Accumulates the error codes of two expected objects. Returns the current object if it has an error, otherwise it returns the previous object. Creating an Expected An Expected can be created in two ways: By constructing it with a value of type T Expected&lt;int&gt; result{42}; By constructing it with an error code of type gxf_result_t Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; Accessing the Value or Error Code The value or error code of an Expected can be accessed using the value() and error() member functions, respectively. If the Expected contains a value, value() returns that value and error() returns an error code of type gxf_result_t with the value GXF_SUCCESS . If the Expected contains an error code, value() returns an error code of type gxf_result_t with the value GXF_FAILURE and error() returns the error code. Expected&lt;int&gt; result {42}; int value = result.value(); // value == 42 gxf_result_t error = result.error(); // GXF_ASSERT raised Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; error = result.error(); // error == GXF_OUT_OF_MEMORY value = result.value(); // GXF_ASSERT raised Checking if an Expected Contains a Value The presence of a value in an Expected can be checked using the has_value() member function. Expected&lt;int&gt; result {42}; if (result.has_value()) { // The expected contains a value } else { // The expected contains an error code } Converting an Expected to a Result Code An Expected can be converted to a result code using the ToResultCode() function. If the Expected contains a value, the function returns GXF_SUCCESS . If the Expected contains an error code, the function returns that error code. Expected&lt;int&gt; result {42}; gxf_result_t code = ToResultCode(result); // code == GXF_SUCCESS Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; code = ToResultCode(result); // code == GXF_OUT_OF_MEMORY Creating an Expected from a Result Code An Expected can be created from a result code using the ExpectedOrCode() function. If the result code is GXF_SUCCESS , the function returns an Expected with a value of type T . If the result code is not GXF_SUCCESS , the function returns an Expected with the corresponding error code of type gxf_result_t .` gxf_result_t code = GXF_SUCCESS; int value = 42; Expected&lt;int&gt; result = ExpectedOrCode(code, 42); // result contains a value of type int with the value 42 Using Expected with Functions that Return Values The Expected type can be used with functions that return values to simplify error handling. For example, consider the following function that divides two integers: Expected&lt;int&gt; Divide(int dividend, int divisor) { if (divisor == 0) { return Unexpected{GXF_INVALID_ARGUMENT}; } return dividend / divisor; } This function returns an Expected with a value of type int if the division is successful, or an error code of type gxf_result_t if the division is not possible (i.e., if the divisor is zero). The nvidia::gxf::Unexpected type is a template specialization that is used in conjunction with the nvidia::gxf::Expected template to represent an error state in a result type. To use this function, the caller can check if the Expected contains a value or an error code: Expected&lt;int&gt; result = Divide(42, 0); if (result.has_value()) { // The division was successful int value = result.value(); } else { // The division was not successful gxf_result_t error = result.error(); }", "keywords": []}, {"id": 1013, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::S", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::S", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE12gxf_result_t12gxf_result_t12gxf_result_t", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; gxf_result_t  nvidia :: gxf :: AccumulateError gxf_result_t  previous gxf_result_t  current Accumulates the error codes of two nvidia::gxf::gxf_result_t objects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous code", "keywords": []}, {"id": 1014, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE12gxf_result_t12gxf_result_t12gxf_result_t", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; gxf_result_t  nvidia :: gxf :: AccumulateError gxf_result_t  previous gxf_result_t  current Accumulates the error codes of two nvidia::gxf::gxf_result_t objects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous code", "keywords": []}, {"id": 1015, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::current", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::current", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE12gxf_result_t12gxf_result_t12gxf_result_t", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; gxf_result_t  nvidia :: gxf :: AccumulateError gxf_result_t  previous gxf_result_t  current Accumulates the error codes of two nvidia::gxf::gxf_result_t objects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous code", "keywords": []}, {"id": 1016, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::current", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::current", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE8ExpectedIvE8ExpectedIvE", "priority": 1, "content": "nvidia :: gxf :: Expected &lt; void &gt;  nvidia :: gxf :: AccumulateError Expected &lt; void &gt;  previous Expected &lt; void &gt;  current Accumulates the error codes of two expected objects. Returns the current object if it has an error, otherwise it returns the previous object. Creating an Expected An Expected can be created in two ways: By constructing it with a value of type T Expected&lt;int&gt; result{42}; By constructing it with an error code of type gxf_result_t Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; Accessing the Value or Error Code The value or error code of an Expected can be accessed using the value() and error() member functions, respectively. If the Expected contains a value, value() returns that value and error() returns an error code of type gxf_result_t with the value GXF_SUCCESS . If the Expected contains an error code, value() returns an error code of type gxf_result_t with the value GXF_FAILURE and error() returns the error code. Expected&lt;int&gt; result {42}; int value = result.value(); // value == 42 gxf_result_t error = result.error(); // GXF_ASSERT raised Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; error = result.error(); // error == GXF_OUT_OF_MEMORY value = result.value(); // GXF_ASSERT raised Checking if an Expected Contains a Value The presence of a value in an Expected can be checked using the has_value() member function. Expected&lt;int&gt; result {42}; if (result.has_value()) { // The expected contains a value } else { // The expected contains an error code } Converting an Expected to a Result Code An Expected can be converted to a result code using the ToResultCode() function. If the Expected contains a value, the function returns GXF_SUCCESS . If the Expected contains an error code, the function returns that error code. Expected&lt;int&gt; result {42}; gxf_result_t code = ToResultCode(result); // code == GXF_SUCCESS Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; code = ToResultCode(result); // code == GXF_OUT_OF_MEMORY Creating an Expected from a Result Code An Expected can be created from a result code using the ExpectedOrCode() function. If the result code is GXF_SUCCESS , the function returns an Expected with a value of type T . If the result code is not GXF_SUCCESS , the function returns an Expected with the corresponding error code of type gxf_result_t .` gxf_result_t code = GXF_SUCCESS; int value = 42; Expected&lt;int&gt; result = ExpectedOrCode(code, 42); // result contains a value of type int with the value 42 Using Expected with Functions that Return Values The Expected type can be used with functions that return values to simplify error handling. For example, consider the following function that divides two integers: Expected&lt;int&gt; Divide(int dividend, int divisor) { if (divisor == 0) { return Unexpected{GXF_INVALID_ARGUMENT}; } return dividend / divisor; } This function returns an Expected with a value of type int if the division is successful, or an error code of type gxf_result_t if the division is not possible (i.e., if the divisor is zero). The nvidia::gxf::Unexpected type is a template specialization that is used in conjunction with the nvidia::gxf::Expected template to represent an error state in a result type. To use this function, the caller can check if the Expected contains a value or an error code: Expected&lt;int&gt; result = Divide(42, 0); if (result.has_value()) { // The division was successful int value = result.value(); } else { // The division was not successful gxf_result_t error = result.error(); }", "keywords": []}, {"id": 1017, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::previous", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::previous", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE12gxf_result_t12gxf_result_t12gxf_result_t", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; gxf_result_t  nvidia :: gxf :: AccumulateError gxf_result_t  previous gxf_result_t  current Accumulates the error codes of two nvidia::gxf::gxf_result_t objects. Returns the first code if it is not a GXF_SUCCESS, else returns the previous code", "keywords": []}, {"id": 1018, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::previous", "display_name": "nvidia::gxf::Expected::nvidia::gxf::AccumulateError::previous", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8Expected6nvidia3gxf15AccumulateErrorE8ExpectedIvE8ExpectedIvE", "priority": 1, "content": "nvidia :: gxf :: Expected &lt; void &gt;  nvidia :: gxf :: AccumulateError Expected &lt; void &gt;  previous Expected &lt; void &gt;  current Accumulates the error codes of two expected objects. Returns the current object if it has an error, otherwise it returns the previous object. Creating an Expected An Expected can be created in two ways: By constructing it with a value of type T Expected&lt;int&gt; result{42}; By constructing it with an error code of type gxf_result_t Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; Accessing the Value or Error Code The value or error code of an Expected can be accessed using the value() and error() member functions, respectively. If the Expected contains a value, value() returns that value and error() returns an error code of type gxf_result_t with the value GXF_SUCCESS . If the Expected contains an error code, value() returns an error code of type gxf_result_t with the value GXF_FAILURE and error() returns the error code. Expected&lt;int&gt; result {42}; int value = result.value(); // value == 42 gxf_result_t error = result.error(); // GXF_ASSERT raised Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; error = result.error(); // error == GXF_OUT_OF_MEMORY value = result.value(); // GXF_ASSERT raised Checking if an Expected Contains a Value The presence of a value in an Expected can be checked using the has_value() member function. Expected&lt;int&gt; result {42}; if (result.has_value()) { // The expected contains a value } else { // The expected contains an error code } Converting an Expected to a Result Code An Expected can be converted to a result code using the ToResultCode() function. If the Expected contains a value, the function returns GXF_SUCCESS . If the Expected contains an error code, the function returns that error code. Expected&lt;int&gt; result {42}; gxf_result_t code = ToResultCode(result); // code == GXF_SUCCESS Expected&lt;int&gt; result = Unexpected{GXF_OUT_OF_MEMORY}; code = ToResultCode(result); // code == GXF_OUT_OF_MEMORY Creating an Expected from a Result Code An Expected can be created from a result code using the ExpectedOrCode() function. If the result code is GXF_SUCCESS , the function returns an Expected with a value of type T . If the result code is not GXF_SUCCESS , the function returns an Expected with the corresponding error code of type gxf_result_t .` gxf_result_t code = GXF_SUCCESS; int value = 42; Expected&lt;int&gt; result = ExpectedOrCode(code, 42); // result contains a value of type int with the value 42 Using Expected with Functions that Return Values The Expected type can be used with functions that return values to simplify error handling. For example, consider the following function that divides two integers: Expected&lt;int&gt; Divide(int dividend, int divisor) { if (divisor == 0) { return Unexpected{GXF_INVALID_ARGUMENT}; } return dividend / divisor; } This function returns an Expected with a value of type int if the division is successful, or an error code of type gxf_result_t if the division is not possible (i.e., if the divisor is zero). The nvidia::gxf::Unexpected type is a template specialization that is used in conjunction with the nvidia::gxf::Expected template to represent an error state in a result type. To use this function, the caller can check if the Expected contains a value or an error code: Expected&lt;int&gt; result = Divide(42, 0); if (result.has_value()) { // The division was successful int value = result.value(); } else { // The division was not successful gxf_result_t error = result.error(); }", "keywords": []}, {"id": 1019, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEE1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  value Constructs an expected object with a value of type T. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1020, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEERR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  &amp; &amp; value Constructs an expected object with a value of type T using move construct. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1021, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEE1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  value Constructs an expected object with a value of type T. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1022, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEERR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  &amp; &amp; value Constructs an expected object with a value of type T using move construct. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1023, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::error", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::error", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected5errorE12gxf_result_tv", "priority": 1, "content": "template &lt; typename  T &gt; gxf_result_t  nvidia :: gxf :: Expected :: error Returns the error code of the expected object if it was constructed using an Unexpected, otherwise an assert will be raised. Returns The error code stored in the Expected object.", "keywords": []}, {"id": 1024, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::error::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::error::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected5errorE12gxf_result_tv", "priority": 1, "content": "template &lt; typename  T &gt; gxf_result_t  nvidia :: gxf :: Expected :: error Returns the error code of the expected object if it was constructed using an Unexpected, otherwise an assert will be raised. Returns The error code stored in the Expected object.", "keywords": []}, {"id": 1025, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::has_value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::has_value", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected9has_valueEbv", "priority": 1, "content": "template &lt; typename  T &gt; bool  nvidia :: gxf :: Expected :: has_value Returns true if the Expected object contains a value, false otherwise. Returns True if the Expected object contains a value, false otherwise.", "keywords": []}, {"id": 1026, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::has_value::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::has_value::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected9has_valueEbv", "priority": 1, "content": "template &lt; typename  T &gt; bool  nvidia :: gxf :: Expected :: has_value Returns true if the Expected object contains a value, false otherwise. Returns True if the Expected object contains a value, false otherwise.", "keywords": []}, {"id": 1027, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected5valueE1Tv", "priority": 1, "content": "template &lt; typename  T &gt; T  nvidia :: gxf :: Expected :: value Returns the value of the expected object if it has a valid value, otherwise an assert will be raised if it was constructed using an Unexpected. Returns The value stored in the Expected object.", "keywords": []}, {"id": 1028, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEE1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  value Constructs an expected object with a value of type T. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1029, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8ExpectedEN6nvidia3gxf8ExpectedI1TEERR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; T &gt;  nvidia :: gxf :: Expected T  &amp; &amp; value Constructs an expected object with a value of type T using move construct. Parameters value \u2013 The value to be stored in the Expected object.", "keywords": []}, {"id": 1030, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::Expected::value::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf8Expected5valueE1Tv", "priority": 1, "content": "template &lt; typename  T &gt; T  nvidia :: gxf :: Expected :: value Returns the value of the expected object if it has a valid value, otherwise an assert will be raised if it was constructed using an Unexpected. Returns The value stored in the Expected object.", "keywords": []}, {"id": 1031, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEE12gxf_result_tRR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code T  &amp; &amp; value If the result code is GXF_SUCCESS the function returns the value, otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. value \u2013 Value to be returned when code is GXF_SUCCESS Returns An Expected object", "keywords": []}, {"id": 1032, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeE12gxf_result_t", "priority": 1, "content": "nvidia :: gxf :: Expected &lt; void &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code If the result code is GXF_SUCCESS the function returns nvidia::gxf::Success , otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. Returns An Expected object", "keywords": []}, {"id": 1033, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEE12gxf_result_tRR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code T  &amp; &amp; value If the result code is GXF_SUCCESS the function returns the value, otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. value \u2013 Value to be returned when code is GXF_SUCCESS Returns An Expected object", "keywords": []}, {"id": 1034, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::code", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::code", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEE12gxf_result_tRR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code T  &amp; &amp; value If the result code is GXF_SUCCESS the function returns the value, otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. value \u2013 Value to be returned when code is GXF_SUCCESS Returns An Expected object", "keywords": []}, {"id": 1035, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::code", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::code", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeE12gxf_result_t", "priority": 1, "content": "nvidia :: gxf :: Expected &lt; void &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code If the result code is GXF_SUCCESS the function returns nvidia::gxf::Success , otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. Returns An Expected object", "keywords": []}, {"id": 1036, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrCode::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf14ExpectedOrCodeEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEE12gxf_result_tRR1T", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrCode gxf_result_t  code T  &amp; &amp; value If the result code is GXF_SUCCESS the function returns the value, otherwise it returns an unexpected with the given error code. Parameters code \u2013 The result code to interpret. value \u2013 Value to be returned when code is GXF_SUCCESS Returns An Expected object", "keywords": []}, {"id": 1037, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15ExpectedOrErrorEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEERKN6nvidia3gxf8ExpectedI1SEERR1T", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrError const  nvidia :: gxf :: Expected &lt; S &gt;  &amp; code T  &amp; &amp; value If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected. Parameters code \u2013 The expected object to interpret. value \u2013 Value to be returned when code has a valid object Returns An Expected object", "keywords": []}, {"id": 1038, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::S", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::S", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15ExpectedOrErrorEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEERKN6nvidia3gxf8ExpectedI1SEERR1T", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrError const  nvidia :: gxf :: Expected &lt; S &gt;  &amp; code T  &amp; &amp; value If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected. Parameters code \u2013 The expected object to interpret. value \u2013 Value to be returned when code has a valid object Returns An Expected object", "keywords": []}, {"id": 1039, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15ExpectedOrErrorEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEERKN6nvidia3gxf8ExpectedI1SEERR1T", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrError const  nvidia :: gxf :: Expected &lt; S &gt;  &amp; code T  &amp; &amp; value If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected. Parameters code \u2013 The expected object to interpret. value \u2013 Value to be returned when code has a valid object Returns An Expected object", "keywords": []}, {"id": 1040, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::code", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::code", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15ExpectedOrErrorEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEERKN6nvidia3gxf8ExpectedI1SEERR1T", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrError const  nvidia :: gxf :: Expected &lt; S &gt;  &amp; code T  &amp; &amp; value If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected. Parameters code \u2013 The expected object to interpret. value \u2013 Value to be returned when code has a valid object Returns An Expected object", "keywords": []}, {"id": 1041, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::value", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ExpectedOrError::value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I00EN6nvidia3gxf8Expected6nvidia3gxf15ExpectedOrErrorEN6nvidia3gxf8ExpectedINSt11remove_cv_tINSt18remove_reference_tI1TEEEEEERKN6nvidia3gxf8ExpectedI1SEERR1T", "priority": 1, "content": "template &lt; typename  S ,  typename  T &gt; nvidia :: gxf :: Expected &lt; std :: remove_cv_t &lt; std :: remove_reference_t &lt; T &gt; &gt; &gt;  nvidia :: gxf :: ExpectedOrError const  nvidia :: gxf :: Expected &lt; S &gt;  &amp; code T  &amp; &amp; value If the expected code is a valid expected object, the function returns the given value, otherwise it returns the error as an Unexpected. Parameters code \u2013 The expected object to interpret. value \u2013 Value to be returned when code has a valid object Returns An Expected object", "keywords": []}, {"id": 1042, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1043, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERRN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError nvidia :: gxf :: Expected &lt; T &gt;  &amp; &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1044, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1045, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERRN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError nvidia :: gxf :: Expected &lt; T &gt;  &amp; &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1046, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::expected", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::expected", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1047, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::expected", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ForwardError::expected", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ForwardErrorEN6nvidia3gxf10UnexpectedI12gxf_result_tEERRN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; nvidia :: gxf :: Unexpected &lt; gxf_result_t &gt;  nvidia :: gxf :: ForwardError nvidia :: gxf :: Expected &lt; T &gt;  &amp; &amp; expected Extracts the error code as an unexpected. Parameters expected \u2013 The Expected object from which to extract the error code. Returns The error code stored in the Expected object as an unexpected.", "keywords": []}, {"id": 1048, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ToResultCodeE12gxf_result_tRKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; gxf_result_t  nvidia :: gxf :: ToResultCode const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; result Interprets an expected as a result code. Returns GXF_SUCCESS if the result has a value and the result\u2019s error code otherwise. Parameters result \u2013 The Expected object to interpret as a result code. Returns GXF_SUCCESS if the Expected object contains a value, the result\u2019s error code otherwise.", "keywords": []}, {"id": 1049, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode::T", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ToResultCodeE12gxf_result_tRKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; gxf_result_t  nvidia :: gxf :: ToResultCode const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; result Interprets an expected as a result code. Returns GXF_SUCCESS if the result has a value and the result\u2019s error code otherwise. Parameters result \u2013 The Expected object to interpret as a result code. Returns GXF_SUCCESS if the Expected object contains a value, the result\u2019s error code otherwise.", "keywords": []}, {"id": 1050, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode::result", "display_name": "nvidia::gxf::Expected::nvidia::gxf::ToResultCode::result", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf8Expected6nvidia3gxf12ToResultCodeE12gxf_result_tRKN6nvidia3gxf8ExpectedI1TEE", "priority": 1, "content": "template &lt; typename  T &gt; gxf_result_t  nvidia :: gxf :: ToResultCode const  nvidia :: gxf :: Expected &lt; T &gt;  &amp; result Interprets an expected as a result code. Returns GXF_SUCCESS if the result has a value and the result\u2019s error code otherwise. Parameters result \u2013 The Expected object to interpret as a result code. Returns GXF_SUCCESS if the Expected object contains a value, the result\u2019s error code otherwise.", "keywords": []}, {"id": 1051, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle", "display_name": "nvidia::gxf::Handle", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleE", "priority": 1, "content": "class  nvidia :: gxf :: Handle The Handle class is a template class that derives from UntypedHandle and provides access to components with a specific type.", "keywords": []}, {"id": 1052, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Create", "display_name": "nvidia::gxf::Handle::Create", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; Handle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new handle using the component id Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new Handle object for the given context and component ID.", "keywords": []}, {"id": 1053, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Create", "display_name": "nvidia::gxf::Handle::Create", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6CreateERK13UntypedHandle", "priority": 1, "content": "static  Expected &lt; Handle &gt;  Create const  UntypedHandle  &amp; untyped_handle Creates a new handle from an untyped handle Parameters untyped_handle \u2013 The UntypedHandle object to create a Handle object from. Returns A new Handle object for the given UntypedHandle object.", "keywords": []}, {"id": 1054, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Create::cid", "display_name": "nvidia::gxf::Handle::Create::cid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; Handle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new handle using the component id Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new Handle object for the given context and component ID.", "keywords": []}, {"id": 1055, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Create::context", "display_name": "nvidia::gxf::Handle::Create::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; Handle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new handle using the component id Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new Handle object for the given context and component ID.", "keywords": []}, {"id": 1056, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Create::untyped_handle", "display_name": "nvidia::gxf::Handle::Create::untyped_handle", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6CreateERK13UntypedHandle", "priority": 1, "content": "static  Expected &lt; Handle &gt;  Create const  UntypedHandle  &amp; untyped_handle Creates a new handle from an untyped handle Parameters untyped_handle \u2013 The UntypedHandle object to create a Handle object from. Returns A new Handle object for the given UntypedHandle object.", "keywords": []}, {"id": 1057, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle", "display_name": "nvidia::gxf::Handle::Handle", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Handle6HandleE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "template &lt; typename  Derived &gt; Handle gxf_context_t  context  =  kNullContext gxf_uid_t  uid  =  kNullUid Constructor equivalent to :cpp:func:: Handle::Create function", "keywords": []}, {"id": 1058, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle", "display_name": "nvidia::gxf::Handle::Handle", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6HandleERK6Handle", "priority": 1, "content": "Handle const  Handle  &amp; component  =  default Parameters component \u2013 The Handle object to copy.", "keywords": []}, {"id": 1059, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle", "display_name": "nvidia::gxf::Handle::Handle", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6HandleERR6Handle", "priority": 1, "content": "Handle Handle  &amp; &amp; component  =  default Parameters component \u2013 The Handle object to move.", "keywords": []}, {"id": 1060, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle::Derived", "display_name": "nvidia::gxf::Handle::Handle::Derived", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Handle6HandleE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "template &lt; typename  Derived &gt; Handle gxf_context_t  context  =  kNullContext gxf_uid_t  uid  =  kNullUid Constructor equivalent to :cpp:func:: Handle::Create function", "keywords": []}, {"id": 1061, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle::component", "display_name": "nvidia::gxf::Handle::Handle::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6HandleERK6Handle", "priority": 1, "content": "Handle const  Handle  &amp; component  =  default Parameters component \u2013 The Handle object to copy.", "keywords": []}, {"id": 1062, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle::component", "display_name": "nvidia::gxf::Handle::Handle::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle6HandleERR6Handle", "priority": 1, "content": "Handle Handle  &amp; &amp; component  =  default Parameters component \u2013 The Handle object to move.", "keywords": []}, {"id": 1063, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle::context", "display_name": "nvidia::gxf::Handle::Handle::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Handle6HandleE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "template &lt; typename  Derived &gt; Handle gxf_context_t  context  =  kNullContext gxf_uid_t  uid  =  kNullUid Constructor equivalent to :cpp:func:: Handle::Create function", "keywords": []}, {"id": 1064, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Handle::uid", "display_name": "nvidia::gxf::Handle::Handle::uid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf6Handle6HandleE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "template &lt; typename  Derived &gt; Handle gxf_context_t  context  =  kNullContext gxf_uid_t  uid  =  kNullUid Constructor equivalent to :cpp:func:: Handle::Create function", "keywords": []}, {"id": 1065, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Null", "display_name": "nvidia::gxf::Handle::Null", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle4NullEv", "priority": 1, "content": "static  Handle  Null Returns A null Handle object.", "keywords": []}, {"id": 1066, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::Unspecified", "display_name": "nvidia::gxf::Handle::Unspecified", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6Handle11UnspecifiedEv", "priority": 1, "content": "static  Handle  Unspecified An unspecified handle is a unique handle used to denote a component which will be created in the future. A parameter of Handle to a type does not consider \u201cUnspecified\u201d as a valid parameter value and hence this handle must only be used when defining a graph application across different files and the parameters are set in a delayed fashion (sub-graphs and parameter yaml files for example) Entity activation will fail if any of the mandatory parameters are \u201cUnspecified\u201d Returns An unspecified Handle object.", "keywords": []}, {"id": 1067, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::get", "display_name": "nvidia::gxf::Handle::get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Handle3getEv", "priority": 1, "content": "T  * get  const Returns A pointer to the component of the specific type.", "keywords": []}, {"id": 1068, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator T*", "display_name": "nvidia::gxf::Handle::operator T*", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6HandlecvP1TEv", "priority": 1, "content": "operator  T *  const Returns A pointer to the component of the specific type.", "keywords": []}, {"id": 1069, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator!=", "display_name": "nvidia::gxf::Handle::operator!=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleneERK6HandleRK6Handle", "priority": 1, "content": "bool  operator != const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are not equal Returns True if the handle objects are not pointing to the same component", "keywords": []}, {"id": 1070, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator!=::lhs", "display_name": "nvidia::gxf::Handle::operator!=::lhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleneERK6HandleRK6Handle", "priority": 1, "content": "bool  operator != const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are not equal Returns True if the handle objects are not pointing to the same component", "keywords": []}, {"id": 1071, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator!=::rhs", "display_name": "nvidia::gxf::Handle::operator!=::rhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleneERK6HandleRK6Handle", "priority": 1, "content": "bool  operator != const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are not equal Returns True if the handle objects are not pointing to the same component", "keywords": []}, {"id": 1072, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator->", "display_name": "nvidia::gxf::Handle::operator->", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6HandleptEv", "priority": 1, "content": "T  * operator -&gt;  const Returns A pointer to the component of the specific type.", "keywords": []}, {"id": 1073, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator<", "display_name": "nvidia::gxf::Handle::operator<", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleltERK6HandleRK6Handle", "priority": 1, "content": "bool  operator &lt; const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if an handle object is less than the other Parameters lhs \u2013 typed handle a component rhs \u2013 typed handle a component Returns True if the component id of lhs is less than rhs", "keywords": []}, {"id": 1074, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator<::lhs", "display_name": "nvidia::gxf::Handle::operator<::lhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleltERK6HandleRK6Handle", "priority": 1, "content": "bool  operator &lt; const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if an handle object is less than the other Parameters lhs \u2013 typed handle a component rhs \u2013 typed handle a component Returns True if the component id of lhs is less than rhs", "keywords": []}, {"id": 1075, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator<::rhs", "display_name": "nvidia::gxf::Handle::operator<::rhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleltERK6HandleRK6Handle", "priority": 1, "content": "bool  operator &lt; const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if an handle object is less than the other Parameters lhs \u2013 typed handle a component rhs \u2013 typed handle a component Returns True if the component id of lhs is less than rhs", "keywords": []}, {"id": 1076, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator=", "display_name": "nvidia::gxf::Handle::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleaSERK6Handle", "priority": 1, "content": "Handle  &amp; operator = const  Handle  &amp; component  =  default Parameters component \u2013 The Handle object to copy.", "keywords": []}, {"id": 1077, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator=", "display_name": "nvidia::gxf::Handle::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleaSERR6Handle", "priority": 1, "content": "Handle  &amp; operator = Handle  &amp; &amp; component  =  default Parameters component \u2013 The Handle object to move.", "keywords": []}, {"id": 1078, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator=::component", "display_name": "nvidia::gxf::Handle::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleaSERK6Handle", "priority": 1, "content": "Handle  &amp; operator = const  Handle  &amp; component  =  default Parameters component \u2013 The Handle object to copy.", "keywords": []}, {"id": 1079, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator=::component", "display_name": "nvidia::gxf::Handle::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleaSERR6Handle", "priority": 1, "content": "Handle  &amp; operator = Handle  &amp; &amp; component  =  default Parameters component \u2013 The Handle object to move.", "keywords": []}, {"id": 1080, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator==", "display_name": "nvidia::gxf::Handle::operator==", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleeqERK6HandleRK6Handle", "priority": 1, "content": "bool  operator == const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are equal Returns True if the handle objects are pointing to the same component", "keywords": []}, {"id": 1081, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator==::lhs", "display_name": "nvidia::gxf::Handle::operator==::lhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleeqERK6HandleRK6Handle", "priority": 1, "content": "bool  operator == const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are equal Returns True if the handle objects are pointing to the same component", "keywords": []}, {"id": 1082, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::operator==::rhs", "display_name": "nvidia::gxf::Handle::operator==::rhs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf6HandleeqERK6HandleRK6Handle", "priority": 1, "content": "bool  operator == const  Handle  &amp; lhs const  Handle  &amp; rhs ; Compare if two handle objects are equal Returns True if the handle objects are pointing to the same component", "keywords": []}, {"id": 1083, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Handle::try_get", "display_name": "nvidia::gxf::Handle::try_get", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf6Handle7try_getEv", "priority": 1, "content": "Expected &lt; T * &gt;  try_get  const Returns A pointer to the component of the specific type or an error if the handle is invalid.", "keywords": []}, {"id": 1084, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar", "display_name": "nvidia::gxf::Registrar", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9RegistrarE", "priority": 1, "content": "class  nvidia :: gxf :: Registrar The Registrar class is used to register parameters and resources of a component. The following api\u2019s must be used within the registerInterface() function only.", "keywords": []}, {"id": 1085, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::NoDefaultParameter", "display_name": "nvidia::gxf::Registrar::NoDefaultParameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf9Registrar18NoDefaultParameterEv", "priority": 1, "content": "static  constexpr  Unexpected  NoDefaultParameter Returns a constant for registering an optional parameter with no default value. Returns Unexpected with code GXF_PARAMETER_NOT_INITIALIZED", "keywords": []}, {"id": 1086, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key Registers a parameter with the given key, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1087, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline Registers a parameter with the given key and headline, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1088, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1089, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1090, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1091, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1092, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter", "display_name": "nvidia::gxf::Registrar::parameter", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvERN6nvidia3gxf9ParameterI1TEERK13ParameterInfoI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter nvidia :: gxf :: Parameter &lt; T &gt;  &amp; parameter const  ParameterInfo &lt; T &gt;  &amp; parameter_info Registers a parameter with ParameterInfo containing all the parameter metadata, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register parameter_info \u2013 A struct containing all the parameter metadata Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1093, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key Registers a parameter with the given key, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1094, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline Registers a parameter with the given key and headline, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1095, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1096, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1097, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1098, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1099, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::T", "display_name": "nvidia::gxf::Registrar::parameter::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvERN6nvidia3gxf9ParameterI1TEERK13ParameterInfoI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter nvidia :: gxf :: Parameter &lt; T &gt;  &amp; parameter const  ParameterInfo &lt; T &gt;  &amp; parameter_info Registers a parameter with ParameterInfo containing all the parameter metadata, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register parameter_info \u2013 A struct containing all the parameter metadata Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1100, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::default_value", "display_name": "nvidia::gxf::Registrar::parameter::default_value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1101, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::default_value", "display_name": "nvidia::gxf::Registrar::parameter::default_value", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1102, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::description", "display_name": "nvidia::gxf::Registrar::parameter::description", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1103, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::description", "display_name": "nvidia::gxf::Registrar::parameter::description", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1104, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::description", "display_name": "nvidia::gxf::Registrar::parameter::description", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1105, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::description", "display_name": "nvidia::gxf::Registrar::parameter::description", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1106, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::flags", "display_name": "nvidia::gxf::Registrar::parameter::flags", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1107, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::flags", "display_name": "nvidia::gxf::Registrar::parameter::flags", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1108, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::headline", "display_name": "nvidia::gxf::Registrar::parameter::headline", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline Registers a parameter with the given key and headline, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1109, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::headline", "display_name": "nvidia::gxf::Registrar::parameter::headline", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1110, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::headline", "display_name": "nvidia::gxf::Registrar::parameter::headline", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1111, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::headline", "display_name": "nvidia::gxf::Registrar::parameter::headline", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1112, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::headline", "display_name": "nvidia::gxf::Registrar::parameter::headline", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1113, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key Registers a parameter with the given key, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1114, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline Registers a parameter with the given key and headline, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1115, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1116, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1117, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1118, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::key", "display_name": "nvidia::gxf::Registrar::parameter::key", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1119, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key Registers a parameter with the given key, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1120, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline Registers a parameter with the given key and headline, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1121, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Registers a parameter with the given key, headline and description, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1122, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKc10Unexpected21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description Unexpected gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, and flags, where T is a valid parameter type. The default value is set to an nvidia::gxf::Unexpected. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1123, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value Registers a parameter with the given key, headline, description, and default value, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1124, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvER9ParameterI1TEPKcPKcPKcRK1T21gxf_parameter_flags_t", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter Parameter &lt; T &gt;  &amp; parameter const  char  * key const  char  * headline const  char  * description const  T  &amp; default_value gxf_parameter_flags_t  flags Registers a parameter with the given key, headline, description, default value, and flags, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register key \u2013 A unique string value used during component registration headline \u2013 A brief description of the parameter description \u2013 A detailed description of the parameter default_value \u2013 The default value of the parameter flags \u2013 Flags to specify parameter properties Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1125, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter", "display_name": "nvidia::gxf::Registrar::parameter::parameter", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvERN6nvidia3gxf9ParameterI1TEERK13ParameterInfoI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter nvidia :: gxf :: Parameter &lt; T &gt;  &amp; parameter const  ParameterInfo &lt; T &gt;  &amp; parameter_info Registers a parameter with ParameterInfo containing all the parameter metadata, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register parameter_info \u2013 A struct containing all the parameter metadata Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1126, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::parameter::parameter_info", "display_name": "nvidia::gxf::Registrar::parameter::parameter_info", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar9parameterE8ExpectedIvERN6nvidia3gxf9ParameterI1TEERK13ParameterInfoI1TE", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  parameter nvidia :: gxf :: Parameter &lt; T &gt;  &amp; parameter const  ParameterInfo &lt; T &gt;  &amp; parameter_info Registers a parameter with ParameterInfo containing all the parameter metadata, where T is a valid parameter type. Parameters parameter \u2013 The parameter to register parameter_info \u2013 A struct containing all the parameter metadata Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1127, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::registerParameterlessComponent", "display_name": "nvidia::gxf::Registrar::registerParameterlessComponent", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar30registerParameterlessComponentE8ExpectedIvEv", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  registerParameterlessComponent Registers a component with no parameters. This is called internally by GXF if registerInterface() is not overridden. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1128, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::registerParameterlessComponent::T", "display_name": "nvidia::gxf::Registrar::registerParameterlessComponent::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar30registerParameterlessComponentE8ExpectedIvEv", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  registerParameterlessComponent Registers a component with no parameters. This is called internally by GXF if registerInterface() is not overridden. Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1129, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::resource", "display_name": "nvidia::gxf::Registrar::resource", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar8resourceE8ExpectedIvER8ResourceI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  resource Resource &lt; Handle &lt; T &gt; &gt;  &amp; resource const  char  * description Registers a resource with a description Parameters resource \u2013 The resource to register description \u2013 A detailed description of the resource Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1130, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::resource::T", "display_name": "nvidia::gxf::Registrar::resource::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar8resourceE8ExpectedIvER8ResourceI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  resource Resource &lt; Handle &lt; T &gt; &gt;  &amp; resource const  char  * description Registers a resource with a description Parameters resource \u2013 The resource to register description \u2013 A detailed description of the resource Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1131, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::resource::description", "display_name": "nvidia::gxf::Registrar::resource::description", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar8resourceE8ExpectedIvER8ResourceI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  resource Resource &lt; Handle &lt; T &gt; &gt;  &amp; resource const  char  * description Registers a resource with a description Parameters resource \u2013 The resource to register description \u2013 A detailed description of the resource Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1132, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::Registrar::resource::resource", "display_name": "nvidia::gxf::Registrar::resource::resource", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4I0EN6nvidia3gxf9Registrar8resourceE8ExpectedIvER8ResourceI6HandleI1TEEPKc", "priority": 1, "content": "template &lt; typename  T &gt; Expected &lt; void &gt;  resource Resource &lt; Handle &lt; T &gt; &gt;  &amp; resource const  char  * description Registers a resource with a description Parameters resource \u2013 The resource to register description \u2013 A detailed description of the resource Returns Expected&lt;void&gt; Success or error code on failure", "keywords": []}, {"id": 1133, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle", "display_name": "nvidia::gxf::UntypedHandle", "type": "class", "display_type": "C++ class", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandleE", "priority": 1, "content": "class  nvidia :: gxf :: UntypedHandle The UntypedHandle class is a base class for Handle and provides common functionality for accessing components without specifying their type.", "keywords": []}, {"id": 1134, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::Create", "display_name": "nvidia::gxf::UntypedHandle::Create", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; UntypedHandle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new untyped handle Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new UntypedHandle object for the given context and component ID.", "keywords": []}, {"id": 1135, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::Create::cid", "display_name": "nvidia::gxf::UntypedHandle::Create::cid", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; UntypedHandle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new untyped handle Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new UntypedHandle object for the given context and component ID.", "keywords": []}, {"id": 1136, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::Create::context", "display_name": "nvidia::gxf::UntypedHandle::Create::context", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle6CreateE13gxf_context_t9gxf_uid_t", "priority": 1, "content": "static  Expected &lt; UntypedHandle &gt;  Create gxf_context_t  context gxf_uid_t  cid Creates a new untyped handle Parameters context \u2013 The context to which the component belongs. cid \u2013 The ID of the component. Returns A new UntypedHandle object for the given context and component ID.", "keywords": []}, {"id": 1137, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::Null", "display_name": "nvidia::gxf::UntypedHandle::Null", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle4NullEv", "priority": 1, "content": "static  UntypedHandle  Null Returns A null UntypedHandle object.", "keywords": []}, {"id": 1138, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::UntypedHandle", "display_name": "nvidia::gxf::UntypedHandle::UntypedHandle", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle13UntypedHandleERK13UntypedHandle", "priority": 1, "content": "UntypedHandle const  UntypedHandle  &amp; component  =  default Parameters component \u2013 The UntypedHandle object to copy.", "keywords": []}, {"id": 1139, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::UntypedHandle", "display_name": "nvidia::gxf::UntypedHandle::UntypedHandle", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle13UntypedHandleERR13UntypedHandle", "priority": 1, "content": "UntypedHandle UntypedHandle  &amp; &amp; component  =  default Parameters component \u2013 The UntypedHandle object to move.", "keywords": []}, {"id": 1140, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::UntypedHandle::component", "display_name": "nvidia::gxf::UntypedHandle::UntypedHandle::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle13UntypedHandleERK13UntypedHandle", "priority": 1, "content": "UntypedHandle const  UntypedHandle  &amp; component  =  default Parameters component \u2013 The UntypedHandle object to copy.", "keywords": []}, {"id": 1141, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::UntypedHandle::component", "display_name": "nvidia::gxf::UntypedHandle::UntypedHandle::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandle13UntypedHandleERR13UntypedHandle", "priority": 1, "content": "UntypedHandle UntypedHandle  &amp; &amp; component  =  default Parameters component \u2013 The UntypedHandle object to move.", "keywords": []}, {"id": 1142, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::cid", "display_name": "nvidia::gxf::UntypedHandle::cid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandle3cidEv", "priority": 1, "content": "gxf_uid_t  cid  const Returns The ID of the component.", "keywords": []}, {"id": 1143, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::context", "display_name": "nvidia::gxf::UntypedHandle::context", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandle7contextEv", "priority": 1, "content": "gxf_context_t  context  const Returns The context to which the component belongs.", "keywords": []}, {"id": 1144, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::is_null", "display_name": "nvidia::gxf::UntypedHandle::is_null", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandle7is_nullEv", "priority": 1, "content": "bool  is_null  const Returns True if the handle is equivalent to a nullptr.", "keywords": []}, {"id": 1145, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::name", "display_name": "nvidia::gxf::UntypedHandle::name", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandle4nameEv", "priority": 1, "content": "const  char  * name  const Returns The name of the component.", "keywords": []}, {"id": 1146, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::operator bool", "display_name": "nvidia::gxf::UntypedHandle::operator bool", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandlecvbEv", "priority": 1, "content": "explicit  operator  bool  const Returns True if the handle is not null.", "keywords": []}, {"id": 1147, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::operator=", "display_name": "nvidia::gxf::UntypedHandle::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandleaSERK13UntypedHandle", "priority": 1, "content": "UntypedHandle  &amp; operator = const  UntypedHandle  &amp; component  =  default Parameters component \u2013 The UntypedHandle object to copy.", "keywords": []}, {"id": 1148, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::operator=", "display_name": "nvidia::gxf::UntypedHandle::operator=", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandleaSERR13UntypedHandle", "priority": 1, "content": "UntypedHandle  &amp; operator = UntypedHandle  &amp; &amp; component  =  default Parameters component \u2013 The UntypedHandle object to move.", "keywords": []}, {"id": 1149, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::operator=::component", "display_name": "nvidia::gxf::UntypedHandle::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandleaSERK13UntypedHandle", "priority": 1, "content": "UntypedHandle  &amp; operator = const  UntypedHandle  &amp; component  =  default Parameters component \u2013 The UntypedHandle object to copy.", "keywords": []}, {"id": 1150, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::operator=::component", "display_name": "nvidia::gxf::UntypedHandle::operator=::component", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4N6nvidia3gxf13UntypedHandleaSERR13UntypedHandle", "priority": 1, "content": "UntypedHandle  &amp; operator = UntypedHandle  &amp; &amp; component  =  default Parameters component \u2013 The UntypedHandle object to move.", "keywords": []}, {"id": 1151, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "cpp", "name": "nvidia::gxf::UntypedHandle::tid", "display_name": "nvidia::gxf::UntypedHandle::tid", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "_CPPv4NK6nvidia3gxf13UntypedHandle3tidEv", "priority": 1, "content": "gxf_tid_t  tid  const Returns The type ID describing the component type.", "keywords": []}, {"id": 1152, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C++_APIs#parameter-types", "display_name": "Parameter Types", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "parameter-types", "priority": -1, "content": "GXF supports multiple parameter types natively as described in :c:enum:: gxf_parameter_type_t . All standard C++ data types are supported including POD types, string, bool, handles to components and complex numbers. ParameterWrapper and ParameterParser interfaces can be used to support any custom Parameter type.", "keywords": []}, {"id": 1153, "doc_id": 1153, "filename": "graphtools-docs/docs/text/GXF_Core_C%2B%2B_APIs.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "display_name": "GXF Core C++ APIs", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_Core_C++_APIs", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 1154, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ARGUMENT_INVALID", "display_name": "GXF_ARGUMENT_INVALID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_INVALID", "priority": 1, "content": "enumerator  GXF_ARGUMENT_INVALID Invalid argument.", "keywords": []}, {"id": 1155, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ARGUMENT_NULL", "display_name": "GXF_ARGUMENT_NULL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_NULL", "priority": 1, "content": "enumerator  GXF_ARGUMENT_NULL Argument is null.", "keywords": []}, {"id": 1156, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ARGUMENT_OUT_OF_RANGE", "display_name": "GXF_ARGUMENT_OUT_OF_RANGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_OUT_OF_RANGE", "priority": 1, "content": "enumerator  GXF_ARGUMENT_OUT_OF_RANGE Argument is out of range.", "keywords": []}, {"id": 1157, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_BEHAVIOR_FAILURE", "display_name": "GXF_BEHAVIOR_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_FAILURE", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_FAILURE For codelet that terminates with failure after ticking.", "keywords": []}, {"id": 1158, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_BEHAVIOR_INIT", "display_name": "GXF_BEHAVIOR_INIT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_INIT", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_INIT For codelet that have not yet started running.", "keywords": []}, {"id": 1159, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_BEHAVIOR_RUNNING", "display_name": "GXF_BEHAVIOR_RUNNING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_RUNNING", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_RUNNING For codelet that needs multiple ticks to complete.", "keywords": []}, {"id": 1160, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_BEHAVIOR_SUCCESS", "display_name": "GXF_BEHAVIOR_SUCCESS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_SUCCESS", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_SUCCESS For codelet that terminates with success after ticking.", "keywords": []}, {"id": 1161, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_BEHAVIOR_UNKNOWN", "display_name": "GXF_BEHAVIOR_UNKNOWN", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_UNKNOWN", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_UNKNOWN For non-behavior-tree codelet because we don\u2019t care about the behavior status returned by controller if it is not a BT codelet.", "keywords": []}, {"id": 1162, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONNECTION_ATTEMPTS_EXCEEDED", "display_name": "GXF_CONNECTION_ATTEMPTS_EXCEEDED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONNECTION_ATTEMPTS_EXCEEDED", "priority": 1, "content": "enumerator  GXF_CONNECTION_ATTEMPTS_EXCEEDED Connection attempts exceeded.", "keywords": []}, {"id": 1163, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONNECTION_BROKEN", "display_name": "GXF_CONNECTION_BROKEN", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONNECTION_BROKEN", "priority": 1, "content": "enumerator  GXF_CONNECTION_BROKEN Connection is broken.", "keywords": []}, {"id": 1164, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONTEXT_INVALID", "display_name": "GXF_CONTEXT_INVALID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTEXT_INVALID", "priority": 1, "content": "enumerator  GXF_CONTEXT_INVALID Invalid context.", "keywords": []}, {"id": 1165, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONTRACT_INVALID_SEQUENCE", "display_name": "GXF_CONTRACT_INVALID_SEQUENCE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_INVALID_SEQUENCE", "priority": 1, "content": "enumerator  GXF_CONTRACT_INVALID_SEQUENCE Invalid contract sequence.", "keywords": []}, {"id": 1166, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "display_name": "GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "priority": 1, "content": "enumerator  GXF_CONTRACT_MESSAGE_NOT_AVAILABLE Contract message is not available.", "keywords": []}, {"id": 1167, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_CONTRACT_PARAMETER_NOT_SET", "display_name": "GXF_CONTRACT_PARAMETER_NOT_SET", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_PARAMETER_NOT_SET", "priority": 1, "content": "enumerator  GXF_CONTRACT_PARAMETER_NOT_SET Contract parameter is not set.", "keywords": []}, {"id": 1168, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "display_name": "GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "priority": 1, "content": "enumerator  GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION Cannot add component to entity after initialization.", "keywords": []}, {"id": 1169, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "display_name": "GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "priority": 1, "content": "enumerator  GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION Cannot remove component from entity after initialization.", "keywords": []}, {"id": 1170, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_COMPONENT_NOT_FOUND", "display_name": "GXF_ENTITY_COMPONENT_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_COMPONENT_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_COMPONENT_NOT_FOUND Entity component was not found.", "keywords": []}, {"id": 1171, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_GROUP_NOT_FOUND", "display_name": "GXF_ENTITY_GROUP_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_GROUP_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_GROUP_NOT_FOUND Entity group was not found.", "keywords": []}, {"id": 1172, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_MAX", "display_name": "GXF_ENTITY_MAX", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_MAX", "priority": 1, "content": "enumerator  GXF_ENTITY_MAX Entity max", "keywords": []}, {"id": 1173, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "display_name": "GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "priority": 1, "content": "enumerator  GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED Maximum limit of number of components in an entity exceeded", "keywords": []}, {"id": 1174, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_NAME_EXCEEDS_LIMIT", "display_name": "GXF_ENTITY_NAME_EXCEEDS_LIMIT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_NAME_EXCEEDS_LIMIT", "priority": 1, "content": "enumerator  GXF_ENTITY_NAME_EXCEEDS_LIMIT Entity name string exceeds specified limit.", "keywords": []}, {"id": 1175, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_NOT_FOUND", "display_name": "GXF_ENTITY_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_NOT_FOUND Entity was not found.", "keywords": []}, {"id": 1176, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_IDLE", "display_name": "GXF_ENTITY_STATUS_IDLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_IDLE", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_IDLE Entity is idle.", "keywords": []}, {"id": 1177, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_NOT_STARTED", "display_name": "GXF_ENTITY_STATUS_NOT_STARTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_NOT_STARTED", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_NOT_STARTED Entity has not started.", "keywords": []}, {"id": 1178, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_STARTED", "display_name": "GXF_ENTITY_STATUS_STARTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_STARTED", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_STARTED Entity has started.", "keywords": []}, {"id": 1179, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_START_PENDING", "display_name": "GXF_ENTITY_STATUS_START_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_START_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_START_PENDING Entity start is pending.", "keywords": []}, {"id": 1180, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_STOP_PENDING", "display_name": "GXF_ENTITY_STATUS_STOP_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_STOP_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_STOP_PENDING Entity stop is pending.", "keywords": []}, {"id": 1181, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_TICKING", "display_name": "GXF_ENTITY_STATUS_TICKING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_TICKING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_TICKING Entity is ticking.", "keywords": []}, {"id": 1182, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_ENTITY_STATUS_TICK_PENDING", "display_name": "GXF_ENTITY_STATUS_TICK_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_TICK_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_TICK_PENDING Entity tick is pending.", "keywords": []}, {"id": 1183, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_CUSTOM", "display_name": "GXF_EVENT_CUSTOM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_CUSTOM", "priority": 1, "content": "enumerator  GXF_EVENT_CUSTOM", "keywords": []}, {"id": 1184, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_EXTERNAL", "display_name": "GXF_EVENT_EXTERNAL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_EXTERNAL", "priority": 1, "content": "enumerator  GXF_EVENT_EXTERNAL", "keywords": []}, {"id": 1185, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_MEMORY_FREE", "display_name": "GXF_EVENT_MEMORY_FREE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_MEMORY_FREE", "priority": 1, "content": "enumerator  GXF_EVENT_MEMORY_FREE", "keywords": []}, {"id": 1186, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_MESSAGE_SYNC", "display_name": "GXF_EVENT_MESSAGE_SYNC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_MESSAGE_SYNC", "priority": 1, "content": "enumerator  GXF_EVENT_MESSAGE_SYNC", "keywords": []}, {"id": 1187, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_STATE_UPDATE", "display_name": "GXF_EVENT_STATE_UPDATE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_STATE_UPDATE", "priority": 1, "content": "enumerator  GXF_EVENT_STATE_UPDATE", "keywords": []}, {"id": 1188, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EVENT_TIME_UPDATE", "display_name": "GXF_EVENT_TIME_UPDATE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_TIME_UPDATE", "priority": 1, "content": "enumerator  GXF_EVENT_TIME_UPDATE", "keywords": []}, {"id": 1189, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EXCEEDING_PREALLOCATED_SIZE", "display_name": "GXF_EXCEEDING_PREALLOCATED_SIZE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXCEEDING_PREALLOCATED_SIZE", "priority": 1, "content": "enumerator  GXF_EXCEEDING_PREALLOCATED_SIZE Exceeding preallocated size.", "keywords": []}, {"id": 1190, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EXTENSION_FILE_NOT_FOUND", "display_name": "GXF_EXTENSION_FILE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_FILE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_EXTENSION_FILE_NOT_FOUND Extension file was not found.", "keywords": []}, {"id": 1191, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EXTENSION_NOT_FOUND", "display_name": "GXF_EXTENSION_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_EXTENSION_NOT_FOUND Extension was not found.", "keywords": []}, {"id": 1192, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_EXTENSION_NO_FACTORY", "display_name": "GXF_EXTENSION_NO_FACTORY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_NO_FACTORY", "priority": 1, "content": "enumerator  GXF_EXTENSION_NO_FACTORY Extension has no factory.", "keywords": []}, {"id": 1193, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_ABSTRACT_CLASS", "display_name": "GXF_FACTORY_ABSTRACT_CLASS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_ABSTRACT_CLASS", "priority": 1, "content": "enumerator  GXF_FACTORY_ABSTRACT_CLASS Factory abstract class.", "keywords": []}, {"id": 1194, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_DUPLICATE_TID", "display_name": "GXF_FACTORY_DUPLICATE_TID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_DUPLICATE_TID", "priority": 1, "content": "enumerator  GXF_FACTORY_DUPLICATE_TID Duplicate type ID in a factory.", "keywords": []}, {"id": 1195, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_INCOMPATIBLE", "display_name": "GXF_FACTORY_INCOMPATIBLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_INCOMPATIBLE", "priority": 1, "content": "enumerator  GXF_FACTORY_INCOMPATIBLE Factory is incompatible.", "keywords": []}, {"id": 1196, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_INVALID_INFO", "display_name": "GXF_FACTORY_INVALID_INFO", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_INVALID_INFO", "priority": 1, "content": "enumerator  GXF_FACTORY_INVALID_INFO Invalid factory info.", "keywords": []}, {"id": 1197, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_TOO_MANY_COMPONENTS", "display_name": "GXF_FACTORY_TOO_MANY_COMPONENTS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_TOO_MANY_COMPONENTS", "priority": 1, "content": "enumerator  GXF_FACTORY_TOO_MANY_COMPONENTS Too many components in factory.", "keywords": []}, {"id": 1198, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_UNKNOWN_CLASS_NAME", "display_name": "GXF_FACTORY_UNKNOWN_CLASS_NAME", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_UNKNOWN_CLASS_NAME", "priority": 1, "content": "enumerator  GXF_FACTORY_UNKNOWN_CLASS_NAME Unknown class name in factory.", "keywords": []}, {"id": 1199, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FACTORY_UNKNOWN_TID", "display_name": "GXF_FACTORY_UNKNOWN_TID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_UNKNOWN_TID", "priority": 1, "content": "enumerator  GXF_FACTORY_UNKNOWN_TID Unknown type ID in a factory.", "keywords": []}, {"id": 1200, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FAILURE", "display_name": "GXF_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FAILURE", "priority": 1, "content": "enumerator  GXF_FAILURE Operation failed.", "keywords": []}, {"id": 1201, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_FILE_NOT_FOUND", "display_name": "GXF_FILE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FILE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_FILE_NOT_FOUND File was not found.", "keywords": []}, {"id": 1202, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_HTTP_GET_FAILURE", "display_name": "GXF_HTTP_GET_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_HTTP_GET_FAILURE", "priority": 1, "content": "enumerator  GXF_HTTP_GET_FAILURE HTTP GET request failed.", "keywords": []}, {"id": 1203, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_HTTP_POST_FAILURE", "display_name": "GXF_HTTP_POST_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_HTTP_POST_FAILURE", "priority": 1, "content": "enumerator  GXF_HTTP_POST_FAILURE HTTP POST request failed.", "keywords": []}, {"id": 1204, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_INVALID_DATA_FORMAT", "display_name": "GXF_INVALID_DATA_FORMAT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_DATA_FORMAT", "priority": 1, "content": "enumerator  GXF_INVALID_DATA_FORMAT Invalid data format.", "keywords": []}, {"id": 1205, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_INVALID_ENUM", "display_name": "GXF_INVALID_ENUM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_ENUM", "priority": 1, "content": "enumerator  GXF_INVALID_ENUM Invalid enumeration value.", "keywords": []}, {"id": 1206, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_INVALID_EXECUTION_SEQUENCE", "display_name": "GXF_INVALID_EXECUTION_SEQUENCE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_EXECUTION_SEQUENCE", "priority": 1, "content": "enumerator  GXF_INVALID_EXECUTION_SEQUENCE Invalid execution sequence.", "keywords": []}, {"id": 1207, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_INVALID_LIFECYCLE_STAGE", "display_name": "GXF_INVALID_LIFECYCLE_STAGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_LIFECYCLE_STAGE", "priority": 1, "content": "enumerator  GXF_INVALID_LIFECYCLE_STAGE Invalid lifecycle stage.", "keywords": []}, {"id": 1208, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_IPC_CALL_FAILURE", "display_name": "GXF_IPC_CALL_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_CALL_FAILURE", "priority": 1, "content": "enumerator  GXF_IPC_CALL_FAILURE IPC call failure.", "keywords": []}, {"id": 1209, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_IPC_CONNECTION_FAILURE", "display_name": "GXF_IPC_CONNECTION_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_CONNECTION_FAILURE", "priority": 1, "content": "enumerator  GXF_IPC_CONNECTION_FAILURE IPC connection failure.", "keywords": []}, {"id": 1210, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_IPC_SERVICE_NOT_FOUND", "display_name": "GXF_IPC_SERVICE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_SERVICE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_IPC_SERVICE_NOT_FOUND IPC service was not found.", "keywords": []}, {"id": 1211, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_MEMORY_INVALID_STORAGE_MODE", "display_name": "GXF_MEMORY_INVALID_STORAGE_MODE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_MEMORY_INVALID_STORAGE_MODE", "priority": 1, "content": "enumerator  GXF_MEMORY_INVALID_STORAGE_MODE Invalid memory storage mode.", "keywords": []}, {"id": 1212, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_NOT_FINISHED", "display_name": "GXF_NOT_FINISHED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NOT_FINISHED", "priority": 1, "content": "enumerator  GXF_NOT_FINISHED Operation is not finished.", "keywords": []}, {"id": 1213, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_NOT_IMPLEMENTED", "display_name": "GXF_NOT_IMPLEMENTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NOT_IMPLEMENTED", "priority": 1, "content": "enumerator  GXF_NOT_IMPLEMENTED Feature is not implemented.", "keywords": []}, {"id": 1214, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_NULL_POINTER", "display_name": "GXF_NULL_POINTER", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NULL_POINTER", "priority": 1, "content": "enumerator  GXF_NULL_POINTER Null pointer was passed.", "keywords": []}, {"id": 1215, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_OUT_OF_MEMORY", "display_name": "GXF_OUT_OF_MEMORY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_OUT_OF_MEMORY", "priority": 1, "content": "enumerator  GXF_OUT_OF_MEMORY Out of memory.", "keywords": []}, {"id": 1216, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_ALREADY_REGISTERED", "display_name": "GXF_PARAMETER_ALREADY_REGISTERED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_ALREADY_REGISTERED", "priority": 1, "content": "enumerator  GXF_PARAMETER_ALREADY_REGISTERED Parameter is already registered.", "keywords": []}, {"id": 1217, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "display_name": "GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "priority": 1, "content": "enumerator  GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT Cannot modify constant parameter.", "keywords": []}, {"id": 1218, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_FLAGS_DYNAMIC", "display_name": "GXF_PARAMETER_FLAGS_DYNAMIC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_DYNAMIC", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_DYNAMIC The parameter is dynamic an might change after entity activation. However it is still guaranteed that parameters do not change during the initialize, deinitialize, start, tick, or stop functions.", "keywords": []}, {"id": 1219, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_FLAGS_NONE", "display_name": "GXF_PARAMETER_FLAGS_NONE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_NONE", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_NONE No additional flags are set (the default). This means the parameter is mandatory and static. The parameter must be set before entity activation and can not be changed after entity activation.", "keywords": []}, {"id": 1220, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_FLAGS_OPTIONAL", "display_name": "GXF_PARAMETER_FLAGS_OPTIONAL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_OPTIONAL", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_OPTIONAL The parameter value is optional and might not be available after entity activation. This implies that it is not allowed to access the parameter with \u2018get()\u2019 in the C++ API. Instead \u2018try_get\u2019 must be used.", "keywords": []}, {"id": 1221, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_INVALID_TYPE", "display_name": "GXF_PARAMETER_INVALID_TYPE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_INVALID_TYPE", "priority": 1, "content": "enumerator  GXF_PARAMETER_INVALID_TYPE Invalid parameter type.", "keywords": []}, {"id": 1222, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_MANDATORY_NOT_SET", "display_name": "GXF_PARAMETER_MANDATORY_NOT_SET", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_MANDATORY_NOT_SET", "priority": 1, "content": "enumerator  GXF_PARAMETER_MANDATORY_NOT_SET Mandatory parameter is not set.", "keywords": []}, {"id": 1223, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_NOT_FOUND", "display_name": "GXF_PARAMETER_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_FOUND Parameter was not found.", "keywords": []}, {"id": 1224, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_NOT_INITIALIZED", "display_name": "GXF_PARAMETER_NOT_INITIALIZED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_INITIALIZED", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_INITIALIZED Parameter is not initialized.", "keywords": []}, {"id": 1225, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_NOT_NUMERIC", "display_name": "GXF_PARAMETER_NOT_NUMERIC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_NUMERIC", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_NUMERIC Parameter is not numeric.", "keywords": []}, {"id": 1226, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_OUT_OF_RANGE", "display_name": "GXF_PARAMETER_OUT_OF_RANGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_OUT_OF_RANGE", "priority": 1, "content": "enumerator  GXF_PARAMETER_OUT_OF_RANGE Parameter is out of range.", "keywords": []}, {"id": 1227, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_PARSER_ERROR", "display_name": "GXF_PARAMETER_PARSER_ERROR", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_PARSER_ERROR", "priority": 1, "content": "enumerator  GXF_PARAMETER_PARSER_ERROR Parameter parser error.", "keywords": []}, {"id": 1228, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_BOOL", "display_name": "GXF_PARAMETER_TYPE_BOOL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_BOOL", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_BOOL A boolean type ( bool ).", "keywords": []}, {"id": 1229, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_COMPLEX128", "display_name": "GXF_PARAMETER_TYPE_COMPLEX128", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX128", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_COMPLEX128 A 128-bit complex floating point ( double ). Gets a string describing the parameter type", "keywords": []}, {"id": 1230, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_COMPLEX64", "display_name": "GXF_PARAMETER_TYPE_COMPLEX64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_COMPLEX64 A 64-bit complex floating point ( float ).", "keywords": []}, {"id": 1231, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_CUSTOM", "display_name": "GXF_PARAMETER_TYPE_CUSTOM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_CUSTOM", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_CUSTOM A custom type not natively supported by GXF.", "keywords": []}, {"id": 1232, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_FILE", "display_name": "GXF_PARAMETER_TYPE_FILE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FILE", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FILE A file system path (string).", "keywords": []}, {"id": 1233, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_FLOAT32", "display_name": "GXF_PARAMETER_TYPE_FLOAT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FLOAT32 A 32-bit floating point ( float ).", "keywords": []}, {"id": 1234, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_FLOAT64", "display_name": "GXF_PARAMETER_TYPE_FLOAT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FLOAT64 A 64-bit floating point ( double ).", "keywords": []}, {"id": 1235, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_HANDLE", "display_name": "GXF_PARAMETER_TYPE_HANDLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_HANDLE", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_HANDLE A GXF handle. The handle type is specified separately.", "keywords": []}, {"id": 1236, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_INT16", "display_name": "GXF_PARAMETER_TYPE_INT16", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT16", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT16 A 16-bit signed integer ( int16_t ).", "keywords": []}, {"id": 1237, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_INT32", "display_name": "GXF_PARAMETER_TYPE_INT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT32 A 32-bit signed integer ( int32_t ).", "keywords": []}, {"id": 1238, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_INT64", "display_name": "GXF_PARAMETER_TYPE_INT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT64 A 64-bit signed integer ( int64_t ).", "keywords": []}, {"id": 1239, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_INT8", "display_name": "GXF_PARAMETER_TYPE_INT8", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT8", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT8 A 8-bit signed integer ( int8_t ).", "keywords": []}, {"id": 1240, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_STRING", "display_name": "GXF_PARAMETER_TYPE_STRING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_STRING", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_STRING A null-terminated character string ( const char* ).", "keywords": []}, {"id": 1241, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_UINT16", "display_name": "GXF_PARAMETER_TYPE_UINT16", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT16", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT16 A 16-bit unsigned integer ( uint16_t ).", "keywords": []}, {"id": 1242, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_UINT32", "display_name": "GXF_PARAMETER_TYPE_UINT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT32 A 32-bit unsigned integer ( uint32_t ).", "keywords": []}, {"id": 1243, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_UINT64", "display_name": "GXF_PARAMETER_TYPE_UINT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT64 A 64-bit unsigned integer ( uint64_t ).", "keywords": []}, {"id": 1244, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_PARAMETER_TYPE_UINT8", "display_name": "GXF_PARAMETER_TYPE_UINT8", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT8", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT8 A 8-bit unsigned integer ( uint8_t ).", "keywords": []}, {"id": 1245, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_QUERY_NOT_APPLICABLE", "display_name": "GXF_QUERY_NOT_APPLICABLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_APPLICABLE", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_APPLICABLE Query is not applicable.", "keywords": []}, {"id": 1246, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_QUERY_NOT_ENOUGH_CAPACITY", "display_name": "GXF_QUERY_NOT_ENOUGH_CAPACITY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_ENOUGH_CAPACITY", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_ENOUGH_CAPACITY Query does not have enough capacity.", "keywords": []}, {"id": 1247, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_QUERY_NOT_FOUND", "display_name": "GXF_QUERY_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_FOUND Query was not found.", "keywords": []}, {"id": 1248, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_REF_COUNT_NEGATIVE", "display_name": "GXF_REF_COUNT_NEGATIVE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_REF_COUNT_NEGATIVE", "priority": 1, "content": "enumerator  GXF_REF_COUNT_NEGATIVE Reference count is negative.", "keywords": []}, {"id": 1249, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_RESOURCE_NOT_FOUND", "display_name": "GXF_RESOURCE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESOURCE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_RESOURCE_NOT_FOUND Resource was not found.", "keywords": []}, {"id": 1250, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_RESOURCE_NOT_INITIALIZED", "display_name": "GXF_RESOURCE_NOT_INITIALIZED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESOURCE_NOT_INITIALIZED", "priority": 1, "content": "enumerator  GXF_RESOURCE_NOT_INITIALIZED Resource is not initialized.", "keywords": []}, {"id": 1251, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_RESULT_ARRAY_TOO_SMALL", "display_name": "GXF_RESULT_ARRAY_TOO_SMALL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESULT_ARRAY_TOO_SMALL", "priority": 1, "content": "enumerator  GXF_RESULT_ARRAY_TOO_SMALL Result array is too small.", "keywords": []}, {"id": 1252, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_SUCCESS", "display_name": "GXF_SUCCESS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_SUCCESS", "priority": 1, "content": "enumerator  GXF_SUCCESS Operation was successful.", "keywords": []}, {"id": 1253, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GXF_UNINITIALIZED_VALUE", "display_name": "GXF_UNINITIALIZED_VALUE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_UNINITIALIZED_VALUE", "priority": 1, "content": "enumerator  GXF_UNINITIALIZED_VALUE Value was not initialized.", "keywords": []}, {"id": 1254, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd", "display_name": "GxfComponentAdd", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1255, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd.cid", "display_name": "GxfComponentAdd.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1256, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd.context", "display_name": "GxfComponentAdd.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1257, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd.eid", "display_name": "GxfComponentAdd.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1258, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd.name", "display_name": "GxfComponentAdd.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1259, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAdd.tid", "display_name": "GxfComponentAdd.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAdd", "priority": 1, "content": "gxf_result_t  GxfComponentAdd gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name gxf_uid_t  * cid ; Adds a new component to an entity An entity can contain multiple components and this function can be used to add a new component to an entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1260, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr", "display_name": "GxfComponentAddAndGetPtr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1261, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.cid", "display_name": "GxfComponentAddAndGetPtr.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1262, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.comp_ptr", "display_name": "GxfComponentAddAndGetPtr.comp_ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1263, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.context", "display_name": "GxfComponentAddAndGetPtr.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1264, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.item_ptr", "display_name": "GxfComponentAddAndGetPtr.item_ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1265, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.name", "display_name": "GxfComponentAddAndGetPtr.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1266, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddAndGetPtr.tid", "display_name": "GxfComponentAddAndGetPtr.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentAddAndGetPtr gxf_context_t  context void  * item_ptr gxf_tid_t  tid const  char  * name gxf_uid_t  * cid void  * * comp_ptr ; An entity can contain multiple components and this function can be used to add a new component to an Entity. A component must be added before an entity is activated, or after it was deactivated. Components must not be added to active entities. The order of components is stable and identical to the order in which components are added (see \u2018GxfComponentFind\u2019). Parameters context \u2013 A valid GXF context item_ptr \u2013 The pointer to entity item tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. cid \u2013 The returned UID of the created component comp_ptr \u2013 The returned pointer to the created component object Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1267, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddToInterface", "display_name": "GxfComponentAddToInterface", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddToInterface", "priority": 1, "content": "gxf_result_t  GxfComponentAddToInterface gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid const  char  * name ; Adds an existing component to the interface of an entity An entity can holds references to other components in its interface, so that when finding a component in an entity, both the component this entity holds and those it refers to will be returned. This supports the case when an entity contains a subgraph, then those components that has been declared in the subgraph interface will be put to the interface of the parent entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. cid \u2013 The unique object ID of the component. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1268, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddToInterface.cid", "display_name": "GxfComponentAddToInterface.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddToInterface", "priority": 1, "content": "gxf_result_t  GxfComponentAddToInterface gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid const  char  * name ; Adds an existing component to the interface of an entity An entity can holds references to other components in its interface, so that when finding a component in an entity, both the component this entity holds and those it refers to will be returned. This supports the case when an entity contains a subgraph, then those components that has been declared in the subgraph interface will be put to the interface of the parent entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. cid \u2013 The unique object ID of the component. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1269, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddToInterface.context", "display_name": "GxfComponentAddToInterface.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddToInterface", "priority": 1, "content": "gxf_result_t  GxfComponentAddToInterface gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid const  char  * name ; Adds an existing component to the interface of an entity An entity can holds references to other components in its interface, so that when finding a component in an entity, both the component this entity holds and those it refers to will be returned. This supports the case when an entity contains a subgraph, then those components that has been declared in the subgraph interface will be put to the interface of the parent entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. cid \u2013 The unique object ID of the component. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1270, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddToInterface.eid", "display_name": "GxfComponentAddToInterface.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddToInterface", "priority": 1, "content": "gxf_result_t  GxfComponentAddToInterface gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid const  char  * name ; Adds an existing component to the interface of an entity An entity can holds references to other components in its interface, so that when finding a component in an entity, both the component this entity holds and those it refers to will be returned. This supports the case when an entity contains a subgraph, then those components that has been declared in the subgraph interface will be put to the interface of the parent entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. cid \u2013 The unique object ID of the component. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1271, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentAddToInterface.name", "display_name": "GxfComponentAddToInterface.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentAddToInterface", "priority": 1, "content": "gxf_result_t  GxfComponentAddToInterface gxf_context_t  context gxf_uid_t  eid gxf_uid_t  cid const  char  * name ; Adds an existing component to the interface of an entity An entity can holds references to other components in its interface, so that when finding a component in an entity, both the component this entity holds and those it refers to will be returned. This supports the case when an entity contains a subgraph, then those components that has been declared in the subgraph interface will be put to the interface of the parent entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. cid \u2013 The unique object ID of the component. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1272, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentEntity", "display_name": "GxfComponentEntity", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentEntity", "priority": 1, "content": "gxf_result_t  GxfComponentEntity gxf_context_t  context gxf_uid_t  cid gxf_uid_t  * eid ; Gets the unique object ID of the entity of a component Each component has a unique ID with respect to the context and is stored in one entity. This function can be used to retreive the ID of the entity to which a given component belongs. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1273, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentEntity.cid", "display_name": "GxfComponentEntity.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentEntity", "priority": 1, "content": "gxf_result_t  GxfComponentEntity gxf_context_t  context gxf_uid_t  cid gxf_uid_t  * eid ; Gets the unique object ID of the entity of a component Each component has a unique ID with respect to the context and is stored in one entity. This function can be used to retreive the ID of the entity to which a given component belongs. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1274, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentEntity.context", "display_name": "GxfComponentEntity.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentEntity", "priority": 1, "content": "gxf_result_t  GxfComponentEntity gxf_context_t  context gxf_uid_t  cid gxf_uid_t  * eid ; Gets the unique object ID of the entity of a component Each component has a unique ID with respect to the context and is stored in one entity. This function can be used to retreive the ID of the entity to which a given component belongs. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1275, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentEntity.eid", "display_name": "GxfComponentEntity.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentEntity", "priority": 1, "content": "gxf_result_t  GxfComponentEntity gxf_context_t  context gxf_uid_t  cid gxf_uid_t  * eid ; Gets the unique object ID of the entity of a component Each component has a unique ID with respect to the context and is stored in one entity. This function can be used to retreive the ID of the entity to which a given component belongs. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1276, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind", "display_name": "GxfComponentFind", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1277, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.cid", "display_name": "GxfComponentFind.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1278, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.context", "display_name": "GxfComponentFind.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1279, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.eid", "display_name": "GxfComponentFind.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1280, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.name", "display_name": "GxfComponentFind.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1281, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.offset", "display_name": "GxfComponentFind.offset", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1282, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFind.tid", "display_name": "GxfComponentFind.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFind", "priority": 1, "content": "gxf_result_t  GxfComponentFind gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid ; Finds a component in an entity Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1283, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAll", "display_name": "GxfComponentFindAll", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAll", "priority": 1, "content": "gxf_result_t  GxfComponentFindAll gxf_context_t  context gxf_uid_t  eid uint64_t  * num_cids gxf_uid_t  * cids ; Finds all components in an entity Finds and returns all component ids for the given entity. If more than num_cids exist GXF_QUERY_NOT_ENOUGH_CAPACITY will be returned and num_cids will be updated to the actual number of components in the entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. num_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of components that exist in the entity cids \u2013 A buffer allocated by the caller for returned UIDs of all components, with capacity for num_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more components exist in the entity than num_cids , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1284, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAll.cids", "display_name": "GxfComponentFindAll.cids", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAll", "priority": 1, "content": "gxf_result_t  GxfComponentFindAll gxf_context_t  context gxf_uid_t  eid uint64_t  * num_cids gxf_uid_t  * cids ; Finds all components in an entity Finds and returns all component ids for the given entity. If more than num_cids exist GXF_QUERY_NOT_ENOUGH_CAPACITY will be returned and num_cids will be updated to the actual number of components in the entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. num_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of components that exist in the entity cids \u2013 A buffer allocated by the caller for returned UIDs of all components, with capacity for num_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more components exist in the entity than num_cids , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1285, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAll.context", "display_name": "GxfComponentFindAll.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAll", "priority": 1, "content": "gxf_result_t  GxfComponentFindAll gxf_context_t  context gxf_uid_t  eid uint64_t  * num_cids gxf_uid_t  * cids ; Finds all components in an entity Finds and returns all component ids for the given entity. If more than num_cids exist GXF_QUERY_NOT_ENOUGH_CAPACITY will be returned and num_cids will be updated to the actual number of components in the entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. num_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of components that exist in the entity cids \u2013 A buffer allocated by the caller for returned UIDs of all components, with capacity for num_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more components exist in the entity than num_cids , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1286, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAll.eid", "display_name": "GxfComponentFindAll.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAll", "priority": 1, "content": "gxf_result_t  GxfComponentFindAll gxf_context_t  context gxf_uid_t  eid uint64_t  * num_cids gxf_uid_t  * cids ; Finds all components in an entity Finds and returns all component ids for the given entity. If more than num_cids exist GXF_QUERY_NOT_ENOUGH_CAPACITY will be returned and num_cids will be updated to the actual number of components in the entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. num_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of components that exist in the entity cids \u2013 A buffer allocated by the caller for returned UIDs of all components, with capacity for num_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more components exist in the entity than num_cids , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1287, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAll.num_cids", "display_name": "GxfComponentFindAll.num_cids", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAll", "priority": 1, "content": "gxf_result_t  GxfComponentFindAll gxf_context_t  context gxf_uid_t  eid uint64_t  * num_cids gxf_uid_t  * cids ; Finds all components in an entity Finds and returns all component ids for the given entity. If more than num_cids exist GXF_QUERY_NOT_ENOUGH_CAPACITY will be returned and num_cids will be updated to the actual number of components in the entity. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. num_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of components that exist in the entity cids \u2013 A buffer allocated by the caller for returned UIDs of all components, with capacity for num_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more components exist in the entity than num_cids , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1288, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr", "display_name": "GxfComponentFindAndGetPtr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1289, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.cid", "display_name": "GxfComponentFindAndGetPtr.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1290, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.context", "display_name": "GxfComponentFindAndGetPtr.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1291, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.eid", "display_name": "GxfComponentFindAndGetPtr.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1292, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.item_ptr", "display_name": "GxfComponentFindAndGetPtr.item_ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1293, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.name", "display_name": "GxfComponentFindAndGetPtr.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1294, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.offset", "display_name": "GxfComponentFindAndGetPtr.offset", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1295, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.ptr", "display_name": "GxfComponentFindAndGetPtr.ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1296, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentFindAndGetPtr.tid", "display_name": "GxfComponentFindAndGetPtr.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentFindAndGetPtr", "priority": 1, "content": "gxf_result_t  GxfComponentFindAndGetPtr gxf_context_t  context gxf_uid_t  eid void  * item_ptr gxf_tid_t  tid const  char  * name int32_t  * offset gxf_uid_t  * cid void  * * ptr ; Searches components in an entity which satisfy certain criteria: component type, component name. All two criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is returned. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity which is searched. item_ptr \u2013 The pointer to entity item tid \u2013 The component type ID (TID) of the component to find (optional) name \u2013 The component name of the component to find (optional). Ownership not transferred. offset \u2013 The index of the first component in the entity to search. Also contains the index of the component which was found. cid \u2013 The returned UID of the searched component ptr \u2013 The returned pointer of the searched component Returns GXF_SUCCESS if a component matching the criteria was found, GXF_ENTITY_NOT_FOUND if no component matching the criteria was found, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1297, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentInfo", "display_name": "GxfComponentInfo", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentInfo", "priority": 1, "content": "gxf_result_t  GxfComponentInfo gxf_context_t  context gxf_tid_t  tid gxf_component_info_t  * info ; Note: Parameters are only available after at least one instance is created for the Component. Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the component. info \u2013 pointer to gxf_component_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1298, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentInfo.context", "display_name": "GxfComponentInfo.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentInfo", "priority": 1, "content": "gxf_result_t  GxfComponentInfo gxf_context_t  context gxf_tid_t  tid gxf_component_info_t  * info ; Note: Parameters are only available after at least one instance is created for the Component. Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the component. info \u2013 pointer to gxf_component_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1299, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentInfo.info", "display_name": "GxfComponentInfo.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentInfo", "priority": 1, "content": "gxf_result_t  GxfComponentInfo gxf_context_t  context gxf_tid_t  tid gxf_component_info_t  * info ; Note: Parameters are only available after at least one instance is created for the Component. Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the component. info \u2013 pointer to gxf_component_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1300, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentInfo.tid", "display_name": "GxfComponentInfo.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentInfo", "priority": 1, "content": "gxf_result_t  GxfComponentInfo gxf_context_t  context gxf_tid_t  tid gxf_component_info_t  * info ; Note: Parameters are only available after at least one instance is created for the Component. Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the component. info \u2013 pointer to gxf_component_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1301, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentIsBase", "display_name": "GxfComponentIsBase", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentIsBase", "priority": 1, "content": "gxf_result_t  GxfComponentIsBase gxf_context_t  context gxf_tid_t  derived gxf_tid_t  base bool  * result ; Check if a registered type in an extension is derived from another registered type from the same or any other extension. This is useful query the component hierarchies using their type id\u2019s. Both the derived and base types have to be registered in an extension via one of the registered via GXF_EXT_FACTORY_ADD* macros. Parameters context \u2013 A valid GXF context derived \u2013 The type ID (TID) of a derived type base \u2013 The type ID (TID) of a base type Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1302, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentIsBase.base", "display_name": "GxfComponentIsBase.base", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentIsBase", "priority": 1, "content": "gxf_result_t  GxfComponentIsBase gxf_context_t  context gxf_tid_t  derived gxf_tid_t  base bool  * result ; Check if a registered type in an extension is derived from another registered type from the same or any other extension. This is useful query the component hierarchies using their type id\u2019s. Both the derived and base types have to be registered in an extension via one of the registered via GXF_EXT_FACTORY_ADD* macros. Parameters context \u2013 A valid GXF context derived \u2013 The type ID (TID) of a derived type base \u2013 The type ID (TID) of a base type Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1303, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentIsBase.context", "display_name": "GxfComponentIsBase.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentIsBase", "priority": 1, "content": "gxf_result_t  GxfComponentIsBase gxf_context_t  context gxf_tid_t  derived gxf_tid_t  base bool  * result ; Check if a registered type in an extension is derived from another registered type from the same or any other extension. This is useful query the component hierarchies using their type id\u2019s. Both the derived and base types have to be registered in an extension via one of the registered via GXF_EXT_FACTORY_ADD* macros. Parameters context \u2013 A valid GXF context derived \u2013 The type ID (TID) of a derived type base \u2013 The type ID (TID) of a base type Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1304, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentIsBase.derived", "display_name": "GxfComponentIsBase.derived", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentIsBase", "priority": 1, "content": "gxf_result_t  GxfComponentIsBase gxf_context_t  context gxf_tid_t  derived gxf_tid_t  base bool  * result ; Check if a registered type in an extension is derived from another registered type from the same or any other extension. This is useful query the component hierarchies using their type id\u2019s. Both the derived and base types have to be registered in an extension via one of the registered via GXF_EXT_FACTORY_ADD* macros. Parameters context \u2013 A valid GXF context derived \u2013 The type ID (TID) of a derived type base \u2013 The type ID (TID) of a base type Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1305, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentIsBase.result", "display_name": "GxfComponentIsBase.result", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentIsBase", "priority": 1, "content": "gxf_result_t  GxfComponentIsBase gxf_context_t  context gxf_tid_t  derived gxf_tid_t  base bool  * result ; Check if a registered type in an extension is derived from another registered type from the same or any other extension. This is useful query the component hierarchies using their type id\u2019s. Both the derived and base types have to be registered in an extension via one of the registered via GXF_EXT_FACTORY_ADD* macros. Parameters context \u2013 A valid GXF context derived \u2013 The type ID (TID) of a derived type base \u2013 The type ID (TID) of a base type Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1306, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentName", "display_name": "GxfComponentName", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentName", "priority": 1, "content": "gxf_result_t  GxfComponentName gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the name of a component Each component has a user-defined name which was used in the call to \u2018GxfComponentAdd\u2019. Usually the name is specified in the GXF application file. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1307, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentName.cid", "display_name": "GxfComponentName.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentName", "priority": 1, "content": "gxf_result_t  GxfComponentName gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the name of a component Each component has a user-defined name which was used in the call to \u2018GxfComponentAdd\u2019. Usually the name is specified in the GXF application file. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1308, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentName.context", "display_name": "GxfComponentName.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentName", "priority": 1, "content": "gxf_result_t  GxfComponentName gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the name of a component Each component has a user-defined name which was used in the call to \u2018GxfComponentAdd\u2019. Usually the name is specified in the GXF application file. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1309, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentName.name", "display_name": "GxfComponentName.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentName", "priority": 1, "content": "gxf_result_t  GxfComponentName gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the name of a component Each component has a user-defined name which was used in the call to \u2018GxfComponentAdd\u2019. Usually the name is specified in the GXF application file. Parameters context \u2013 A valid GXF context cid \u2013 The unique object ID (UID) of the component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1310, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentPointer", "display_name": "GxfComponentPointer", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentPointer", "priority": 1, "content": "gxf_result_t  GxfComponentPointer gxf_context_t  context gxf_uid_t  uid gxf_tid_t  tid void  * * pointer ; Verifies that a component exists, has the given type, gets a pointer to it. Parameters context \u2013 A valid GXF context uid \u2013 The component object ID (UID). tid \u2013 The expected component type ID (TID) of the component pointer \u2013 The returned pointer to the component object. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1311, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentPointer.context", "display_name": "GxfComponentPointer.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentPointer", "priority": 1, "content": "gxf_result_t  GxfComponentPointer gxf_context_t  context gxf_uid_t  uid gxf_tid_t  tid void  * * pointer ; Verifies that a component exists, has the given type, gets a pointer to it. Parameters context \u2013 A valid GXF context uid \u2013 The component object ID (UID). tid \u2013 The expected component type ID (TID) of the component pointer \u2013 The returned pointer to the component object. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1312, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentPointer.pointer", "display_name": "GxfComponentPointer.pointer", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentPointer", "priority": 1, "content": "gxf_result_t  GxfComponentPointer gxf_context_t  context gxf_uid_t  uid gxf_tid_t  tid void  * * pointer ; Verifies that a component exists, has the given type, gets a pointer to it. Parameters context \u2013 A valid GXF context uid \u2013 The component object ID (UID). tid \u2013 The expected component type ID (TID) of the component pointer \u2013 The returned pointer to the component object. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1313, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentPointer.tid", "display_name": "GxfComponentPointer.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentPointer", "priority": 1, "content": "gxf_result_t  GxfComponentPointer gxf_context_t  context gxf_uid_t  uid gxf_tid_t  tid void  * * pointer ; Verifies that a component exists, has the given type, gets a pointer to it. Parameters context \u2013 A valid GXF context uid \u2013 The component object ID (UID). tid \u2013 The expected component type ID (TID) of the component pointer \u2013 The returned pointer to the component object. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1314, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentPointer.uid", "display_name": "GxfComponentPointer.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentPointer", "priority": 1, "content": "gxf_result_t  GxfComponentPointer gxf_context_t  context gxf_uid_t  uid gxf_tid_t  tid void  * * pointer ; Verifies that a component exists, has the given type, gets a pointer to it. Parameters context \u2013 A valid GXF context uid \u2013 The component object ID (UID). tid \u2013 The expected component type ID (TID) of the component pointer \u2013 The returned pointer to the component object. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1315, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemove", "display_name": "GxfComponentRemove", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemove", "priority": 1, "content": "gxf_result_t  GxfComponentRemove gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1316, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemove.context", "display_name": "GxfComponentRemove.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemove", "priority": 1, "content": "gxf_result_t  GxfComponentRemove gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1317, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemove.eid", "display_name": "GxfComponentRemove.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemove", "priority": 1, "content": "gxf_result_t  GxfComponentRemove gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1318, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemove.name", "display_name": "GxfComponentRemove.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemove", "priority": 1, "content": "gxf_result_t  GxfComponentRemove gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1319, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemove.tid", "display_name": "GxfComponentRemove.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemove", "priority": 1, "content": "gxf_result_t  GxfComponentRemove gxf_context_t  context gxf_uid_t  eid gxf_tid_t  tid const  char  * name ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity to which the component is added. tid \u2013 The unique type ID (TID) of the component to be added to the entity. name \u2013 The name of the new component. Ownership is not transferred. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1320, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemoveWithUID", "display_name": "GxfComponentRemoveWithUID", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemoveWithUID", "priority": 1, "content": "gxf_result_t  GxfComponentRemoveWithUID gxf_context_t  context gxf_uid_t  cid ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context cid \u2013 The UID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1321, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemoveWithUID.cid", "display_name": "GxfComponentRemoveWithUID.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemoveWithUID", "priority": 1, "content": "gxf_result_t  GxfComponentRemoveWithUID gxf_context_t  context gxf_uid_t  cid ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context cid \u2013 The UID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1322, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentRemoveWithUID.context", "display_name": "GxfComponentRemoveWithUID.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentRemoveWithUID", "priority": 1, "content": "gxf_result_t  GxfComponentRemoveWithUID gxf_context_t  context gxf_uid_t  cid ; Removes a component from an entity An entity can contain multiple components and this function can be used to remove a component from an entity. A component must be removed before an entity is activated, or after it was deactivated. Components must not be removed from active entities. Parameters context \u2013 A valid GXF context cid \u2013 The UID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1323, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentType", "display_name": "GxfComponentType", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentType", "priority": 1, "content": "gxf_result_t  GxfComponentType gxf_context_t  context gxf_uid_t  cid gxf_tid_t  * tid ; Gets the component type ID (TID) of a component Parameters context \u2013 A valid GXF context cid \u2013 The component object ID (UID) for which the component type is requested. tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1324, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentType.cid", "display_name": "GxfComponentType.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentType", "priority": 1, "content": "gxf_result_t  GxfComponentType gxf_context_t  context gxf_uid_t  cid gxf_tid_t  * tid ; Gets the component type ID (TID) of a component Parameters context \u2013 A valid GXF context cid \u2013 The component object ID (UID) for which the component type is requested. tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1325, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentType.context", "display_name": "GxfComponentType.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentType", "priority": 1, "content": "gxf_result_t  GxfComponentType gxf_context_t  context gxf_uid_t  cid gxf_tid_t  * tid ; Gets the component type ID (TID) of a component Parameters context \u2013 A valid GXF context cid \u2013 The component object ID (UID) for which the component type is requested. tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1326, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentType.tid", "display_name": "GxfComponentType.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentType", "priority": 1, "content": "gxf_result_t  GxfComponentType gxf_context_t  context gxf_uid_t  cid gxf_tid_t  * tid ; Gets the component type ID (TID) of a component Parameters context \u2013 A valid GXF context cid \u2013 The component object ID (UID) for which the component type is requested. tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1327, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeId", "display_name": "GxfComponentTypeId", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeId", "priority": 1, "content": "gxf_result_t  GxfComponentTypeId gxf_context_t  context const  char  * name gxf_tid_t  * tid ; Gets the GXF unique type ID (TID) of a component Get the unique type ID which was used to register the component with GXF. The function expects the fully qualified C++ type name of the component including namespaces. Example of a valid component type name: \u201cnvidia::gxf::test::PingTx\u201d Parameters context \u2013 A valid GXF context name \u2013 The fully qualified C++ type name of the component tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1328, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeId.context", "display_name": "GxfComponentTypeId.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeId", "priority": 1, "content": "gxf_result_t  GxfComponentTypeId gxf_context_t  context const  char  * name gxf_tid_t  * tid ; Gets the GXF unique type ID (TID) of a component Get the unique type ID which was used to register the component with GXF. The function expects the fully qualified C++ type name of the component including namespaces. Example of a valid component type name: \u201cnvidia::gxf::test::PingTx\u201d Parameters context \u2013 A valid GXF context name \u2013 The fully qualified C++ type name of the component tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1329, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeId.name", "display_name": "GxfComponentTypeId.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeId", "priority": 1, "content": "gxf_result_t  GxfComponentTypeId gxf_context_t  context const  char  * name gxf_tid_t  * tid ; Gets the GXF unique type ID (TID) of a component Get the unique type ID which was used to register the component with GXF. The function expects the fully qualified C++ type name of the component including namespaces. Example of a valid component type name: \u201cnvidia::gxf::test::PingTx\u201d Parameters context \u2013 A valid GXF context name \u2013 The fully qualified C++ type name of the component tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1330, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeId.tid", "display_name": "GxfComponentTypeId.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeId", "priority": 1, "content": "gxf_result_t  GxfComponentTypeId gxf_context_t  context const  char  * name gxf_tid_t  * tid ; Gets the GXF unique type ID (TID) of a component Get the unique type ID which was used to register the component with GXF. The function expects the fully qualified C++ type name of the component including namespaces. Example of a valid component type name: \u201cnvidia::gxf::test::PingTx\u201d Parameters context \u2013 A valid GXF context name \u2013 The fully qualified C++ type name of the component tid \u2013 The returned TID of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1331, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeName", "display_name": "GxfComponentTypeName", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeName", "priority": 1, "content": "gxf_result_t  GxfComponentTypeName gxf_context_t  context gxf_tid_t  tid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context tid \u2013 The unique type ID (TID) of the component with which the component was registered name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1332, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeName.context", "display_name": "GxfComponentTypeName.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeName", "priority": 1, "content": "gxf_result_t  GxfComponentTypeName gxf_context_t  context gxf_tid_t  tid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context tid \u2013 The unique type ID (TID) of the component with which the component was registered name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1333, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeName.name", "display_name": "GxfComponentTypeName.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeName", "priority": 1, "content": "gxf_result_t  GxfComponentTypeName gxf_context_t  context gxf_tid_t  tid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context tid \u2013 The unique type ID (TID) of the component with which the component was registered name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1334, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeName.tid", "display_name": "GxfComponentTypeName.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeName", "priority": 1, "content": "gxf_result_t  GxfComponentTypeName gxf_context_t  context gxf_tid_t  tid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context tid \u2013 The unique type ID (TID) of the component with which the component was registered name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1335, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeNameFromUID", "display_name": "GxfComponentTypeNameFromUID", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeNameFromUID", "priority": 1, "content": "gxf_result_t  GxfComponentTypeNameFromUID gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename from the component UID Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context cid \u2013 The UID of a valid component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1336, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeNameFromUID.cid", "display_name": "GxfComponentTypeNameFromUID.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeNameFromUID", "priority": 1, "content": "gxf_result_t  GxfComponentTypeNameFromUID gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename from the component UID Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context cid \u2013 The UID of a valid component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1337, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeNameFromUID.context", "display_name": "GxfComponentTypeNameFromUID.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeNameFromUID", "priority": 1, "content": "gxf_result_t  GxfComponentTypeNameFromUID gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename from the component UID Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context cid \u2013 The UID of a valid component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1338, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfComponentTypeNameFromUID.name", "display_name": "GxfComponentTypeNameFromUID.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfComponentTypeNameFromUID", "priority": 1, "content": "gxf_result_t  GxfComponentTypeNameFromUID gxf_context_t  context gxf_uid_t  cid const  char  * * name ; Gets the fully qualified C++ type name GXF component typename from the component UID Get the unique typename of the component with which it was registered using one of the GXF_EXT_FACTORY_ADD*() macros Parameters context \u2013 A valid GXF context cid \u2013 The UID of a valid component name \u2013 The returned name of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1339, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextCreate", "display_name": "GxfContextCreate", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextCreate", "priority": 1, "content": "gxf_result_t  GxfContextCreate gxf_context_t  * context ; Creates a new GXF context A GXF context is required for all almost all GXF operations. The context must be destroyed with \u2018GxfContextDestroy\u2019. Multiple contexts can be created in the same process, however they can not communicate with each other. Parameters context \u2013 The new GXF context is written to the given pointer. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1340, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextCreate.context", "display_name": "GxfContextCreate.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextCreate", "priority": 1, "content": "gxf_result_t  GxfContextCreate gxf_context_t  * context ; Creates a new GXF context A GXF context is required for all almost all GXF operations. The context must be destroyed with \u2018GxfContextDestroy\u2019. Multiple contexts can be created in the same process, however they can not communicate with each other. Parameters context \u2013 The new GXF context is written to the given pointer. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1341, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextCreateShared", "display_name": "GxfContextCreateShared", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextCreateShared", "priority": 1, "content": "gxf_result_t  GxfContextCreateShared gxf_context_t  shared gxf_context_t  * context ; Creates a new runtime context from shared context. A shared runtime context is used for sharing entities between graphs running within the same process. Parameters shared \u2013 A valid GXF shared context. context \u2013 The new GXF context is written to the given pointer Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1342, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextCreateShared.context", "display_name": "GxfContextCreateShared.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextCreateShared", "priority": 1, "content": "gxf_result_t  GxfContextCreateShared gxf_context_t  shared gxf_context_t  * context ; Creates a new runtime context from shared context. A shared runtime context is used for sharing entities between graphs running within the same process. Parameters shared \u2013 A valid GXF shared context. context \u2013 The new GXF context is written to the given pointer Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1343, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextCreateShared.shared", "display_name": "GxfContextCreateShared.shared", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextCreateShared", "priority": 1, "content": "gxf_result_t  GxfContextCreateShared gxf_context_t  shared gxf_context_t  * context ; Creates a new runtime context from shared context. A shared runtime context is used for sharing entities between graphs running within the same process. Parameters shared \u2013 A valid GXF shared context. context \u2013 The new GXF context is written to the given pointer Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1344, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextDestroy", "display_name": "GxfContextDestroy", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextDestroy", "priority": 1, "content": "gxf_result_t  GxfContextDestroy gxf_context_t  context ; Destroys a GXF context Every GXF context must be destroyed by calling this function. The context must have been previously created with \u2018GxfContextCreate\u2019. This will also destroy all entities and components which were created as part of the context. Parameters context \u2013 A valid GXF context. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1345, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfContextDestroy.context", "display_name": "GxfContextDestroy.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfContextDestroy", "priority": 1, "content": "gxf_result_t  GxfContextDestroy gxf_context_t  context ; Destroys a GXF context Every GXF context must be destroyed by calling this function. The context must have been previously created with \u2018GxfContextCreate\u2019. This will also destroy all entities and components which were created as part of the context. Parameters context \u2013 A valid GXF context. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1346, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntity", "display_name": "GxfCreateEntity", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntity", "priority": 1, "content": "gxf_result_t  GxfCreateEntity gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid ; Create a new GXF entity. Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. Parameters context \u2013 GXF context that creates the entity. info \u2013 pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 pointer to a gxf_uid_t handle in which the resulting entity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1347, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntity.context", "display_name": "GxfCreateEntity.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntity", "priority": 1, "content": "gxf_result_t  GxfCreateEntity gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid ; Create a new GXF entity. Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. Parameters context \u2013 GXF context that creates the entity. info \u2013 pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 pointer to a gxf_uid_t handle in which the resulting entity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1348, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntity.eid", "display_name": "GxfCreateEntity.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntity", "priority": 1, "content": "gxf_result_t  GxfCreateEntity gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid ; Create a new GXF entity. Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. Parameters context \u2013 GXF context that creates the entity. info \u2013 pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 pointer to a gxf_uid_t handle in which the resulting entity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1349, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntity.info", "display_name": "GxfCreateEntity.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntity", "priority": 1, "content": "gxf_result_t  GxfCreateEntity gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid ; Create a new GXF entity. Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. Parameters context \u2013 GXF context that creates the entity. info \u2013 pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 pointer to a gxf_uid_t handle in which the resulting entity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1350, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityAndGetItem", "display_name": "GxfCreateEntityAndGetItem", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityAndGetItem", "priority": 1, "content": "gxf_result_t  GxfCreateEntityAndGetItem gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid void  * * item_ptr ; Create a new GXF entity and return the entity item ptr Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. This function also returns the pointer entity item which can be used to create C++ nvidia::gxf::Entity type objects. Parameters context \u2013 is the GXF context that creates the entity. info \u2013 is a pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 is a pointer to a gxf_uid_t handle in which the resulting entity is returned. item_ptr \u2013 is a pointer to pointer to entity item which is created Returns On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 1351, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityAndGetItem.context", "display_name": "GxfCreateEntityAndGetItem.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityAndGetItem", "priority": 1, "content": "gxf_result_t  GxfCreateEntityAndGetItem gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid void  * * item_ptr ; Create a new GXF entity and return the entity item ptr Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. This function also returns the pointer entity item which can be used to create C++ nvidia::gxf::Entity type objects. Parameters context \u2013 is the GXF context that creates the entity. info \u2013 is a pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 is a pointer to a gxf_uid_t handle in which the resulting entity is returned. item_ptr \u2013 is a pointer to pointer to entity item which is created Returns On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 1352, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityAndGetItem.eid", "display_name": "GxfCreateEntityAndGetItem.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityAndGetItem", "priority": 1, "content": "gxf_result_t  GxfCreateEntityAndGetItem gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid void  * * item_ptr ; Create a new GXF entity and return the entity item ptr Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. This function also returns the pointer entity item which can be used to create C++ nvidia::gxf::Entity type objects. Parameters context \u2013 is the GXF context that creates the entity. info \u2013 is a pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 is a pointer to a gxf_uid_t handle in which the resulting entity is returned. item_ptr \u2013 is a pointer to pointer to entity item which is created Returns On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 1353, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityAndGetItem.info", "display_name": "GxfCreateEntityAndGetItem.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityAndGetItem", "priority": 1, "content": "gxf_result_t  GxfCreateEntityAndGetItem gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid void  * * item_ptr ; Create a new GXF entity and return the entity item ptr Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. This function also returns the pointer entity item which can be used to create C++ nvidia::gxf::Entity type objects. Parameters context \u2013 is the GXF context that creates the entity. info \u2013 is a pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 is a pointer to a gxf_uid_t handle in which the resulting entity is returned. item_ptr \u2013 is a pointer to pointer to entity item which is created Returns On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 1354, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityAndGetItem.item_ptr", "display_name": "GxfCreateEntityAndGetItem.item_ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityAndGetItem", "priority": 1, "content": "gxf_result_t  GxfCreateEntityAndGetItem gxf_context_t  context const  GxfEntityCreateInfo  * info gxf_uid_t  * eid void  * * item_ptr ; Create a new GXF entity and return the entity item ptr Entities are light-weight containers to hold components and form the basic building blocks of a GXF application. Entities are created when a GXF file is loaded, or they can be created manually using this function. Entities created with this function must be destroyed using \u2018GxfEntityDestroy\u2019. After the entity was created components can be added to it with \u2018GxfComponentAdd\u2019. To start execution of codelets on an entity the entity needs to be activated first. This can happen automatically using \u2018GXF_ENTITY_CREATE_PROGRAM_BIT\u2019 or manually using \u2018GxfEntityActivate\u2019. This function also returns the pointer entity item which can be used to create C++ nvidia::gxf::Entity type objects. Parameters context \u2013 is the GXF context that creates the entity. info \u2013 is a pointer to a GxfEntityCreateInfo structure containing parameters affecting the creation of the entity. eid \u2013 is a pointer to a gxf_uid_t handle in which the resulting entity is returned. item_ptr \u2013 is a pointer to pointer to entity item which is created Returns On success the function returns GXF_SUCCESS.", "keywords": []}, {"id": 1355, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityGroup", "display_name": "GxfCreateEntityGroup", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfCreateEntityGroup gxf_context_t  context const  char  * name gxf_uid_t  * gid ; Create a new GXF EntityGroup. EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Parameters context \u2013 A valid GXF context name \u2013 name to create the EntityGroup gid \u2013 pointer to returned uid for the created EntityGroup, abbreviation for group id Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1356, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityGroup.context", "display_name": "GxfCreateEntityGroup.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfCreateEntityGroup gxf_context_t  context const  char  * name gxf_uid_t  * gid ; Create a new GXF EntityGroup. EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Parameters context \u2013 A valid GXF context name \u2013 name to create the EntityGroup gid \u2013 pointer to returned uid for the created EntityGroup, abbreviation for group id Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1357, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityGroup.gid", "display_name": "GxfCreateEntityGroup.gid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfCreateEntityGroup gxf_context_t  context const  char  * name gxf_uid_t  * gid ; Create a new GXF EntityGroup. EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Parameters context \u2013 A valid GXF context name \u2013 name to create the EntityGroup gid \u2013 pointer to returned uid for the created EntityGroup, abbreviation for group id Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1358, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfCreateEntityGroup.name", "display_name": "GxfCreateEntityGroup.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfCreateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfCreateEntityGroup gxf_context_t  context const  char  * name gxf_uid_t  * gid ; Create a new GXF EntityGroup. EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Parameters context \u2013 A valid GXF context name \u2013 name to create the EntityGroup gid \u2013 pointer to returned uid for the created EntityGroup, abbreviation for group id Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1359, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityActivate", "display_name": "GxfEntityActivate", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityActivate", "priority": 1, "content": "gxf_result_t  GxfEntityActivate gxf_context_t  context gxf_uid_t  eid ; Activates a previously created and inactive entity Activating an entity generally marks the official start of its lifetime and has multiple implications: - If mandatory parameters, i.e. parameter which do not hav the flag \u201coptional\u201d, are not set the operation will fail. All components on the entity are initialized. All codelets on the entity are scheduled for execution. The scheduler will start calling start, tick and stop functions as specified by scheduling terms. After activation trying to change a dynamic parameters will result in a failure. Adding or removing components of an entity after activation will result in a failure. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1360, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityActivate.context", "display_name": "GxfEntityActivate.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityActivate", "priority": 1, "content": "gxf_result_t  GxfEntityActivate gxf_context_t  context gxf_uid_t  eid ; Activates a previously created and inactive entity Activating an entity generally marks the official start of its lifetime and has multiple implications: - If mandatory parameters, i.e. parameter which do not hav the flag \u201coptional\u201d, are not set the operation will fail. All components on the entity are initialized. All codelets on the entity are scheduled for execution. The scheduler will start calling start, tick and stop functions as specified by scheduling terms. After activation trying to change a dynamic parameters will result in a failure. Adding or removing components of an entity after activation will result in a failure. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1361, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityActivate.eid", "display_name": "GxfEntityActivate.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityActivate", "priority": 1, "content": "gxf_result_t  GxfEntityActivate gxf_context_t  context gxf_uid_t  eid ; Activates a previously created and inactive entity Activating an entity generally marks the official start of its lifetime and has multiple implications: - If mandatory parameters, i.e. parameter which do not hav the flag \u201coptional\u201d, are not set the operation will fail. All components on the entity are initialized. All codelets on the entity are scheduled for execution. The scheduler will start calling start, tick and stop functions as specified by scheduling terms. After activation trying to change a dynamic parameters will result in a failure. Adding or removing components of an entity after activation will result in a failure. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1362, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateFlagBits", "display_name": "GxfEntityCreateFlagBits", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateFlagBits", "priority": 1, "content": "type  GxfEntityCreateFlagBits Bitmask specifying storage mode for an entity.", "keywords": []}, {"id": 1363, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateFlagBits.GXF_ENTITY_CREATE_PROGRAM_BIT", "display_name": "GxfEntityCreateFlagBits.GXF_ENTITY_CREATE_PROGRAM_BIT", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateFlagBits.GXF_ENTITY_CREATE_PROGRAM_BIT", "priority": 1, "content": "type  GXF_ENTITY_CREATE_PROGRAM_BIT specifies that the entity will be added to the program entities. Program entities are kept alive for the duration of the program. They are activated automatically when the program is activated and deactivated when the program is deactivated. If the program was already activated when the entity is created the entity must still be activated manually.", "keywords": []}, {"id": 1364, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateFlags", "display_name": "GxfEntityCreateFlags", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateFlags", "priority": 1, "content": "type  GxfEntityCreateFlags Bitmask of GxfEntityCreateFlagBits .", "keywords": []}, {"id": 1365, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateInfo", "display_name": "GxfEntityCreateInfo", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateInfo", "priority": 1, "content": "type  GxfEntityCreateInfo A structure specifying parameters for creating entities.", "keywords": []}, {"id": 1366, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateInfo.entity_name", "display_name": "GxfEntityCreateInfo.entity_name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateInfo.entity_name", "priority": 1, "content": "const  char  * entity_name the name of the entity which is created. If this is a nullptr an undefined unique name is chosen. The name must not start with a double underscore.", "keywords": []}, {"id": 1367, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityCreateInfo.flags", "display_name": "GxfEntityCreateInfo.flags", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityCreateInfo.flags", "priority": 1, "content": "GxfEntityCreateFlags  flags Bitmask of GxfEntityCreateFlagsBits indicating storage method and usage behavior for the created entity.", "keywords": []}, {"id": 1368, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDeactivate", "display_name": "GxfEntityDeactivate", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDeactivate", "priority": 1, "content": "gxf_result_t  GxfEntityDeactivate gxf_context_t  context gxf_uid_t  eid ; Deactivates a previously activated entity Deactivating an entity generally marks the official end of its lifetime and has multiple implications: All codelets are removed from the schedule. Already running entities are run to completion. All components on the entity are deinitialized. Components can be added or removed again once the entity was deactivated. Mandatory and non-dynamic parameters can be changed again. Note: In case that the entity is currently executing this function will wait and block until the current execution is finished. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1369, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDeactivate.context", "display_name": "GxfEntityDeactivate.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDeactivate", "priority": 1, "content": "gxf_result_t  GxfEntityDeactivate gxf_context_t  context gxf_uid_t  eid ; Deactivates a previously activated entity Deactivating an entity generally marks the official end of its lifetime and has multiple implications: All codelets are removed from the schedule. Already running entities are run to completion. All components on the entity are deinitialized. Components can be added or removed again once the entity was deactivated. Mandatory and non-dynamic parameters can be changed again. Note: In case that the entity is currently executing this function will wait and block until the current execution is finished. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1370, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDeactivate.eid", "display_name": "GxfEntityDeactivate.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDeactivate", "priority": 1, "content": "gxf_result_t  GxfEntityDeactivate gxf_context_t  context gxf_uid_t  eid ; Deactivates a previously activated entity Deactivating an entity generally marks the official end of its lifetime and has multiple implications: All codelets are removed from the schedule. Already running entities are run to completion. All components on the entity are deinitialized. Components can be added or removed again once the entity was deactivated. Mandatory and non-dynamic parameters can be changed again. Note: In case that the entity is currently executing this function will wait and block until the current execution is finished. Parameters context \u2013 A valid GXF context eid \u2013 UID of a valid entity Returns GXF error code", "keywords": []}, {"id": 1371, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDestroy", "display_name": "GxfEntityDestroy", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDestroy", "priority": 1, "content": "gxf_result_t  GxfEntityDestroy gxf_context_t  context gxf_uid_t  eid ; Destroys a previously created entity Destroys an entity immediately. The entity is destroyed even if the reference count has not yet reached 0. If the entity is active it is deactivated first. Note: This function can block for the same reasons as \u2018GxfEntityDeactivate\u2019. Parameters context \u2013 A valid GXF context eid \u2013 The returned UID of the created entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1372, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDestroy.context", "display_name": "GxfEntityDestroy.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDestroy", "priority": 1, "content": "gxf_result_t  GxfEntityDestroy gxf_context_t  context gxf_uid_t  eid ; Destroys a previously created entity Destroys an entity immediately. The entity is destroyed even if the reference count has not yet reached 0. If the entity is active it is deactivated first. Note: This function can block for the same reasons as \u2018GxfEntityDeactivate\u2019. Parameters context \u2013 A valid GXF context eid \u2013 The returned UID of the created entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1373, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityDestroy.eid", "display_name": "GxfEntityDestroy.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityDestroy", "priority": 1, "content": "gxf_result_t  GxfEntityDestroy gxf_context_t  context gxf_uid_t  eid ; Destroys a previously created entity Destroys an entity immediately. The entity is destroyed even if the reference count has not yet reached 0. If the entity is active it is deactivated first. Note: This function can block for the same reasons as \u2018GxfEntityDeactivate\u2019. Parameters context \u2013 A valid GXF context eid \u2013 The returned UID of the created entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1374, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityEventNotify", "display_name": "GxfEntityEventNotify", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityEventNotify", "priority": 1, "content": "gxf_result_t  GxfEntityEventNotify gxf_context_t  context gxf_uid_t  eid ; Notifies the occurrence of an event and inform the scheduler to check the status of the entity The entity must have an \u2018AsynchronousSchedulingTerm\u2019 scheduling term component and it must be in \u201cEVENT_WAITING\u201d state for the notification to be acknowledged. See \u2018AsynchronousEventState\u2019 for various states Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1375, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityEventNotify.context", "display_name": "GxfEntityEventNotify.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityEventNotify", "priority": 1, "content": "gxf_result_t  GxfEntityEventNotify gxf_context_t  context gxf_uid_t  eid ; Notifies the occurrence of an event and inform the scheduler to check the status of the entity The entity must have an \u2018AsynchronousSchedulingTerm\u2019 scheduling term component and it must be in \u201cEVENT_WAITING\u201d state for the notification to be acknowledged. See \u2018AsynchronousEventState\u2019 for various states Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1376, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityEventNotify.eid", "display_name": "GxfEntityEventNotify.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityEventNotify", "priority": 1, "content": "gxf_result_t  GxfEntityEventNotify gxf_context_t  context gxf_uid_t  eid ; Notifies the occurrence of an event and inform the scheduler to check the status of the entity The entity must have an \u2018AsynchronousSchedulingTerm\u2019 scheduling term component and it must be in \u201cEVENT_WAITING\u201d state for the notification to be acknowledged. See \u2018AsynchronousEventState\u2019 for various states Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1377, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFind", "display_name": "GxfEntityFind", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFind", "priority": 1, "content": "gxf_result_t  GxfEntityFind gxf_context_t  context const  char  * name gxf_uid_t  * eid ; Finds an entity by its name Parameters context \u2013 A valid GXF context name \u2013 A C string with the name of the entity. Ownership is not transferred. eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1378, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFind.context", "display_name": "GxfEntityFind.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFind", "priority": 1, "content": "gxf_result_t  GxfEntityFind gxf_context_t  context const  char  * name gxf_uid_t  * eid ; Finds an entity by its name Parameters context \u2013 A valid GXF context name \u2013 A C string with the name of the entity. Ownership is not transferred. eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1379, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFind.eid", "display_name": "GxfEntityFind.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFind", "priority": 1, "content": "gxf_result_t  GxfEntityFind gxf_context_t  context const  char  * name gxf_uid_t  * eid ; Finds an entity by its name Parameters context \u2013 A valid GXF context name \u2013 A C string with the name of the entity. Ownership is not transferred. eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1380, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFind.name", "display_name": "GxfEntityFind.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFind", "priority": 1, "content": "gxf_result_t  GxfEntityFind gxf_context_t  context const  char  * name gxf_uid_t  * eid ; Finds an entity by its name Parameters context \u2013 A valid GXF context name \u2013 A C string with the name of the entity. Ownership is not transferred. eid \u2013 The returned UID of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1381, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFindAll", "display_name": "GxfEntityFindAll", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFindAll", "priority": 1, "content": "gxf_result_t  GxfEntityFindAll gxf_context_t  context uint64_t  * num_entities gxf_uid_t  * entities ; Finds all entities in the current application Finds and returns all entity ids for the current application. If more than max_entities exist only max_entities will be returned. The order and selection of entities returned is abritrary. Parameters context \u2013 A valid GXF context num_entities \u2013 In/Out: the max number of entities that can fit in the buffer/the number of entities that exist in the application entities \u2013 A buffer allocated by the caller for returned UIDs of all entities, with capacity for num_entities . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more entites exist in the application than max_entities , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1382, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFindAll.context", "display_name": "GxfEntityFindAll.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFindAll", "priority": 1, "content": "gxf_result_t  GxfEntityFindAll gxf_context_t  context uint64_t  * num_entities gxf_uid_t  * entities ; Finds all entities in the current application Finds and returns all entity ids for the current application. If more than max_entities exist only max_entities will be returned. The order and selection of entities returned is abritrary. Parameters context \u2013 A valid GXF context num_entities \u2013 In/Out: the max number of entities that can fit in the buffer/the number of entities that exist in the application entities \u2013 A buffer allocated by the caller for returned UIDs of all entities, with capacity for num_entities . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more entites exist in the application than max_entities , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1383, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFindAll.entities", "display_name": "GxfEntityFindAll.entities", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFindAll", "priority": 1, "content": "gxf_result_t  GxfEntityFindAll gxf_context_t  context uint64_t  * num_entities gxf_uid_t  * entities ; Finds all entities in the current application Finds and returns all entity ids for the current application. If more than max_entities exist only max_entities will be returned. The order and selection of entities returned is abritrary. Parameters context \u2013 A valid GXF context num_entities \u2013 In/Out: the max number of entities that can fit in the buffer/the number of entities that exist in the application entities \u2013 A buffer allocated by the caller for returned UIDs of all entities, with capacity for num_entities . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more entites exist in the application than max_entities , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1384, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityFindAll.num_entities", "display_name": "GxfEntityFindAll.num_entities", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityFindAll", "priority": 1, "content": "gxf_result_t  GxfEntityFindAll gxf_context_t  context uint64_t  * num_entities gxf_uid_t  * entities ; Finds all entities in the current application Finds and returns all entity ids for the current application. If more than max_entities exist only max_entities will be returned. The order and selection of entities returned is abritrary. Parameters context \u2013 A valid GXF context num_entities \u2013 In/Out: the max number of entities that can fit in the buffer/the number of entities that exist in the application entities \u2013 A buffer allocated by the caller for returned UIDs of all entities, with capacity for num_entities . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more entites exist in the application than max_entities , or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1385, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetItemPtr", "display_name": "GxfEntityGetItemPtr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetItemPtr", "priority": 1, "content": "gxf_result_t  GxfEntityGetItemPtr gxf_context_t  context gxf_uid_t  eid void  * * ptr ; Each entity has a unique ID with respect to the context and is stored in the entity warden. This function can be used to retrieve the pointer to entity item stored in the entity warden for a given entity id. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity ptr \u2013 The returned pointer to the entity item Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1386, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetItemPtr.context", "display_name": "GxfEntityGetItemPtr.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetItemPtr", "priority": 1, "content": "gxf_result_t  GxfEntityGetItemPtr gxf_context_t  context gxf_uid_t  eid void  * * ptr ; Each entity has a unique ID with respect to the context and is stored in the entity warden. This function can be used to retrieve the pointer to entity item stored in the entity warden for a given entity id. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity ptr \u2013 The returned pointer to the entity item Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1387, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetItemPtr.eid", "display_name": "GxfEntityGetItemPtr.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetItemPtr", "priority": 1, "content": "gxf_result_t  GxfEntityGetItemPtr gxf_context_t  context gxf_uid_t  eid void  * * ptr ; Each entity has a unique ID with respect to the context and is stored in the entity warden. This function can be used to retrieve the pointer to entity item stored in the entity warden for a given entity id. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity ptr \u2013 The returned pointer to the entity item Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1388, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetItemPtr.ptr", "display_name": "GxfEntityGetItemPtr.ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetItemPtr", "priority": 1, "content": "gxf_result_t  GxfEntityGetItemPtr gxf_context_t  context gxf_uid_t  eid void  * * ptr ; Each entity has a unique ID with respect to the context and is stored in the entity warden. This function can be used to retrieve the pointer to entity item stored in the entity warden for a given entity id. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of the entity ptr \u2013 The returned pointer to the entity item Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1389, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetName", "display_name": "GxfEntityGetName", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetName", "priority": 1, "content": "gxf_result_t  GxfEntityGetName gxf_context_t  context gxf_uid_t  eid const  char  * * entity_name ; Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity entity_name \u2013 output; name of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1390, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetName.context", "display_name": "GxfEntityGetName.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetName", "priority": 1, "content": "gxf_result_t  GxfEntityGetName gxf_context_t  context gxf_uid_t  eid const  char  * * entity_name ; Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity entity_name \u2013 output; name of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1391, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetName.eid", "display_name": "GxfEntityGetName.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetName", "priority": 1, "content": "gxf_result_t  GxfEntityGetName gxf_context_t  context gxf_uid_t  eid const  char  * * entity_name ; Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity entity_name \u2013 output; name of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1392, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetName.entity_name", "display_name": "GxfEntityGetName.entity_name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetName", "priority": 1, "content": "gxf_result_t  GxfEntityGetName gxf_context_t  context gxf_uid_t  eid const  char  * * entity_name ; Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity entity_name \u2013 output; name of the entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1393, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetRefCount", "display_name": "GxfEntityGetRefCount", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetRefCount", "priority": 1, "content": "gxf_result_t  GxfEntityGetRefCount gxf_context_t  context gxf_uid_t  eid int64_t  * count ; Provides the reference count for an entity. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity count \u2013 The reference count of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1394, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetRefCount.context", "display_name": "GxfEntityGetRefCount.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetRefCount", "priority": 1, "content": "gxf_result_t  GxfEntityGetRefCount gxf_context_t  context gxf_uid_t  eid int64_t  * count ; Provides the reference count for an entity. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity count \u2013 The reference count of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1395, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetRefCount.count", "display_name": "GxfEntityGetRefCount.count", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetRefCount", "priority": 1, "content": "gxf_result_t  GxfEntityGetRefCount gxf_context_t  context gxf_uid_t  eid int64_t  * count ; Provides the reference count for an entity. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity count \u2013 The reference count of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1396, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetRefCount.eid", "display_name": "GxfEntityGetRefCount.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetRefCount", "priority": 1, "content": "gxf_result_t  GxfEntityGetRefCount gxf_context_t  context gxf_uid_t  eid int64_t  * count ; Provides the reference count for an entity. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The unique object ID (UID) of a valid entity count \u2013 The reference count of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1397, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetState", "display_name": "GxfEntityGetState", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetState", "priority": 1, "content": "gxf_result_t  GxfEntityGetState gxf_context_t  context gxf_uid_t  eid entity_state_t  * entity_state ; Gets the state of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_state \u2013 output; behavior status of an entity eid used by the behavior tree parent codelet Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1398, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetState.context", "display_name": "GxfEntityGetState.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetState", "priority": 1, "content": "gxf_result_t  GxfEntityGetState gxf_context_t  context gxf_uid_t  eid entity_state_t  * entity_state ; Gets the state of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_state \u2013 output; behavior status of an entity eid used by the behavior tree parent codelet Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1399, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetState.eid", "display_name": "GxfEntityGetState.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetState", "priority": 1, "content": "gxf_result_t  GxfEntityGetState gxf_context_t  context gxf_uid_t  eid entity_state_t  * entity_state ; Gets the state of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_state \u2013 output; behavior status of an entity eid used by the behavior tree parent codelet Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1400, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetState.entity_state", "display_name": "GxfEntityGetState.entity_state", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetState", "priority": 1, "content": "gxf_result_t  GxfEntityGetState gxf_context_t  context gxf_uid_t  eid entity_state_t  * entity_state ; Gets the state of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_state \u2013 output; behavior status of an entity eid used by the behavior tree parent codelet Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1401, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetStatus", "display_name": "GxfEntityGetStatus", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetStatus", "priority": 1, "content": "gxf_result_t  GxfEntityGetStatus gxf_context_t  context gxf_uid_t  eid gxf_entity_status_t  * entity_status ; Gets the status of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_status \u2013 output; status of an entity eid Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1402, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetStatus.context", "display_name": "GxfEntityGetStatus.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetStatus", "priority": 1, "content": "gxf_result_t  GxfEntityGetStatus gxf_context_t  context gxf_uid_t  eid gxf_entity_status_t  * entity_status ; Gets the status of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_status \u2013 output; status of an entity eid Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1403, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetStatus.eid", "display_name": "GxfEntityGetStatus.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetStatus", "priority": 1, "content": "gxf_result_t  GxfEntityGetStatus gxf_context_t  context gxf_uid_t  eid gxf_entity_status_t  * entity_status ; Gets the status of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_status \u2013 output; status of an entity eid Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1404, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGetStatus.entity_status", "display_name": "GxfEntityGetStatus.entity_status", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGetStatus", "priority": 1, "content": "gxf_result_t  GxfEntityGetStatus gxf_context_t  context gxf_uid_t  eid gxf_entity_status_t  * entity_status ; Gets the status of the entity. See \u2018gxf_entity_status_t\u2019 for the various status. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity entity_status \u2013 output; status of an entity eid Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1405, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupFindResources", "display_name": "GxfEntityGroupFindResources", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupFindResources", "priority": 1, "content": "gxf_result_t  GxfEntityGroupFindResources gxf_context_t  context gxf_uid_t  eid uint64_t  * num_resource_cids gxf_uid_t  * resource_cids ; Find all resources from an EntityGroup Finds and returns all resource component cids for EntityGroup pointed by eid. If more than max_entities exist only max_entities will be returned. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity num_resource_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of resources in eid\u2019s EntityGroup resource_cids \u2013 A buffer allocated by the caller for returned UIDs of all resources, with capacity for num_resource_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more resources exist in eid\u2019s EntityGroup, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1406, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupFindResources.context", "display_name": "GxfEntityGroupFindResources.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupFindResources", "priority": 1, "content": "gxf_result_t  GxfEntityGroupFindResources gxf_context_t  context gxf_uid_t  eid uint64_t  * num_resource_cids gxf_uid_t  * resource_cids ; Find all resources from an EntityGroup Finds and returns all resource component cids for EntityGroup pointed by eid. If more than max_entities exist only max_entities will be returned. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity num_resource_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of resources in eid\u2019s EntityGroup resource_cids \u2013 A buffer allocated by the caller for returned UIDs of all resources, with capacity for num_resource_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more resources exist in eid\u2019s EntityGroup, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1407, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupFindResources.eid", "display_name": "GxfEntityGroupFindResources.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupFindResources", "priority": 1, "content": "gxf_result_t  GxfEntityGroupFindResources gxf_context_t  context gxf_uid_t  eid uint64_t  * num_resource_cids gxf_uid_t  * resource_cids ; Find all resources from an EntityGroup Finds and returns all resource component cids for EntityGroup pointed by eid. If more than max_entities exist only max_entities will be returned. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity num_resource_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of resources in eid\u2019s EntityGroup resource_cids \u2013 A buffer allocated by the caller for returned UIDs of all resources, with capacity for num_resource_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more resources exist in eid\u2019s EntityGroup, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1408, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupFindResources.num_resource_cids", "display_name": "GxfEntityGroupFindResources.num_resource_cids", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupFindResources", "priority": 1, "content": "gxf_result_t  GxfEntityGroupFindResources gxf_context_t  context gxf_uid_t  eid uint64_t  * num_resource_cids gxf_uid_t  * resource_cids ; Find all resources from an EntityGroup Finds and returns all resource component cids for EntityGroup pointed by eid. If more than max_entities exist only max_entities will be returned. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity num_resource_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of resources in eid\u2019s EntityGroup resource_cids \u2013 A buffer allocated by the caller for returned UIDs of all resources, with capacity for num_resource_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more resources exist in eid\u2019s EntityGroup, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1409, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupFindResources.resource_cids", "display_name": "GxfEntityGroupFindResources.resource_cids", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupFindResources", "priority": 1, "content": "gxf_result_t  GxfEntityGroupFindResources gxf_context_t  context gxf_uid_t  eid uint64_t  * num_resource_cids gxf_uid_t  * resource_cids ; Find all resources from an EntityGroup Finds and returns all resource component cids for EntityGroup pointed by eid. If more than max_entities exist only max_entities will be returned. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity num_resource_cids \u2013 In/Out: the max number of components that can fit in the buffer/the number of resources in eid\u2019s EntityGroup resource_cids \u2013 A buffer allocated by the caller for returned UIDs of all resources, with capacity for num_resource_cids . Returns GXF_SUCCESS if the operation was successful, GXF_QUERY_NOT_ENOUGH_CAPACITY if more resources exist in eid\u2019s EntityGroup, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1410, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupId", "display_name": "GxfEntityGroupId", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupId", "priority": 1, "content": "gxf_result_t  GxfEntityGroupId gxf_context_t  context gxf_uid_t  eid gxf_uid_t  * gid ; EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created EntityItem points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an EntityItem, whose EntityGroup id field is used find EntityGroup name gid \u2013 The returned id of the entity group. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1411, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupId.context", "display_name": "GxfEntityGroupId.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupId", "priority": 1, "content": "gxf_result_t  GxfEntityGroupId gxf_context_t  context gxf_uid_t  eid gxf_uid_t  * gid ; EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created EntityItem points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an EntityItem, whose EntityGroup id field is used find EntityGroup name gid \u2013 The returned id of the entity group. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1412, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupId.eid", "display_name": "GxfEntityGroupId.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupId", "priority": 1, "content": "gxf_result_t  GxfEntityGroupId gxf_context_t  context gxf_uid_t  eid gxf_uid_t  * gid ; EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created EntityItem points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an EntityItem, whose EntityGroup id field is used find EntityGroup name gid \u2013 The returned id of the entity group. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1413, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupId.gid", "display_name": "GxfEntityGroupId.gid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupId", "priority": 1, "content": "gxf_result_t  GxfEntityGroupId gxf_context_t  context gxf_uid_t  eid gxf_uid_t  * gid ; EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created EntityItem points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an EntityItem, whose EntityGroup id field is used find EntityGroup name gid \u2013 The returned id of the entity group. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1414, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupName", "display_name": "GxfEntityGroupName", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupName", "priority": 1, "content": "gxf_result_t  GxfEntityGroupName gxf_context_t  context gxf_uid_t  eid const  char  * * name ; Get name of EntityGroup held by entity EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created Entity item points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity item, whose EntityGroup id field is used find EntityGroup name name \u2013 The returned name of the EntityGroup Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1415, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupName.context", "display_name": "GxfEntityGroupName.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupName", "priority": 1, "content": "gxf_result_t  GxfEntityGroupName gxf_context_t  context gxf_uid_t  eid const  char  * * name ; Get name of EntityGroup held by entity EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created Entity item points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity item, whose EntityGroup id field is used find EntityGroup name name \u2013 The returned name of the EntityGroup Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1416, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupName.eid", "display_name": "GxfEntityGroupName.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupName", "priority": 1, "content": "gxf_result_t  GxfEntityGroupName gxf_context_t  context gxf_uid_t  eid const  char  * * name ; Get name of EntityGroup held by entity EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created Entity item points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity item, whose EntityGroup id field is used find EntityGroup name name \u2013 The returned name of the EntityGroup Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1417, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityGroupName.name", "display_name": "GxfEntityGroupName.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityGroupName", "priority": 1, "content": "gxf_result_t  GxfEntityGroupName gxf_context_t  context gxf_uid_t  eid const  char  * * name ; Get name of EntityGroup held by entity EntityGroup is a group of EntityItems, such that these entities are bonded to some common properties. For now the common property is all kinds of resources. Through life time of each entity, it always corresponds to an EntityGroup. Eg, newly created Entity item points to Default EntityGroup, and user can update its EntityGroup to valid one only. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity item, whose EntityGroup id field is used find EntityGroup name name \u2013 The returned name of the EntityGroup Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1418, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityIsValid", "display_name": "GxfEntityIsValid", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityIsValid", "priority": 1, "content": "gxf_result_t  GxfEntityIsValid gxf_context_t  context gxf_uid_t  eid bool  * valid ; Check if an entity id is valid currently in GXF runtime. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity to check valid \u2013 returned boolean indicating if the entity is valid in Gxf runtime(warden) Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1419, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityIsValid.context", "display_name": "GxfEntityIsValid.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityIsValid", "priority": 1, "content": "gxf_result_t  GxfEntityIsValid gxf_context_t  context gxf_uid_t  eid bool  * valid ; Check if an entity id is valid currently in GXF runtime. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity to check valid \u2013 returned boolean indicating if the entity is valid in Gxf runtime(warden) Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1420, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityIsValid.eid", "display_name": "GxfEntityIsValid.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityIsValid", "priority": 1, "content": "gxf_result_t  GxfEntityIsValid gxf_context_t  context gxf_uid_t  eid bool  * valid ; Check if an entity id is valid currently in GXF runtime. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity to check valid \u2013 returned boolean indicating if the entity is valid in Gxf runtime(warden) Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1421, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityIsValid.valid", "display_name": "GxfEntityIsValid.valid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityIsValid", "priority": 1, "content": "gxf_result_t  GxfEntityIsValid gxf_context_t  context gxf_uid_t  eid bool  * valid ; Check if an entity id is valid currently in GXF runtime. Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity to check valid \u2013 returned boolean indicating if the entity is valid in Gxf runtime(warden) Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1422, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityNotifyEventType", "display_name": "GxfEntityNotifyEventType", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityNotifyEventType", "priority": 1, "content": "gxf_result_t  GxfEntityNotifyEventType gxf_context_t  context gxf_uid_t  eid gxf_event_t  event ; Notifies the occurrence of an event with event type and inform the scheduler to check the status of the entity GXF_EVENT_EXTERNAL is supported by all GXF schedulers and the rest of the event types are supported by event based scheduler only. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity event \u2013 The type of event. Can be GXF_EVENT_CUSTOM, GXF_EVENT_EXTERNAL, GXF_EVENT_MEMORY_FREE, GXF_EVENT_MESSAGE_SYNC, GXF_EVENT_TIME_UPDATE, GXF_EVENT_STATE_UPDATE. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1423, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityNotifyEventType.context", "display_name": "GxfEntityNotifyEventType.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityNotifyEventType", "priority": 1, "content": "gxf_result_t  GxfEntityNotifyEventType gxf_context_t  context gxf_uid_t  eid gxf_event_t  event ; Notifies the occurrence of an event with event type and inform the scheduler to check the status of the entity GXF_EVENT_EXTERNAL is supported by all GXF schedulers and the rest of the event types are supported by event based scheduler only. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity event \u2013 The type of event. Can be GXF_EVENT_CUSTOM, GXF_EVENT_EXTERNAL, GXF_EVENT_MEMORY_FREE, GXF_EVENT_MESSAGE_SYNC, GXF_EVENT_TIME_UPDATE, GXF_EVENT_STATE_UPDATE. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1424, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityNotifyEventType.eid", "display_name": "GxfEntityNotifyEventType.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityNotifyEventType", "priority": 1, "content": "gxf_result_t  GxfEntityNotifyEventType gxf_context_t  context gxf_uid_t  eid gxf_event_t  event ; Notifies the occurrence of an event with event type and inform the scheduler to check the status of the entity GXF_EVENT_EXTERNAL is supported by all GXF schedulers and the rest of the event types are supported by event based scheduler only. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity event \u2013 The type of event. Can be GXF_EVENT_CUSTOM, GXF_EVENT_EXTERNAL, GXF_EVENT_MEMORY_FREE, GXF_EVENT_MESSAGE_SYNC, GXF_EVENT_TIME_UPDATE, GXF_EVENT_STATE_UPDATE. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1425, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityNotifyEventType.event", "display_name": "GxfEntityNotifyEventType.event", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityNotifyEventType", "priority": 1, "content": "gxf_result_t  GxfEntityNotifyEventType gxf_context_t  context gxf_uid_t  eid gxf_event_t  event ; Notifies the occurrence of an event with event type and inform the scheduler to check the status of the entity GXF_EVENT_EXTERNAL is supported by all GXF schedulers and the rest of the event types are supported by event based scheduler only. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity event \u2013 The type of event. Can be GXF_EVENT_CUSTOM, GXF_EVENT_EXTERNAL, GXF_EVENT_MEMORY_FREE, GXF_EVENT_MESSAGE_SYNC, GXF_EVENT_TIME_UPDATE, GXF_EVENT_STATE_UPDATE. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1426, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountDec", "display_name": "GxfEntityRefCountDec", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountDec", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountDec gxf_context_t  context gxf_uid_t  eid ; Decreases the reference count for an entity by 1. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1427, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountDec.context", "display_name": "GxfEntityRefCountDec.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountDec", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountDec gxf_context_t  context gxf_uid_t  eid ; Decreases the reference count for an entity by 1. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1428, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountDec.eid", "display_name": "GxfEntityRefCountDec.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountDec", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountDec gxf_context_t  context gxf_uid_t  eid ; Decreases the reference count for an entity by 1. See \u2018GxfEntityRefCountInc\u2019 for more details on reference counting. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1429, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountInc", "display_name": "GxfEntityRefCountInc", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountInc", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountInc gxf_context_t  context gxf_uid_t  eid ; Increases the reference count for an entity by 1. By default reference counting is disabled for an entity. This means that entities created with \u2018GxfEntityCreate\u2019 are not automatically destroyed. If this function is called for an entity with disabled reference count, reference counting is enabled and the reference count is set to 1. Once reference counting is enabled an entity will be automatically destroyed if the reference count reaches zero, or if \u2018GxfEntityCreate\u2019 is called explicitely. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1430, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountInc.context", "display_name": "GxfEntityRefCountInc.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountInc", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountInc gxf_context_t  context gxf_uid_t  eid ; Increases the reference count for an entity by 1. By default reference counting is disabled for an entity. This means that entities created with \u2018GxfEntityCreate\u2019 are not automatically destroyed. If this function is called for an entity with disabled reference count, reference counting is enabled and the reference count is set to 1. Once reference counting is enabled an entity will be automatically destroyed if the reference count reaches zero, or if \u2018GxfEntityCreate\u2019 is called explicitely. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1431, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityRefCountInc.eid", "display_name": "GxfEntityRefCountInc.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityRefCountInc", "priority": 1, "content": "gxf_result_t  GxfEntityRefCountInc gxf_context_t  context gxf_uid_t  eid ; Increases the reference count for an entity by 1. By default reference counting is disabled for an entity. This means that entities created with \u2018GxfEntityCreate\u2019 are not automatically destroyed. If this function is called for an entity with disabled reference count, reference counting is enabled and the reference count is set to 1. Once reference counting is enabled an entity will be automatically destroyed if the reference count reaches zero, or if \u2018GxfEntityCreate\u2019 is called explicitely. Parameters context \u2013 A valid GXF context eid \u2013 The UID of a valid entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1432, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle", "display_name": "GxfEntityResourceGetHandle", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1433, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle.context", "display_name": "GxfEntityResourceGetHandle.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1434, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle.eid", "display_name": "GxfEntityResourceGetHandle.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1435, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle.resource_cid", "display_name": "GxfEntityResourceGetHandle.resource_cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1436, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle.resource_key", "display_name": "GxfEntityResourceGetHandle.resource_key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1437, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityResourceGetHandle.type", "display_name": "GxfEntityResourceGetHandle.type", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityResourceGetHandle", "priority": 1, "content": "gxf_result_t  GxfEntityResourceGetHandle gxf_context_t  context gxf_uid_t  eid const  char  * type const  char  * resource_key gxf_uid_t  * resource_cid ; Gets cid of a resource component that is grouped with the given entity Parameters context \u2013 A valid GXF context eid \u2013 eid of an Entity type \u2013 The fully qualified C++ type name of the component resource_key \u2013 the key or name of the resource resource_cid \u2013 The returned cid of the resource component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1438, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityStatusStr", "display_name": "GxfEntityStatusStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityStatusStr", "priority": 1, "content": "const  char  * GxfEntityStatusStr gxf_entity_status_t  status ; Gets a string describing an GXF entity status. The caller does not get ownership of the return C string and must not delete it. Parameters status \u2013 A GXF entity status Returns A pointer to a C string with the entity status description.", "keywords": []}, {"id": 1439, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEntityStatusStr.status", "display_name": "GxfEntityStatusStr.status", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEntityStatusStr", "priority": 1, "content": "const  char  * GxfEntityStatusStr gxf_entity_status_t  status ; Gets a string describing an GXF entity status. The caller does not get ownership of the return C string and must not delete it. Parameters status \u2013 A GXF entity status Returns A pointer to a C string with the entity status description.", "keywords": []}, {"id": 1440, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEventStr", "display_name": "GxfEventStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEventStr", "priority": 1, "content": "const  char  * GxfEventStr gxf_event_t  event ; Gets a string describing an GXF event type. The caller does not get ownership of the return C string and must not delete it. Parameters result \u2013 A GXF error code Returns A pointer to a C string with the error code description.", "keywords": []}, {"id": 1441, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfEventStr.event", "display_name": "GxfEventStr.event", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfEventStr", "priority": 1, "content": "const  char  * GxfEventStr gxf_event_t  event ; Gets a string describing an GXF event type. The caller does not get ownership of the return C string and must not delete it. Parameters result \u2013 A GXF error code Returns A pointer to a C string with the error code description.", "keywords": []}, {"id": 1442, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfExtensionInfo", "display_name": "GxfExtensionInfo", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfExtensionInfo", "priority": 1, "content": "gxf_result_t  GxfExtensionInfo gxf_context_t  context gxf_tid_t  tid gxf_extension_info_t  * info ; Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the extension. info \u2013 pointer to gxf_extension_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1443, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfExtensionInfo.context", "display_name": "GxfExtensionInfo.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfExtensionInfo", "priority": 1, "content": "gxf_result_t  GxfExtensionInfo gxf_context_t  context gxf_tid_t  tid gxf_extension_info_t  * info ; Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the extension. info \u2013 pointer to gxf_extension_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1444, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfExtensionInfo.info", "display_name": "GxfExtensionInfo.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfExtensionInfo", "priority": 1, "content": "gxf_result_t  GxfExtensionInfo gxf_context_t  context gxf_tid_t  tid gxf_extension_info_t  * info ; Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the extension. info \u2013 pointer to gxf_extension_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1445, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfExtensionInfo.tid", "display_name": "GxfExtensionInfo.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfExtensionInfo", "priority": 1, "content": "gxf_result_t  GxfExtensionInfo gxf_context_t  context gxf_tid_t  tid gxf_extension_info_t  * info ; Parameters context \u2013 A valid GXF context. tid \u2013 The unique identifier of the extension. info \u2013 pointer to gxf_extension_info_t object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1446, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfFlags", "display_name": "GxfFlags", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfFlags", "priority": 1, "content": "type  GxfFlags GXF bitmasks. Defined as uint32_t.", "keywords": []}, {"id": 1447, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetParameterInfo", "display_name": "GxfGetParameterInfo", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetParameterInfo", "priority": 1, "content": "gxf_result_t  GxfGetParameterInfo gxf_context_t  context gxf_tid_t  cid const  char  * key gxf_parameter_info_t  * info ; Parameters context \u2013 A valid GXF context. cid \u2013 The unique identifier of the component. key \u2013 The name of the parameter. info \u2013 Pointer to a gxf_parameter_info_t object to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1448, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetParameterInfo.cid", "display_name": "GxfGetParameterInfo.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetParameterInfo", "priority": 1, "content": "gxf_result_t  GxfGetParameterInfo gxf_context_t  context gxf_tid_t  cid const  char  * key gxf_parameter_info_t  * info ; Parameters context \u2013 A valid GXF context. cid \u2013 The unique identifier of the component. key \u2013 The name of the parameter. info \u2013 Pointer to a gxf_parameter_info_t object to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1449, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetParameterInfo.context", "display_name": "GxfGetParameterInfo.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetParameterInfo", "priority": 1, "content": "gxf_result_t  GxfGetParameterInfo gxf_context_t  context gxf_tid_t  cid const  char  * key gxf_parameter_info_t  * info ; Parameters context \u2013 A valid GXF context. cid \u2013 The unique identifier of the component. key \u2013 The name of the parameter. info \u2013 Pointer to a gxf_parameter_info_t object to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1450, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetParameterInfo.info", "display_name": "GxfGetParameterInfo.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetParameterInfo", "priority": 1, "content": "gxf_result_t  GxfGetParameterInfo gxf_context_t  context gxf_tid_t  cid const  char  * key gxf_parameter_info_t  * info ; Parameters context \u2013 A valid GXF context. cid \u2013 The unique identifier of the component. key \u2013 The name of the parameter. info \u2013 Pointer to a gxf_parameter_info_t object to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1451, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetParameterInfo.key", "display_name": "GxfGetParameterInfo.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetParameterInfo", "priority": 1, "content": "gxf_result_t  GxfGetParameterInfo gxf_context_t  context gxf_tid_t  cid const  char  * key gxf_parameter_info_t  * info ; Parameters context \u2013 A valid GXF context. cid \u2013 The unique identifier of the component. key \u2013 The name of the parameter. info \u2013 Pointer to a gxf_parameter_info_t object to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1452, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSeverity", "display_name": "GxfGetSeverity", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSeverity", "priority": 1, "content": "gxf_result_t  GxfGetSeverity gxf_context_t  context gxf_severity_t  severity ; Returns the current severity level of the logs. Parameters context \u2013 a valid GXF context severity \u2013 a pointer to a gxf_severity_t in which the resulting severity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1453, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSeverity.context", "display_name": "GxfGetSeverity.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSeverity", "priority": 1, "content": "gxf_result_t  GxfGetSeverity gxf_context_t  context gxf_severity_t  severity ; Returns the current severity level of the logs. Parameters context \u2013 a valid GXF context severity \u2013 a pointer to a gxf_severity_t in which the resulting severity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1454, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSeverity.severity", "display_name": "GxfGetSeverity.severity", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSeverity", "priority": 1, "content": "gxf_result_t  GxfGetSeverity gxf_context_t  context gxf_severity_t  severity ; Returns the current severity level of the logs. Parameters context \u2013 a valid GXF context severity \u2013 a pointer to a gxf_severity_t in which the resulting severity is returned. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1455, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSharedContext", "display_name": "GxfGetSharedContext", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSharedContext", "priority": 1, "content": "gxf_result_t  GxfGetSharedContext gxf_context_t  context gxf_context_t  * shared ; Get a shared context from an existing runtime context. Parameters context \u2013 A valid GXF shared context. shared \u2013 The shared context. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1456, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSharedContext.context", "display_name": "GxfGetSharedContext.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSharedContext", "priority": 1, "content": "gxf_result_t  GxfGetSharedContext gxf_context_t  context gxf_context_t  * shared ; Get a shared context from an existing runtime context. Parameters context \u2013 A valid GXF shared context. shared \u2013 The shared context. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1457, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGetSharedContext.shared", "display_name": "GxfGetSharedContext.shared", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGetSharedContext", "priority": 1, "content": "gxf_result_t  GxfGetSharedContext gxf_context_t  context gxf_context_t  * shared ; Get a shared context from an existing runtime context. Parameters context \u2013 A valid GXF shared context. shared \u2013 The shared context. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1458, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphActivate", "display_name": "GxfGraphActivate", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphActivate", "priority": 1, "content": "gxf_result_t  GxfGraphActivate gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1459, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphActivate.context", "display_name": "GxfGraphActivate.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphActivate", "priority": 1, "content": "gxf_result_t  GxfGraphActivate gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1460, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphDeactivate", "display_name": "GxfGraphDeactivate", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphDeactivate", "priority": 1, "content": "gxf_result_t  GxfGraphDeactivate gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1461, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphDeactivate.context", "display_name": "GxfGraphDeactivate.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphDeactivate", "priority": 1, "content": "gxf_result_t  GxfGraphDeactivate gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1462, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphInterrupt", "display_name": "GxfGraphInterrupt", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphInterrupt", "priority": 1, "content": "gxf_result_t  GxfGraphInterrupt gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1463, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphInterrupt.context", "display_name": "GxfGraphInterrupt.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphInterrupt", "priority": 1, "content": "gxf_result_t  GxfGraphInterrupt gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1464, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphLoadFile", "display_name": "GxfGraphLoadFile", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphLoadFile", "priority": 1, "content": "gxf_result_t  GxfGraphLoadFile gxf_context_t  context const  char  * filename const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context filename \u2013 A valid YAML filename. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1465, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphLoadFile.context", "display_name": "GxfGraphLoadFile.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphLoadFile", "priority": 1, "content": "gxf_result_t  GxfGraphLoadFile gxf_context_t  context const  char  * filename const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context filename \u2013 A valid YAML filename. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1466, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphLoadFile.filename", "display_name": "GxfGraphLoadFile.filename", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphLoadFile", "priority": 1, "content": "gxf_result_t  GxfGraphLoadFile gxf_context_t  context const  char  * filename const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context filename \u2013 A valid YAML filename. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1467, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphLoadFile.num_overrides", "display_name": "GxfGraphLoadFile.num_overrides", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphLoadFile", "priority": 1, "content": "gxf_result_t  GxfGraphLoadFile gxf_context_t  context const  char  * filename const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context filename \u2013 A valid YAML filename. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1468, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphLoadFile.parameters_override", "display_name": "GxfGraphLoadFile.parameters_override", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphLoadFile", "priority": 1, "content": "gxf_result_t  GxfGraphLoadFile gxf_context_t  context const  char  * filename const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context filename \u2013 A valid YAML filename. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1469, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphParseString", "display_name": "GxfGraphParseString", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphParseString", "priority": 1, "content": "gxf_result_t  GxfGraphParseString gxf_context_t  context const  char  * tex const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context text \u2013 A valid YAML text. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1470, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphParseString.context", "display_name": "GxfGraphParseString.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphParseString", "priority": 1, "content": "gxf_result_t  GxfGraphParseString gxf_context_t  context const  char  * tex const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context text \u2013 A valid YAML text. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1471, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphParseString.num_overrides", "display_name": "GxfGraphParseString.num_overrides", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphParseString", "priority": 1, "content": "gxf_result_t  GxfGraphParseString gxf_context_t  context const  char  * tex const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context text \u2013 A valid YAML text. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1472, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphParseString.parameters_override", "display_name": "GxfGraphParseString.parameters_override", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphParseString", "priority": 1, "content": "gxf_result_t  GxfGraphParseString gxf_context_t  context const  char  * tex const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context text \u2013 A valid YAML text. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1473, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphParseString.tex", "display_name": "GxfGraphParseString.tex", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphParseString", "priority": 1, "content": "gxf_result_t  GxfGraphParseString gxf_context_t  context const  char  * tex const  char  * parameters_override [ ] const  uint32_t  num_overrides ; Parameters context \u2013 A valid GXF context text \u2013 A valid YAML text. params_override \u2013 An optional array of strings used for override parameters in yaml file. num_overrides \u2013 Number of optional override parameter strings. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1474, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphRun", "display_name": "GxfGraphRun", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphRun", "priority": 1, "content": "gxf_result_t  GxfGraphRun gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1475, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphRun.context", "display_name": "GxfGraphRun.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphRun", "priority": 1, "content": "gxf_result_t  GxfGraphRun gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1476, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphRunAsync", "display_name": "GxfGraphRunAsync", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphRunAsync", "priority": 1, "content": "gxf_result_t  GxfGraphRunAsync gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1477, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphRunAsync.context", "display_name": "GxfGraphRunAsync.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphRunAsync", "priority": 1, "content": "gxf_result_t  GxfGraphRunAsync gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1478, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphSetRootPath", "display_name": "GxfGraphSetRootPath", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphSetRootPath", "priority": 1, "content": "gxf_result_t  GxfGraphSetRootPath gxf_context_t  context const  char  * path ; Parameters context \u2013 A valid GXF context path \u2013 Path to root folder for searching YAML files during loading Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1479, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphSetRootPath.context", "display_name": "GxfGraphSetRootPath.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphSetRootPath", "priority": 1, "content": "gxf_result_t  GxfGraphSetRootPath gxf_context_t  context const  char  * path ; Parameters context \u2013 A valid GXF context path \u2013 Path to root folder for searching YAML files during loading Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1480, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphSetRootPath.path", "display_name": "GxfGraphSetRootPath.path", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphSetRootPath", "priority": 1, "content": "gxf_result_t  GxfGraphSetRootPath gxf_context_t  context const  char  * path ; Parameters context \u2013 A valid GXF context path \u2013 Path to root folder for searching YAML files during loading Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1481, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphWait", "display_name": "GxfGraphWait", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphWait", "priority": 1, "content": "gxf_result_t  GxfGraphWait gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.`", "keywords": []}, {"id": 1482, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfGraphWait.context", "display_name": "GxfGraphWait.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfGraphWait", "priority": 1, "content": "gxf_result_t  GxfGraphWait gxf_context_t  context ; Parameters context \u2013 A valid GXF context Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.`", "keywords": []}, {"id": 1483, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionFromPointer", "display_name": "GxfLoadExtensionFromPointer", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionFromPointer", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionFromPointer gxf_context_t  context void  * extension_ptr ; Loads an extension from a pointer to the Extension object. Parameters context \u2013 A valid GXF context extension_ptr \u2013 A pointer to Extension Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1484, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionFromPointer.context", "display_name": "GxfLoadExtensionFromPointer.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionFromPointer", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionFromPointer gxf_context_t  context void  * extension_ptr ; Loads an extension from a pointer to the Extension object. Parameters context \u2013 A valid GXF context extension_ptr \u2013 A pointer to Extension Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1485, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionFromPointer.extension_ptr", "display_name": "GxfLoadExtensionFromPointer.extension_ptr", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionFromPointer", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionFromPointer gxf_context_t  context void  * extension_ptr ; Loads an extension from a pointer to the Extension object. Parameters context \u2013 A valid GXF context extension_ptr \u2013 A pointer to Extension Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1486, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionMetadataFiles", "display_name": "GxfLoadExtensionMetadataFiles", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionMetadataFiles", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionMetadataFiles gxf_context_t  context const  char  * const  * filenames uint32_t  count ; Loads a metadata file generated by the gxf_registry The gxf_registry tool generates a metadata file of the contents of an extension during registration. These metadata files can be used to resolve typename and TID\u2019s of components for other extensions which depend on them. metadata files do not contain the actual implementation of the extension and must be loaded only to run the extension query API\u2019s on extension libraries which have the actual implementation and only depend on the metadata for type resolution. If some components of extension B depend on some components in extension A: - Load metadata file for extension A - Load extension library for extension B using \u2018GxfLoadExtensions\u2019 - Run extension query api\u2019s on extension B and it\u2019s components. Parameters context \u2013 A valid GXF context. filenames \u2013 absolute paths of metadata files generated by the registry during extension registration count \u2013 The number of metadata files to be loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1487, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionMetadataFiles.context", "display_name": "GxfLoadExtensionMetadataFiles.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionMetadataFiles", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionMetadataFiles gxf_context_t  context const  char  * const  * filenames uint32_t  count ; Loads a metadata file generated by the gxf_registry The gxf_registry tool generates a metadata file of the contents of an extension during registration. These metadata files can be used to resolve typename and TID\u2019s of components for other extensions which depend on them. metadata files do not contain the actual implementation of the extension and must be loaded only to run the extension query API\u2019s on extension libraries which have the actual implementation and only depend on the metadata for type resolution. If some components of extension B depend on some components in extension A: - Load metadata file for extension A - Load extension library for extension B using \u2018GxfLoadExtensions\u2019 - Run extension query api\u2019s on extension B and it\u2019s components. Parameters context \u2013 A valid GXF context. filenames \u2013 absolute paths of metadata files generated by the registry during extension registration count \u2013 The number of metadata files to be loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1488, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionMetadataFiles.count", "display_name": "GxfLoadExtensionMetadataFiles.count", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionMetadataFiles", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionMetadataFiles gxf_context_t  context const  char  * const  * filenames uint32_t  count ; Loads a metadata file generated by the gxf_registry The gxf_registry tool generates a metadata file of the contents of an extension during registration. These metadata files can be used to resolve typename and TID\u2019s of components for other extensions which depend on them. metadata files do not contain the actual implementation of the extension and must be loaded only to run the extension query API\u2019s on extension libraries which have the actual implementation and only depend on the metadata for type resolution. If some components of extension B depend on some components in extension A: - Load metadata file for extension A - Load extension library for extension B using \u2018GxfLoadExtensions\u2019 - Run extension query api\u2019s on extension B and it\u2019s components. Parameters context \u2013 A valid GXF context. filenames \u2013 absolute paths of metadata files generated by the registry during extension registration count \u2013 The number of metadata files to be loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1489, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionMetadataFiles.filenames", "display_name": "GxfLoadExtensionMetadataFiles.filenames", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionMetadataFiles", "priority": 1, "content": "gxf_result_t  GxfLoadExtensionMetadataFiles gxf_context_t  context const  char  * const  * filenames uint32_t  count ; Loads a metadata file generated by the gxf_registry The gxf_registry tool generates a metadata file of the contents of an extension during registration. These metadata files can be used to resolve typename and TID\u2019s of components for other extensions which depend on them. metadata files do not contain the actual implementation of the extension and must be loaded only to run the extension query API\u2019s on extension libraries which have the actual implementation and only depend on the metadata for type resolution. If some components of extension B depend on some components in extension A: - Load metadata file for extension A - Load extension library for extension B using \u2018GxfLoadExtensions\u2019 - Run extension query api\u2019s on extension B and it\u2019s components. Parameters context \u2013 A valid GXF context. filenames \u2013 absolute paths of metadata files generated by the registry during extension registration count \u2013 The number of metadata files to be loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1490, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensions", "display_name": "GxfLoadExtensions", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensions", "priority": 1, "content": "gxf_result_t  GxfLoadExtensions gxf_context_t  context const  GxfLoadExtensionsInfo  * info ; Loads GXF extension libraries Loads one or more extensions either directly by their filename or indirectly by loading manifest files. Before a component can be added to a GXF entity the GXF extension shared library providing the component must be loaded. An extensions must only be loaded once. To simplify loading multiple extensions at once the developer can create a manifest file which lists all extensions he needs. This function will then load all extensions listed in the manifest file. Multiple manifest may be loaded, however each extensions may still be loaded only a single time. A manifest file is a YAML file with a single top-level entry \u2018extensions\u2019 followed by a list of filenames of GXF extension shared libraries. Example: \u2014\u2013 START OF FILE \u2014\u2013 extensions: - gxf/std/libgxf_std.so - gxf/npp/libgxf_npp.so \u2014\u2013 END OF FILE \u2014\u2013 Parameters context \u2013 A valid GXF context filename \u2013 A valid filename. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1491, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensions.context", "display_name": "GxfLoadExtensions.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensions", "priority": 1, "content": "gxf_result_t  GxfLoadExtensions gxf_context_t  context const  GxfLoadExtensionsInfo  * info ; Loads GXF extension libraries Loads one or more extensions either directly by their filename or indirectly by loading manifest files. Before a component can be added to a GXF entity the GXF extension shared library providing the component must be loaded. An extensions must only be loaded once. To simplify loading multiple extensions at once the developer can create a manifest file which lists all extensions he needs. This function will then load all extensions listed in the manifest file. Multiple manifest may be loaded, however each extensions may still be loaded only a single time. A manifest file is a YAML file with a single top-level entry \u2018extensions\u2019 followed by a list of filenames of GXF extension shared libraries. Example: \u2014\u2013 START OF FILE \u2014\u2013 extensions: - gxf/std/libgxf_std.so - gxf/npp/libgxf_npp.so \u2014\u2013 END OF FILE \u2014\u2013 Parameters context \u2013 A valid GXF context filename \u2013 A valid filename. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1492, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensions.info", "display_name": "GxfLoadExtensions.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensions", "priority": 1, "content": "gxf_result_t  GxfLoadExtensions gxf_context_t  context const  GxfLoadExtensionsInfo  * info ; Loads GXF extension libraries Loads one or more extensions either directly by their filename or indirectly by loading manifest files. Before a component can be added to a GXF entity the GXF extension shared library providing the component must be loaded. An extensions must only be loaded once. To simplify loading multiple extensions at once the developer can create a manifest file which lists all extensions he needs. This function will then load all extensions listed in the manifest file. Multiple manifest may be loaded, however each extensions may still be loaded only a single time. A manifest file is a YAML file with a single top-level entry \u2018extensions\u2019 followed by a list of filenames of GXF extension shared libraries. Example: \u2014\u2013 START OF FILE \u2014\u2013 extensions: - gxf/std/libgxf_std.so - gxf/npp/libgxf_npp.so \u2014\u2013 END OF FILE \u2014\u2013 Parameters context \u2013 A valid GXF context filename \u2013 A valid filename. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1493, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo", "display_name": "GxfLoadExtensionsInfo", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo", "priority": 1, "content": "type  GxfLoadExtensionsInfo A structure specifying parameters for loading extensions.", "keywords": []}, {"id": 1494, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo.base_directory", "display_name": "GxfLoadExtensionsInfo.base_directory", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo.base_directory", "priority": 1, "content": "const  char  * base_directory An optional base directory which is prepended to all extensions filenames, including those loaded via manifests.", "keywords": []}, {"id": 1495, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo.extension_filenames", "display_name": "GxfLoadExtensionsInfo.extension_filenames", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo.extension_filenames", "priority": 1, "content": "const  char  * const  * extension_filenames Optional list of extension filenames to load.", "keywords": []}, {"id": 1496, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo.extension_filenames_count", "display_name": "GxfLoadExtensionsInfo.extension_filenames_count", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo.extension_filenames_count", "priority": 1, "content": "uint32_t  extension_filenames_count The number of extensions to load.", "keywords": []}, {"id": 1497, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo.manifest_filenames", "display_name": "GxfLoadExtensionsInfo.manifest_filenames", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo.manifest_filenames", "priority": 1, "content": "const  char  * const  * manifest_filenames Optional list of manifest filenames to load.", "keywords": []}, {"id": 1498, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfLoadExtensionsInfo.manifest_filenames_count", "display_name": "GxfLoadExtensionsInfo.manifest_filenames_count", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfLoadExtensionsInfo.manifest_filenames_count", "priority": 1, "content": "uint32_t  manifest_filenames_count The number of manifests to load.", "keywords": []}, {"id": 1499, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterFlagTypeStr", "display_name": "GxfParameterFlagTypeStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterFlagTypeStr", "priority": 1, "content": "const  char  * GxfParameterFlagTypeStr gxf_parameter_flags_t_  flag_type ; Parameters flag_type \u2013 Type of flag to get info about. Returns C-style string description of the flag type.", "keywords": []}, {"id": 1500, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterFlagTypeStr.flag_type", "display_name": "GxfParameterFlagTypeStr.flag_type", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterFlagTypeStr", "priority": 1, "content": "const  char  * GxfParameterFlagTypeStr gxf_parameter_flags_t_  flag_type ; Parameters flag_type \u2013 Type of flag to get info about. Returns C-style string description of the flag type.", "keywords": []}, {"id": 1501, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetBool", "display_name": "GxfParameterGetBool", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetBool", "priority": 1, "content": "gxf_result_t  GxfParameterGetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the boolean value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1502, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetBool.context", "display_name": "GxfParameterGetBool.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetBool", "priority": 1, "content": "gxf_result_t  GxfParameterGetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the boolean value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1503, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetBool.key", "display_name": "GxfParameterGetBool.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetBool", "priority": 1, "content": "gxf_result_t  GxfParameterGetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the boolean value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1504, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetBool.uid", "display_name": "GxfParameterGetBool.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetBool", "priority": 1, "content": "gxf_result_t  GxfParameterGetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the boolean value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1505, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetBool.value", "display_name": "GxfParameterGetBool.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetBool", "priority": 1, "content": "gxf_result_t  GxfParameterGetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the boolean value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1506, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetFloat64", "display_name": "GxfParameterGetFloat64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterGetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the double value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1507, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetFloat64.context", "display_name": "GxfParameterGetFloat64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterGetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the double value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1508, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetFloat64.key", "display_name": "GxfParameterGetFloat64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterGetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the double value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1509, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetFloat64.uid", "display_name": "GxfParameterGetFloat64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterGetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the double value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1510, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetFloat64.value", "display_name": "GxfParameterGetFloat64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterGetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the double value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1511, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetHandle", "display_name": "GxfParameterGetHandle", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterGetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  * cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 Pointer to a unique identifier to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1512, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetHandle.cid", "display_name": "GxfParameterGetHandle.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterGetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  * cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 Pointer to a unique identifier to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1513, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetHandle.context", "display_name": "GxfParameterGetHandle.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterGetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  * cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 Pointer to a unique identifier to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1514, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetHandle.key", "display_name": "GxfParameterGetHandle.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterGetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  * cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 Pointer to a unique identifier to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1515, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetHandle.uid", "display_name": "GxfParameterGetHandle.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterGetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  * cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 Pointer to a unique identifier to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1516, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt32", "display_name": "GxfParameterGetInt32", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1517, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt32.context", "display_name": "GxfParameterGetInt32.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1518, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt32.key", "display_name": "GxfParameterGetInt32.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1519, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt32.uid", "display_name": "GxfParameterGetInt32.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1520, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt32.value", "display_name": "GxfParameterGetInt32.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1521, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt64", "display_name": "GxfParameterGetInt64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1522, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt64.context", "display_name": "GxfParameterGetInt64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1523, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt64.key", "display_name": "GxfParameterGetInt64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1524, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt64.uid", "display_name": "GxfParameterGetInt64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1525, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetInt64.value", "display_name": "GxfParameterGetInt64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1526, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetStr", "display_name": "GxfParameterGetStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetStr", "priority": 1, "content": "gxf_result_t  GxfParameterGetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to a char* array to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1527, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetStr.context", "display_name": "GxfParameterGetStr.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetStr", "priority": 1, "content": "gxf_result_t  GxfParameterGetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to a char* array to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1528, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetStr.key", "display_name": "GxfParameterGetStr.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetStr", "priority": 1, "content": "gxf_result_t  GxfParameterGetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to a char* array to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1529, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetStr.uid", "display_name": "GxfParameterGetStr.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetStr", "priority": 1, "content": "gxf_result_t  GxfParameterGetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to a char* array to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1530, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetStr.value", "display_name": "GxfParameterGetStr.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetStr", "priority": 1, "content": "gxf_result_t  GxfParameterGetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to a char* array to get the value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1531, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt16", "display_name": "GxfParameterGetUInt16", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 16-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1532, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt16.context", "display_name": "GxfParameterGetUInt16.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 16-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1533, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt16.key", "display_name": "GxfParameterGetUInt16.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 16-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1534, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt16.uid", "display_name": "GxfParameterGetUInt16.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 16-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1535, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt16.value", "display_name": "GxfParameterGetUInt16.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 16-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1536, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt32", "display_name": "GxfParameterGetUInt32", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1537, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt32.context", "display_name": "GxfParameterGetUInt32.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1538, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt32.key", "display_name": "GxfParameterGetUInt32.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1539, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt32.uid", "display_name": "GxfParameterGetUInt32.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1540, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt32.value", "display_name": "GxfParameterGetUInt32.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the 32-bit unsigned integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1541, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt64", "display_name": "GxfParameterGetUInt64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the unsigned 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1542, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt64.context", "display_name": "GxfParameterGetUInt64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the unsigned 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1543, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt64.key", "display_name": "GxfParameterGetUInt64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the unsigned 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1544, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt64.uid", "display_name": "GxfParameterGetUInt64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the unsigned 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1545, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterGetUInt64.value", "display_name": "GxfParameterGetUInt64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterGetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterGetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 pointer to get the unsigned 64-bit integer value. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1546, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector", "display_name": "GxfParameterSet1DDataTypeVector", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1547, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector.context", "display_name": "GxfParameterSet1DDataTypeVector.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1548, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector.key", "display_name": "GxfParameterSet1DDataTypeVector.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1549, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector.length", "display_name": "GxfParameterSet1DDataTypeVector.length", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1550, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector.uid", "display_name": "GxfParameterSet1DDataTypeVector.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1551, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet1DDataTypeVector.value", "display_name": "GxfParameterSet1DDataTypeVector.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet1DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet1DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * value uint64_t  length ; value should point to an array of the data to be set of the corresponding type. The size of the stored array should match the length argument passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter length \u2013 The length of the vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet1DFloat64Vector(...) double GxfParameterSet1DInt64Vector(...) int64_t GxfParameterSet1DUInt64Vector(...) uint64_t GxfParameterSet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1552, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector", "display_name": "GxfParameterSet2DDataTypeVector", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1553, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.context", "display_name": "GxfParameterSet2DDataTypeVector.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1554, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.height", "display_name": "GxfParameterSet2DDataTypeVector.height", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1555, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.key", "display_name": "GxfParameterSet2DDataTypeVector.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1556, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.uid", "display_name": "GxfParameterSet2DDataTypeVector.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1557, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.value", "display_name": "GxfParameterSet2DDataTypeVector.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1558, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSet2DDataTypeVector.width", "display_name": "GxfParameterSet2DDataTypeVector.width", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSet2DDataTypeVector", "priority": 1, "content": "gxf_result_t  GxfParameterSet2DDataTypeVector gxf_context_t  context gxf_uid_t  uid const  char  * key data_type  * * value uint64_t  height uint64_t  width ; value should point to an array of array (and not to the address of a contiguous array of data) of the data to be set of the corresponding type. The length of the first dimension of the array should match the height argument passed and similarly the length of the second dimension of the array should match the width passed. See the table below for all the supported data types and their corresponding function signatures. Parameters key \u2013 The name of the parameter value \u2013 The value to set of the parameter height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes. Function Name data_type GxfParameterSet2DFloat64Vector(...) double GxfParameterSet2DInt64Vector(...) int64_t GxfParameterSet2DUInt64Vector(...) uint64_t GxfParameterSet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1559, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetBool", "display_name": "GxfParameterSetBool", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetBool", "priority": 1, "content": "gxf_result_t  GxfParameterSetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A boolean value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1560, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetBool.context", "display_name": "GxfParameterSetBool.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetBool", "priority": 1, "content": "gxf_result_t  GxfParameterSetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A boolean value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1561, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetBool.key", "display_name": "GxfParameterSetBool.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetBool", "priority": 1, "content": "gxf_result_t  GxfParameterSetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A boolean value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1562, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetBool.uid", "display_name": "GxfParameterSetBool.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetBool", "priority": 1, "content": "gxf_result_t  GxfParameterSetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A boolean value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1563, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetBool.value", "display_name": "GxfParameterSetBool.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetBool", "priority": 1, "content": "gxf_result_t  GxfParameterSetBool gxf_context_t  context gxf_uid_t  uid const  char  * key bool  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A boolean value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1564, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFloat64", "display_name": "GxfParameterSetFloat64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterSetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a double value Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1565, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFloat64.context", "display_name": "GxfParameterSetFloat64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterSetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a double value Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1566, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFloat64.key", "display_name": "GxfParameterSetFloat64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterSetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a double value Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1567, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFloat64.uid", "display_name": "GxfParameterSetFloat64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterSetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a double value Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1568, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFloat64.value", "display_name": "GxfParameterSetFloat64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFloat64", "priority": 1, "content": "gxf_result_t  GxfParameterSetFloat64 gxf_context_t  context gxf_uid_t  uid const  char  * key double  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a double value Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1569, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode", "display_name": "GxfParameterSetFromYamlNode", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1570, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode.context", "display_name": "GxfParameterSetFromYamlNode.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1571, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode.key", "display_name": "GxfParameterSetFromYamlNode.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1572, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode.prefix", "display_name": "GxfParameterSetFromYamlNode.prefix", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1573, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode.uid", "display_name": "GxfParameterSetFromYamlNode.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1574, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetFromYamlNode.yaml_node", "display_name": "GxfParameterSetFromYamlNode.yaml_node", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetFromYamlNode", "priority": 1, "content": "gxf_result_t  GxfParameterSetFromYamlNode gxf_context_t  context gxf_uid_t  uid const  char  * key void  * yaml_node const  char  * prefix ; Sets a parameter from YAML. The YAML node pointer should be a type of \u2018YAML::Node*\u2019. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. yaml_node \u2013 a yaml node pointer prefix \u2013 prefix Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1575, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetHandle", "display_name": "GxfParameterSetHandle", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterSetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. cid \u2013 Unique identifier to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1576, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetHandle.cid", "display_name": "GxfParameterSetHandle.cid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterSetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. cid \u2013 Unique identifier to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1577, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetHandle.context", "display_name": "GxfParameterSetHandle.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterSetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. cid \u2013 Unique identifier to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1578, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetHandle.key", "display_name": "GxfParameterSetHandle.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterSetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. cid \u2013 Unique identifier to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1579, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetHandle.uid", "display_name": "GxfParameterSetHandle.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetHandle", "priority": 1, "content": "gxf_result_t  GxfParameterSetHandle gxf_context_t  context gxf_uid_t  uid const  char  * key gxf_uid_t  cid ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. cid \u2013 Unique identifier to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1580, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt16", "display_name": "GxfParameterSetInt16", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key int16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1581, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt16.context", "display_name": "GxfParameterSetInt16.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key int16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1582, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt16.key", "display_name": "GxfParameterSetInt16.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key int16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1583, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt16.uid", "display_name": "GxfParameterSetInt16.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key int16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1584, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt16.value", "display_name": "GxfParameterSetInt16.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key int16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1585, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt32", "display_name": "GxfParameterSetInt32", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1586, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt32.context", "display_name": "GxfParameterSetInt32.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1587, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt32.key", "display_name": "GxfParameterSetInt32.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1588, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt32.uid", "display_name": "GxfParameterSetInt32.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1589, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt32.value", "display_name": "GxfParameterSetInt32.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key int32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1590, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt64", "display_name": "GxfParameterSetInt64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 64-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1591, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt64.context", "display_name": "GxfParameterSetInt64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 64-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1592, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt64.key", "display_name": "GxfParameterSetInt64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 64-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1593, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt64.uid", "display_name": "GxfParameterSetInt64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 64-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1594, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt64.value", "display_name": "GxfParameterSetInt64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key int64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 64-bit integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1595, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt8", "display_name": "GxfParameterSetInt8", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key int8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1596, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt8.context", "display_name": "GxfParameterSetInt8.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key int8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1597, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt8.key", "display_name": "GxfParameterSetInt8.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key int8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1598, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt8.uid", "display_name": "GxfParameterSetInt8.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key int8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1599, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetInt8.value", "display_name": "GxfParameterSetInt8.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key int8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit signed integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1600, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetPath", "display_name": "GxfParameterSetPath", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetPath", "priority": 1, "content": "gxf_result_t  GxfParameterSetPath gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Sets a FilePath parameter. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a file path Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1601, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetPath.context", "display_name": "GxfParameterSetPath.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetPath", "priority": 1, "content": "gxf_result_t  GxfParameterSetPath gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Sets a FilePath parameter. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a file path Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1602, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetPath.key", "display_name": "GxfParameterSetPath.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetPath", "priority": 1, "content": "gxf_result_t  GxfParameterSetPath gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Sets a FilePath parameter. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a file path Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1603, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetPath.uid", "display_name": "GxfParameterSetPath.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetPath", "priority": 1, "content": "gxf_result_t  GxfParameterSetPath gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Sets a FilePath parameter. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a file path Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1604, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetPath.value", "display_name": "GxfParameterSetPath.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetPath", "priority": 1, "content": "gxf_result_t  GxfParameterSetPath gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Sets a FilePath parameter. Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 a file path Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1605, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetStr", "display_name": "GxfParameterSetStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetStr", "priority": 1, "content": "gxf_result_t  GxfParameterSetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A char array containing value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1606, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetStr.context", "display_name": "GxfParameterSetStr.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetStr", "priority": 1, "content": "gxf_result_t  GxfParameterSetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A char array containing value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1607, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetStr.key", "display_name": "GxfParameterSetStr.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetStr", "priority": 1, "content": "gxf_result_t  GxfParameterSetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A char array containing value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1608, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetStr.uid", "display_name": "GxfParameterSetStr.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetStr", "priority": 1, "content": "gxf_result_t  GxfParameterSetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A char array containing value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1609, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetStr.value", "display_name": "GxfParameterSetStr.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetStr", "priority": 1, "content": "gxf_result_t  GxfParameterSetStr gxf_context_t  context gxf_uid_t  uid const  char  * key const  char  * value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 A char array containing value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1610, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt16", "display_name": "GxfParameterSetUInt16", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1611, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt16.context", "display_name": "GxfParameterSetUInt16.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1612, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt16.key", "display_name": "GxfParameterSetUInt16.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1613, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt16.uid", "display_name": "GxfParameterSetUInt16.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1614, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt16.value", "display_name": "GxfParameterSetUInt16.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt16", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt16 gxf_context_t  context gxf_uid_t  uid const  char  * key uint16_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 16-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1615, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt32", "display_name": "GxfParameterSetUInt32", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1616, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt32.context", "display_name": "GxfParameterSetUInt32.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1617, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt32.key", "display_name": "GxfParameterSetUInt32.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1618, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt32.uid", "display_name": "GxfParameterSetUInt32.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1619, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt32.value", "display_name": "GxfParameterSetUInt32.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt32", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt32 gxf_context_t  context gxf_uid_t  uid const  char  * key uint32_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 32-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1620, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt64", "display_name": "GxfParameterSetUInt64", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 unsigned 64-bit integet value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1621, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt64.context", "display_name": "GxfParameterSetUInt64.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 unsigned 64-bit integet value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1622, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt64.key", "display_name": "GxfParameterSetUInt64.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 unsigned 64-bit integet value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1623, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt64.uid", "display_name": "GxfParameterSetUInt64.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 unsigned 64-bit integet value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1624, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt64.value", "display_name": "GxfParameterSetUInt64.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt64", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt64 gxf_context_t  context gxf_uid_t  uid const  char  * key uint64_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 unsigned 64-bit integet value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1625, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt8", "display_name": "GxfParameterSetUInt8", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key uint8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1626, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt8.context", "display_name": "GxfParameterSetUInt8.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key uint8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1627, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt8.key", "display_name": "GxfParameterSetUInt8.key", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key uint8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1628, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt8.uid", "display_name": "GxfParameterSetUInt8.uid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key uint8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1629, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterSetUInt8.value", "display_name": "GxfParameterSetUInt8.value", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterSetUInt8", "priority": 1, "content": "gxf_result_t  GxfParameterSetUInt8 gxf_context_t  context gxf_uid_t  uid const  char  * key uint8_t  value ; Parameters context \u2013 A valid GXF context. uid \u2013 A valid component identifier. key \u2013 A valid name of a component to set. value \u2013 8-bit unsigned integer value to set. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1630, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterTypeStr", "display_name": "GxfParameterTypeStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterTypeStr", "priority": 1, "content": "const  char  * GxfParameterTypeStr gxf_parameter_type_t  param_type ; Parameters param_type \u2013 Type of parameter to get info about. Returns C-style string description of the parameter type.", "keywords": []}, {"id": 1631, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfParameterTypeStr.param_type", "display_name": "GxfParameterTypeStr.param_type", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfParameterTypeStr", "priority": 1, "content": "const  char  * GxfParameterTypeStr gxf_parameter_type_t  param_type ; Parameters param_type \u2013 Type of parameter to get info about. Returns C-style string description of the parameter type.", "keywords": []}, {"id": 1632, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRedirectLog", "display_name": "GxfRedirectLog", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRedirectLog", "priority": 1, "content": "gxf_result_t  GxfRedirectLog gxf_context_t  context FILE  * fp ; Parameters context \u2013 A valid GXF context. fp \u2013 File path for the redirected logs. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1633, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRedirectLog.context", "display_name": "GxfRedirectLog.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRedirectLog", "priority": 1, "content": "gxf_result_t  GxfRedirectLog gxf_context_t  context FILE  * fp ; Parameters context \u2013 A valid GXF context. fp \u2013 File path for the redirected logs. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1634, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRedirectLog.fp", "display_name": "GxfRedirectLog.fp", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRedirectLog", "priority": 1, "content": "gxf_result_t  GxfRedirectLog gxf_context_t  context FILE  * fp ; Parameters context \u2013 A valid GXF context. fp \u2013 File path for the redirected logs. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1635, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponent", "display_name": "GxfRegisterComponent", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponent", "priority": 1, "content": "gxf_result_t  GxfRegisterComponent gxf_context_t  context gxf_tid_t  tid const  char  * name const  char  * base_name ; Registers a component with a GXF extension A GXF extension need to register all of its components in the extension factory function. For convenience the helper macros in gxf/std/extension_factory_helper.hpp can be used. The developer must choose a unique GXF tid with two random 64-bit integers. The developer must ensure that every GXF component has a unique tid. The name of the component must be the fully qualified C++ type name of the component. A component may only have a single base class and that base class must be specified with its fully qualified C++ type name as the parameter \u2018base_name\u2019. ref: gxf/std/extension_factory_helper.hpp ref: core/type_name.hpp Parameters context \u2013 A valid GXF context tid \u2013 The chosen GXF tid name \u2013 The type name of the component base_name \u2013 The type name of the base class of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1636, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponent.base_name", "display_name": "GxfRegisterComponent.base_name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponent", "priority": 1, "content": "gxf_result_t  GxfRegisterComponent gxf_context_t  context gxf_tid_t  tid const  char  * name const  char  * base_name ; Registers a component with a GXF extension A GXF extension need to register all of its components in the extension factory function. For convenience the helper macros in gxf/std/extension_factory_helper.hpp can be used. The developer must choose a unique GXF tid with two random 64-bit integers. The developer must ensure that every GXF component has a unique tid. The name of the component must be the fully qualified C++ type name of the component. A component may only have a single base class and that base class must be specified with its fully qualified C++ type name as the parameter \u2018base_name\u2019. ref: gxf/std/extension_factory_helper.hpp ref: core/type_name.hpp Parameters context \u2013 A valid GXF context tid \u2013 The chosen GXF tid name \u2013 The type name of the component base_name \u2013 The type name of the base class of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1637, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponent.context", "display_name": "GxfRegisterComponent.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponent", "priority": 1, "content": "gxf_result_t  GxfRegisterComponent gxf_context_t  context gxf_tid_t  tid const  char  * name const  char  * base_name ; Registers a component with a GXF extension A GXF extension need to register all of its components in the extension factory function. For convenience the helper macros in gxf/std/extension_factory_helper.hpp can be used. The developer must choose a unique GXF tid with two random 64-bit integers. The developer must ensure that every GXF component has a unique tid. The name of the component must be the fully qualified C++ type name of the component. A component may only have a single base class and that base class must be specified with its fully qualified C++ type name as the parameter \u2018base_name\u2019. ref: gxf/std/extension_factory_helper.hpp ref: core/type_name.hpp Parameters context \u2013 A valid GXF context tid \u2013 The chosen GXF tid name \u2013 The type name of the component base_name \u2013 The type name of the base class of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1638, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponent.name", "display_name": "GxfRegisterComponent.name", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponent", "priority": 1, "content": "gxf_result_t  GxfRegisterComponent gxf_context_t  context gxf_tid_t  tid const  char  * name const  char  * base_name ; Registers a component with a GXF extension A GXF extension need to register all of its components in the extension factory function. For convenience the helper macros in gxf/std/extension_factory_helper.hpp can be used. The developer must choose a unique GXF tid with two random 64-bit integers. The developer must ensure that every GXF component has a unique tid. The name of the component must be the fully qualified C++ type name of the component. A component may only have a single base class and that base class must be specified with its fully qualified C++ type name as the parameter \u2018base_name\u2019. ref: gxf/std/extension_factory_helper.hpp ref: core/type_name.hpp Parameters context \u2013 A valid GXF context tid \u2013 The chosen GXF tid name \u2013 The type name of the component base_name \u2013 The type name of the base class of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1639, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponent.tid", "display_name": "GxfRegisterComponent.tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponent", "priority": 1, "content": "gxf_result_t  GxfRegisterComponent gxf_context_t  context gxf_tid_t  tid const  char  * name const  char  * base_name ; Registers a component with a GXF extension A GXF extension need to register all of its components in the extension factory function. For convenience the helper macros in gxf/std/extension_factory_helper.hpp can be used. The developer must choose a unique GXF tid with two random 64-bit integers. The developer must ensure that every GXF component has a unique tid. The name of the component must be the fully qualified C++ type name of the component. A component may only have a single base class and that base class must be specified with its fully qualified C++ type name as the parameter \u2018base_name\u2019. ref: gxf/std/extension_factory_helper.hpp ref: core/type_name.hpp Parameters context \u2013 A valid GXF context tid \u2013 The chosen GXF tid name \u2013 The type name of the component base_name \u2013 The type name of the base class of the component Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1640, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponentInExtension", "display_name": "GxfRegisterComponentInExtension", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponentInExtension", "priority": 1, "content": "gxf_result_t  GxfRegisterComponentInExtension gxf_context_t  context gxf_tid_t  component_tid gxf_tid_t  extension_tid ; Registers a new component from an extension during runtime Once an extension is loaded any newly added components to that extension can be registered with the context using this function Parameters context \u2013 A valid GXF context component_tid \u2013 The valid GXF tid of a unregistered new component extension_tid \u2013 The valid GXF tid of an extension which has already been loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1641, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponentInExtension.component_tid", "display_name": "GxfRegisterComponentInExtension.component_tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponentInExtension", "priority": 1, "content": "gxf_result_t  GxfRegisterComponentInExtension gxf_context_t  context gxf_tid_t  component_tid gxf_tid_t  extension_tid ; Registers a new component from an extension during runtime Once an extension is loaded any newly added components to that extension can be registered with the context using this function Parameters context \u2013 A valid GXF context component_tid \u2013 The valid GXF tid of a unregistered new component extension_tid \u2013 The valid GXF tid of an extension which has already been loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1642, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponentInExtension.context", "display_name": "GxfRegisterComponentInExtension.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponentInExtension", "priority": 1, "content": "gxf_result_t  GxfRegisterComponentInExtension gxf_context_t  context gxf_tid_t  component_tid gxf_tid_t  extension_tid ; Registers a new component from an extension during runtime Once an extension is loaded any newly added components to that extension can be registered with the context using this function Parameters context \u2013 A valid GXF context component_tid \u2013 The valid GXF tid of a unregistered new component extension_tid \u2013 The valid GXF tid of an extension which has already been loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1643, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRegisterComponentInExtension.extension_tid", "display_name": "GxfRegisterComponentInExtension.extension_tid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRegisterComponentInExtension", "priority": 1, "content": "gxf_result_t  GxfRegisterComponentInExtension gxf_context_t  context gxf_tid_t  component_tid gxf_tid_t  extension_tid ; Registers a new component from an extension during runtime Once an extension is loaded any newly added components to that extension can be registered with the context using this function Parameters context \u2013 A valid GXF context component_tid \u2013 The valid GXF tid of a unregistered new component extension_tid \u2013 The valid GXF tid of an extension which has already been loaded Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1644, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfResultStr", "display_name": "GxfResultStr", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfResultStr", "priority": 1, "content": "const  char  * GxfResultStr gxf_result_t  result ; Gets a string describing an GXF error code. The caller does not get ownership of the return C string and must not delete it. Parameters result \u2013 A GXF error code Returns A pointer to a C string with the error code description.", "keywords": []}, {"id": 1645, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfResultStr.result", "display_name": "GxfResultStr.result", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfResultStr", "priority": 1, "content": "const  char  * GxfResultStr gxf_result_t  result ; Gets a string describing an GXF error code. The caller does not get ownership of the return C string and must not delete it. Parameters result \u2013 A GXF error code Returns A pointer to a C string with the error code description.", "keywords": []}, {"id": 1646, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRuntimeInfo", "display_name": "GxfRuntimeInfo", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRuntimeInfo", "priority": 1, "content": "gxf_result_t  GxfRuntimeInfo gxf_context_t  context gxf_runtime_info  * info ; Parameters context \u2013 A valid GXF context. info \u2013 pointer to gxf_runtime_info object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1647, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRuntimeInfo.context", "display_name": "GxfRuntimeInfo.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRuntimeInfo", "priority": 1, "content": "gxf_result_t  GxfRuntimeInfo gxf_context_t  context gxf_runtime_info  * info ; Parameters context \u2013 A valid GXF context. info \u2013 pointer to gxf_runtime_info object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1648, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfRuntimeInfo.info", "display_name": "GxfRuntimeInfo.info", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfRuntimeInfo", "priority": 1, "content": "gxf_result_t  GxfRuntimeInfo gxf_context_t  context gxf_runtime_info  * info ; Parameters context \u2013 A valid GXF context. info \u2013 pointer to gxf_runtime_info object to get the meta data. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1649, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfSetSeverity", "display_name": "GxfSetSeverity", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfSetSeverity", "priority": 1, "content": "gxf_result_t  GxfSetSeverity gxf_context_t  context gxf_severity_t  severity ; Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for the entire application. Parameters context \u2013 a valid GXF context severity \u2013 a valid severity level as defined in gxf_severity_t . Logs corresponding to any level &lt;= severity will be logged. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1650, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfSetSeverity.context", "display_name": "GxfSetSeverity.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfSetSeverity", "priority": 1, "content": "gxf_result_t  GxfSetSeverity gxf_context_t  context gxf_severity_t  severity ; Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for the entire application. Parameters context \u2013 a valid GXF context severity \u2013 a valid severity level as defined in gxf_severity_t . Logs corresponding to any level &lt;= severity will be logged. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1651, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfSetSeverity.severity", "display_name": "GxfSetSeverity.severity", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfSetSeverity", "priority": 1, "content": "gxf_result_t  GxfSetSeverity gxf_context_t  context gxf_severity_t  severity ; Sets the severity level of the logs (corresponding to GXF_LOG_* logging macros) for the entire application. Parameters context \u2013 a valid GXF context severity \u2013 a valid severity level as defined in gxf_severity_t . Logs corresponding to any level &lt;= severity will be logged. Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1652, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfUpdateEntityGroup", "display_name": "GxfUpdateEntityGroup", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfUpdateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfUpdateEntityGroup gxf_context_t  context gxf_uid_t  gid gxf_uid_t  eid ; Update entity\u2019s EntityGroup by adding the entity eid into the target EntityGroup; and remove the entity eid from previous EntityGroup. Each entity always has one and only one EntityGroup. The entity holds the entity group gid, and the EntityGroup holds a set of entity eids that has this entity eid. Each entity is created with default EntityGroup. When update an entity\u2019s EntityGroup: 1. updates EntityGroup uid in current EntityItem, to new group id gid; 2. Remove eid from its previous EntityGroup; 3. add eid to its new EntityGroup Parameters context \u2013 A valid GXF context gid \u2013 UID of an existing (new) EntityGroup eid \u2013 eid of an Entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1653, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfUpdateEntityGroup.context", "display_name": "GxfUpdateEntityGroup.context", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfUpdateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfUpdateEntityGroup gxf_context_t  context gxf_uid_t  gid gxf_uid_t  eid ; Update entity\u2019s EntityGroup by adding the entity eid into the target EntityGroup; and remove the entity eid from previous EntityGroup. Each entity always has one and only one EntityGroup. The entity holds the entity group gid, and the EntityGroup holds a set of entity eids that has this entity eid. Each entity is created with default EntityGroup. When update an entity\u2019s EntityGroup: 1. updates EntityGroup uid in current EntityItem, to new group id gid; 2. Remove eid from its previous EntityGroup; 3. add eid to its new EntityGroup Parameters context \u2013 A valid GXF context gid \u2013 UID of an existing (new) EntityGroup eid \u2013 eid of an Entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1654, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfUpdateEntityGroup.eid", "display_name": "GxfUpdateEntityGroup.eid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfUpdateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfUpdateEntityGroup gxf_context_t  context gxf_uid_t  gid gxf_uid_t  eid ; Update entity\u2019s EntityGroup by adding the entity eid into the target EntityGroup; and remove the entity eid from previous EntityGroup. Each entity always has one and only one EntityGroup. The entity holds the entity group gid, and the EntityGroup holds a set of entity eids that has this entity eid. Each entity is created with default EntityGroup. When update an entity\u2019s EntityGroup: 1. updates EntityGroup uid in current EntityItem, to new group id gid; 2. Remove eid from its previous EntityGroup; 3. add eid to its new EntityGroup Parameters context \u2013 A valid GXF context gid \u2013 UID of an existing (new) EntityGroup eid \u2013 eid of an Entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1655, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "GxfUpdateEntityGroup.gid", "display_name": "GxfUpdateEntityGroup.gid", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.GxfUpdateEntityGroup", "priority": 1, "content": "gxf_result_t  GxfUpdateEntityGroup gxf_context_t  context gxf_uid_t  gid gxf_uid_t  eid ; Update entity\u2019s EntityGroup by adding the entity eid into the target EntityGroup; and remove the entity eid from previous EntityGroup. Each entity always has one and only one EntityGroup. The entity holds the entity group gid, and the EntityGroup holds a set of entity eids that has this entity eid. Each entity is created with default EntityGroup. When update an entity\u2019s EntityGroup: 1. updates EntityGroup uid in current EntityItem, to new group id gid; 2. Remove eid from its previous EntityGroup; 3. add eid to its new EntityGroup Parameters context \u2013 A valid GXF context gid \u2013 UID of an existing (new) EntityGroup eid \u2013 eid of an Entity Returns GXF_SUCCESS if the operation was successful, or otherwise one of the GXF error codes.", "keywords": []}, {"id": 1656, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t", "display_name": "entity_state_t", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t", "priority": 1, "content": "enum  entity_state_t An enumeration used by behavior parent codelet in Behavior Tree denoting the result of codelet::tick() .", "keywords": []}, {"id": 1657, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t.GXF_BEHAVIOR_FAILURE", "display_name": "entity_state_t.GXF_BEHAVIOR_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_FAILURE", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_FAILURE For codelet that terminates with failure after ticking.", "keywords": []}, {"id": 1658, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t.GXF_BEHAVIOR_INIT", "display_name": "entity_state_t.GXF_BEHAVIOR_INIT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_INIT", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_INIT For codelet that have not yet started running.", "keywords": []}, {"id": 1659, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t.GXF_BEHAVIOR_RUNNING", "display_name": "entity_state_t.GXF_BEHAVIOR_RUNNING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_RUNNING", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_RUNNING For codelet that needs multiple ticks to complete.", "keywords": []}, {"id": 1660, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t.GXF_BEHAVIOR_SUCCESS", "display_name": "entity_state_t.GXF_BEHAVIOR_SUCCESS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_SUCCESS", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_SUCCESS For codelet that terminates with success after ticking.", "keywords": []}, {"id": 1661, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "entity_state_t.GXF_BEHAVIOR_UNKNOWN", "display_name": "entity_state_t.GXF_BEHAVIOR_UNKNOWN", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.entity_state_t.GXF_BEHAVIOR_UNKNOWN", "priority": 1, "content": "enumerator  GXF_BEHAVIOR_UNKNOWN For non-behavior-tree codelet because we don\u2019t care about the behavior status returned by controller if it is not a BT codelet.", "keywords": []}, {"id": 1662, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t", "display_name": "gxf_component_info_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t", "priority": 1, "content": "type  gxf_component_info_t A structure representing description and list of parameters of a component.", "keywords": []}, {"id": 1663, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.base_name", "display_name": "gxf_component_info_t.base_name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.base_name", "priority": 1, "content": "const  char  * base_name Base class name registered via GXF_EXT_FACTORY_ADD .", "keywords": []}, {"id": 1664, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.brief", "display_name": "gxf_component_info_t.brief", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.brief", "priority": 1, "content": "const  char  * brief Component brief registered via GXF_EXT_FACTORY_SET_DISPLAY_INFO , maximum 50 characters.", "keywords": []}, {"id": 1665, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.cid", "display_name": "gxf_component_info_t.cid", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.cid", "priority": 1, "content": "gxf_tid_t  cid Component ID registered via GXF_EXT_FACTORY_ADD .", "keywords": []}, {"id": 1666, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.description", "display_name": "gxf_component_info_t.description", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.description", "priority": 1, "content": "const  char  * description Description registered via GXF_EXT_FACTORY_ADD .", "keywords": []}, {"id": 1667, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.display_name", "display_name": "gxf_component_info_t.display_name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.display_name", "priority": 1, "content": "const  char  * display_name Component display name registered via GXF_EXT_FACTORY_SET_DISPLAY_INFO , maximum 30 characters.", "keywords": []}, {"id": 1668, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.is_abstract", "display_name": "gxf_component_info_t.is_abstract", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.is_abstract", "priority": 1, "content": "int  is_abstract Whether the component is abstract and cannot be instantiated.", "keywords": []}, {"id": 1669, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.num_parameters", "display_name": "gxf_component_info_t.num_parameters", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.num_parameters", "priority": 1, "content": "uint64_t  num_parameters In-out capacity of parameters/Number of parameters.", "keywords": []}, {"id": 1670, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.parameters", "display_name": "gxf_component_info_t.parameters", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.parameters", "priority": 1, "content": "const  char  * * parameters List of names for parameters.", "keywords": []}, {"id": 1671, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_component_info_t.type_name", "display_name": "gxf_component_info_t.type_name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_component_info_t.type_name", "priority": 1, "content": "const  char  * type_name Component name registered via GXF_EXT_FACTORY_ADD .", "keywords": []}, {"id": 1672, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_context_t", "display_name": "gxf_context_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_context_t", "priority": 1, "content": "type  gxf_context_t Type for context handle. Defined as void* .", "keywords": []}, {"id": 1673, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t", "display_name": "gxf_entity_status_t", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t", "priority": 1, "content": "enum  gxf_entity_status_t An enumeration representing various lifecycle states of an entity.", "keywords": []}, {"id": 1674, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_MAX", "display_name": "gxf_entity_status_t.GXF_ENTITY_MAX", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_MAX", "priority": 1, "content": "enumerator  GXF_ENTITY_MAX Entity max", "keywords": []}, {"id": 1675, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_IDLE", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_IDLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_IDLE", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_IDLE Entity is idle.", "keywords": []}, {"id": 1676, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_NOT_STARTED", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_NOT_STARTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_NOT_STARTED", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_NOT_STARTED Entity has not started.", "keywords": []}, {"id": 1677, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_STARTED", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_STARTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_STARTED", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_STARTED Entity has started.", "keywords": []}, {"id": 1678, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_START_PENDING", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_START_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_START_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_START_PENDING Entity start is pending.", "keywords": []}, {"id": 1679, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_STOP_PENDING", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_STOP_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_STOP_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_STOP_PENDING Entity stop is pending.", "keywords": []}, {"id": 1680, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_TICKING", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_TICKING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_TICKING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_TICKING Entity is ticking.", "keywords": []}, {"id": 1681, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_entity_status_t.GXF_ENTITY_STATUS_TICK_PENDING", "display_name": "gxf_entity_status_t.GXF_ENTITY_STATUS_TICK_PENDING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_entity_status_t.GXF_ENTITY_STATUS_TICK_PENDING", "priority": 1, "content": "enumerator  GXF_ENTITY_STATUS_TICK_PENDING Entity tick is pending.", "keywords": []}, {"id": 1682, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t", "display_name": "gxf_event_t", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t", "priority": 1, "content": "enum  gxf_event_t An enumeration of various types of events used to communicate with a GXF scheduler. GXF_EVENT_EXTERNAL is supported by all GXF schedulers and the rest of the event types are supported by event based scheduler only. GXF_EVENT_EXTERNAL is typically intended to be used by events originating outside of the GXF framework by threads which are not owned by GXF. All other event types occur within GXF and each of them describe a specific event trigger scenario", "keywords": []}, {"id": 1683, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_CUSTOM", "display_name": "gxf_event_t.GXF_EVENT_CUSTOM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_CUSTOM", "priority": 1, "content": "enumerator  GXF_EVENT_CUSTOM", "keywords": []}, {"id": 1684, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_EXTERNAL", "display_name": "gxf_event_t.GXF_EVENT_EXTERNAL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_EXTERNAL", "priority": 1, "content": "enumerator  GXF_EVENT_EXTERNAL", "keywords": []}, {"id": 1685, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_MEMORY_FREE", "display_name": "gxf_event_t.GXF_EVENT_MEMORY_FREE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_MEMORY_FREE", "priority": 1, "content": "enumerator  GXF_EVENT_MEMORY_FREE", "keywords": []}, {"id": 1686, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_MESSAGE_SYNC", "display_name": "gxf_event_t.GXF_EVENT_MESSAGE_SYNC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_MESSAGE_SYNC", "priority": 1, "content": "enumerator  GXF_EVENT_MESSAGE_SYNC", "keywords": []}, {"id": 1687, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_STATE_UPDATE", "display_name": "gxf_event_t.GXF_EVENT_STATE_UPDATE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_STATE_UPDATE", "priority": 1, "content": "enumerator  GXF_EVENT_STATE_UPDATE", "keywords": []}, {"id": 1688, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_event_t.GXF_EVENT_TIME_UPDATE", "display_name": "gxf_event_t.GXF_EVENT_TIME_UPDATE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_event_t.GXF_EVENT_TIME_UPDATE", "priority": 1, "content": "enumerator  GXF_EVENT_TIME_UPDATE", "keywords": []}, {"id": 1689, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t", "display_name": "gxf_extension_info_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t", "priority": 1, "content": "type  gxf_extension_info_t A structure representing description and list of components for a loaded extension.", "keywords": []}, {"id": 1690, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.author", "display_name": "gxf_extension_info_t.author", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.author", "priority": 1, "content": "const  char  * author Extension author registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1691, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.brief", "display_name": "gxf_extension_info_t.brief", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.brief", "priority": 1, "content": "const  char  * brief Extension brief registered via GXF_EXT_FACTORY_SET_DISPLAY_INFO .", "keywords": []}, {"id": 1692, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.category", "display_name": "gxf_extension_info_t.category", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.category", "priority": 1, "content": "const  char  * category Extension category registered via GXF_EXT_FACTORY_SET_DISPLAY_INFO .", "keywords": []}, {"id": 1693, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.components", "display_name": "gxf_extension_info_t.components", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.components", "priority": 1, "content": "gxf_tid_t  * components List of IDs of provided components.", "keywords": []}, {"id": 1694, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.description", "display_name": "gxf_extension_info_t.description", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.description", "priority": 1, "content": "const  char  * description Description registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1695, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.display_name", "display_name": "gxf_extension_info_t.display_name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.display_name", "priority": 1, "content": "const  char  * display_name Extension display name registered via GXF_EXT_FACTORY_SET_DISPLAY_INFO .", "keywords": []}, {"id": 1696, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.id", "display_name": "gxf_extension_info_t.id", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.id", "priority": 1, "content": "gxf_tid_t  id Extension ID (UUID) registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1697, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.license", "display_name": "gxf_extension_info_t.license", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.license", "priority": 1, "content": "const  char  * license Extension license registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1698, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.name", "display_name": "gxf_extension_info_t.name", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.name", "priority": 1, "content": "const  char  * name Extension name registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1699, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.num_components", "display_name": "gxf_extension_info_t.num_components", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.num_components", "priority": 1, "content": "uint64_t  num_components In-out capacity of components/Number of components.", "keywords": []}, {"id": 1700, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.runtime_version", "display_name": "gxf_extension_info_t.runtime_version", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.runtime_version", "priority": 1, "content": "const  char  * runtime_version GXF Core version the extension was compiled with.", "keywords": []}, {"id": 1701, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_extension_info_t.version", "display_name": "gxf_extension_info_t.version", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_extension_info_t.version", "priority": 1, "content": "const  char  * version Extension version registered via GXF_EXT_FACTORY_SET_INFO .", "keywords": []}, {"id": 1702, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_flags_t", "display_name": "gxf_parameter_flags_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t", "priority": 1, "content": "type  gxf_parameter_flags_t typedef uint32_t gxf_parameter_flags_t Type used for parameter flags. See gxf_parameter_flags_t_ .", "keywords": []}, {"id": 1703, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_flags_t_", "display_name": "gxf_parameter_flags_t_", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_", "priority": 1, "content": "enum  gxf_parameter_flags_t_ Flags describing the behavior of a parameter. Parameter flags are specified when a parameter is registered as part of the component interface. Multiple flags can be OR combined.", "keywords": []}, {"id": 1704, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_DYNAMIC", "display_name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_DYNAMIC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_DYNAMIC", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_DYNAMIC The parameter is dynamic an might change after entity activation. However it is still guaranteed that parameters do not change during the initialize, deinitialize, start, tick, or stop functions.", "keywords": []}, {"id": 1705, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_NONE", "display_name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_NONE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_NONE", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_NONE No additional flags are set (the default). This means the parameter is mandatory and static. The parameter must be set before entity activation and can not be changed after entity activation.", "keywords": []}, {"id": 1706, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_OPTIONAL", "display_name": "gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_OPTIONAL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_flags_t_.GXF_PARAMETER_FLAGS_OPTIONAL", "priority": 1, "content": "enumerator  GXF_PARAMETER_FLAGS_OPTIONAL The parameter value is optional and might not be available after entity activation. This implies that it is not allowed to access the parameter with \u2018get()\u2019 in the C++ API. Instead \u2018try_get\u2019 must be used.", "keywords": []}, {"id": 1707, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t", "display_name": "gxf_parameter_info_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t", "priority": 1, "content": "type  gxf_parameter_info_t A structure holding metadata information about a parameter which was registered as part of the component interface.", "keywords": []}, {"id": 1708, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.default_value", "display_name": "gxf_parameter_info_t.default_value", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.default_value", "priority": 1, "content": "const  void  * default_value Default value of parameter, N/A for handle and custom params.", "keywords": []}, {"id": 1709, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.description", "display_name": "gxf_parameter_info_t.description", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.description", "priority": 1, "content": "const  char  * description A longer text describing the usage of the parameter.", "keywords": []}, {"id": 1710, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.flags", "display_name": "gxf_parameter_info_t.flags", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.flags", "priority": 1, "content": "gxf_parameter_flags_t  flags Parameter flags for example to make a parameter optional.", "keywords": []}, {"id": 1711, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.handle_tid", "display_name": "gxf_parameter_info_t.handle_tid", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.handle_tid", "priority": 1, "content": "gxf_tid_t  handle_tid In case the parameter is a handle the TID of the component.", "keywords": []}, {"id": 1712, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.headline", "display_name": "gxf_parameter_info_t.headline", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.headline", "priority": 1, "content": "const  char  * headline A short headline used to display the parameter to a human.", "keywords": []}, {"id": 1713, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.key", "display_name": "gxf_parameter_info_t.key", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.key", "priority": 1, "content": "const  char  * key The name of the parameter as it appears in the GXF file.", "keywords": []}, {"id": 1714, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.numeric_max", "display_name": "gxf_parameter_info_t.numeric_max", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.numeric_max", "priority": 1, "content": "const  void  * numeric_max Max value of range for numeric parameters, N/A for other types.", "keywords": []}, {"id": 1715, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.numeric_min", "display_name": "gxf_parameter_info_t.numeric_min", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.numeric_min", "priority": 1, "content": "const  void  * numeric_min Min value of range for numeric parameters, N/A for other types.", "keywords": []}, {"id": 1716, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.numeric_step", "display_name": "gxf_parameter_info_t.numeric_step", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.numeric_step", "priority": 1, "content": "const  void  * numeric_step Step value of range for numeric parameters, N/A for other types.", "keywords": []}, {"id": 1717, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.platform_information", "display_name": "gxf_parameter_info_t.platform_information", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.platform_information", "priority": 1, "content": "const  char  * platform_information Platforms separated by comma. Empty means all platforms.", "keywords": []}, {"id": 1718, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.rank", "display_name": "gxf_parameter_info_t.rank", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.rank", "priority": 1, "content": "int32_t  rank Rank of the parameter. 0-scalar, 1-list etc. Max rank is 8.", "keywords": []}, {"id": 1719, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.shape", "display_name": "gxf_parameter_info_t.shape", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.shape", "priority": 1, "content": "int32_t  shape [ 8 ] Sizes of multi dimensional parameters if it is of fixed length. Shape of a dimension is -1 for scalar and variable length arrays. Gets description of specific parameter. Fails if the component is not instantiated yet.", "keywords": []}, {"id": 1720, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_info_t.type", "display_name": "gxf_parameter_info_t.type", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_info_t.type", "priority": 1, "content": "gxf_parameter_type_t  type The type of the parameter", "keywords": []}, {"id": 1721, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t", "display_name": "gxf_parameter_type_t", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t", "priority": 1, "content": "enum  gxf_parameter_type_t An enumeration representing the type of a parameter.", "keywords": []}, {"id": 1722, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_BOOL", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_BOOL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_BOOL", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_BOOL A boolean type ( bool ).", "keywords": []}, {"id": 1723, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX128", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX128", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX128", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_COMPLEX128 A 128-bit complex floating point ( double ). Gets a string describing the parameter type", "keywords": []}, {"id": 1724, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX64", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_COMPLEX64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_COMPLEX64 A 64-bit complex floating point ( float ).", "keywords": []}, {"id": 1725, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_CUSTOM", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_CUSTOM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_CUSTOM", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_CUSTOM A custom type not natively supported by GXF.", "keywords": []}, {"id": 1726, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FILE", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FILE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FILE", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FILE A file system path (string).", "keywords": []}, {"id": 1727, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT32", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FLOAT32 A 32-bit floating point ( float ).", "keywords": []}, {"id": 1728, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT64", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_FLOAT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_FLOAT64 A 64-bit floating point ( double ).", "keywords": []}, {"id": 1729, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_HANDLE", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_HANDLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_HANDLE", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_HANDLE A GXF handle. The handle type is specified separately.", "keywords": []}, {"id": 1730, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT16", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT16", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT16", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT16 A 16-bit signed integer ( int16_t ).", "keywords": []}, {"id": 1731, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT32", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT32 A 32-bit signed integer ( int32_t ).", "keywords": []}, {"id": 1732, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT64", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT64 A 64-bit signed integer ( int64_t ).", "keywords": []}, {"id": 1733, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT8", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT8", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_INT8", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_INT8 A 8-bit signed integer ( int8_t ).", "keywords": []}, {"id": 1734, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_STRING", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_STRING", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_STRING", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_STRING A null-terminated character string ( const char* ).", "keywords": []}, {"id": 1735, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT16", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT16", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT16", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT16 A 16-bit unsigned integer ( uint16_t ).", "keywords": []}, {"id": 1736, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT32", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT32", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT32", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT32 A 32-bit unsigned integer ( uint32_t ).", "keywords": []}, {"id": 1737, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT64", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT64", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT64", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT64 A 64-bit unsigned integer ( uint64_t ).", "keywords": []}, {"id": 1738, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT8", "display_name": "gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT8", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_parameter_type_t.GXF_PARAMETER_TYPE_UINT8", "priority": 1, "content": "enumerator  GXF_PARAMETER_TYPE_UINT8 A 8-bit unsigned integer ( uint8_t ).", "keywords": []}, {"id": 1739, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t", "display_name": "gxf_result_t", "type": "enum", "display_type": "C enum", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t", "priority": 1, "content": "enum  gxf_result_t An enumeration type representing GXF error and result codes.", "keywords": []}, {"id": 1740, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ARGUMENT_INVALID", "display_name": "gxf_result_t.GXF_ARGUMENT_INVALID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_INVALID", "priority": 1, "content": "enumerator  GXF_ARGUMENT_INVALID Invalid argument.", "keywords": []}, {"id": 1741, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ARGUMENT_NULL", "display_name": "gxf_result_t.GXF_ARGUMENT_NULL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_NULL", "priority": 1, "content": "enumerator  GXF_ARGUMENT_NULL Argument is null.", "keywords": []}, {"id": 1742, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ARGUMENT_OUT_OF_RANGE", "display_name": "gxf_result_t.GXF_ARGUMENT_OUT_OF_RANGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ARGUMENT_OUT_OF_RANGE", "priority": 1, "content": "enumerator  GXF_ARGUMENT_OUT_OF_RANGE Argument is out of range.", "keywords": []}, {"id": 1743, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONNECTION_ATTEMPTS_EXCEEDED", "display_name": "gxf_result_t.GXF_CONNECTION_ATTEMPTS_EXCEEDED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONNECTION_ATTEMPTS_EXCEEDED", "priority": 1, "content": "enumerator  GXF_CONNECTION_ATTEMPTS_EXCEEDED Connection attempts exceeded.", "keywords": []}, {"id": 1744, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONNECTION_BROKEN", "display_name": "gxf_result_t.GXF_CONNECTION_BROKEN", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONNECTION_BROKEN", "priority": 1, "content": "enumerator  GXF_CONNECTION_BROKEN Connection is broken.", "keywords": []}, {"id": 1745, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONTEXT_INVALID", "display_name": "gxf_result_t.GXF_CONTEXT_INVALID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTEXT_INVALID", "priority": 1, "content": "enumerator  GXF_CONTEXT_INVALID Invalid context.", "keywords": []}, {"id": 1746, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONTRACT_INVALID_SEQUENCE", "display_name": "gxf_result_t.GXF_CONTRACT_INVALID_SEQUENCE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_INVALID_SEQUENCE", "priority": 1, "content": "enumerator  GXF_CONTRACT_INVALID_SEQUENCE Invalid contract sequence.", "keywords": []}, {"id": 1747, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "display_name": "gxf_result_t.GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_MESSAGE_NOT_AVAILABLE", "priority": 1, "content": "enumerator  GXF_CONTRACT_MESSAGE_NOT_AVAILABLE Contract message is not available.", "keywords": []}, {"id": 1748, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_CONTRACT_PARAMETER_NOT_SET", "display_name": "gxf_result_t.GXF_CONTRACT_PARAMETER_NOT_SET", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_CONTRACT_PARAMETER_NOT_SET", "priority": 1, "content": "enumerator  GXF_CONTRACT_PARAMETER_NOT_SET Contract parameter is not set.", "keywords": []}, {"id": 1749, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "display_name": "gxf_result_t.GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION", "priority": 1, "content": "enumerator  GXF_ENTITY_CAN_NOT_ADD_COMPONENT_AFTER_INITIALIZATION Cannot add component to entity after initialization.", "keywords": []}, {"id": 1750, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "display_name": "gxf_result_t.GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION", "priority": 1, "content": "enumerator  GXF_ENTITY_CAN_NOT_REMOVE_COMPONENT_AFTER_INITIALIZATION Cannot remove component from entity after initialization.", "keywords": []}, {"id": 1751, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_COMPONENT_NOT_FOUND", "display_name": "gxf_result_t.GXF_ENTITY_COMPONENT_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_COMPONENT_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_COMPONENT_NOT_FOUND Entity component was not found.", "keywords": []}, {"id": 1752, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_GROUP_NOT_FOUND", "display_name": "gxf_result_t.GXF_ENTITY_GROUP_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_GROUP_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_GROUP_NOT_FOUND Entity group was not found.", "keywords": []}, {"id": 1753, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "display_name": "gxf_result_t.GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED", "priority": 1, "content": "enumerator  GXF_ENTITY_MAX_COMPONENTS_LIMIT_EXCEEDED Maximum limit of number of components in an entity exceeded", "keywords": []}, {"id": 1754, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_NAME_EXCEEDS_LIMIT", "display_name": "gxf_result_t.GXF_ENTITY_NAME_EXCEEDS_LIMIT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_NAME_EXCEEDS_LIMIT", "priority": 1, "content": "enumerator  GXF_ENTITY_NAME_EXCEEDS_LIMIT Entity name string exceeds specified limit.", "keywords": []}, {"id": 1755, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_ENTITY_NOT_FOUND", "display_name": "gxf_result_t.GXF_ENTITY_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_ENTITY_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_ENTITY_NOT_FOUND Entity was not found.", "keywords": []}, {"id": 1756, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_EXCEEDING_PREALLOCATED_SIZE", "display_name": "gxf_result_t.GXF_EXCEEDING_PREALLOCATED_SIZE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXCEEDING_PREALLOCATED_SIZE", "priority": 1, "content": "enumerator  GXF_EXCEEDING_PREALLOCATED_SIZE Exceeding preallocated size.", "keywords": []}, {"id": 1757, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_EXTENSION_FILE_NOT_FOUND", "display_name": "gxf_result_t.GXF_EXTENSION_FILE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_FILE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_EXTENSION_FILE_NOT_FOUND Extension file was not found.", "keywords": []}, {"id": 1758, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_EXTENSION_NOT_FOUND", "display_name": "gxf_result_t.GXF_EXTENSION_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_EXTENSION_NOT_FOUND Extension was not found.", "keywords": []}, {"id": 1759, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_EXTENSION_NO_FACTORY", "display_name": "gxf_result_t.GXF_EXTENSION_NO_FACTORY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_EXTENSION_NO_FACTORY", "priority": 1, "content": "enumerator  GXF_EXTENSION_NO_FACTORY Extension has no factory.", "keywords": []}, {"id": 1760, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_ABSTRACT_CLASS", "display_name": "gxf_result_t.GXF_FACTORY_ABSTRACT_CLASS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_ABSTRACT_CLASS", "priority": 1, "content": "enumerator  GXF_FACTORY_ABSTRACT_CLASS Factory abstract class.", "keywords": []}, {"id": 1761, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_DUPLICATE_TID", "display_name": "gxf_result_t.GXF_FACTORY_DUPLICATE_TID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_DUPLICATE_TID", "priority": 1, "content": "enumerator  GXF_FACTORY_DUPLICATE_TID Duplicate type ID in a factory.", "keywords": []}, {"id": 1762, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_INCOMPATIBLE", "display_name": "gxf_result_t.GXF_FACTORY_INCOMPATIBLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_INCOMPATIBLE", "priority": 1, "content": "enumerator  GXF_FACTORY_INCOMPATIBLE Factory is incompatible.", "keywords": []}, {"id": 1763, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_INVALID_INFO", "display_name": "gxf_result_t.GXF_FACTORY_INVALID_INFO", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_INVALID_INFO", "priority": 1, "content": "enumerator  GXF_FACTORY_INVALID_INFO Invalid factory info.", "keywords": []}, {"id": 1764, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_TOO_MANY_COMPONENTS", "display_name": "gxf_result_t.GXF_FACTORY_TOO_MANY_COMPONENTS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_TOO_MANY_COMPONENTS", "priority": 1, "content": "enumerator  GXF_FACTORY_TOO_MANY_COMPONENTS Too many components in factory.", "keywords": []}, {"id": 1765, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_UNKNOWN_CLASS_NAME", "display_name": "gxf_result_t.GXF_FACTORY_UNKNOWN_CLASS_NAME", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_UNKNOWN_CLASS_NAME", "priority": 1, "content": "enumerator  GXF_FACTORY_UNKNOWN_CLASS_NAME Unknown class name in factory.", "keywords": []}, {"id": 1766, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FACTORY_UNKNOWN_TID", "display_name": "gxf_result_t.GXF_FACTORY_UNKNOWN_TID", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FACTORY_UNKNOWN_TID", "priority": 1, "content": "enumerator  GXF_FACTORY_UNKNOWN_TID Unknown type ID in a factory.", "keywords": []}, {"id": 1767, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FAILURE", "display_name": "gxf_result_t.GXF_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FAILURE", "priority": 1, "content": "enumerator  GXF_FAILURE Operation failed.", "keywords": []}, {"id": 1768, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_FILE_NOT_FOUND", "display_name": "gxf_result_t.GXF_FILE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_FILE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_FILE_NOT_FOUND File was not found.", "keywords": []}, {"id": 1769, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_HTTP_GET_FAILURE", "display_name": "gxf_result_t.GXF_HTTP_GET_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_HTTP_GET_FAILURE", "priority": 1, "content": "enumerator  GXF_HTTP_GET_FAILURE HTTP GET request failed.", "keywords": []}, {"id": 1770, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_HTTP_POST_FAILURE", "display_name": "gxf_result_t.GXF_HTTP_POST_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_HTTP_POST_FAILURE", "priority": 1, "content": "enumerator  GXF_HTTP_POST_FAILURE HTTP POST request failed.", "keywords": []}, {"id": 1771, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_INVALID_DATA_FORMAT", "display_name": "gxf_result_t.GXF_INVALID_DATA_FORMAT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_DATA_FORMAT", "priority": 1, "content": "enumerator  GXF_INVALID_DATA_FORMAT Invalid data format.", "keywords": []}, {"id": 1772, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_INVALID_ENUM", "display_name": "gxf_result_t.GXF_INVALID_ENUM", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_ENUM", "priority": 1, "content": "enumerator  GXF_INVALID_ENUM Invalid enumeration value.", "keywords": []}, {"id": 1773, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_INVALID_EXECUTION_SEQUENCE", "display_name": "gxf_result_t.GXF_INVALID_EXECUTION_SEQUENCE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_EXECUTION_SEQUENCE", "priority": 1, "content": "enumerator  GXF_INVALID_EXECUTION_SEQUENCE Invalid execution sequence.", "keywords": []}, {"id": 1774, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_INVALID_LIFECYCLE_STAGE", "display_name": "gxf_result_t.GXF_INVALID_LIFECYCLE_STAGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_INVALID_LIFECYCLE_STAGE", "priority": 1, "content": "enumerator  GXF_INVALID_LIFECYCLE_STAGE Invalid lifecycle stage.", "keywords": []}, {"id": 1775, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_IPC_CALL_FAILURE", "display_name": "gxf_result_t.GXF_IPC_CALL_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_CALL_FAILURE", "priority": 1, "content": "enumerator  GXF_IPC_CALL_FAILURE IPC call failure.", "keywords": []}, {"id": 1776, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_IPC_CONNECTION_FAILURE", "display_name": "gxf_result_t.GXF_IPC_CONNECTION_FAILURE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_CONNECTION_FAILURE", "priority": 1, "content": "enumerator  GXF_IPC_CONNECTION_FAILURE IPC connection failure.", "keywords": []}, {"id": 1777, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_IPC_SERVICE_NOT_FOUND", "display_name": "gxf_result_t.GXF_IPC_SERVICE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_IPC_SERVICE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_IPC_SERVICE_NOT_FOUND IPC service was not found.", "keywords": []}, {"id": 1778, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_MEMORY_INVALID_STORAGE_MODE", "display_name": "gxf_result_t.GXF_MEMORY_INVALID_STORAGE_MODE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_MEMORY_INVALID_STORAGE_MODE", "priority": 1, "content": "enumerator  GXF_MEMORY_INVALID_STORAGE_MODE Invalid memory storage mode.", "keywords": []}, {"id": 1779, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_NOT_FINISHED", "display_name": "gxf_result_t.GXF_NOT_FINISHED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NOT_FINISHED", "priority": 1, "content": "enumerator  GXF_NOT_FINISHED Operation is not finished.", "keywords": []}, {"id": 1780, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_NOT_IMPLEMENTED", "display_name": "gxf_result_t.GXF_NOT_IMPLEMENTED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NOT_IMPLEMENTED", "priority": 1, "content": "enumerator  GXF_NOT_IMPLEMENTED Feature is not implemented.", "keywords": []}, {"id": 1781, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_NULL_POINTER", "display_name": "gxf_result_t.GXF_NULL_POINTER", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_NULL_POINTER", "priority": 1, "content": "enumerator  GXF_NULL_POINTER Null pointer was passed.", "keywords": []}, {"id": 1782, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_OUT_OF_MEMORY", "display_name": "gxf_result_t.GXF_OUT_OF_MEMORY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_OUT_OF_MEMORY", "priority": 1, "content": "enumerator  GXF_OUT_OF_MEMORY Out of memory.", "keywords": []}, {"id": 1783, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_ALREADY_REGISTERED", "display_name": "gxf_result_t.GXF_PARAMETER_ALREADY_REGISTERED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_ALREADY_REGISTERED", "priority": 1, "content": "enumerator  GXF_PARAMETER_ALREADY_REGISTERED Parameter is already registered.", "keywords": []}, {"id": 1784, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "display_name": "gxf_result_t.GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT", "priority": 1, "content": "enumerator  GXF_PARAMETER_CAN_NOT_MODIFY_CONSTANT Cannot modify constant parameter.", "keywords": []}, {"id": 1785, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_INVALID_TYPE", "display_name": "gxf_result_t.GXF_PARAMETER_INVALID_TYPE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_INVALID_TYPE", "priority": 1, "content": "enumerator  GXF_PARAMETER_INVALID_TYPE Invalid parameter type.", "keywords": []}, {"id": 1786, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_MANDATORY_NOT_SET", "display_name": "gxf_result_t.GXF_PARAMETER_MANDATORY_NOT_SET", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_MANDATORY_NOT_SET", "priority": 1, "content": "enumerator  GXF_PARAMETER_MANDATORY_NOT_SET Mandatory parameter is not set.", "keywords": []}, {"id": 1787, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_NOT_FOUND", "display_name": "gxf_result_t.GXF_PARAMETER_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_FOUND Parameter was not found.", "keywords": []}, {"id": 1788, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_NOT_INITIALIZED", "display_name": "gxf_result_t.GXF_PARAMETER_NOT_INITIALIZED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_INITIALIZED", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_INITIALIZED Parameter is not initialized.", "keywords": []}, {"id": 1789, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_NOT_NUMERIC", "display_name": "gxf_result_t.GXF_PARAMETER_NOT_NUMERIC", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_NOT_NUMERIC", "priority": 1, "content": "enumerator  GXF_PARAMETER_NOT_NUMERIC Parameter is not numeric.", "keywords": []}, {"id": 1790, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_OUT_OF_RANGE", "display_name": "gxf_result_t.GXF_PARAMETER_OUT_OF_RANGE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_OUT_OF_RANGE", "priority": 1, "content": "enumerator  GXF_PARAMETER_OUT_OF_RANGE Parameter is out of range.", "keywords": []}, {"id": 1791, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_PARAMETER_PARSER_ERROR", "display_name": "gxf_result_t.GXF_PARAMETER_PARSER_ERROR", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_PARAMETER_PARSER_ERROR", "priority": 1, "content": "enumerator  GXF_PARAMETER_PARSER_ERROR Parameter parser error.", "keywords": []}, {"id": 1792, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_QUERY_NOT_APPLICABLE", "display_name": "gxf_result_t.GXF_QUERY_NOT_APPLICABLE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_APPLICABLE", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_APPLICABLE Query is not applicable.", "keywords": []}, {"id": 1793, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_QUERY_NOT_ENOUGH_CAPACITY", "display_name": "gxf_result_t.GXF_QUERY_NOT_ENOUGH_CAPACITY", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_ENOUGH_CAPACITY", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_ENOUGH_CAPACITY Query does not have enough capacity.", "keywords": []}, {"id": 1794, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_QUERY_NOT_FOUND", "display_name": "gxf_result_t.GXF_QUERY_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_QUERY_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_QUERY_NOT_FOUND Query was not found.", "keywords": []}, {"id": 1795, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_REF_COUNT_NEGATIVE", "display_name": "gxf_result_t.GXF_REF_COUNT_NEGATIVE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_REF_COUNT_NEGATIVE", "priority": 1, "content": "enumerator  GXF_REF_COUNT_NEGATIVE Reference count is negative.", "keywords": []}, {"id": 1796, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_RESOURCE_NOT_FOUND", "display_name": "gxf_result_t.GXF_RESOURCE_NOT_FOUND", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESOURCE_NOT_FOUND", "priority": 1, "content": "enumerator  GXF_RESOURCE_NOT_FOUND Resource was not found.", "keywords": []}, {"id": 1797, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_RESOURCE_NOT_INITIALIZED", "display_name": "gxf_result_t.GXF_RESOURCE_NOT_INITIALIZED", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESOURCE_NOT_INITIALIZED", "priority": 1, "content": "enumerator  GXF_RESOURCE_NOT_INITIALIZED Resource is not initialized.", "keywords": []}, {"id": 1798, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_RESULT_ARRAY_TOO_SMALL", "display_name": "gxf_result_t.GXF_RESULT_ARRAY_TOO_SMALL", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_RESULT_ARRAY_TOO_SMALL", "priority": 1, "content": "enumerator  GXF_RESULT_ARRAY_TOO_SMALL Result array is too small.", "keywords": []}, {"id": 1799, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_SUCCESS", "display_name": "gxf_result_t.GXF_SUCCESS", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_SUCCESS", "priority": 1, "content": "enumerator  GXF_SUCCESS Operation was successful.", "keywords": []}, {"id": 1800, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_result_t.GXF_UNINITIALIZED_VALUE", "display_name": "gxf_result_t.GXF_UNINITIALIZED_VALUE", "type": "enumerator", "display_type": "C enumerator", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_result_t.GXF_UNINITIALIZED_VALUE", "priority": 1, "content": "enumerator  GXF_UNINITIALIZED_VALUE Value was not initialized.", "keywords": []}, {"id": 1801, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_runtime_info", "display_name": "gxf_runtime_info", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_runtime_info", "priority": 1, "content": "type  gxf_runtime_info A structure representing version of GXF Runtime and list of loaded extensions.", "keywords": []}, {"id": 1802, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_runtime_info.extensions", "display_name": "gxf_runtime_info.extensions", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_runtime_info.extensions", "priority": 1, "content": "gxf_tid_t  * extensions List of extension IDs.", "keywords": []}, {"id": 1803, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_runtime_info.num_extensions", "display_name": "gxf_runtime_info.num_extensions", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_runtime_info.num_extensions", "priority": 1, "content": "uint64_t  num_extensions In-out capacity of extensions/Number of extension types.", "keywords": []}, {"id": 1804, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_runtime_info.version", "display_name": "gxf_runtime_info.version", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_runtime_info.version", "priority": 1, "content": "const  char  * version GXF Runtime version.", "keywords": []}, {"id": 1805, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t", "display_name": "gxf_severity_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t", "priority": 1, "content": "type  gxf_severity_t An enumeration of severity levels for GXF_LOG_* logging macros.", "keywords": []}, {"id": 1806, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_DEBUG", "display_name": "gxf_severity_t.GXF_SEVERITY_DEBUG", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_DEBUG", "priority": 1, "content": "type  GXF_SEVERITY_DEBUG", "keywords": []}, {"id": 1807, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_ERROR", "display_name": "gxf_severity_t.GXF_SEVERITY_ERROR", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_ERROR", "priority": 1, "content": "type  GXF_SEVERITY_ERROR", "keywords": []}, {"id": 1808, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_INFO", "display_name": "gxf_severity_t.GXF_SEVERITY_INFO", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_INFO", "priority": 1, "content": "type  GXF_SEVERITY_INFO", "keywords": []}, {"id": 1809, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_NONE", "display_name": "gxf_severity_t.GXF_SEVERITY_NONE", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_NONE", "priority": 1, "content": "type  GXF_SEVERITY_NONE", "keywords": []}, {"id": 1810, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_VERBOSE", "display_name": "gxf_severity_t.GXF_SEVERITY_VERBOSE", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_VERBOSE", "priority": 1, "content": "type  GXF_SEVERITY_VERBOSE", "keywords": []}, {"id": 1811, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_severity_t.GXF_SEVERITY_WARNING", "display_name": "gxf_severity_t.GXF_SEVERITY_WARNING", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_severity_t.GXF_SEVERITY_WARNING", "priority": 1, "content": "type  GXF_SEVERITY_WARNING", "keywords": []}, {"id": 1812, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_tid_t", "display_name": "gxf_tid_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_tid_t", "priority": 1, "content": "type  gxf_tid_t Type of unique GXF type identifier (TID/tid) Tids are used to uniquely identify the type of a component, instead of for example using a string with the type name.", "keywords": []}, {"id": 1813, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_tid_t.hash1", "display_name": "gxf_tid_t.hash1", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_tid_t.hash1", "priority": 1, "content": "uint64_t  hash1 The first part of the hash.", "keywords": []}, {"id": 1814, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_tid_t.hash2", "display_name": "gxf_tid_t.hash2", "type": "member", "display_type": "C member", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_tid_t.hash2", "priority": 1, "content": "uint64_t  hash2 The second part of the hash.", "keywords": []}, {"id": 1815, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "gxf_uid_t", "display_name": "gxf_uid_t", "type": "type", "display_type": "C type", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.gxf_uid_t", "priority": 1, "content": "type  gxf_uid_t Type of unique GXF object identifiers (UID/uid). Uids are used to reference entities and components throughout the GXF API. Defined as int64_t .", "keywords": []}, {"id": 1816, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "isSuccessful", "display_name": "isSuccessful", "type": "function", "display_type": "C function", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.isSuccessful", "priority": 1, "content": "bool  isSuccessful gxf_result_t  result ; Checks if a result code is GXF_SUCCESS or not. Parameters result \u2013 A GXF result code Returns A boolean value indicating if the result code is GXF_SUCCESS.", "keywords": []}, {"id": 1817, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "isSuccessful.result", "display_name": "isSuccessful.result", "type": "functionParam", "display_type": "C function parameter", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.isSuccessful", "priority": 1, "content": "bool  isSuccessful gxf_result_t  result ; Checks if a result code is GXF_SUCCESS or not. Parameters result \u2013 A GXF result code Returns A boolean value indicating if the result code is GXF_SUCCESS.", "keywords": []}, {"id": 1818, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kDefaultEntityGroupName", "display_name": "kDefaultEntityGroupName", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kDefaultEntityGroupName", "priority": 1, "content": "kDefaultEntityGroupName Name of default entity group. Defined as \u201cdefault_entity_group\u201d .", "keywords": []}, {"id": 1819, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kGxfCoreVersion", "display_name": "kGxfCoreVersion", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kGxfCoreVersion", "priority": 1, "content": "kGxfCoreVersion GXF Core Version Defined as 4.1.0 .", "keywords": []}, {"id": 1820, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxComponentNameSize", "display_name": "kMaxComponentNameSize", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxComponentNameSize", "priority": 1, "content": "kMaxComponentNameSize Maximum number of characters in the name of a component. Defined as 256.", "keywords": []}, {"id": 1821, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxComponents", "display_name": "kMaxComponents", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxComponents", "priority": 1, "content": "kMaxComponents Maximum number of components in an entity or extension. Defined as 1024.", "keywords": []}, {"id": 1822, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxEntities", "display_name": "kMaxEntities", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxEntities", "priority": 1, "content": "kMaxEntities Maximum number of entities in a context. Defined as 1024.", "keywords": []}, {"id": 1823, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxEntityNameSize", "display_name": "kMaxEntityNameSize", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxEntityNameSize", "priority": 1, "content": "kMaxEntityNameSize Maximum number of characters in the name of an entity. Defined as 2048.", "keywords": []}, {"id": 1824, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxExtensions", "display_name": "kMaxExtensions", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxExtensions", "priority": 1, "content": "kMaxExtensions Maximum number of extensions in a context. Defined as 1024.", "keywords": []}, {"id": 1825, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kMaxParameters", "display_name": "kMaxParameters", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kMaxParameters", "priority": 1, "content": "kMaxParameters Maximum number of parameters in a component. Defined as 1024.", "keywords": []}, {"id": 1826, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kNullContext", "display_name": "kNullContext", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kNullContext", "priority": 1, "content": "kNullContext An invalid context. Defined as nullptr .", "keywords": []}, {"id": 1827, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kNullUid", "display_name": "kNullUid", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kNullUid", "priority": 1, "content": "kNullUid A GXF UID which can be used to indicate an invalid or unused GXF UID. Defined as 0L.", "keywords": []}, {"id": 1828, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "c", "name": "kUnspecifiedUid", "display_name": "kUnspecifiedUid", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "c.kUnspecifiedUid", "priority": 1, "content": "kUnspecifiedUid A GXF UID which can be used to indicate an unspecified component during graph load operation. This component should be updated in a subsequent graph/parameters file. Failing to do so will result in an error during graph activation. Defined as -1L.", "keywords": []}, {"id": 1829, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs#get-1-d-vetor-parameters", "display_name": "Get 1-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "get-1-d-vetor-parameters", "priority": -1, "content": "Use gxf_result_t GxfParameterGet1D&quot;DataType&quot;Vector(gxf_context_t context,  gxf_uid_t uid, const char* key, data_type** value, uint64_t* length) to get the value of a 1-D vector. Before calling this method, use GxfParameterGet1D&quot;DataType&quot;VectorInfo(gxf_context_t context, gxf_uid_t uid, const char* key, uint64_t* length) to obtain the length of the vector param and then allocate at least that much memory to retrieve the value . value should point to an array of size greater than or equal to length allocated by user of the corresponding type to retrieve the data. If the length doesn\u2019t match the size of stored vector then it will be updated with the expected size. See the table below for all the supported data types and their corresponding function signatures. param key The name of the parameter param value The value to set of the parameter param length The length of the 1-D vector parameter obtained by calling GxfParameterGet1D&quot;DataType&quot;VectorInfo(...) Function Name data_type GxfParameterGet1DFloat64Vector(...) double GxfParameterGet1DInt64Vector(...) int64_t GxfParameterGet1DUInt64Vector(...) uint64_t GxfParameterGet1DInt32Vector(...) int32_t", "keywords": []}, {"id": 1830, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs#get-2-d-vetor-parameters", "display_name": "Get 2-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "get-2-d-vetor-parameters", "priority": -1, "content": "Use gxf_result_t GxfParameterGet2D&quot;DataType&quot;Vector(gxf_context_t context,  gxf_uid_t uid, const char* key, data_type** value, uint64_t* height, uint64_t* width) to get the value of a -2D vector. Before calling this method, users should call GxfParameterGet1D&quot;DataType&quot;VectorInfo(gxf_context_t context, gxf_uid_t uid, const char* key, uint64_t* height, uint64_t* width) to obtain the height and width of the 2D-vector param and then allocate at least that much memory to retrieve the value . value should point to an array of array of height (size of first dimension) greater than or equal to height and width (size of the second dimension) greater than or equal to width allocated by user of the corresponding type to get the data. If the height or width don\u2019t match the height and width of the stored vector then they will be updated with the expected values. See the table below for all the supported data types and their corresponding function signatures. parameter\u201d: key The name of the parameter parameter\u201d: value Allocated array to get the value of the parameter parameter\u201d: height The height of the 2-D vector parameter obtained by calling GxfParameterGet2D&quot;DataType&quot;VectorInfo(...) parameter\u201d: width The width of the 2-D vector parameter obtained by calling GxfParameterGet2D&quot;DataType&quot;VectorInfo(...) Function Name data_type GxfParameterGet2DFloat64Vector(...) double GxfParameterGet2DInt64Vector(...) int64_t GxfParameterGet2DUInt64Vector(...) uint64_t GxfParameterGet2DInt32Vector(...) int32_t", "keywords": []}, {"id": 1831, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs#get-flag-type-description", "display_name": "Get flag type description", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "get-flag-type-description", "priority": -1, "content": "Gets a string describing the flag type", "keywords": []}, {"id": 1832, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs#redirect-logs-to-a-file", "display_name": "Redirect logs to a file", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "redirect-logs-to-a-file", "priority": -1, "content": "Redirect console logs to the provided file.", "keywords": []}, {"id": 1833, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs#vector-parameters", "display_name": "Vector Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "vector-parameters", "priority": -1, "content": "To set/get the vector parameters of a component, users can use the following C-APIs for various data types:", "keywords": []}, {"id": 1834, "doc_id": 1834, "filename": "graphtools-docs/docs/text/GXF_Core_C_APIs.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_Core_C_APIs", "display_name": "GXF Core C APIs", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_Core_C_APIs", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 1835, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#components", "display_name": "Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "components", "priority": -1, "content": "Maximum number of components in an entity or an extension can be upto 1024 .", "keywords": []}, {"id": 1836, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#extensions", "display_name": "Extensions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "extensions", "priority": -1, "content": "Maximum number of extensions in a context can be 1024 .", "keywords": []}, {"id": 1837, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#get-1-d-vetor-parameters", "display_name": "Get 1-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get-1-d-vetor-parameters", "priority": -1, "content": "parameter_get_1d_&lt;data_type&gt;_vector(context, eid, key, length) Parameters context \u2013 A valid GXF context. eid \u2013 A valid component identifier. key \u2013 The name of the parameter length \u2013 The length of the stored 1-D vector parameter. Should match the length of the parameter. If it is less than the parameter length then error is thrown. If it is greater than the length a larger list with the values set is retured. Returns A list containing the values. See the table below for all the supported data types and their corresponding function signatures. Function Name data_type parameter_get_1d_float64_vector(...) double parameter_get_1d_int64_vector(...) int64_t parameter_get_1d_uint64_vector(...) uint64_t parameter_get_1d_int32_vector(...) int32_t", "keywords": []}, {"id": 1838, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#get-2-d-vetor-parameters", "display_name": "Get 2-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get-2-d-vetor-parameters", "priority": -1, "content": "parameter_get_2d_&#x27;data_type&#x27;_vector(context, eid, key, height, width) Parameters context \u2013 A valid GXF context. eid \u2013 A valid component identifier. key \u2013 The name of the parameter height \u2013 The height of the stored 2-D vector parameter. width \u2013 The width of the stored 2-D vector parameter. The height or width should match the height and width of the stored vector. If they are smaller than the stored values then error is thrown. If greater than the stored values then larger lists will be returned with values set. Returns A list of list containing the values. See the table below for all the supported data types and their corresponding function signatures. Function Name data_type parameter_get_2d_float64_vector(...) double parameter_get_2d_int64_vector(...) int64_t parameter_get_2d_uint64_vector(...) uint64_t parameter_get_2d_int32_vector(...) int32_t", "keywords": []}, {"id": 1839, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#set-1-d-vetor-parameters", "display_name": "Set 1-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "set-1-d-vetor-parameters", "priority": -1, "content": "parameter_set_1d_&lt;data_type&gt;_vector(context, eid, key, value, length) Parameters context \u2013 A valid GXF context. eid \u2013 A valid component identifier. key \u2013 The name of the parameter value \u2013 The value to set of the parameter. should be a list of the data to be set. The size of the stored array should match the length argument passed length \u2013 The length of the vector parameter Raises ValueError \u2013 If setting the parameter fails. See the table below for all the supported data types and their corresponding function signatures. Function Name data_type parameter_set_1d_float64_vector(...) double parameter_set_1d_int64_vector(...) int64_t parameter_set_1d_uint64_vector(...) uint64_t parameter_set_1d_int32_vector(...) int32_t", "keywords": []}, {"id": 1840, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#set-2-d-vetor-parameters", "display_name": "Set 2-D Vetor Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "set-2-d-vetor-parameters", "priority": -1, "content": "parameter_set_2d_&lt;data_type&gt;_vector(context, eid, key, value, height, width) Parameters context \u2013 A valid GXF context. eid \u2013 A valid component identifier. key \u2013 The name of the parameter value \u2013 The value to set of the parameter. Should point to a list of list of the data to be set. The length of the first dimension of the list should match the height argument passed and similarly the length of the second dimension of the list should match the width passed. height \u2013 The height of the 2-D vector parameter width \u2013 The width of the 2-D vector parameter Raises ValueError \u2013 If setting the parameter fails. See the table below for all the supported data types and their corresponding function signatures. Function Name data_type parameter_set_2d_float64_vector(...) double parameter_set_2d_int64_vector(...) int64_t parameter_set_2d_uint64_vector(...) uint64_t parameter_set_2d_int32_vector(...) int32_t", "keywords": []}, {"id": 1841, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs#vector-parameters", "display_name": "Vector Parameters", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "vector-parameters", "priority": -1, "content": "To set/get the vector parameters of a component, users can use the following python-APIs for various data types:", "keywords": []}, {"id": 1842, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "_subgraph_load_file", "display_name": "_subgraph_load_file", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "subgraph_load_file", "priority": 1, "content": "_subgraph_load_file context filename entity_prefix parent_eid prerequisites Loads a list of entities from a YAML file. This API is used when shared context is created using Parameters context ( int ) \u2013 A valid GXF context. filename ( str ) \u2013 The path to the file containing the subgraph. entity_prefix ( str ) \u2013 The prefix for entities in the subgraph. parent_eid ( int ) \u2013 The unique identifier of the parent entity. prerequisites ( str ) \u2013 GXF subgraph prerequisites YAML node in str. Raises ValueError \u2013 If loading the subgraph file fails.", "keywords": []}, {"id": 1843, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "component_add", "display_name": "component_add", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "component_add", "priority": 1, "content": "component_add context eid tid name Add a component of the specified type to an entity. Parameters context ( int ) \u2013 The context in which to create the component. eid ( int ) \u2013 The unique identifier of the entity to contain the component. tid ( gxf_tid_t ) \u2013 The type identifier of the component type to create. name ( str ) \u2013 The name of the component. Returns The unique identifier of the added component. Return type int Raises ValueError \u2013 If adding the component fails.", "keywords": []}, {"id": 1844, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "component_add_to_interface", "display_name": "component_add_to_interface", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "component_add_to_interface", "priority": 1, "content": "component_add_to_interface context eid cid name Adds the component to the alias map Parameters context ( int ) \u2013 The context in which the entity and component exist. eid ( int ) \u2013 The unique identifier of the entity. cid ( int ) \u2013 The unique identifier of the component to add to the interface. name ( str ) \u2013 The name of the component in the interface. Raises ValueError \u2013 If adding the component to the interface fails.", "keywords": []}, {"id": 1845, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "component_find", "display_name": "component_find", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "component_find", "priority": 1, "content": "component_find context eid tid component_name Find components of a specific type in an entity. Searches components in an entity which satisfy certain criteria: component type, component name, and component min index. All three criteria are optional; in case no criteria is given the first component is returned. The main use case for \u201ccomponent min index\u201d is a repeated search which continues at the index which was returned by a previous search. In case no entity with the given criteria was found GXF_ENTITY_NOT_FOUND is thrown. Parameters context ( int ) \u2013 The context in which the entity and components exist. eid ( int ) \u2013 The unique identifier of the entity. tid ( gxf_tid_t ) \u2013 The type identifier of the components to find. If not provided, all components will be searched. component_name ( str ) \u2013 The name of the component to find. If not provided, all components of the specified type will be returned. Returns A list of unique identifiers for the found components. Return type list Raises ValueError \u2013 If finding the components fails.", "keywords": []}, {"id": 1846, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "component_type_id", "display_name": "component_type_id", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "component_type_id", "priority": 1, "content": "component_type_id context component_name Get the type identifier for a component type. Parameters context ( int ) \u2013 The context in which the component type exists. component_name ( str ) \u2013 The fully qualified C++ type name of the component. Returns The type identifier for the specified component type. Return type gxf_tid_t Raises ValueError \u2013 If getting the type identifier fails.", "keywords": []}, {"id": 1847, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "component_type_name", "display_name": "component_type_name", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "component_type_name", "priority": 1, "content": "component_type_name context tid Get the fully qualified C++ type name from its type identifier. Parameters context ( int ) \u2013 The context in which the component type exists. tid ( gxf_tid_t ) \u2013 The type identifier of the component type. Returns The fully qualified C++ type name. Return type str Raises ValueError \u2013 If getting the type name fails.", "keywords": []}, {"id": 1848, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "context_create", "display_name": "context_create", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "context_create", "priority": 1, "content": "context_create Create a GXF context. Returns The unique identifier of the created context. Return type int Raises ValueError \u2013 If creating the context fails.", "keywords": []}, {"id": 1849, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "context_destroy", "display_name": "context_destroy", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "context_destroy", "priority": 1, "content": "context_destroy context Destroy a GXF context. Parameters context ( int ) \u2013 The unique identifier of the context to destroy. Raises ValueError \u2013 If destroying the context fails.", "keywords": []}, {"id": 1850, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_activate", "display_name": "entity_activate", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_activate", "priority": 1, "content": "entity_activate context eid Activate an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1851, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_create", "display_name": "entity_create", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_create", "priority": 1, "content": "entity_create context info Create an entity with info Parameters context ( int ) \u2013 A unique interger representing GXF context. info ( gxf_entity_create_info ) \u2013 The entity creation information. Returns A unique entity identifier. Return type int Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1852, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_deactivate", "display_name": "entity_deactivate", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_deactivate", "priority": 1, "content": "entity_deactivate context eid Deactivate an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1853, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_destroy", "display_name": "entity_destroy", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_destroy", "priority": 1, "content": "entity_destroy context eid Destroy an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1854, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_event_notify", "display_name": "entity_event_notify", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_event_notify", "priority": 1, "content": "entity_event_notify context eid Notify entity on an event Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1855, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_find", "display_name": "entity_find", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_find", "priority": 1, "content": "entity_find context entity_name Finds an entity by its name Parameters context ( int ) \u2013 A unique interger representing GXF context. entity_name ( str ) \u2013 A C string with the name of the entity. Ownership is not transferred. Returns A unique entity identifier. Return type int Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1856, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_find_all", "display_name": "entity_find_all", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_find_all", "priority": 1, "content": "entity_find_all context Get all the entities of the given context Parameters context ( int ) \u2013 A unique interger representing GXF context. Returns A list of unique identifiers for the entities in the context. Return type list Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1857, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_get_state", "display_name": "entity_get_state", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_get_state", "priority": 1, "content": "entity_get_state context eid Get state of an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Returns The state of the entity. Return type int Raises ValueError \u2013 If not successful. The returned state has following values: 0: GXF_BEHAVIOR_INIT, 1: GXF_BEHAVIOR_SUCCESS, 2: GXF_BEHAVIOR_RUNNING, 3: GXF_BEHAVIOR_FAILURE, 4: GXF_BEHAVIOR_UNKNOWN", "keywords": []}, {"id": 1858, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_get_status", "display_name": "entity_get_status", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_get_status", "priority": 1, "content": "entity_get_status context eid Gets the status of the entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Returns The status of the entity. Return type int Raises ValueError \u2013 If not successful. The returned status has following values: 0: GXF_ENTITY_STATUS_NOT_STARTED, 1: GXF_ENTITY_STATUS_START_PENDING, 2: GXF_ENTITY_STATUS_STARTED, 3: GXF_ENTITY_STATUS_TICK_PENDING, 4: GXF_ENTITY_STATUS_TICKING, 5: GXF_ENTITY_STATUS_IDLE, 6: GXF_ENTITY_STATUS_STOP_PENDING, 7: GXF_ENTITY_MAX", "keywords": []}, {"id": 1859, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_group_add", "display_name": "entity_group_add", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_group_add", "priority": 1, "content": "entity_group_add context gid eid Add an entity to an entity group Parameters context ( int ) \u2013 A unique interger representing GXF context. gid ( int ) \u2013 The UID of a valid entity group. eid ( int ) \u2013 The UID of a valid entity. Returns The entity group ID used to add this entity. Return type int Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1860, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_group_create", "display_name": "entity_group_create", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_group_create", "priority": 1, "content": "entity_group_create context name Create an entity group with name Parameters context ( int ) \u2013 A unique interger representing GXF context. name ( str ) \u2013 entity group name. Returns A unique entity group identifier. Return type int Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1861, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_notify_event_type", "display_name": "entity_notify_event_type", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_notify_event_type", "priority": 1, "content": "entity_notify_event_type context eid Notify entity on an event Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1862, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_ref_count_dec", "display_name": "entity_ref_count_dec", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_ref_count_dec", "priority": 1, "content": "entity_ref_count_dec context eid Decrease reference count of an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1863, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "entity_ref_count_inc", "display_name": "entity_ref_count_inc", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "entity_ref_count_inc", "priority": 1, "content": "entity_ref_count_inc context eid Increase reference count of an entity Parameters context ( int ) \u2013 A unique interger representing GXF context. eid ( int ) \u2013 The UID of a valid entity. Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1864, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_component_info", "display_name": "get_component_info", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_component_info", "priority": 1, "content": "get_component_info context uuid intro Parameters context ( int ) \u2013 A unique interger representing GXF context. uuid ( str ) \u2013 GXF component type UUID. The length has to be 36, in format 8-4-4-4-12. Eg, 85f64c84-8236-4035-9b9a-3843a6a2026f Returns A dictionary containing information about the component. Return type dict Raises ValueError \u2013 If not successful. The returned dictionary has the following keys: typename (str): The fully qualified C++ type name of the component name. display_name (str): The display name of the component. brief (str): A brief description of the component. description (str): A detailed description of the component. base_typename (str): The fully qualified C++ type name of the base class, or an empty string if it is not inherited. is_abstract (bool): Whether the component is abstract or not.", "keywords": []}, {"id": 1865, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_component_list", "display_name": "get_component_list", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_component_list", "priority": 1, "content": "get_component_list context uuid Get list of components of an extension Parameters context ( int ) \u2013 A unique interger representing GXF context. uuid ( str ) \u2013 GXF extension UUID. The length has to be 36, in format 8-4-4-4-12. Eg, 85f64c84-8236-4035-9b9a-3843a6a2026f Returns A list of comonent type UUID. Return type list Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1866, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_extension_info", "display_name": "get_extension_info", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_extension_info", "priority": 1, "content": "get_extension_info context uuid Get information about a loaded extension. Parameters context ( int ) \u2013 The context in which the extension is loaded. uuid ( str ) \u2013 The UUID of the extension. Returns A dictionary containing information about the extension. Return type dict Raises ValueError \u2013 If getting the extension information fails. The returned dictionary has the following keys: name (str): The name of the extension. display_name (str): The display name of the extension. category (str): The category of the extension. brief (str): A brief description of the extension. description (str): A detailed description of the extension. version (str): The version of the extension. author (str): The author of the extension. license (str): The license of the extension.", "keywords": []}, {"id": 1867, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_extension_list", "display_name": "get_extension_list", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_extension_list", "priority": 1, "content": "get_extension_list context Get a list of loaded extensions. Parameters context ( int ) \u2013 The context from which to retrieve the extension list. Returns A list of UUIDs representing the loaded extensions. Return type list Raises ValueError \u2013 If getting the extension list fails.", "keywords": []}, {"id": 1868, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_param_info", "display_name": "get_param_info", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_param_info", "priority": 1, "content": "get_param_info context uuid key Get information about a parameter of a component. Parameters context ( int ) \u2013 The context in which the component exists. uuid ( str ) \u2013 GXF component type UUID. The length has to be 36, in format 8-4-4-4-12. Eg, 85f64c84-8236-4035-9b9a-3843a6a2026f. key ( str ) \u2013 The key of the parameter. Returns A dictionary containing information about the parameter. Return type dict Raises ValueError \u2013 If not successful. The returned dictionary has the following keys: key (str): The key of the parameter. headline (str): The headline or short description of the parameter. description (str): A detailed description of the parameter. gxf_parameter_type (str): The type of the parameter, as a string representation. rank (int): The rank or number of dimensions of the parameter. shape (list): A list representing the shape of the parameter. flags (str): The flags associated with the parameter, as a string representation. handle_type (str): The fully qualified C++ type name of the handle component, or \u201cN/A\u201d if not applicable. default (varies): The default value of the parameter, or \u201cN/A\u201d if not applicable. max_value (varies): The maximum value of the parameter, if applicable. min_value (varies): The minimum value of the parameter, if applicable. step_value (varies): The step value of the parameter, if applicable.", "keywords": []}, {"id": 1869, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "get_param_list", "display_name": "get_param_list", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "get_param_list", "priority": 1, "content": "get_param_list context uuid Get parameter list of a component Parameters context ( int ) \u2013 A unique interger representing GXF context. uuid ( str ) \u2013 GXF component type UUID. The length has to be 36, in format 8-4-4-4-12. Eg, 85f64c84-8236-4035-9b9a-3843a6a2026f. Returns A list of parameter key of this component. Return type list Raises ValueError \u2013 If not successful.", "keywords": []}, {"id": 1870, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_activate", "display_name": "graph_activate", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_activate", "priority": 1, "content": "graph_activate context Activate the graph. Parameters context ( int ) \u2013 The context containing the graph to activate. Raises ValueError \u2013 If activating the graph fails.", "keywords": []}, {"id": 1871, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_deactivate", "display_name": "graph_deactivate", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_deactivate", "priority": 1, "content": "graph_deactivate context Deactivate the graph. Parameters context ( int ) \u2013 The context containing the graph to deactivate. Raises ValueError \u2013 If deactivating the graph fails.", "keywords": []}, {"id": 1872, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_interrupt", "display_name": "graph_interrupt", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_interrupt", "priority": 1, "content": "graph_interrupt context Interrupt the graph. Parameters context ( int ) \u2013 The context containing the graph to interrupt. Raises ValueError \u2013 If interrupting the graph fails.", "keywords": []}, {"id": 1873, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_load_file", "display_name": "graph_load_file", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_load_file", "priority": 1, "content": "graph_load_file context filename Load a graph from a file. Parameters context ( int ) \u2013 A valid GXF context. filename ( str ) \u2013 A valid YAML filename. Raises ValueError \u2013 If loading the graph file fails.", "keywords": []}, {"id": 1874, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_run", "display_name": "graph_run", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_run", "priority": 1, "content": "graph_run context Run the graph. It blocks the caller thread until graph completes. Parameters context ( int ) \u2013 The context containing the graph to run. Raises ValueError \u2013 If running the graph fails.", "keywords": []}, {"id": 1875, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_run_async", "display_name": "graph_run_async", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_run_async", "priority": 1, "content": "graph_run_async context Run the graph asynchronously, i.e. without blocking the caller thread. Parameters context ( int ) \u2013 The context containing the graph to run asynchronously. Raises ValueError \u2013 If running the graph asynchronously fails.", "keywords": []}, {"id": 1876, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_save", "display_name": "graph_save", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_save", "priority": 1, "content": "graph_save context filename Save the graph to a file. Parameters context ( int ) \u2013 The context containing the graph to save. filename ( str ) \u2013 The path to the file where the graph will be saved. Raises ValueError \u2013 If saving the graph fails.", "keywords": []}, {"id": 1877, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "graph_wait", "display_name": "graph_wait", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "graph_wait", "priority": 1, "content": "graph_wait context Wait for the graph to complete, i.e. blocks caller thread until graph completes. Parameters context ( int ) \u2013 The context containing the graph to wait for. Raises ValueError \u2013 If waiting for the graph fails.", "keywords": []}, {"id": 1878, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_entity_create_info", "display_name": "gxf_entity_create_info", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_entity_create_info", "priority": 1, "content": "class  gxf_entity_create_info", "keywords": []}, {"id": 1879, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_entity_create_info.entity_name", "display_name": "gxf_entity_create_info.entity_name", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_entity_create_info.entity_name", "priority": 1, "content": "entity_name :  str The name of the entity.", "keywords": []}, {"id": 1880, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_entity_create_info.flags", "display_name": "gxf_entity_create_info.flags", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_entity_create_info.flags", "priority": 1, "content": "flags :  int 1 for system entity, 0 for non system entity", "keywords": []}, {"id": 1881, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_set_severity", "display_name": "gxf_set_severity", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_set_severity", "priority": 1, "content": "gxf_set_severity context severity Set severity levels for GXF_LOG_* logging macros Parameters context ( int ) \u2013 The context for which to set the logging severity. severity ( int ) \u2013 The severity level to set. - 0: GXF_SEVERITY_NONE, - 1: GXF_SEVERITY_ERROR, - 2: GXF_SEVERITY_WARNING, - 3: GXF_SEVERITY_INFO, - 4: GXF_SEVERITY_DEBUG, - 5: GXF_SEVERITY_VERBOSE Raises ValueError \u2013 If setting the logging severity fails.", "keywords": []}, {"id": 1882, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_tid_t", "display_name": "gxf_tid_t", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_tid_t", "priority": 1, "content": "class  gxf_tid_t", "keywords": []}, {"id": 1883, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_tid_t.hash1", "display_name": "gxf_tid_t.hash1", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_tid_t.hash1", "priority": 1, "content": "hash1 :  int", "keywords": []}, {"id": 1884, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_tid_t.hash2", "display_name": "gxf_tid_t.hash2", "type": "attribute", "display_type": "Python attribute", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_tid_t.hash2", "priority": 1, "content": "hash2 :  int", "keywords": []}, {"id": 1885, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "gxf_uid_t", "display_name": "gxf_uid_t", "type": "class", "display_type": "Python class", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "gxf_uid_t", "priority": 1, "content": "class  gxf_uid_t Type int", "keywords": []}, {"id": 1886, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "load_extensions", "display_name": "load_extensions", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "load_extensions", "priority": 1, "content": "load_extensions context extension_filenames = [] manifest_filenames = [] base_directory = &#x27;&#x27; Load GXF extension libraries. Parameters context ( int ) \u2013 A valid GXF context. extension_filenames ( list ) \u2013 A list of valid filename. manifest_filenames ( list ) \u2013 A list of valid filename. base_directory ( str ) \u2013 Valid directory. Raises ValueError \u2013 If loading the extensions fails.", "keywords": []}, {"id": 1887, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_bool", "display_name": "parameter_get_bool", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_bool", "priority": 1, "content": "parameter_get_bool context eid key Get a boolean parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type bool Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1888, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_float32", "display_name": "parameter_get_float32", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_float32", "priority": 1, "content": "parameter_get_float32 context eid key Get a float32 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type float Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1889, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_float64", "display_name": "parameter_get_float64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_float64", "priority": 1, "content": "parameter_get_float64 context eid key Get a float64 (double) parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type double Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1890, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_handle", "display_name": "parameter_get_handle", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_handle", "priority": 1, "content": "parameter_get_handle context eid key Get a handle parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type int Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1891, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_int32", "display_name": "parameter_get_int32", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_int32", "priority": 1, "content": "parameter_get_int32 context eid key Get an int32 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type int Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1892, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_int64", "display_name": "parameter_get_int64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_int64", "priority": 1, "content": "parameter_get_int64 context eid key Get an int64 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type int Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1893, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_str", "display_name": "parameter_get_str", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_str", "priority": 1, "content": "parameter_get_str context eid key Get a string parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type str Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1894, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_get_uint64", "display_name": "parameter_get_uint64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_get_uint64", "priority": 1, "content": "parameter_get_uint64 context eid key Get a uint64 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. Returns The value of the parameter. Return type int Raises ValueError \u2013 If getting the parameter fails.", "keywords": []}, {"id": 1895, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_bool", "display_name": "parameter_set_bool", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_bool", "priority": 1, "content": "parameter_set_bool context eid key value Set a boolean parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( bool ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1896, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_float32", "display_name": "parameter_set_float32", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_float32", "priority": 1, "content": "parameter_set_float32 context eid key value Set a float32 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( float ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1897, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_float64", "display_name": "parameter_set_float64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_float64", "priority": 1, "content": "parameter_set_float64 context eid key value Set a float64 (double) parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( double ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1898, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_from_yaml_node", "display_name": "parameter_set_from_yaml_node", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_from_yaml_node", "priority": 1, "content": "parameter_set_from_yaml_node context eid key input Set parameters using a YAML string. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. input ( str ) \u2013 The YAML string containing the parameter values. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1899, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_handle", "display_name": "parameter_set_handle", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_handle", "priority": 1, "content": "parameter_set_handle context eid key value Set a handle parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( gxf_uid_t ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1900, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_int32", "display_name": "parameter_set_int32", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_int32", "priority": 1, "content": "parameter_set_int32 context eid key value Set an int32 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( int ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1901, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_int64", "display_name": "parameter_set_int64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_int64", "priority": 1, "content": "parameter_set_int64 context eid key value Set an int64 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( int ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1902, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_path", "display_name": "parameter_set_path", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_path", "priority": 1, "content": "parameter_set_path context eid key value Set a string parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( str ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1903, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_str", "display_name": "parameter_set_str", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_str", "priority": 1, "content": "parameter_set_str context eid key value Set a string parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( str ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1904, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "parameter_set_uint64", "display_name": "parameter_set_uint64", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "parameter_set_uint64", "priority": 1, "content": "parameter_set_uint64 context eid key value Set a uint64 parameter. Parameters context ( int ) \u2013 The context in which the entity and parameter exist. eid ( int ) \u2013 The unique identifier of the entity. key ( str ) \u2013 The key of the parameter to set. value ( int ) \u2013 The value to set for the parameter. Raises ValueError \u2013 If setting the parameter fails.", "keywords": []}, {"id": 1905, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "py", "name": "set_root_filepath", "display_name": "set_root_filepath", "type": "function", "display_type": "Python function", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "set_root_filepath", "priority": 1, "content": "set_root_filepath context filename Set the root file path for the graph. Parameters context ( int ) \u2013 The context for which to set the root file path. filename ( str ) \u2013 The root path. Raises ValueError \u2013 If setting the root file path fails.", "keywords": []}, {"id": 1906, "doc_id": 1906, "filename": "graphtools-docs/docs/text/GXF_Core_Python_APIs.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "display_name": "GXF Core Python APIs", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_Core_Python_APIs", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 1907, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_DEBUG", "display_name": "GXF_LOG_LEVEL_DEBUG", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_DEBUG", "priority": 1, "content": "GXF_LOG_LEVEL_DEBUG Defined as 4 .", "keywords": []}, {"id": 1908, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_ERROR", "display_name": "GXF_LOG_LEVEL_ERROR", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_ERROR", "priority": 1, "content": "GXF_LOG_LEVEL_ERROR Defined as 1 .", "keywords": []}, {"id": 1909, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_INFO", "display_name": "GXF_LOG_LEVEL_INFO", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_INFO", "priority": 1, "content": "GXF_LOG_LEVEL_INFO Defined as 3 .", "keywords": []}, {"id": 1910, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_PANIC", "display_name": "GXF_LOG_LEVEL_PANIC", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_PANIC", "priority": 1, "content": "GXF_LOG_LEVEL_PANIC Defined as 0 .", "keywords": []}, {"id": 1911, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_VERBOSE", "display_name": "GXF_LOG_LEVEL_VERBOSE", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_VERBOSE", "priority": 1, "content": "GXF_LOG_LEVEL_VERBOSE Defined as 5 . Define GXF_LOG_ACTIVE_LEVEL before including common/logger.hpp to control the logging level at compile time. This allows you to skip logging at certain levels. Example: #define GXF_LOG_ACTIVE_LEVEL 2 #include &quot;common/logger.hpp&quot; With this setting, logging will occur only at the WARNING(2), ERROR(1), and PANIC(0) levels. You can define GXF_LOG_ACTIVE_LEVEL in your build system. For instance, in CMake, use: target_compile_definitions(my_target PRIVATE GXF_LOG_ACTIVE_LEVEL=2) This sets the active logging level to WARNING(2) for the target my_target . Alternatively, define GXF_LOG_ACTIVE_LEVEL at compile time by passing -DGXF_LOG_ACTIVE_LEVEL=2 directly to the compiler. In the Bazel build system, set this in your build configuration as follows: cc_binary( name = &quot;my_binary&quot;, srcs = [&quot;my_binary.cc&quot;], copts = [&quot;-DGXF_LOG_ACTIVE_LEVEL=2&quot;], ) This sets the active logging level to WARNING(2) for the target my_binary . Or, when using a Bazel build command: bazel build --copt=-DGXF_LOG_ACTIVE_LEVEL=3 //path:to_your_target This sets the active logging level to INFO(3) for the target //path:to_your_target . GXF_LOG_ACTIVE_LEVEL Can also be used enable logging severity specific to each source file. Example: File A #define GXF_LOG_ACTIVE_LEVEL 2 #include &quot;common/logger.hpp&quot; Codelet B #define GXF_LOG_ACTIVE_LEVEL 5 #include &quot;common/logger.hpp&quot; File A will have warning and above logs, and File B will have verbose and above logs.", "keywords": []}, {"id": 1912, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "c", "name": "GXF_LOG_LEVEL_WARNING", "display_name": "GXF_LOG_LEVEL_WARNING", "type": "macro", "display_type": "C macro", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "c.GXF_LOG_LEVEL_WARNING", "priority": 1, "content": "GXF_LOG_LEVEL_WARNING Defined as 2 .", "keywords": []}, {"id": 1913, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD", "display_name": "GXF_EXT_FACTORY_ADD", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv419GXF_EXT_FACTORY_ADD2H12H24TYPE4BASE4DESC", "priority": 1, "content": "GXF_EXT_FACTORY_ADD H1 H2 TYPE BASE DESC Register a new component to this component factory. Example: GXF_EXT_FACTORY_ADD(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, nvidia::gxf::DummyCodelet, nvidia::gxf::Codelet, &quot;Description&quot;);", "keywords": []}, {"id": 1914, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD_0", "display_name": "GXF_EXT_FACTORY_ADD_0", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv421GXF_EXT_FACTORY_ADD_02H12H24TYPE4DESC", "priority": 1, "content": "GXF_EXT_FACTORY_ADD_0 H1 H2 TYPE DESC Register a new component to this component factory with minimal metadata. Example: GXF_EXT_FACTORY_ADD_0(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, sample::test::Helper, &quot;Description&quot;);", "keywords": []}, {"id": 1915, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD_0_LITE", "display_name": "GXF_EXT_FACTORY_ADD_0_LITE", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv426GXF_EXT_FACTORY_ADD_0_LITE2H12H24TYPE", "priority": 1, "content": "GXF_EXT_FACTORY_ADD_0_LITE H1 H2 TYPE Example: GXF_EXT_FACTORY_ADD_0_LITE(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, sample::test::Helper);", "keywords": []}, {"id": 1916, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD_0_VERBOSE", "display_name": "GXF_EXT_FACTORY_ADD_0_VERBOSE", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv429GXF_EXT_FACTORY_ADD_0_VERBOSE2H12H24TYPE12DISPLAY_NAME5BRIEF4DESC", "priority": 1, "content": "GXF_EXT_FACTORY_ADD_0_VERBOSE H1 H2 TYPE DISPLAY_NAME BRIEF DESC Register a new component to this component factory with verbose metadata. Example: GXF_EXT_FACTORY_ADD_0_VERBOSE(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, sample::test::Helper, &quot;Description&quot;, &quot;Brief&quot;, &quot;Description&quot;);", "keywords": []}, {"id": 1917, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD_LITE", "display_name": "GXF_EXT_FACTORY_ADD_LITE", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv424GXF_EXT_FACTORY_ADD_LITE2H12H24TYPE4BASE", "priority": 1, "content": "GXF_EXT_FACTORY_ADD_LITE H1 H2 TYPE BASE Register a new component to this component factory with minimal metadata. Example: GXF_EXT_FACTORY_ADD_LITE(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, nvidia::gxf::DummyCodelet, nvidia::gxf::Codelet); Register Components without a base type", "keywords": []}, {"id": 1918, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_ADD_VERBOSE", "display_name": "GXF_EXT_FACTORY_ADD_VERBOSE", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv427GXF_EXT_FACTORY_ADD_VERBOSE2H12H24TYPE4BASE12DISPLAY_NAME5BRIEF4DESC", "priority": 1, "content": "GXF_EXT_FACTORY_ADD_VERBOSE H1 H2 TYPE BASE DISPLAY_NAME BRIEF DESC Register a new component to this component factory with verbose metadata. Example: GXF_EXT_FACTORY_ADD_VERBOSE(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, nvidia::gxf::DummyCodelet, nvidia::gxf::Codelet, &quot;Display Name&quot;, &quot;Brief&quot;, &quot;Description&quot;);", "keywords": []}, {"id": 1919, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_BEGIN", "display_name": "GXF_EXT_FACTORY_BEGIN", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv421GXF_EXT_FACTORY_BEGINv", "priority": 1, "content": "GXF_EXT_FACTORY_BEGIN Start defining CreateComponentFactory() function, that starts with creating a nvidia::gxf::DefaultExtension object. H1 and H2 are first and second half hash values of the 128-bit identifier.", "keywords": []}, {"id": 1920, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_END", "display_name": "GXF_EXT_FACTORY_END", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv419GXF_EXT_FACTORY_ENDv", "priority": 1, "content": "GXF_EXT_FACTORY_END Close the CreateComponentFactory() function and then call CreateComponentFactory() to return the factory object. Register Components", "keywords": []}, {"id": 1921, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_SET_DISPLAY_INFO", "display_name": "GXF_EXT_FACTORY_SET_DISPLAY_INFO", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv432GXF_EXT_FACTORY_SET_DISPLAY_INFO12DISPLAY_NAME8CATEGORY5BRIEF", "priority": 1, "content": "GXF_EXT_FACTORY_SET_DISPLAY_INFO DISPLAY_NAME CATEGORY BRIEF Set additional display info this component factory. Example: GXF_EXT_FACTORY_SET_DISPLAY_INFO(&quot;Dummy Extension&quot;, &quot;Dummy&quot;, &quot;GXF Dummy Extension&quot;);", "keywords": []}, {"id": 1922, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_EXT_FACTORY_SET_INFO", "display_name": "GXF_EXT_FACTORY_SET_INFO", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv424GXF_EXT_FACTORY_SET_INFO2H12H24NAME4DESC6AUTHOR7VERSION7LICENSE", "priority": 1, "content": "GXF_EXT_FACTORY_SET_INFO H1 H2 NAME DESC AUTHOR VERSION LICENSE Set info for this extension factory. Example: GXF_EXT_FACTORY_SET_INFO(0xd8629d822909316d, 0xa9ee7410c8c1a7b6, &quot;test&quot;, &quot;A Dummy Example&quot;, &quot;&quot;, &quot;1.0.0&quot;, &quot;NVIDIA&quot;);", "keywords": []}, {"id": 1923, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_LOG_DEBUG", "display_name": "GXF_LOG_DEBUG", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv413GXF_LOG_DEBUGz", "priority": 1, "content": "GXF_LOG_DEBUG ... Example: GXF_LOG_DEBUG(&quot;This is a test message, codelet eid %ld, cid %ld, name %s&quot;, eid(), cid(), name());", "keywords": []}, {"id": 1924, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_LOG_ERROR", "display_name": "GXF_LOG_ERROR", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv413GXF_LOG_ERRORz", "priority": 1, "content": "GXF_LOG_ERROR ... Example: GXF_LOG_ERROR(&quot;This is a test message, codelet eid %ld, cid %ld, name %s&quot;, eid(), cid(), name()); Logging Levels GXF Logging supports the following log levels", "keywords": []}, {"id": 1925, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_LOG_INFO", "display_name": "GXF_LOG_INFO", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv412GXF_LOG_INFOz", "priority": 1, "content": "GXF_LOG_INFO ... Example: GXF_LOG_INFO(&quot;This is a test message, codelet eid %ld, cid %ld, name %s&quot;, eid(), cid(), name());", "keywords": []}, {"id": 1926, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_LOG_VERBOSE", "display_name": "GXF_LOG_VERBOSE", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv415GXF_LOG_VERBOSEz", "priority": 1, "content": "GXF_LOG_VERBOSE ... Example: GXF_LOG_VERBOSE(&quot;This is a test message, codelet eid %ld, cid %ld, name %s&quot;, eid(), cid(), name());", "keywords": []}, {"id": 1927, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "cpp", "name": "GXF_LOG_WARNING", "display_name": "GXF_LOG_WARNING", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "_CPPv415GXF_LOG_WARNINGz", "priority": 1, "content": "GXF_LOG_WARNING ... Example: GXF_LOG_WARNING(&quot;This is a test message, codelet eid %ld, cid %ld, name %s&quot;, eid(), cid(), name());", "keywords": []}, {"id": 1928, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#asynchronousschedulingterm", "display_name": "AsynchronousSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "asynchronousschedulingterm", "priority": -1, "content": "AsynchronousSchedulingTerm is primarily associated with entities which are working with asynchronous events happening outside of their regular execution performed by the scheduler. Since these events are non-periodic in nature, AsynchronousSchedulingTerm prevents the scheduler from polling the entity for its status regularly and reduces CPU utilization. AsynchronousSchedulingTerm can either be in READY, WAIT, WAIT_EVENT or NEVER states based on asynchronous event it\u2019s waiting on. The state of an asynchronous event is described using nvidia::gxf::AsynchronousEventState and is updated using the setEventState API. AsynchronousEventState Description READY Init state, first tick is pending WAIT Request to async service yet to be sent, nothing to do but wait EVENT_WAITING Request sent to an async service, pending event done notification EVENT_DONE Event done notification received, entity ready to be ticked EVENT_NEVER Entity does not want to be ticked again, end of execution Entities associated with this scheduling term most likely have an asynchronous thread which can update the state of the scheduling term outside of it\u2019s regular execution cycle performed by the gxf scheduler. When the scheduling term is in WAIT state, the scheduler regularly polls for the state of the entity. When the scheduling term is in EVENT_WAITING state, schedulers will not check the status of the entity again until they receive an event notification which can be triggered using the GxfEntityEventNotify api. Setting the state of the scheduling term to EVENT_DONE automatically sends this notification to the scheduler. Entities can use the EVENT_NEVER state to indicate the end of its execution cycle. Example usage - - name: async_scheduling_term type: nvidia::gxf::AsynchronousSchedulingTerm", "keywords": []}, {"id": 1929, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#booleanschedulingterm", "display_name": "BooleanSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "booleanschedulingterm", "priority": -1, "content": "An entity associated with nvidia::gxf::BooleanSchedulingTerm is executed when its internal state is set to tick. The parameter enable_tick is used to control the entity execution. The scheduling term also has two APIs enable_tick() and disable_tick() to toggle its internal state. The entity execution can be controlled by calling these APIs. If enable_tick is set to false, the entity is not executed (Scheduling condition is set to NEVER ). If enable_tick is set to true, the entity will be executed (Scheduling condition is set to READY ). Entities can toggle the state of the scheduling term by maintaining a handle to it. Example usage - - type: nvidia::gxf::BooleanSchedulingTerm parameters: enable_tick: true", "keywords": []}, {"id": 1930, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#btschedulingterm", "display_name": "BTSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "btschedulingterm", "priority": -1, "content": "A BT (Behavior Tree) scheduling term is used to schedule a behavior tree entity itself and its child entities (if any) in a Behavior tree. Example usage - name: root components: - name: root_controller type: nvidia::gxf::EntityCountFailureRepeatController parameters: max_repeat_count: 0 - name: root_st type: nvidia::gxf::BTSchedulingTerm parameters: is_root: true - name: root_codelet type: nvidia::gxf::SequenceBehavior parameters: children: [ child1/child1_st ] s_term: root_st controller: root_controller", "keywords": []}, {"id": 1931, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#combining-schedulingterms", "display_name": "Combining SchedulingTerms", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "combining-schedulingterms", "priority": -1, "content": "An entity can be associated with multiple scheduling terms which define it\u2019s execution behavior. Scheduling terms are AND combined to describe the current state of an entity. For an entity to be executed by the scheduler, all the scheduling terms must be in READY state and conversely, the entity is unscheduled from execution whenever any one of the scheduling term reaches NEVER state. The priority of various states during AND combine follows the order NEVER, WAIT_EVENT, WAIT, WAIT_TIME, and READY. Example usage - components: - name: integers type: nvidia::gxf::DoubleBufferTransmitter - name: fibonacci type: nvidia::gxf::DoubleBufferTransmitter - type: nvidia::gxf::CountSchedulingTerm parameters: count: 100 - type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: integers min_size: 1", "keywords": []}, {"id": 1932, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#component-factory", "display_name": "Component Factory", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "component-factory", "priority": -1, "content": "An extension contains its own component factory, in which all components are explicitly registered. GXF provides helper macros to easily implement the component factory needed for any extension. Normally extension factory implementation is organized as a standalone cpp file at the extension directory. It starts with GXF_EXT_FACTORY_BEGIN() and ends with GXF_EXT_FACTORY_END(). A component can be registered using the macro GXF_EXT_FACTORY_ADD(). For each component the base class need to be specified. Components base classes must be registered before they can be used as a base class in a component registration. If a component does not have a base class the macro GXF_EXT_FACTORY_ADD_0() is used instead. Components can have at most one base class. Multiple base classes are not supported. A unique 128-bit identifier must be provided for the factory and each component. The identifier must be unique across all existing extensions. Example: GXF_EXT_FACTORY_BEGIN() GXF_EXT_FACTORY_SET_INFO(0xd8629d822909316d, 0xa9ee7410c8c1a7b6, &quot;test&quot;, &quot;A Dummy Example&quot;, &quot;&quot;, &quot;1.0.0&quot;, &quot;NVIDIA&quot;); // ... GXF_EXT_FACTORY_ADD(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, sample::test::HelloWorld, nvidia::gxf::Codelet, &quot;Dummy example source codelet.&quot;); // ... GXF_EXT_FACTORY_END() The following macros are provided to help simplify the process of creating a component factory. The terms Component Factory, Extension and Extension are used interchangeably in these macros. Note that the extension factory can also be created manually without using these macros. Create a Component Factory", "keywords": []}, {"id": 1933, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#connection-topologies", "display_name": "Connection Topologies", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "connection-topologies", "priority": -1, "content": "GXF supports creating multiple connection topologies between graph entities. 1 : 1 Connection The simplest connection between a single transmitter and a single receiver. The underlying codelets have either a Handle&lt;Transmitter&gt; and Handle&lt;Receiver&gt; as the registered parameter. 1 : m Connection A single transmitter can be connected to a single receiver and vice-versa. The underlying codelets have either a Handle&lt;Transmitter&gt; and Handle&lt;Receiver&gt; as the registered parameter. Multiple 1 : 1 Connections A 1 : m connection can alternatively be realized by creating multiple 1 : 1 connections. In this scenario, the underlying codelet in the receiver entity must have either a std::vector&lt;Handle&lt;Receiver&gt;&gt; or std::Array&lt;Handle&lt;Receiver&gt;, N&gt; parameter. The same is applicable to m : 1 connections as well. Each 1 : 1 connection will have its own scheduling terms to monitor the incoming and outgoing message queues.", "keywords": []}, {"id": 1934, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#countschedulingterm", "display_name": "CountSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "countschedulingterm", "priority": -1, "content": "An entity associated with nvidia::gxf::CountSchedulingTerm is executed for a specific number of times specified using its count parameter. The CountSchedulingTerm can either be in READY or NEVER state. The scheduling term reaches the NEVER state when the entity has been executed count number of times. Example usage - - name: scheduling_term type: nvidia::gxf::CountSchedulingTerm parameters: count: 42", "keywords": []}, {"id": 1935, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#cuda-based-scheduling-terms", "display_name": "Cuda based scheduling terms", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "cuda-based-scheduling-terms", "priority": -1, "content": "Producer codelets based on cuda based processing can queue in the jobs to the cuda stream without waiting for the jobs to be complete. The consumers can wait for the availability of the data with the help of below two described scheduling terms.", "keywords": []}, {"id": 1936, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#cuda-event-schedulingterm", "display_name": "Cuda Event SchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "cuda-event-schedulingterm", "priority": -1, "content": "CudaEventSchedulingTerm specifies the availability of data at the receiver on completion of the work on the provided cuda stream with the help of cuda event. This scheduling term will keep polling on the event provided to check for data availability for consumption. Example usage - components: - type: nvidia::gxf::CudaEventSchedulingTerm parameters: receiver: rx0 - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: rx1 min_size: 1", "keywords": []}, {"id": 1937, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#cuda-stream-order-allocator", "display_name": "Cuda Stream Order Allocator", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "cuda-stream-order-allocator", "priority": -1, "content": "GXF provides a way for allocation and de-allocation of memory using native Cuda API in stream ordered approach that would be required by the codelets. There is only device memory allocation type which is supported as mentioned below. Device Memory : Allocates device memory in stream ordered approach. This stream-ordered allocation ensures that the memory operations are properly synchronized with other GPU operations in the same stream. This allocation method utilizes CUDA\u2019s asynchronous memory management functions, specifically cudaMallocAsync and cudaFreeAsync, to allocate and deallocate memory respectively. GXF provides a component called nvidia::gxf::StreamOrderedAllocator which is used to allocate/deallocate device memory in stream ordered approach. This component enables efficient and stream-ordered memory allocation for GPU operations within the GXF ecosystem. Below example specifies on how to allocate device memory. The memory allocation type supported here is Device Memory. - name: device_memory_pool type: nvidia::gxf::StreamOrderedAllocator parameters: device_memory_initial_size: &quot;32KB&quot; # 32 KB initial pool size device_max_memory_pool_size: &quot;64MB&quot; # 64 MB max pool size", "keywords": []}, {"id": 1938, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#cuda-stream-schedulingterm", "display_name": "Cuda Stream SchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "cuda-stream-schedulingterm", "priority": -1, "content": "CudaStreamSchedulingTerm specifies the availability of data at the receiver on completion of the work on the provided cuda stream with the help of callback function to host. This scheduling term will register a call back function which will be called once the work on the specified cuda stream completes indicating that the data is available for consumption. Example usage - components: - type: nvidia::gxf::CudaStreamSchedulingTerm parameters: receiver: rx0 - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: rx1 min_size: 1", "keywords": []}, {"id": 1939, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#distributed-execution", "display_name": "Distributed Execution", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "distributed-execution", "priority": -1, "content": "Segment is a group of graph entities created in a single GXF runtime context. A segment will have its own scheduler. Graph entities in a segment are connected with each other via double buffer transmitter and receiver components. A segment is connected to other segments via ucx transmitters and receivers. The connected pair of segments can run in two remote processes, or within the same process. The execution of segment is governed by the graph worker and the graph driver. The graph worker is a nvidia::gxf::System component responsible for orchestrating the execution of each segment configured to this worker. The graph worker provides and manages threads for each segment to run, and communicates with the graph driver to determine the life cycle of each segment. The graph worker and driver are GXF System components, that blocks main thread during its life cycle and spawns its own threads for execution. It\u2019s very similar to GXF schedulers in a way that, each scheduler orchestrates one GXF runtime from inside; whereas graph worker orchestrate one or multiple GXF runtimes from outside. The graph driver orchestrates one or more graph workers to go through the execution sequence. Both graph worker and graph driver consists of an IPC server and an IPC client. The IPC server\u2019s services are implemented within graph worker and graph driver respectively. These IPC services are exposed via the IPC server, that a corresponding IPC client on remote process can call. graph worker\u2019s IPC client sends remote request to graph driver\u2019s services; graph driver\u2019s IPC client sends remote request to graph worker\u2019s services.", "keywords": []}, {"id": 1940, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#downstreamreceptiveschedulingterm", "display_name": "DownstreamReceptiveSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "downstreamreceptiveschedulingterm", "priority": -1, "content": "This scheduling term specifies that an entity shall be executed if the receiver for a given transmitter can accept new messages. Example usage - - name: downstream_st type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: output min_size: 1", "keywords": []}, {"id": 1941, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#epoch-scheduler", "display_name": "Epoch Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "epoch-scheduler", "priority": -1, "content": "The Epoch scheduler is used for running loads in externally managed threads. Each run is called an Epoch. The scheduler goes over all entities that are known to be active and executes them one by one. If the epoch budget is provided (in ms), it would keep running all codelets until the budget is consumed or no codelet is ready. It might run over budget since it guarantees to cover all codelets in epoch. In case the budget is not provided, it would go over all the codelets once and execute them only once. The epoch scheduler takes in the following parameters from the configuration file - Parameter name Description clock The clock used by the scheduler to define the flow of time. Typical choice is a RealtimeClock. Example usage - The following code snippet configures an Epoch scheduler - name: scheduler components: - name: clock type: nvidia::gxf::RealtimeClock - name: epoch type: nvidia::gxf::EpochScheduler parameters: clock: clock Note that the epoch scheduler is intended to run from an external thread. The runEpoch(float budget_ms); can be used to set the budget_ms and run the scheduler from the external thread. If the specified budget is not positive, all the nodes are executed once.", "keywords": []}, {"id": 1942, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#event-based-scheduler", "display_name": "Event Based Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "event-based-scheduler", "priority": -1, "content": "The Event Based scheduler is more suitable for large applications with complex execution patterns. This scheduler maintains three different queues holding entities in READY or WAIT_TIME, WAIT_EVENT and WAIT states. An event is defined as a change in the scheduling term of any entity which can be triggered either by expiration of a time duration, execution of an entity, API called by a user thread, message transmission across the edges, etc. Events are generated at the end of an entity execution, or after change in state of scheduling conditions. In addition, the event-based scheduler launches several worker threads , async event handler thread and a dispatcher thread. Worker threads pop entities from the READY or WAIT_TIME queue and acquire them for execution. After the execution is complete, the worker thread generates an event. The dispatcher thread responds to events by moving entities from one queue to another by evaluating their scheduling condition. The async event handler thread responds to external events. The dispatcher thread and async event handler thread sleep between events thus saving CPU cycles. The number of worker threads can be configured using worker_thread_number parameter.", "keywords": []}, {"id": 1943, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#event-based-scheduler-configuration", "display_name": "Event Based Scheduler Configuration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "event-based-scheduler-configuration", "priority": -1, "content": "The Event Based scheduler takes in the following parameters from the configuration file Parameter name Description clock The clock used by the scheduler to define the flow of time. Typical choices are RealtimeClock or ManualClock. max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified, the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely. stop_on_deadlock If enabled the scheduler will stop when all entities are in a waiting state, but no periodic entity exists to break the dead end. Should be disabled when scheduling conditions can be changed by external actors, for example by clearing queues manually. worker_thread_number Number of threads. thread_pool_allocation_auto If enabled, only one thread pool will be created. If disabled, user should enumerate pools and priorities. stop_on_deadlock_timeout Scheduler will wait this amount of time when stop_on_dead_lock indicates should stop. It will reset if a job comes in during the wait. Negative value means not stop on deadlock. Example usage - The following code snippet configures a Event Based scheduler with the number of worked threads and max duration specified - name: scheduler components: - type: nvidia::gxf::EventBasedScheduler parameters: max_duration_ms: 5000 clock: misc/clock stop_on_deadlock: false worker_thread_number: 5 thread_pool_allocation_auto: true stop_on_deadlock_timeout: 500 --- name: misc components: - name: clock type: nvidia::gxf::RealtimeClock", "keywords": []}, {"id": 1944, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#expiringmessageavailableschedulingterm", "display_name": "ExpiringMessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "expiringmessageavailableschedulingterm", "priority": -1, "content": "This scheduling waits for a specified number of messages in the receiver. The entity is executed when the first message received in the queue is expiring or when there are enough messages in the queue. The receiver parameter is used to set the receiver to watch on. The parameters max_batch_size and max_delay_ns dictate the maximum number of messages to be batched together and the maximum delay from first message to wait before executing the entity respectively. In the example shown below, the associated entity will be executed when the number of messages in the queue is greater than max_batch_size , i.e 5, or when the delay from the first message to current time is greater than max_delay_ns , i.e 10000000. - name: target_st type: nvidia::gxf::ExpiringMessageAvailableSchedulingTerm parameters: receiver: signal max_batch_size: 5 max_delay_ns: 10000000 clock: misc/clock", "keywords": []}, {"id": 1945, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#graphdriver", "display_name": "GraphDriver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "graphdriver", "priority": -1, "content": "Graph driver implements a series of IPC services to handle different steps in discovering all segments in their graph workers; and resolving segments UCX connection addresses. Calling on these IPC services via the IPC server like Http or Grpc triggers these steps. Each IPC service ultimately translates a non-blocking IPC call to enqueuing an event. The threading of graph driver is based on an event-based queue thread. Figure: Graph driver execution sequence As shown in the sequence diagram, the caller main thread starts graph driver in 3 steps. read the global segment connection map configuration file; register the series of IPC services and start the server; start the event-based queue thread. Then the caller main thread gets blocked waiting for completion of graph driver. After startup, graph driver listens to requests from all graph workers. Upon each graph worker startup, it sends request to the graph driver to report its segments and address info. Graph driver is expected to starts before all graph workers. However if graph worker starts before graph driver, it keeps re-trying the request for a configurable times. Example graph driver entity: Figure: Entity containing GraphDriver and its dependency --- name: driver components: - name: driver_server type: nvidia::gxf::HttpServer parameters: port: 50000 - name: driver_client type: nvidia::gxf::HttpIPCClient - name: graph_driver type: nvidia::gxf::GraphDriver parameters: server: driver_server client: driver_client connections: - source: ucx_upstream.tx.signal target: ucx_downstream.rx.signal", "keywords": []}, {"id": 1946, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#graphworker", "display_name": "GraphWorker", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "graphworker", "priority": -1, "content": "Graph worker implements a series of IPC services to handle different steps in running a graph segment. Calling on these IPC services via the IPC server like Http or Grpc triggers these steps. Each IPC service ultimately translates a non-blocking IPC call to enqueuing an event. The threading of graph worker is based on an event-based queue thread, and a table of segment runners. Figure: Graph worker execution sequence As shown in the sequence diagram, the caller main thread starts graph worker in 4 steps. register the series of IPC services and start the server; start the event-based queue thread; enqueue event to instantiate the table of segment runners; enqueue event to request communication with graph driver. Then the caller main thread gets blocked waiting for completion of graph worker. Graph worker\u2019s first communication to graph driver is to register all segments along with their address info, eg IP and port. When graph driver discovers all segments, it possesses global knowledge of all segments and their addresses. It is graph driver to resolve the UCX connections between all segment pairs, and for each pair spread UCX receiver addresses to UCX transmitter via the graph worker. Example graph worker entity: Figure: Entity containing GraphWorker and its dependency --- name: worker_entity components: - name: graph_worker type: nvidia::gxf::GraphWorker parameters: server: this_worker_server client: client_to_remote_driver graph-specs: ucx_upstream: app-path: gxf/ucx/tests/test_ping_ucx_tx.yaml manifest-path: gxf/test/distributed/test_graph_worker_manifest.yaml severity: 4 ucx_downstream: app-path: gxf/ucx/tests/test_ping_ucx_rx.yaml manifest-path: gxf/test/distributed/test_graph_worker_manifest.yaml severity: 4 - name: this_worker_server type: nvidia::gxf::HttpServer parameters: port: 50001 remote_access: &#x27;True&#x27; - name: client_to_remote_driver type: nvidia::gxf::HttpIPCClient parameters: server_ip_address: localhost port: 50000", "keywords": []}, {"id": 1947, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#greedy-scheduler", "display_name": "Greedy Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "greedy-scheduler", "priority": -1, "content": "This is a basic single threaded scheduler which tests scheduling term greedily. It is great for simple use cases and predictable execution but may incur a large overhead of scheduling term execution, making it unsuitable for large applications. The scheduler requires a clock to keep track of time. Based on the choice of clock the scheduler will execute differently. If a Realtime clock is used the scheduler will execute in real-time. This means pausing execution - sleeping the thread, until periodic scheduling terms are due again. If a ManualClock is used scheduling will happen \u201ctime-compressed\u201d. This means flow of time is altered to execute codelets in immediate succession. The GreedyScheduler maintains a running count of entities which are in READY, WAIT_TIME and WAIT_EVENT states. The following activity diagram depicts the gist of the decision making for scheduling an entity by the greedy scheduler - Figure: Greedy Scheduler Activity Diagram", "keywords": []}, {"id": 1948, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#greedy-scheduler-configuration", "display_name": "Greedy Scheduler Configuration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "greedy-scheduler-configuration", "priority": -1, "content": "The greedy scheduler takes in the following parameters from the configuration file Parameter name Description clock The clock used by the scheduler to define the flow of time. Typical choices are RealtimeClock or ManualClock max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified, the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely stop_on_deadlock If stop_on_deadlock is disabled, the GreedyScheduler constantly polls for the status of all the waiting entities to check if any of them are ready for execution. Example usage - The following code snippet configures a Greedy scheduler with a ManualClock option specified. name: scheduler components: - type: nvidia::gxf::GreedyScheduler parameters: max_duration_ms: 3000 clock: misc/clock stop_on_deadlock: true --- name: misc components: - name: clock type: nvidia::gxf::ManualClock", "keywords": []}, {"id": 1949, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#lifecycle-of-a-codelet", "display_name": "LifeCycle of a Codelet", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "lifecycle-of-a-codelet", "priority": -1, "content": "The life cycle of a codelet is governed by the below five stages Initialize: Used for light-weight initialization. Called directly when the codelet is created for the first time. Called exactly once over the lifetime of a codelet. Deinitialize: Used for light-weight deinitialization. Called directly before the codelet is destroyed. Called exactly once over the lifetime of a codelet. Start: Used for heavy-weight initialization to allocate resources which are necessary for execution. Can be called multiple times over the lifetime of the codelet according to order defined by the lifecycle. Stop: Used for heavy-weight deinitialization to deallocate all resources which were allocated by the start function. Can be called multiple times over the lifetime of the codelet according to order defined by the lifecycle. Tick: Called when the codelet is triggered. Triggering can happen when data arrives or based on a time trigger. Normally called many times over the lifetime of a codelet. Codelet component is used to define a custom codelet that will accomplish the desired work. Below example describes on how to implement a custom codelet. For now please ignore :ref: registerInterface which will covered in the later sections. class Test : public Codelet { public: gxf_result_t start() override { return GXF_SUCCESS; } gxf_result_t tick() override { // Do Something ... return GXF_SUCCESS; } gxf_result_t stop() override { return GXF_SUCCESS; } gxf_result_t registerInterface(Registrar* registrar) override { Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter(some_parameter_, &quot;Some Parameter&quot;); return ToResultCode(result); } Parameter&lt;Handle&lt;Receiver&gt;&gt; some_parameter_; }; Below example shows on how to create a simple custom codelet that prints \u201cHello World\u201d class HelloWorld : public Codelet { public: gxf_result_t start() override { return GXF_SUCCESS; } gxf_result_t tick() override { GXF_LOG_INFO(&quot;Hello World from GXF&quot;); return GXF_SUCCESS; } gxf_result_t stop() override { return GXF_SUCCESS; } gxf_result_t registerInterface(Registrar* registrar) override { Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter(some_parameter_, &quot;Some Parameter&quot;); return ToResultCode(result); } Parameter&lt;Handle&lt;Receiver&gt;&gt; some_parameter_; }; Below example explores on how to use the initialize/deinitialize and start/stop stages class File : public Codelet { public: gxf_result_t initialize() { access_file_ = true; return GXF_SUCCESS; } gxf_result_t start() override { if (access_file_) { file_ = fopen(&quot;Some File Name&quot;, &quot;Read or Write Mode&quot;); if (file_ == nullptr) { GXF_LOG_ERROR(&quot;%s&quot;, strerror(errno)); return Unexpected{GXF_FAILURE}; } } return GXF_SUCCESS; } gxf_result_t tick() override { // Do some file operation return GXF_SUCCESS; } gxf_result_t stop() override { const int result = fclose(file_); if (result != 0) { GXF_LOG_ERROR(&quot;%s&quot;, strerror(errno)); return Unexpected{GXF_FAILURE}; } file_ = nullptr; return GXF_SUCCESS; } gxf_result_t deinitialize() override { access_file_ = false; return GXF_SUCCESS; } gxf_result_t registerInterface(Registrar* registrar) override { Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter(some_parameter_, &quot;Some Parameter&quot;); // Not used here return ToResultCode(result); } Parameter&lt;Handle&lt;Receiver&gt;&gt; some_parameter_; bool access_file_{false}; std::FILE* file_; };", "keywords": []}, {"id": 1950, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#logging", "display_name": "Logging", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "logging", "priority": -1, "content": "GXF logging macros are automatically included when implementing a codelet. The usage is similar to printf(), but they will also print file name and line numbers. See example usage in the sample extension section.", "keywords": []}, {"id": 1951, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#memory-management", "display_name": "Memory Management", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "memory-management", "priority": -1, "content": "GXF provides a way for allocation and de-allocation of memory that would be required by the codelets. There are various types of memory allocation that are provided as mentioned below. System Memory Allocates specified bytes of system memory which typically would make use of underlying OS calls for allocation of requested memory. Host Memory Allocates specified bytes of host memory that is page-locked and accessible to the device. Allocating excessive amounts of memory with cudaMallocHost() may degrade system performance, since it reduces the amount of memory available to the system for paging. This memory is best used sparingly to allocate staging areas for data exchange between host and device. Device Memory Allocates specified bytes of device memory. GXF provides a component called nvidia::gxf::BlockMemoryPool which is used to allocate memory in multiple/single blocks of same size which can be specified as parameters. Below example specifies on how to allocate host memory - name: host_memory_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 0 # host memory block_size: 1024 num_blocks: 5 Below example specifies on how to allocate device memory - name: cuda_device_memory_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 1 # device memory block_size: 1024 num_blocks: 5 Below example specifies on how to allocate system memory - name: system_memory_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 2 # system memory block_size: 1024 num_blocks: 5 Below example specifies on how to use allocator with codelets - name: host_memory_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 0 # host memory block_size: 1024 num_blocks: 5 - name: cuda_device_memory_pool type: nvidia::gxf::BlockMemoryPool parameters: storage_type: 1 # device memory block_size: 1024 num_blocks: 5 - name: generator type: nvidia::gxf::test::cuda::StreamTensorGenerator parameters: cuda_tensor_pool: cuda_device_memory_pool host_tensor_pool: host_memory_pool", "keywords": []}, {"id": 1952, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#memoryavailableschedulingterm", "display_name": "MemoryAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "memoryavailableschedulingterm", "priority": -1, "content": "A scheduling term which waits until a given number of blocks are available in a pool. This can be used to force a codelet to wait until a minimum number of its in-flight buffers have returned from downstream consumers. - type: nvidia::gxf::MemoryAvailableSchedulingTerm parameters: allocator: allocator min_bytes: 256 min_blocks: 1024", "keywords": []}, {"id": 1953, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#messageavailablefrequencythrottler", "display_name": "MessageAvailableFrequencyThrottler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "messageavailablefrequencythrottler", "priority": -1, "content": "A scheduling term which lets an entity maintain a specific execution (min) frequency. The scheduling term will also monitor messages incoming via multiple receivers and switch to READY state if any messages are available. - type: nvidia::gxf::MessageAvailableFrequencyThrottler parameters: receivers: [receiver_0, receiver_1] execution_frequency: 100Hz min_sum: 1 sampling_mode: SumOfAll", "keywords": []}, {"id": 1954, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#messageavailableschedulingterm", "display_name": "MessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "messageavailableschedulingterm", "priority": -1, "content": "An entity associated with nvidia::gxf::MessageAvailableSchedulingTerm is executed when the associated receiver queue has at least a certain number of elements. The receiver is specified using the receiver parameter of the scheduling term. The minimum number of messages that permits the execution of the entity is specified by min_size . An optional parameter for this scheduling term is front_stage_max_size , the maximum front stage message count. If this parameter is set, the scheduling term will only allow execution if the number of messages in the queue does not exceed this count. It can be used for codelets which do not consume all messages from the queue. In the example shown below, the minimum size of the queue is configured to be 4. So, the entity will not be executed till there are at least 4 messages in the queue. - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: tensors min_size: 4", "keywords": []}, {"id": 1955, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#messages", "display_name": "Messages", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "messages", "priority": -1, "content": "In the GXF graph, many a times Codelets may have to communicate with each other to accomplish the defined pipeline. Messages are the form of communication by codelets with each other. When publishing, a message will always have an associated Timestamp component with the name \u201ctimestamp\u201d . If the user doesn\u2019t add it, it will automatically be added when the entity is published. A Timestamp component contains two different time values (See the gxf/std/timestamp.hpp header file for more information.): 1. acqtime - This is the time when the message entity is acquired, for instance, this would generally be the driver time of the camera when it captures an image. You must provide this timestamp if you are publishing a message in a codelet. 1. pubtime - This is the time when the message entity is published by a node in the graph. This will automatically get updated using the clock of the scheduler. Transmitter is used for transmitting the message and Receiver is used for receiving the message. Messages are transmitted or received at tick() of codelet.", "keywords": []}, {"id": 1956, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#messaging-and-events", "display_name": "Messaging and Events", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "messaging-and-events", "priority": -1, "content": "Components communicate with each other to accomplish the defined pipeline. Messages are the form of communication by components with each other. Entities have transmitter and receiver queues in order to transmit and receive messages. The transmitter of an upstream entity is connected to the receiver of a downstream entity. GXF allows M \u00d7 N connections between transmitters and receivers where M is the number of transmitters and N is the number of receivers. After a component consumes a message from its receiver queue, an event is generated to notify the upstream entity so that it can evaluate its scheduling terms and allow a change in its scheduling condition. Similarly, when a component publishes a message to a downstream entity , it generates an event to notifies the entity. The dispatcher thread is responsible for processing the event and evaluating the scheduling terms. This operation is called dispatching an entity. Figure: Messaging Events Activity Diagram The dispatcher thread also maintains a running count of the number of entities in READY, WAIT_EVENT and WAIT_TIME states and uses these statistics to check if the scheduler has reached a deadlock. The scheduler also needs a clock component to keep track of time and it is configured using the clock parameter.", "keywords": []}, {"id": 1957, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#multimessageavailableschedulingterm", "display_name": "MultiMessageAvailableSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "multimessageavailableschedulingterm", "priority": -1, "content": "An entity associated with nvidia::gxf::MultiMessageAvailableSchedulingTerm is executed when a list of provided input receivers combined have at least a given number of messages. The receivers parameter is used to specify a list of the input channels/receivers. The minimum number of messages needed to permit the entity execution is set by min_size parameter. Consider the example shown below. The associated entity will be executed when the number of messages combined for all the three receivers is at least the min_size, i.e. 5. - name: input_1 type: nvidia::gxf::test::MockReceiver parameters: max_capacity: 10 - name: input_2 type: nvidia::gxf::test::MockReceiver parameters: max_capacity: 10 - name: input_3 type: nvidia::gxf::test::MockReceiver parameters: max_capacity: 10 - type: nvidia::gxf::MultiMessageAvailableSchedulingTerm parameters: receivers: [input_1, input_2, input_3] min_size: 5", "keywords": []}, {"id": 1958, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#multithread-scheduler", "display_name": "Multithread Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "multithread-scheduler", "priority": -1, "content": "The MultiThread scheduler is more suitable for large applications with complex execution patterns. The scheduler consists of a dispatcher thread which checks the status of an entity and dispatches it to a thread pool of worker threads responsible for executing them. Worker threads enqueue the entity back on to the dispatch queue upon completion of execution. The number of worker threads can be configured using worker_thread_number parameter. The MultiThread scheduler also manages a dedicated queue and thread to handle asynchronous events. The following activity diagram demonstrates the gist of the multithread scheduler implementation. Figure: MultiThread Scheduler Activity Diagram As depicted in the diagram, when an entity reaches WAIT_EVENT state, it\u2019s moved to a queue where they wait to receive event done notification. The asynchronous event handler thread is responsible for moving entities to the dispatcher upon receiving event done notification. The dispatcher thread also maintains a running count of the number of entities in READY, WAIT_EVENT and WAIT_TIME states and uses these statistics to check if the scheduler has reached a deadlock. The scheduler also needs a clock component to keep track of time and it is configured using the clock parameter. MultiThread scheduler is more resource efficient compared to the Greedy Scheduler and does not incur any additional overhead for constantly polling the states of scheduling terms. The check_recession_period_ms parameter can be used to configure the time interval the scheduler must wait to poll the state of entities which are in WAIT state.", "keywords": []}, {"id": 1959, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#multithread-scheduler-configuration", "display_name": "Multithread Scheduler Configuration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "multithread-scheduler-configuration", "priority": -1, "content": "The multithread scheduler takes in the following parameters from the configuration file Parameter name Description clock The clock used by the scheduler to define the flow of time. Typical choices are RealtimeClock or ManualClock. max_duration_ms The maximum duration for which the scheduler will execute (in ms). If not specified, the scheduler will run until all work is done. If periodic terms are present this means the application will run indefinitely. check_recess_period_ms Duration to sleep before checking the condition of an entity again [ms]. This is the maximum duration for which the scheduler would wait when an entity is not yet ready to run. stop_on_deadlock If enabled the scheduler will stop when all entities are in a waiting state, but no periodic entity exists to break the dead end. Should be disabled when scheduling conditions can be changed by external actors, for example by clearing queues manually. worker_thread_number Number of threads. Example usage - The following code snippet configures a Multithread scheduler with the number of worked threads and max duration specified - name: scheduler components: - type: nvidia::gxf::MultiThreadScheduler parameters: max_duration_ms: 5000 clock: misc/clock worker_thread_number: 5 check_recession_period_ms: 3 stop_on_deadlock: false --- name: misc components: - name: clock type: nvidia::gxf::RealtimeClock", "keywords": []}, {"id": 1960, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#periodicschedulingterm", "display_name": "PeriodicSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "periodicschedulingterm", "priority": -1, "content": "An entity associated with nvidia::gxf::PeriodicSchedulingTerm is ready for execution after periodic time intervals specified using its recess_period parameter. The PeriodicSchedulingTerm can either be in READY or WAIT_TIME state. Example usage - - name: scheduling_term type: nvidia::gxf::PeriodicSchedulingTerm parameters: recess_period: 50000000", "keywords": []}, {"id": 1961, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#receiver", "display_name": "Receiver", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "receiver", "priority": -1, "content": "All the messages from the transmitter are received as an entity. The receiver on getting a tick() call will give a receive() call that helps in receiving the message. Below is an example of transmitter and receiver", "keywords": []}, {"id": 1962, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#receiver-example", "display_name": "Receiver Example", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "receiver-example", "priority": -1, "content": "gxf_result_t PingRx::tick() { auto message = signal_-&gt;receive(); if (!message || message.value().is_null()) { return GXF_CONTRACT_MESSAGE_NOT_AVAILABLE; } auto value = message.value(); auto rx_value = message-&gt;findAll&lt;int32_t&gt;(); GXF_LOG_INFO(&quot;Message Received: rx_value = %d&quot;, *(rx_value-&gt;at(0).value())); return GXF_SUCCESS; }", "keywords": []}, {"id": 1963, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#rmm-rapids-memory-manager", "display_name": "RMM: RAPIDS Memory Manager", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "rmm-rapids-memory-manager", "priority": -1, "content": "GXF provides a way for allocation and de-allocation of memory that would be required by the codelets using RMM. There are various types of memory allocation that are provided as mentioned below. Host Memory : Allocates specified bytes of pinned host memory that is page-locked and accessible to the device. It takes advantage of RMM\u2019s pool allocation strategy for better performance Device Memory : Allocates specified bytes of device memory in stream ordered approach. This stream-ordered allocation ensures that the memory operations are properly synchronized with other GPU operations in the same stream. GXF provides a component called nvidia::gxf::RMMAllocator which is used to allocate/deallocate memory using Rapids Memory Manager (RMM). This component enables efficient and stream-ordered memory allocation for GPU operations within the GXF ecosystem. Below example specifies on how to allocate host/device memory. The memory allocation strategy is determined by the parameter value passed to the allocation function. Depending on this value, the function decides whether to allocate memory on the host or on the device. - name: memory_pool type: nvidia::gxf::RMMAllocator parameters: device_memory_initial_size: &quot;32B&quot; # 32 bytes initial pool size host_memory_initial_size: &quot;32KB&quot; # 32 KB initial pool size device_max_memory_pool_size: &quot;64MB&quot; # 64 MB max pool size host_memory_max_size: &quot;64GB&quot; # 64 GB max pool size", "keywords": []}, {"id": 1964, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#schedulingterms", "display_name": "SchedulingTerms", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "schedulingterms", "priority": -1, "content": "A SchedulingTerm defines a specific condition that is used by an entity to let the scheduler know when it\u2019s ready for execution. There are various scheduling terms currently supported by GXF. If multiple scheduling terms are present in an entity they all have to be true for an entity to execute.", "keywords": []}, {"id": 1965, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#targettimeschedulingterm", "display_name": "TargetTimeSchedulingTerm", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "targettimeschedulingterm", "priority": -1, "content": "This scheduling term permits execution at a user-specified timestamp. The timestamp is specified on the clock provided. Example usage - - name: target_st type: nvidia::gxf::TargetTimeSchedulingTerm parameters: clock: clock/manual_clock", "keywords": []}, {"id": 1966, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#the-gxf-scheduler", "display_name": "The GXF Scheduler", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "the-gxf-scheduler", "priority": -1, "content": "The execution of entities in a graph is governed by the scheduler and the scheduling terms associated with every entity. A scheduler is a component responsible for orchestrating the execution of all the entities defined in a graph. A scheduler typically keeps track of the graph entities and their current execution states and passes them on to a nvidia::gxf::EntityExecutor component when ready for execution. The following diagram depicts the flow for an entity execution. Figure: Entity execution sequence As shown in the sequence diagram, the schedulers begin executing the graph entities via the nvidia::gxf::System::runAsync_abi() interface and continue this process until it meets the certain ending criteria. A single entity can have multiple codelets. These codelets are executed in the same order in which they were defined in the entity. A failure in execution of any single codelet stops the execution of all the entities. Entities are naturally unscheduled from execution when any one of their scheduling term reaches NEVER state. Scheduling terms are components used to define the execution readiness of an entity. An entity can have multiple scheduling terms associated with it and each scheduling term represents the state of an entity using SchedulingCondition. The table below shows various states of nvidia::gxf::SchedulingConditionType described using nvidia::gxf::SchedulingCondition. SchedulingConditionType Description NEVER Entity will never execute again READY Entity is ready for execution WAIT Entity may execute in the future WAIT_TIME Entity will be ready for execution after specified duration WAIT_EVENT Entity is waiting on an asynchronous event with unknown time interval Schedulers define deadlock as a condition when there are no entities which are in READY, WAIT_TIME or WAIT_EVENT state which guarantee execution at a future point in time. This implies all the entities are in WAIT state for which the scheduler does not know if they ever will reach the READY state in the future. The scheduler can be configured to stop when it reaches such a state using the stop_on_deadlock parameter, else the entities are polled to check if any of them have reached READY state. max_duration config parameter can be used to stop execution of all entities regardless of their state after a specified amount of time has elapsed. Figure: Entity State transition for all schedulers There are four types of schedulers currently supported by GXF Greedy Scheduler Multithread Scheduler Epoch Scheduler Event Based Scheduler", "keywords": []}, {"id": 1967, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#transmitter", "display_name": "Transmitter", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "transmitter", "priority": -1, "content": "All the messages from the transmitter are sent as an entity. The transmitter after encapsulating the message will give a publish() call which will send the message to target recipient. In a codelet, when publishing message entities using a Transmitter (tx) , there are two ways to add the required Timestamp : 1. tx.publish(Entity message) : You can manually add a component of type Timestamp with the name \u201ctimestamp\u201d and set the acqtime . The pubtime in this case should be set to 0 . The message is published using the publish(Entity message) . This will be deprecated in the next release. 2. tx.publish(Entity message, int64_t acqtime) : You can simply call publish(Entity message, int64_t acqtime) with the acqtime . Timestamp will be added automatically.", "keywords": []}, {"id": 1968, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_Internals#transmitter-example", "display_name": "Transmitter Example", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "transmitter-example", "priority": -1, "content": "gxf_result_t PingTx::tick() { Expected&lt;Entity&gt; message = Entity::New(context()); if (!message) { GXF_LOG_ERROR(&quot;Failure creating message entity.&quot;); return message.error(); } auto int_value = message.value().add&lt;int32_t&gt;(&quot;Integer&quot;); auto value = int_value.value(); *value = 9999; auto result = signal_-&gt;publish(message.value()); GXF_LOG_INFO(&quot;Message Sent: int_value = %d&quot;, *value); return ToResultCode(message); }", "keywords": []}, {"id": 1969, "doc_id": 1969, "filename": "graphtools-docs/docs/text/GXF_Internals.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_Internals", "display_name": "GXF Internals", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_Internals", "anchor": "", "priority": -1, "content": "This section covers upon the guide that helps in understanding the basic building blocks of GXF One of the key components in the application development is the Codelets and it is important to understand its lifecycle.", "keywords": []}, {"id": 1970, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#benchmark-controller", "display_name": "Benchmark Controller", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "benchmark-controller", "priority": -1, "content": "Benchmark controller connects every component in the benchmark application and orchestrates the benchmark flow. At the end of each benchmark iteration, the controller invokes a number of default and custom performance calculators for computing the performance outcome. A final performance report (in JSON format) is generated by the controller after all benchmark iterations are finished.", "keywords": []}, {"id": 1971, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#benchmark-entity-buffer", "display_name": "Benchmark Entity buffer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "benchmark-entity-buffer", "priority": -1, "content": "Benchmark entity buffer receives all the messages provided from a producer and stores them in message buffers. After all the messages are buffered and the producer is terminated (which ensures that the producer will not induce any additional overhead when executing the main benchmark procedure), the benchmark controller will signal the beginning of the main benchmark procedure.", "keywords": []}, {"id": 1972, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#benchmark-publisher", "display_name": "Benchmark Publisher", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "benchmark-publisher", "priority": -1, "content": "Benchmark publisher is responsible for delivering the messages that are buffered in the Entity buffer component into the target graph. Timestamps are recorded when the messages are published for performance measurement.", "keywords": []}, {"id": 1973, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#benchmark-sink", "display_name": "Benchmark Sink", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "benchmark-sink", "priority": -1, "content": "Benchmark sink recieves the messages produced from the target graph. It records the timestamps when each message arrives for performance measurement. Benchmark sink optionally may have the handle of benchmark publisher to get the published timestamp or rely on the acqtime present in the timestamp of the received messages.", "keywords": []}, {"id": 1974, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#benchmarking", "display_name": "Benchmarking", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "benchmarking", "priority": -1, "content": "Benchmarking is the second stage which executes the main benchmarking procedure. Based on the benchmark\u2019s configurations (a part of which are given as parameters in the benchmark controller component), a benchmark application can run multiple benchmark test cases with different settings (e.g., different publisher\u2019s FPS). For each benchmark case, there can be a configurable number of test iterations for measuring the performance outcome in a statistical manner. When all test iterations for a benchmark case is done, the benchmark controller stores the concluded performance results and moves to testing the next benchmark test case.", "keywords": []}, {"id": 1975, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#buffering", "display_name": "Buffering", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "buffering", "priority": -1, "content": "Buffering is the first stage to load data to be used in benchmarking and buffer them in a entity buffer component. The separation of this stage from other stages is to ensure that the data loading overhead does not interfere with the performance measurement during benchmarking.", "keywords": []}, {"id": 1976, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#components-of-gxf-benchmark-extension", "display_name": "Components of GXF benchmark extension", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "components-of-gxf-benchmark-extension", "priority": -1, "content": "Various benchmark componments that are used are described below with the help of a diagram", "keywords": []}, {"id": 1977, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#concluding", "display_name": "Concluding", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "concluding", "priority": -1, "content": "Concluding is the last stage which occurs after all benchmark cases are tested. The benchmark controller exports all the performance results to a JSON file that can be processed by any other analysis tools further.", "keywords": []}, {"id": 1978, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#results", "display_name": "Results", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "results", "priority": -1, "content": "Benchmark controller creates a json file as explained above. Below is a sample of json file which consists of various statistis. The statistics is for a graph with two sources and two sinks. { &quot;[Sink 1] # of Frames Received&quot;: 20270.0, &quot;[Sink 1] # of Frames Sent&quot;: 20270.0, &quot;[Sink 1] # of Missed Frames&quot;: 0.0, &quot;[Sink 1] Delta between First &amp; Last Received Frames (ms)&quot;: 624.549761, &quot;[Sink 1] Delta between First &amp; Last Sent Frames (ms)&quot;: 499.904755, &quot;[Sink 1] First Sent to First Received Latency (ms)&quot;: 0.200702, &quot;[Sink 1] Last Sent to Last Received Latency (ms)&quot;: 125.057111, &quot;[Sink 1] Max. End-to-End Latency (ms)&quot;: 127.770703, &quot;[Sink 1] Max. Frame-to-Frame Jitter (ms)&quot;: 0.214416, &quot;[Sink 1] Mean End-to-End Latency (ms)&quot;: 75.224532, &quot;[Sink 1] Mean Frame Rate (fps)&quot;: 32550.581433937827, &quot;[Sink 1] Mean Frame-to-Frame Jitter (ms)&quot;: 0.006864, &quot;[Sink 1] Mean Publisher Frame Rate (fps)&quot;: 40545.72355487997, &quot;[Sink 1] Min. End-to-End Latency (ms)&quot;: 0.129046, &quot;[Sink 1] Min. Frame-to-Frame Jitter (ms)&quot;: 0.0, &quot;[Sink 1] SD. End-to-End Latency (ms)&quot;: 40.329108290039265, &quot;[Sink 1] SD. Frame-to-Frame Jitter (ms)&quot;: 0.0062623999229486855, &quot;[Sink 2] # of Frames Received&quot;: 20270.0, &quot;[Sink 2] # of Frames Sent&quot;: 20270.0, &quot;[Sink 2] # of Missed Frames&quot;: 0.0, &quot;[Sink 2] Delta between First &amp; Last Received Frames (ms)&quot;: 624.544266, &quot;[Sink 2] Delta between First &amp; Last Sent Frames (ms)&quot;: 499.904755, &quot;[Sink 2] First Sent to First Received Latency (ms)&quot;: 0.211339, &quot;[Sink 2] Last Sent to Last Received Latency (ms)&quot;: 125.062253, &quot;[Sink 2] Max. End-to-End Latency (ms)&quot;: 127.772703, &quot;[Sink 2] Max. Frame-to-Frame Jitter (ms)&quot;: 0.196638, &quot;[Sink 2] Mean End-to-End Latency (ms)&quot;: 75.227042, &quot;[Sink 2] Mean Frame Rate (fps)&quot;: 32551.20225100854, &quot;[Sink 2] Mean Frame-to-Frame Jitter (ms)&quot;: 0.007822, &quot;[Sink 2] Mean Publisher Frame Rate (fps)&quot;: 40545.72355487997, &quot;[Sink 2] Min. End-to-End Latency (ms)&quot;: 0.133161, &quot;[Sink 2] Min. Frame-to-Frame Jitter (ms)&quot;: 0.0, &quot;[Sink 2] SD. End-to-End Latency (ms)&quot;: 40.32882660754853, &quot;[Sink 2] SD. Frame-to-Frame Jitter (ms)&quot;: 0.007074244521465658 }", "keywords": []}, {"id": 1979, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#sample-graph-to-benchmark", "display_name": "Sample graph to benchmark", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "sample-graph-to-benchmark", "priority": -1, "content": "Below is an example of benchmarking a GXF graph. The GXF graph titled as graph_under_test consists of a Forward component which receives and transmits the messages Example: %YAML 1.2 --- ######################## # Benchmark Controller # ######################## name: benchmark_controller components: - name: allocator type: nvidia::gxf::UnboundedAllocator - name: report type: nvidia::gxf::File parameters: allocator: allocator file_path: /tmp/test_benchmark_one_source_one_sink_report.json file_mode: wb - name: benchmark_controller type: nvidia::gxf::benchmark::BenchmarkController parameters: data_source_async_scheduling_terms: [data_source/async_scheduling_term] data_source_boolean_scheduling_terms: [data_source/boolean_scheduling_term] benchmark_controller_target_time_scheduling_term: target_time_scheduling_term benchmark_controller_boolean_scheduling_term: boolean_scheduling_term benchmark_sinks: [benchmark_sink/sink] benchmark_publishers: [benchmark_publisher/benchmark_publisher] resource_profilers: [resource_profiler] title: &quot;Test Benchmark Framework&quot; exported_report: report benchmark_duration_ms: 500 benchmark_iterations: 3 entity_buffer_size: 10 - name: resource_profiler type: nvidia::gxf::benchmark::ResourceProfiler - name: boolean_scheduling_term type: nvidia::gxf::BooleanSchedulingTerm parameters: enable_tick: true - name: target_time_scheduling_term type: nvidia::gxf::TargetTimeSchedulingTerm parameters: clock: system/clock - type: nvidia::gxf::benchmark::test::BenchmarkReportChecker parameters: report: report --- ##################### # Dummy Data Source # ##################### name: data_source components: - name: transmitter type: nvidia::gxf::test::MockTransmitter - name: ping type: nvidia::gxf::PingTx parameters: signal: transmitter clock: system/clock - name: boolean_scheduling_term type: nvidia::gxf::BooleanSchedulingTerm parameters: enable_tick: true - name: async_scheduling_term type: nvidia::gxf::AsynchronousSchedulingTerm - type: nvidia::gxf::PeriodicSchedulingTerm parameters: recess_period: 10Hz --- #################### # Benchmark Buffer # #################### name: benchmark_buffer components: - name: receiver type: nvidia::gxf::test::MockReceiver - name: entity_buffer type: nvidia::gxf::benchmark::EntityBuffer parameters: receiver: receiver - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: receiver min_size: 1 --- ####################### # Benchmark Publisher # ####################### name: benchmark_publisher components: - name: async_scheduling_term type: nvidia::gxf::AsynchronousSchedulingTerm - type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: transmitter min_size: 1 - name: benchmark_publisher type: nvidia::gxf::benchmark::BenchmarkPublisher parameters: entity_buffer: benchmark_buffer/entity_buffer transmitter: transmitter benchmark_publisher_async_scheduling_term: async_scheduling_term - name: transmitter type: nvidia::gxf::test::MockTransmitter --- #################### # Graph under Test # #################### name: graph_under_test components: - name: receiver type: nvidia::gxf::test::MockReceiver - name: transmitter type: nvidia::gxf::test::MockTransmitter - type: nvidia::gxf::Forward parameters: in: receiver out: transmitter - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: receiver min_size: 1 - type: nvidia::gxf::DownstreamReceptiveSchedulingTerm parameters: transmitter: transmitter min_size: 1 --- ################## # Benchmark Sink # ################## name: benchmark_sink components: - name: receiver type: nvidia::gxf::test::MockReceiver - name: sink type: nvidia::gxf::benchmark::BenchmarkSink parameters: receiver: receiver benchmark_publisher: benchmark_publisher/benchmark_publisher performance_calculators: [basic_metrics] - type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: receiver min_size: 1 - name: basic_metrics type: nvidia::gxf::benchmark::BasicMetricsCalculator --- ############### # Connections # ############### components: - type: nvidia::gxf::Connection parameters: source: data_source/transmitter target: benchmark_buffer/receiver - type: nvidia::gxf::Connection parameters: source: benchmark_publisher/transmitter target: graph_under_test/receiver - type: nvidia::gxf::Connection parameters: source: graph_under_test/transmitter target: benchmark_sink/receiver --- ########## # System # ########## name: system components: - name: clock type: nvidia::gxf::RealtimeClock - type: nvidia::gxf::JobStatistics parameters: clock: clock - type: nvidia::gxf::EventBasedScheduler parameters: clock: clock worker_thread_number: 4", "keywords": []}, {"id": 1980, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GXF_benchmark#target-gxf-graph", "display_name": "Target GXF graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "target-gxf-graph", "priority": -1, "content": "Target GXF graph is a GXF subgraph to be benchmarked. It can contain as simple as one GXF component, or as complex as a GXF application graph", "keywords": []}, {"id": 1981, "doc_id": 1981, "filename": "graphtools-docs/docs/text/GXF_benchmark.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GXF_benchmark", "display_name": "GXF benchmark", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GXF_benchmark", "anchor": "", "priority": -1, "content": "GXF benchmarking can be accomplished with the help of benchmark extension. GXF benchmark extensions have components that allow GXF users to create benchmark applications that can give an insight into the performance outcomes of their GXF component/application designs and implementations.", "keywords": []}, {"id": 1982, "doc_id": 1982, "filename": "graphtools-docs/docs/text/GraphComposer_Acronyms.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Acronyms", "display_name": "Acronyms and Terms", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Acronyms", "anchor": "", "priority": -1, "content": "List of commonly used Acronyms and terms: Term or Abbreviation Definition Extension Dynamic library including collection of components. Graph .yaml file generated by Composer Application One or more graphs GST Gstreamer DS DeepStream UCX Unified Communication - X CLI Command Line Interface Node Entity containing more than one related component Plugin Gstreamer plugin library. A plugin is a software add-on that is installed on a program, enhancing its capabilities. Entity A GXF object. An entity owns multiple components which define its functionality Transmitter An interface for publishing entities Receiver An interface for receiving entities Component A functional block that defines the data and behavior aspects of an entity Connection A link between two components Graph A data-driven representation of an application using entities and connections Sub-graph A graph wrapped in entity as a functional block", "keywords": []}, {"id": 1983, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#backdrop", "display_name": "Backdrop", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "backdrop", "priority": -1, "content": "Backdrop is a tool used to group the nodes in the current graph, which can be created through Drag&amp;Drop from \u201cMiscellaneous\u201d group in the catalog. After a Backdrop rectangle is created, it can be moved and resized to include a number of nodes, so to group them together. Once a Backdrop is created, the nodes inside will be moved altogether while the Backdrop itself is moved. User can rename a Backdrop by double-clicking on its name or change its color through the color picker.", "keywords": []}, {"id": 1984, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#build-container-image", "display_name": "Build Container Image", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "build-container-image", "priority": -1, "content": "A container image can be build through the Composer using the Docker button on the toolbar.", "keywords": []}, {"id": 1985, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#changing-the-component-properties", "display_name": "Changing the Component Properties", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "changing-the-component-properties", "priority": -1, "content": "To select a component, left or right-click on a component or its handles in the graph editor. This displays the component information including its properties in the detail window accordingly, where you can make changes on any writable property. It displays the property name [1], the text field [2] to edit the property, the check box [3] to export a file property to a resource file and another check box [4] to export the property to a different yaml file.", "keywords": []}, {"id": 1986, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#client", "display_name": "Client", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "client", "priority": -1, "content": "On Linux, the following packages may be required on machines where the client is installed: libavcodec , libavformat , libavutil . These packages can be installed using the following command: sudo apt-get install libavcodec57 libavformat57 libavutil55 Windows environments do not require any additional dependencies or configuration, other than ensuring firewall rules do not restrict access to the ports listed above.", "keywords": []}, {"id": 1987, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#comparison-of-available-options", "display_name": "Comparison of available options", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "comparison-of-available-options", "priority": -1, "content": "Technology Devices Benefits Omniverse Streaming Client Windows and Linux Native desktop application. Supports streaming up to 4K at 60 frames per second. WebRTC Web browsers (all devices) Simple to distribute. Strong support across devices and platforms.", "keywords": []}, {"id": 1988, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#component-list", "display_name": "Component List", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "component-list", "priority": -1, "content": "The component list window shows the information of all the available components in various extensions, which are fetched from the remote registry and could be used to build different graphs by the user. It can be grouped in two ways: By default, the list is showed in a two-level hierarchical view grouped by extensions. By Workflows, the list is showed in a two-level hierarchical view grouped by extension categories. You can choose a component from the Component List by a left click on the mouse to display the detailed information of that component in the Property window. The details include the component type, description, details of the extension which includes the component, and the details of the properties supported by the component. The Component List supports direct Drag and Drop , allowing users to create an instance of a specific component in a graph by simply dragging it from the list and dropping to the canvas or a destination node in the graph. If you drops it to the canvas, a default node will be created automatically to accommodate the instance and its input and output port will be initialized as much as possible.", "keywords": []}, {"id": 1989, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#context-menu", "display_name": "Context Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "context-menu", "priority": -1, "content": "Context menu is invoked while a user right-clicks on the canvas with a mouse, which provides the entries to commands bound to the current graph. Menu Items Action Rename the Graph Rename the current graph Export Parameters Export the flagged parameters in the current graph to a file Load Parameters Load the value of parameters from a parameter file Delete Selection Delete the currently selected node Open All Expand all the nodes in the graph with all the details Minimize All Minimize all the nodes in the graph by showing connected ports only Close All Close all the nodes in the graph by hiding all the ports Layout All Automatically layout all the nodes Focus on All Automatically zoom and pan the canvas to fit the entire graph Focus on Selection Automatically zoom and pan the canvas to focus on the current selection", "keywords": []}, {"id": 1990, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#create-new-application", "display_name": "Create New Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "create-new-application", "priority": -1, "content": "Navigate to the File menu from the main window menu bar and choose New Graph , or click the Create Graph` icon from the landing page. An empty graph is created and displayed in the graph canvas.", "keywords": []}, {"id": 1991, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#creating-a-component-instance", "display_name": "Creating a Component Instance", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "creating-a-component-instance", "priority": -1, "content": "Steps to create component instances: Using Drag and Drop To add a new component instance to a graph, find the type of the component from Component List and drag&amp;drop it to the graph canvas. If the component is dropped to the vacant area an entity node will be created automatically to hold the component If the component is dropped to an existing entity node it is going to be added to that entity. Initialize a Handle by Creating a New Component Using Context Menu Through the context menu of a handle, users can choose to Create a new component instance and use it to initialize a handle. Since the compatible components have already been filtered for the specific handle, the list becomes much shorter and it is always recommended to create secondary components including Input and Output through this way.", "keywords": []}, {"id": 1992, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#current-limitations", "display_name": "Current Limitations:", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "current-limitations", "priority": -1, "content": "For a best user experience, it is recommended that only a single User at a time be provided with mouse or keyboard control while others remain in spectator mode. WebRTC Streaming is supported only on RTX GPUs. Copy/paste support is not yet available. The stability of WebRTC streaming is not good enough and Omniverse streaming client is always preferred.", "keywords": []}, {"id": 1993, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#edit-menu", "display_name": "Edit Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "edit-menu", "priority": -1, "content": "Menu Items Action Hot key Delete Remove the selected instance Del Copy Copy the selected instance to the clipboard Ctrl + C Paste Paste the instance from the clipboard to the graph Ctrl + V Undo Undo a command Ctrl + Z Redo Redo a command Ctrl + Y Preferences Set application preferences", "keywords": []}, {"id": 1994, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#editor-features", "display_name": "Editor Features", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "editor-features", "priority": -1, "content": "Zoom and Pan the Canvas The scroll wheel of the mouse enables zoom in and zoom out, and using \u2018ALT\u2019 and left click of the mouse allows users to pan the canvas. Copy and Paste Before doing a Copy , first select a instance from a graph editor, then trigger the operation through Edit menu or corresponding hot key. Copy operation creates a copy of the node instance. When the copy of a node is created, all the components inside the node will be duplicated accordingly, preserving their relationship. There is a global clipboard in the Composer where a copied node is kept temporarily. When a Paste command is triggered, the instance in the clipboard will be added back to the graph. Undo and Redo are supported for following commands: New Node New Component Link a Handle Unlink a Handle Set up a Connection Disconnect an Input/Output Delete a Node Delete a Component Rename a Node Rename a Component Debug View The composer provides an option for users to turn on the debug view on the graph, which represents the graph in the exact same topology its implementation architecture. In the debug view all the abstractions used for visualization simplification have been restored to their raw structures: Connections be expanded to a standalone node with a connection component inside, whose handles be linked to an input component and an output component. Connections cannot be set up from an Output to an Input directly, even after both of them have been linked to some Input and Output components Debug view is useful in inspecting your graph if you notice anything abnormal.", "keywords": []}, {"id": 1995, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#entity-node", "display_name": "Entity Node", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "entity-node", "priority": -1, "content": "An entity node is the container of a group of components who work together to get certain tasks done. Usually there is one primary and several secondary components required by the primary one, including the input, output, and others. An existing node can be deleted from File Menu, the Context Menu of the node or the corresponding hot key. Nodes can be categories based on the roles and types of the components contained inside, different category of nodes will be showed in different style: Node Category Description Example compute General Computing Components Object Analytics cloud Cloud Components Cloud Message Receiver input Input Components Alsa Audio Input neural networks Inference Components with Neural Networks Video Inference output Output Components Alsa Audio Output muxer Muxing/Demuxing Components Stream Muxer utility Utilities RealTimeClock image processing Image Processing Components Video Dewarper", "keywords": []}, {"id": 1996, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#extend-a-graph", "display_name": "Extend a Graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "extend-a-graph", "priority": -1, "content": "Users can extend an open graph by appending a new graph file to it, which is supported in the context menu triggered by a right-click on the graph canvas. While a graph is being extended, new components and nodes in the second graph will be added to the current graph and existing ones will be overridden with new definitions.", "keywords": []}, {"id": 1997, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#file-menu", "display_name": "File Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "file-menu", "priority": -1, "content": "Menu Items Action Hot key New Graph Create an empty graph on the graph canvas Ctrl + N Open Graph Open an existing graph file in the graph canvas Ctrl + O Save Graph Save the current graph to a yaml file Ctrl + S Save Graph As Save the current graph with a different name and path Shift + Ctrl + S Rename Graph Rename the current graph Close Graph Close the current graph Ctrl + W Export Parameters Export the flagged parameters in the current graph to a file Load Parameters Load the value of parameters from a parameter file Exit Quit the application Ctrl + Q", "keywords": []}, {"id": 1998, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#finding-the-right-component", "display_name": "Finding the right component", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "finding-the-right-component", "priority": -1, "content": "Components are grouped by extensions. Information of a specific component and the extension can be found in the details window if you click on the corresponding item showed in the Component List, including its type, the purpose, and supported properties. With the search bar on the top of the Component List window, you can also filter out the candidate components. By choosing the versions from the Version list, the extension with a specific version will be loaded. From Composer perspective, a Component falls into one of the 3 groups below based on the role it plays in the graph: Component Type Description Example Primary Component Compute Components which are executed by scheduler. Decoder Secondary Component Helper components being used by primary ones for data exchange, config, scheduling rules. SinkPad Connection Responsible to connect input and output components Connection Subgraph Component Used to load a subgraph Subgraph Before creating an Application graph, users should always firstly figure out what kind of primary components are needed. Only after all the primary components have been properly picked, they could consider initializing them and then setting up the connections. The component inside an entity node contains: The Component name: can be changed with a double click Handles under the component: displayed under the component if the component could use the other components. Not all the components have handles and the number of handles, their type and names are all predefined by the type of the component itself.", "keywords": []}, {"id": 1999, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#generate-gstreamer-extension", "display_name": "Generate Gstreamer Extension", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "generate-gstreamer-extension", "priority": -1, "content": "If the Deepstream SDK package is not installed, Generate Extension button will be disabled.", "keywords": []}, {"id": 2000, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#graph-menu", "display_name": "Graph Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "graph-menu", "priority": -1, "content": "Menu Items Action Run Graph Run current graph on local or remote machine Stop Graph Stops the execution of the currently running graph Focus Selection Automatically zoom and pan the canvas to focus on the current selection Focus All Automatically zoom and pan the canvas to fit the entire graph Layout All Automatically layout all the nodes Maximize All Expand all the nodes in the graph with all the details Minimize All Minimize all the nodes in the graph by showing connected ports only Close All Close all the nodes in the graph by hiding all the ports Debug View Toggle the Debug View", "keywords": []}, {"id": 2001, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#help-menu", "display_name": "Help Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "help-menu", "priority": -1, "content": "Menu Items Action Graph Composer Docs Open the Graph Composer Documentation from a browser Deepstream Docs Open the Deepstream Documentation from a browser Getting Started Open the Graph Composer Getting Started Guide from a browser About Display versions of the tools", "keywords": []}, {"id": 2002, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#id10", "display_name": "Options", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "id10", "priority": -1, "content": "Options Description Range GStreamer Elements List Comma Separated Elements List Required Target Output Directory Directory where the extension will be generated Required Buttons Description Install Dependencies Install extension development dependencies Generate Generates the extension Build Builds the extension using Bazel", "keywords": []}, {"id": 2003, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#id8", "display_name": "Options", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "id8", "priority": -1, "content": "Runtime Options Options Description Range Configuration File Select a Container Builder configuration file Required Target Config Keys(s) Select a target config key: x86 or aarch64 Required Additional files Path to additional files/directories, separated by comma Optional Working Directory Path to the working directory; on server machine or if running gRPC server locally. Optional Buttons Options Description Create Create a new Container Builder Config File using a template Edit Edit an existing Container Builder Config File Build Build the Container", "keywords": []}, {"id": 2004, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#installation-and-usage", "display_name": "Installation and Usage", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "installation-and-usage", "priority": -1, "content": "To install the Omniverse Streaming Client on user machines: From the Omniverse Launcher, select Exchange from the top-level menu bar. From there, click Omniverse Streaming Client from the left-hand Apps sidebar. In the detail page of Omniverse Streaming Client, click the Install button. Once the download completes, and Omniverse Streaming Client is installed, click the Launch button to start the client. When prompted, enter the IP address or URL of the remote machine which is broadcasting to interact with the remote session:", "keywords": []}, {"id": 2005, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#linking-and-unlinking-components", "display_name": "Linking and Unlinking components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "linking-and-unlinking-components", "priority": -1, "content": "There are two options for a user to initialize a Handle: one is through its context menu, having been mentioned above; the other one is using Link . The Link operation can be done by dragging and dropping a curve from the handle to its required component, meaning the required component must be created at first. As a reverse operation, Users can use Disconnect from the context menu of the target component to break up from its owner, or use Release option from the context menu of a handle to de-initialize it and release the target component. One handle can only be initialized with (or linked to) one component instance at the same time Steps to link or unlink the components: To link two components, left-click with your cursor on an output port (the full circle) in one component and drag a curve to the input port (the half circle) of another component. Links can only be set up among compatible components, which means the type of the link source must be the same type or the base type of a link target. To see the port type, hover the mouse cursor on the port. To remove the link, right click on the input port (the half circle), then choose Disconnect from the context menu.", "keywords": []}, {"id": 2006, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#menu-bar", "display_name": "Menu Bar", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "menu-bar", "priority": -1, "content": "The menu bar on the top of the main window contains the main menus of the Composer, providing entries to execute common commands.", "keywords": []}, {"id": 2007, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#omniverse-streaming-client", "display_name": "Omniverse Streaming Client", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "omniverse-streaming-client", "priority": -1, "content": "Omniverse Streaming Client is a lightweight application allowing Users to connect to Omniverse applications deployed on the network or over the Internet. The application makes it possible to access a broad range of Omniverse applications, even from devices that would otherwise not meet the minimum requirements. Some of these workflows include: Accessing Omniverse applications from low-powered devices or ultrabooks. Facilitating the sharing resources over the network or the Internet, allowing Users to connect to Omniverse applications provisioned by IT resources.", "keywords": []}, {"id": 2008, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#open-and-save-application-graphs", "display_name": "Open and Save Application Graphs", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "open-and-save-application-graphs", "priority": -1, "content": "Be sure the component list is not empty before opening any graph, trying opening a graph file with an empty component list will generate a corrupted graph. To access component information, the Composer must connect to the gxf server either locally or remotely. Users can set the server address through the Edit/Preferences menu. By default, the server is set to run locally with an IP address of 127.0.0.1. If the server is not running, the component list will be empty and a connection error will be displayed in the log. To save the current graph, use the \u2018File\u2019 menu and choose Save the Graph ( Ctrl + S ) or Save the Graph as ( Shift + Ctrl +S ), if the graph has never been saved before or you want to save it to a different file. A file browser dialog pops up prompting you to pick a path in the file system.", "keywords": []}, {"id": 2009, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#options", "display_name": "Options", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "options", "priority": -1, "content": "Options Description Range Platform Config File Select a platform config file. For x86_64, Default value is /opt/nvidia/graph-composer/config/target_x86_64.yaml. For ARM 64, Default value is /opt/nvidia/graph-composer/ config/target_aarch64.yaml Required Comparison of Different Work Flows Work Flow Description Host Requirement Target Requirement Remote Requirement DS Installation Local Execution both the Composer and graphs run on the host machine Ubuntu 22.04 with Nvidia GPU N/A N/A DS 7.1 required on the host Remote Execution the Composer runs on the host machine and graphs on the target machine Ubuntu 22.04 with Nvidia GPU Ubuntu 22.04 on Jetson Xavier/Orin N/A DS 7.1 require on the target Remote Access the Composer runs on the host machine and user access the UI from a remote machine Ubuntu 22.04 with Nvidia GPU Ubuntu 22.04 on Jetson Xavier/Orin Linux/Windows with Browser Support DS 7.1 required on host or target", "keywords": []}, {"id": 2010, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#registry-menu", "display_name": "Registry Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "registry-menu", "priority": -1, "content": "Menu Items Action Sync Repo Sync Repository Clear Cache Clear Registry Cache", "keywords": []}, {"id": 2011, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#remote-access", "display_name": "Remote Access", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "remote-access", "priority": -1, "content": "Composer supports remote access through only one streaming option. 1) Omniverse Streaming Client 2) WebRTC", "keywords": []}, {"id": 2012, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#restrictions", "display_name": "Restrictions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "restrictions", "priority": -1, "content": "Currently the Composer is well supported only on NVIDIA GPU setup.", "keywords": []}, {"id": 2013, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#run-graph", "display_name": "Run Graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "run-graph", "priority": -1, "content": "A Graph can be run through Composer using the Play button on the toolbar. Output of the running graph can be seen on the console window. A running graph can be stopped using the Stop button on the toolbar.", "keywords": []}, {"id": 2014, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#server", "display_name": "Server", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "server", "priority": -1, "content": "To launch Composer with Omniverse Streaming Client, run the following command: composer --enable-streaming ov-streaming Should the host be located on the infrastructure of a third-party Cloud provider, it may additionally be required that the following ports be opened, and that firewall rules allow traffic inbound and outbound traffic: TCP: 47995 to 48012 TCP: 49000 to 49007 TCP: 49100 UDP: 47995 to 48012 UDP: 49000 to 49007", "keywords": []}, {"id": 2015, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#setting-up-a-connection-from-an-input-to-an-output", "display_name": "Setting up a Connection from an Input to an Output", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "setting-up-a-connection-from-an-input-to-an-output", "priority": -1, "content": "A connection represents the data flow from an input component to an output one, and it can be created when a user drags a curve from an output and drop it to a compatible input. It is important to understand that the input and the output of a connection must be compatible, that is to say, the type of data from the output to the input must be exchangeable. Connections can only be set up between two different nodes. Multiple connections are allowed on a single input or output. To remove connections on an Input or Output, users can use the \u201cDisconnect\u201d from the context menu by right clicking on the connection.", "keywords": []}, {"id": 2016, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#subgraph", "display_name": "Subgraph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "subgraph", "priority": -1, "content": "Introduction of the Subgraph concept increases the modularity and reusability of Component based programming significantly. Subgraph is nothing different from a regular graph except that it has exported interfaces which allow it to be re-used in other graphs, and a subgraph itself can also use other subgraphs. When a subgraph is used in other graphs, it will be abstracted as a \u201cSubgraph\u201d type component inside a subgraph node, only the exported interfaces are showed in the same node with all the other details being concealed. Components in the parent graph can interact with the subgraph through those interfaces. Creating a Subgraph Creating a subgraph is similar to creating a regular graph. Once the user has created a regular graph, they can export interfaces so that the graph can be used as a subgraph in other graphs. Additionally, the user can add placeholders to the subgraph, which can be materialized by the parent graph. To export interfaces, users need to right click on the component that is going to be exported as an interface and choose \u201cExport \u2026 as an interface\u201d, before the interface is created users are given a chance to name the interface. Users can also create an interface node through Drag&amp;Drop first, then link it to the component that is going to be exported. To use placeholders, users can drag and drop a Placeholder node to the graph canvas, which holds a prerequisite component and can be used in the graph as a general component. To make the interfaces and placeholders to be effective users must save the graph file. Using a Subgraph In order to use a subgraph in the current graph, the user needs to Drag and Drop a \u201cSubgraph\u201d node from \u201cMiscellaneous\u201d group in the catalog to the canvas, then update the \u201clocation\u201d property to load the subgraph from the filesystem. The location must be a valid file path which could be either absolute or relative to the subgraph search path. In order to make the relative path work correctly with subgraphs user must go to Edit/Preferences menu and set the subgraph search path properly. Users can set multiple file paths as the location for a subgraph by separating them with commas. This is useful when appending multiple graph files to a single subgraph. Viewing a Subgraph A double-click on the subgraph component will trigger a switch of the current graph view to the subgraph view, where the internal details of the subgraph is displayed. A navigation bar will show up on the top of the graph window once a subgraph view is activated so that the user can switch the view between subgraphs and their parent graph.", "keywords": []}, {"id": 2017, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#toolbar", "display_name": "Toolbar", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "toolbar", "priority": -1, "content": "Toolbar on the top of the main window provides shortcuts of available functions of the current graph Toolbar Items Action New Graph Open an empty Graph Editor Window Open Graph Open an existing graph file in an new Graph Editor Window Save Graph Save the current graph Close Graph Close the current graph Run Graph Run current graph on local or remote machine Stop Graph Stops the execution of the currently running graph Container Builder Build container for x86 or aarch64 Export Parameters Export the flagged parameters in the current graph to a file Load Parameters Load the value of parameters from a parameter file Delete Delete the current selection Copy Copy the current selection Paste Paste the current selection Expand Nodes Expand all the nodes in the graph with all the details Minimize Nodes Minimize all the nodes in the graph by showing connected ports only Close Nodes Close all the nodes in the graph by hiding all the ports Focus Selection Automatically zoom and pan the canvas to focus on the current selection Focus All Automatically zoom and pan the canvas to fit the entire graph Layout All Automatically layout all the nodes", "keywords": []}, {"id": 2018, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#tools-menu", "display_name": "Tools Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "tools-menu", "priority": -1, "content": "Menu Items Action Generate Extension Open Generate Extension for Gstreamer Elements window Container Builder Launch the Container Builder", "keywords": []}, {"id": 2019, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#trouble-shooting", "display_name": "Trouble Shooting", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "trouble-shooting", "priority": -1, "content": "Instructions for resolving issues when running the Graph Composer. Component Type not found In some cases users will see such messages as \u201cComponent type invalid\u201d while opening a graph, which means some component types are not available in the current component list thus the loaded graph become incomplete. There are 2 major reasons for the issue: 1. The component list is empty or standalone 2. The graph is not compatible with the latest component list It is recommended for users to close the graph without saving it and perform \u201crepo sync\u201d through the registry menu and try again with the updated list. If the issue still occurs, users should review the graph to figure out which component is missing and replace it with the proper one from the latest component list. Failure During the Repo Sync Sometimes the \u201crepo sync\u201d process takes too long or gets stuck in the middle due to network issues and users can\u2019t close the \u201crepo sync\u201d progress bar, in this case it is recommended to close the Graph Composer app and restart it again. GStreamer Extension not found after building After generating a GStreamer extension, Composer does not show the generated Component name and brief. Currently, Composer shows it as &lt;DISPLAY_NAME&gt; . This is a known issue. However, using the Component is not a problem.", "keywords": []}, {"id": 2020, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#understanding-the-component-handles", "display_name": "Understanding the Component Handles", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "understanding-the-component-handles", "priority": -1, "content": "A component can have handles through which it interact with other components. A handle is essentially a special property supported by the component, and it must be initialized with a component instance of the required type to become functional. There are some special handles called Input and Output who manage the data exchange of a component, and to enable data exchange of a component a user needs to initialize them with appropriate Input and Output components.", "keywords": []}, {"id": 2021, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#user-interface", "display_name": "User Interface", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "user-interface", "priority": -1, "content": "Ref# Option Description 1 File Menu Opens the File Menu 2 Edit Menu Opens the Edit Menu 3 Graph Menu Opens the Graph Menu 4 Registry Menu Opens the Registry Menu 5 Tools Menu Opens the Tools Menu 6 Window Menu Opens the Window Menu 7 Help Menu Opens the Help Menu 8 Toolbar/Shelf Tool buttons for the most frequently used features 9 Graph Canvas A canvas window to create and manipulate a graph 10 Property Window Shows the details on any selected object 11 Extension Grouping Extensions/Components can be grouped by different ways 12 Extension Search Bar A search bar for searching the extensions/components 13 Component Object which can be drag and drop on the graph canvas 14 Node A node on the graph canvas 15 Console Display the console output", "keywords": []}, {"id": 2022, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#webrtc-streaming", "display_name": "WebRTC streaming", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "webrtc-streaming", "priority": -1, "content": "By leveraging the new WebRTC live-streaming, it is now possible to stream Graph Composer to web browsers. Using the WebRTC live-stream is a straightforward process: In a command prompt or terminal, run the command: composer --enable-streaming webrtc Find the IP address of the machine hosting the Graph Composer application on your local network Navigate to the stream page in your favorite web browser: http://&lt;server IP address&gt;:8011/streaming/webrtc-client Click the \u201cplay\u201d button to start streaming your application Sometimes the above URL is not accessible because the port 8011 might have been occupied, in the case we need to replace 8011 with the right HTTP port number displayed in the console. For example, in the following log, the server started on port 8010 instead of 8011 [omni.services.transport.server.http.server] http server was meant to start on 8011 but port is taken, starting on port 8010 instead. Currently there is no feature for security, we assume it is deployed in secure environment", "keywords": []}, {"id": 2023, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Composer#window-menu", "display_name": "Window Menu", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "window-menu", "priority": -1, "content": "Menu Items Action Property Toggle the Property Window Console Toggle the Console Window", "keywords": []}, {"id": 2024, "doc_id": 2024, "filename": "graphtools-docs/docs/text/GraphComposer_Composer.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Composer", "display_name": "Composer", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Composer", "anchor": "", "priority": -1, "content": "The Composer is an GUI application designed to create AI Application pipeline through an easy-to-use graphic interface, reducing the complexity of application development significantly and thus reducing time to market. The Composer is based on the Omniverse SDK which provides a highly responsive hardware-accelerated GUI.", "keywords": []}, {"id": 2025, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#a-basic-example-of-container-builder-configuration", "display_name": "A Basic Example of Container Builder Configuration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "a-basic-example-of-container-builder-configuration", "priority": -1, "content": "This example has 2 sections with a clean_stage build section and a main control section. During stage build: Starts from base_image and installs some debian , python3 packages into the target image Installs archives Copies files from local and other image Finally do some cleanup and environment settings on output target image. The main control section would install the graph dependencies through registry into the target image. You can specify some build options to control the stage build and finally push the target image into the cloud. Here is the sample code with comments inline. # Container dockerfile Stage build section --- # target: x86 # optional, can be used during multi-arch build unique_stage: final_image # required, name must be unique # base_image is required base_image: &quot;nvcr.io/nvidia/deepstream:7.1-triton-multiarch&quot; stage_model: clean_stage # Optional # Install debian packages apt_deps: - curl - ca-certificates - tar - python3 - python3-pip # Install pip3 packages pip3_deps: - PyYAML&gt;=5.4.1 # Copy local files to image local_copy_files: - src: &quot;/opt/nvidia/graph-composer/gxe&quot; # dst: &quot;/opt/nvidia/graph-composer/gxe&quot; - src: &quot;/opt/nvidia/graph-composer/libgxf_core.so&quot; # dst: &quot;/opt/nvidia/graph-composer/libgxf_core.so&quot; # Copy files from other images or other stages stage_copy_files: - src_stage: &quot;nvcr.io/nvidia/deepstream:7.1-samples&quot; src: &quot;/opt/nvidia/deepstream/deepstream/samples&quot; # dst: &quot;/opt/nvidia/deepstream/deepstream/samples&quot; # Download HTTP archives and install http_archives: - url: https://host:port/archive.tar.bz2 curl_option: &quot;-u user:token&quot; post_cmd: &quot;tar -jxvf archive.tar.bz2 -C /&quot; # Clean up operations custom_runs: - &quot;apt autoremove &amp;&amp; ln -s /opt/nvidia/deepstream/deepstream/samples /samples&quot; # Specify WORKDIR work_folder: /workspace/test/ # Specify multiple ENV env_list: PATH: &quot;/opt/nvidia/graph-composer:$PATH&quot; LD_LIBRARY_PATH: &quot;/opt/nvidia/graph-composer/:$LD_LIBRARY_PATH&quot; # specify ENTRYPOINT #entrypoint: [&quot;/opt/nvidia/graph-composer/gxe&quot;] # Container Builder Main Control Section --- # delimiter required container_builder: main # required, any string is ok for name graph: # optional graph_files: [deepstream-test1.yaml] # graph file in local graph_dst: /workspace/test/ # destination path in target image # extension manifest location in target image manifest_dst: /workspace/test/ # extensions installed location in target image ext_install_root: /workspace/test/ # docker build options docker_build: image_name: deepstream_test1:nvgcb_test no_cache: true squash: false # docker push list to cloud, optional # username/password are optional if $docker login already ran docker_push: - url: &quot;nvcr.io/nvidian/user/deepstream_test1:nvgcb_test&quot; Username: password:", "keywords": []}, {"id": 2026, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#a-multi-stage-example", "display_name": "A Multi-Stage Example", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "a-multi-stage-example", "priority": -1, "content": "This example shows a multi-stage build. The download_stage within compile_stage model would download all ONNX models from a private git repo with netrc file for permissions. The final image would copy a specific file out of download_stage into the final image location. The download_stage would be lost as some intermediate layers and the final image is clean to keep minimal dependencies and get rid of netrc files. # use compile_stage to download all models through git --- unique_stage: download_stage base_image: &quot;ubuntu:22.04&quot; stage_model: compile_stage # copy netrc file into compile stage for git clone local_copy_files: - src: &quot;/home/user/.netrc&quot; dst: &quot;/root/.netrc&quot; # download models into folder /download/models git_repo_list: - repo_folder: /downloads/models url: https://privatehost/user/models #a private host require netrc tag: master # use clean_stage for final image output --- # Final Stage unique_stage: final_image base_image: &quot;ubuntu:22.04&quot; stage_model: clean_stage # copy a specific file out of download_stage into final_image stage_copy_files: - src_stage: &quot;download_stage&quot; src: &quot;/downloads/models/modelA.onnx&quot; dst: &quot;/data/modelA.onnx&quot; # Container builder main control settings --- # Container Builder Config container_builder: builder_name # required docker_build: image_name: &quot;cb_multi_stage:cb_test&quot; # specify step orders in case multiple stages out of order stage_steps: [download_stage, final_image] no_cache: true", "keywords": []}, {"id": 2027, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#container-builder-configuration", "display_name": "Container Builder Configuration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "container-builder-configuration", "priority": -1, "content": "The input config file for Container Builder is following YAML1.2 format rules https://yaml.org/spec/1.2/spec.html . There are 2 major YAML document sections in the configuration settings. Container builder main control section - With that, users can specify graph installation options, build/push options and other host side control options. Each config file can have only one control section with key field container_builder: name Container dockerfile stage section - All the sections will be converted into dockerfiles. Users can specify multiple stage sections. There are 2 model templates for different stages. clean_stage model: This is the default model if not specified. The output container image must have a clean_stage section as final stage. Users should keep the final stage as clean as possible. compile_stage model: It is used to do some extra work such as build binaries from source code and to install some compile tools. It should be an intermediate stage, users can specify the clean_stage to copy required binaries from compile_stage. You must store private information safely when building docker images from container builders. Learn more details of docker reference https://docs.docker.com/engine/reference/builder/ to avoid exposing critical layers to the public. MSB(Multi-stage build) is one of the best practices to separate internal source code stage and clean public stage. In container builder, users can use compile_stage to quickly start source code compiling and copy results to clean_stage for the final image. More details refer to https://docs.docker.com/develop/develop-images/multistage-build/", "keywords": []}, {"id": 2028, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#container-builder-features", "display_name": "Container Builder Features", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "container-builder-features", "priority": -1, "content": "The image building is based on docker build. Container builder provides different stage models to build the image. There are compile_stage and clean_stage models for users to select. Some features are applicable for one stage only. For more details, see the feature table. Features Description Stage (compile_stage/clean_stage) Local files/folders copy Copies local files/folders to the current image destination path. both Stage files/folders copy Copies files/folders from other target stages or other image to current image/stage destination path. both Multiple deepstream graph files installation Installs one or more deepstream graph files extensions and relevant files into image N/A, final image Multiple registry repo create/destroy Specifies multiple registry repo list to create and delete N/A, final image Packages installation by apt/pip3 Installs debian package and pip3 packages online both HTTP archives download and installation Downloads HTTP archives and runs custom commands thereafter. both git repo clone and custom build Clones specific branch/tag/commit from repo and does custom build compile_stage only Multiple Stage docker build Builder final target image from multiple stages. N/A, for final image Custom cmdline runs Runs custom commands for on a image stage clean_stage Dockerfile misc Base image Selection and other miscs WORKDIR/ENV/ENTRYPOINT/LABEL clean_stage docker build options Supports platforms, arguments, network, cache, squash N/A, for final image Push Image to cloud Pushes local built image to remote server N/A, for final image Cross platform container build Supports build other platforms(e.g. ARM64) containers from x86_64 N/A", "keywords": []}, {"id": 2029, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#container-builder-main-control-section-specification", "display_name": "Container builder main control section specification", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "container-builder-main-control-section-specification", "priority": -1, "content": "All fields with /*dst ends with \u2018/\u2019 means that is a folder path on the target image. /*src depends on the real source path. Fields Description Type and Range Example Notes container_builder The control section name string, required container_builder: main graph A dictionary with graph file, extension and registry setting dictionary, optional graph: graph_files: [test1.yaml] manifest_dst: /workspace/test/ graph.graphfiles Deepstream gxf graph files in YAML format, which could be generated by Composer list[string], required for graph graph: graph_files: [test1.yaml, test2.yaml] graph.graph_dst Destination in target image for the graph files. If not provided, User can decide to copy from through stage build string, optional graph: graph_dst: /workspace/test1/ Must specify a folder path if multiple graph_files exists. graph.manifest_dst Destination in target image for the manifest files string, required for graph graph: manifest_dst: /workspace/test/ Must specify a folder path if multiple graph_files exists. graph.ext_install_root Destination in target image for graph extensions prefix directory string, optional depends on registry behavior is not set graph: ext_install_root: /opt/nvidia/graph-composer Must specify a folder path docker_build.image_name target image name with tag string, optional if absent, a random name would be used docker_build: image_name: nvgcb_test:21.04 docker_build.no_cache Build with cache or not Cache is disabled by default bool, optional docker_build: no_cache: true docker_build.squash Squash image layers to reduce image size, need enable experimental in docker, check prerequisites. Note: not all layers support squash, if some layers failed, need disable squash bool, optional docker_build: squash: false docker_build.network Network mode for docker build string, optional Default value is host docker_build: network: host docker_build.stage_steps The sequence of stage build sections, available when multi-stage build enabled. list[string], optional If disabled, default sequence is the order of stage sections --- unique_stage: final_stage ... --- unique_stage: download_stage ... --- docker_build: stage_steps: [download_stage, final_stage] docker_push A list of remote image repos for docker to push. each item have a url for remote repo with tag list[dict], optional Must if you intend to use the multi-arch feature docker_push: - url: &quot;nvcr.io/user/repo1:cb_test1&quot; - url: &quot;gitlab/user/repo1:cb_test1&quot; ... docker_push.url Each url is a remote image repo and tag names. string, required for docker_push docker_push: - url: &quot;nvcr.io/user/repo1:cb_test1&quot; docker_push.username username to login the remote repo server Note: it is not required if user already have ran $docker login server:port string, optional docker_push: - url: &quot;nvcr.io/user/repo1:cb_test1&quot; username: &lt;user&gt; docker_push.password text password to login the remote repo server Note: it is not required if user already have ran $docker login server:port string, optional docker_push: - url: &quot;nvcr.io/user/repo1:cb_test1&quot; username: &lt;user&gt; password: &lt;password&gt; docker_push.password_env A variable name of the global OS environment which stores the password. This can avoid user expose text password in config file Note: it is not required if user already have ran $docker login string, optional docker_push: - url: &quot;nvcr.io/user/repo1:cb_test1&quot; username: &lt;user&gt; password_env: &lt;TOKEN&gt; debug Some debug info and reserve some intermediate state dictionary, optional debug: docker_file: /path/to/dockerfile docker_folder: /path/to/docker_folder debug.docker_file Preserve the generated dockerfile for debug string, optional debug: docker_file: /path/to/dockerfile debug.docker_folder Preserve the generated docker folder for debug string, optional debug: docker_folder: /path/to/docker_folder", "keywords": []}, {"id": 2030, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#container-builder-tool-usage", "display_name": "Container Builder Tool Usage", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "container-builder-tool-usage", "priority": -1, "content": "CB (container_builder) tool has very few input arguments. The config file collects all user settings as a YAML format text file. Briefly to generate a container, users need update the config file and run command line, where graph_target_key can be x86 or aarch64 $ container_builder build -c config.yaml -d graph_target_key Container image can also be pushed to remote repository using command $ container_builder push -c config.yaml -d graph_target.yaml See more details of config settings from Configuration Specification. The graph target key corresponds to the graph target configuration, stored in file /opt/nvidia/graph-composer/graph_targets.yaml , which is used by registry during graph install. See registry cli graph install documentation for sample file. The default log print level is INFO and output stream displays on screen. log-level, log-file, and other arguments are used for debug. For more details, refer to help option from the following command $ container_builder -h", "keywords": []}, {"id": 2031, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#container-dockerfile-stage-section-specification", "display_name": "Container dockerfile stage section specification", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "container-dockerfile-stage-section-specification", "priority": -1, "content": "The table below lists both compile_stage and clean_stage sections configuration specification. Most fields are common for both stage models. Only clean_stage should be used for the final stage. In addition, users should keep in mind stages of compile_stage are not optimized and may have extra packages and files not required for final output. All fields with *dst ends with \u2018/\u2019 means that is a folder path on the target image. *src depends on the real source path. Fields Description Type and Range Example Notes Stage compile_stage / clean_stage target A graph target key, which corresponds to a target configuration , used by registry during graph install string, optional Choose from x86 aarch64 target: x86 both unique_stage A unique name on the present stage, It is also used for dockerfile target name string, required unique_stage: final_image both base_image Specify a stage name or a remote/local image for which the current target stage is based on. string, Optional base_image: &quot;ubuntu:22.04&quot; For auto selection based on specified dependencies base_image: &quot;auto&quot; both platform Specify the platform of the base_image in case it has same name in multiple platforms string, optional Choose from linux/amd64 linux/arm64 Default value: linux/amd64 platform: linux/amd64 both stage_model Which stage_model the config file would be used to build this stage string, optional Choose from clean_stage compile_stage Default value: clean_stage stage_model: clean_stage both build_args A dictionary of build arguments on top of the autogenerate d docker file. The arguments could be used for docker and other cmdlines list[string], optional build_args: CURL_PACK: &quot;curl&quot; apt_deps: - &quot;$CURL_PACK&quot; both apt_deps A list of debian package names for apt install list[string], optional apt_deps: - curl - ca-certificates - zip=3.0-11build1 both pip3_deps A list of Python package names for pip3 install. Note: user need specify apt_deps to install python3-pip in config file list[string], optional pip3_deps: - PyGObject - PyYAML - result both resources_files A list of resources files describing resources to copy to the container list[string], optional resources_files: - resources1.yaml - resources2.yaml both local_copy_files A list file names to copy from local files/folders to destination path of stage image list[dict], optional local_copy_files: - src: &quot;/opt/nvidia/graph-composer/gxe&quot; dst: &quot;/opt/nvidia/bin/&quot; - src: deepstream-test1 (a folder in local) dst: &quot;/workspace/deepstream-test1&quot; both local_copy_files.src Specify a file/folder name in the local machine. A relative path is relative to the config file string, optional local_copy_files: - src: &quot;/opt/nvidia/graph-composer/gxe&quot; dst: &quot;/opt/nvidia/bin/&quot; - src: deepstream-test1 dst: &quot;/workspace/deepstream-test1&quot; both local_copy_files.dst Specify an absolute path location in the target image stage. If src is absolute path and dst is empty, dst would be same path as src Read note on top of the section about dst folders policy string, optional Local file example local_copy_files: - src: &quot;/opt/nvidia/graph-composer/gxe&quot; dst: &quot;/opt/nvidia/graph-composer/gxe&quot; Alternatives for dst. 1. dst is empty dst: dst: &quot;/opt/nvidia/graph-composer&quot; 2. local folder example local_copy_files: - src: &quot;/opt/nvidia/samplefolder&quot; dst: &quot;/data/samplefolder&quot; both stage_copy_files A list of StageCopyStr ucture to copy files across multiple stages and multiple images list[dict], optional stage_copy_files: - src_stage: &quot;nvcr.io/public/image:xxxx&quot; src: &quot;/opt/nvidia/samples&quot; An empty dst is same as src path both stage_copy_files.src_stage Specify a stage name or a image name where the src files come from string, optional stage_copy_files: - src_stage: &quot;nvcr.io/public/image:xxxx&quot; src: &quot;/opt/nvidia/samples&quot; - src_stage: &quot;&lt;compile_stage_name&gt;&quot; src: &quot;/opt/nvidia/bin&quot; both stage_copy_files.sr c Specify a file/folder name in src_stage image/stage. Note: absolute path is recommended to avoid conflicts string, optional stage_copy_files: - src_stage: &quot;nvcr.io/public/image:xxxx&quot; src: &quot;/opt/nvidia/samples&quot; both stage_copy_files.dst Specify a file/folder name in target stage. Note: absolute path is recommended to avoid conflicts, an empty dst is same path as src string, optional default: empty value is same path as src stage_copy_files: - src_stage: &quot;nvcr.io/public/image:xxxx&quot; src: &quot;/opt/nvidia/samples&quot; dst: &quot;/opt/nvidia/samples&quot; both http_archives A list of HTTP archive structures to download and custom install. Note: Base image/stage should have curl/ca-certificates otherwise need users specify them in apt_deps. Archives are downloaded into a temp folder and later auto-cleaned. User need specify an absolute path for filename if don\u2019t want it auto-cleaned list[dict], optional http_archives: - url: https://host/download/installer.sh post_cmd: &quot;bash installer.sh&quot; post_env: key: PATH value: &quot;/root/bin:$PATH&quot; - url: https://host/download/sample.mp4 filename: /opt/nvidia/video/sample.mp4 both http_archives.url Specify a url to download the archive string, required for http_archives http_archives: - url: https://host/download/installer.sh both http_archives.filename Rename the downloaded file It could be: a. Empty, parse the last field in the url path as filename and download into a temporary folder and recycle later. b. A filename without a path will make the archive downloaded into a temporary folder and recycled later. c. An absolute path will make the archive downloaded into the path on the target image and keep it there without being recycled. d. A relative path is not supported and causes undefined results. string, optional http_archives: - url: https://host/download/sample.mp4 filename: /opt/nvidia/video/sample.mp4 same as http_archives: - url: https://host/download/sample.mp4 filename: sample.mp4 post_cmd: &quot;cp -a sample.mp4 /opt/nvidia/video/sample.mp4&quot; both http_archives.post_cmd Specify how to install the archive during stage build string, optional http_archives: - url: https://host/download/installer.sh post_cmd: &quot;chmod a+x installer.sh &amp;&amp; ./installer.sh&quot; The default filename is installer.sh both http_archives.post_env Specify a environment setting after download and install this archive The environment variable has a key:string and value:string. key and value settings must follow Linux Shell environment variable rules dict[key, value], optional key:string value: string Refine environment PATH=/root/bin:$PATH http_archives: - url: https://host/download/installer.sh post_cmd: &quot;bash installer.sh&quot; post_env: key: PATH value: &quot;/root/bin:$PATH&quot; both http_archives.curl_option Specify extra curl options(e.g. permissions) while downloading archives. string, optional http_archives: - url: https://host/download/sample.mp4 curl_option: &quot;-u user:token&quot; filename: /data/sample.mp4 An example copy netrc file to image for curl and remove after archives downloaded local_copy_files: - src: &quot;/home/user/.netrc&quot; dst: &quot;/root/.netrc&quot; http_archives: - url: https://host/download/sample.mp4 curl_option: &quot;-n&quot; filename: /data/sample.mp4 custom_runs: - &quot;rm -rf /root/.netrc&quot; both git_repo_list A list of git repo to clone, download and do custom build from source. User can use multi-stage config files to build source code and stage copy binaries to final stage list[dict], optional --- unique_stage: compile_1 stage_model: compile_stage git_repo_list: - url: https://github.com/org/project repo_folder: /workspace/project tag: master build_cmd: &quot;./autogen.sh &amp;&amp; make &amp;&amp; make install&quot; --- unique_stage: final stage_copy_files: - src_stage: compile_1 src: &quot;/usr/local/bin/binary&quot; dst: &quot;/usr/bin/binary&quot; compile_stage only git_repo_list.url Specify a url to git fetch the repo souce code string, required for git_repo_list git_repo_list: - url: https://github.com/org/project compile_stage only git_repo_list.tag Specify a exact tag/branch/co mmit-id of the git repo to fetch string, required for git_repo_li st git_repo_list: - url: https://github.com/org/project tag: master compile_stage only git_repo_list.repo_folder Specify abosulate folder path in target stage to store the repo files string, required for git_repo_li st git_repo_list: - url: https://github.com/org/project tag: master repo_folder: /workspace/project compile_stage only git_repo_list.build_cmd Specify custom shell cmdline how to build and install the repo from source string, optional stage_model: compile_stage git_repo_list: - url: https://github.com/org/project tag: master repo_folder: /workspace/project build_cmd: &quot;./autogen.sh &amp;&amp; make &amp;&amp; make install&quot; compile_stage only ssh_key_host_copy Enable to automatically copy $HOME/.ssh/ config $HOME/.ssh/id_rsa into compile stage /root/.ssh/ and ssh-keyscan all host in git_repo_list Note: It is not recommended to use but could be useful for some git repo requires SSH keys. Users should be careful to enable it since it might expose the private key in the compile stage. string, optional Default value: false ssh_key_host_copy: true compile_stage only work_folder Specify workspace folder in image stage for default folder when launch the container string, optional work_folder: /workspace/deepstream/ both custom_runs A list of custom RUNs at the end of the docker build list[string], optional local_copy_files: - src: &quot;mypackage.deb&quot; dst: &quot;/tmp/&quot; custom_runs: - &quot;dpkg -i /tmp/mypackage.deb &amp;&amp; rm -rf /tmp/*.deb&quot; both disable_run_true Auto generated dockerfile have a RUN true between each copy in locals and stages. It\u2019s a workaround for docker build in some cases report copy errors. It is recommended to keep default value before docker\u2019s fix but still keep an option for users to update. bool, optional Default value: false disable_run_true: false both env_list Specify a list of custom environment settings at the end of docker build list[string], optional env_list: PATH: &quot;/opt/bin/:$PATH&quot; LD_LIBRARY_PATH:&quot;/opt/lib/:$LD_LIBRARY_PATH&quot; DISPLAY: &quot;:0&quot; clean_stage only entrypoint Specify a string list of entrypoint for the image list[string], optional entrypoint: [&quot;/opt/bin/entrypoint.sh&quot;, &quot;param1&quot;] clean_stage only", "keywords": []}, {"id": 2032, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#multiarch-build", "display_name": "Multiarch Build", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "multiarch-build", "priority": -1, "content": "Additionally, CB tool can now build multiarch images. Users can use the following command to achieve the same $ container_builder build -c config_file1.yaml config_file2.yaml -d target_key1 target_key2 -wd [working dir] The users may also skip the target key mentioned in the command if they have specified the target within each of the config files as shown below: %YAML 1.2 --- target: x86 # optional unique_stage: final_image base_image: auto stage_model: clean_stage One thing to note here is the multiarch feature requires the users to mention the docker push configurations as well; otherwise CB will fail to generate the final multiarch image.", "keywords": []}, {"id": 2033, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "prerequisites", "priority": -1, "content": "Install right docker version https://docs.docker.com/engine/install/ubuntu/ log into the server which you might need pull/push images. Run: $ docker login server:port If you need NGC images and resources, follow https://ngc.nvidia.com/setup/api-key to apply permission and get API_KEY token. Then run, $ docker login nvcr.io Some features (e.g. squash) might need docker experimental support. To enable that, update /etc/docker/daemon.json and add { &quot;experimental&quot;: true } Then restart docker by running $ sudo systemctl restart docker If you want to build ARM docker images from x86_64 platform, then need to install QEMU and binfmt . OS restart might be needed. $ sudo apt-get install qemu binfmt-support qemu-user-static $ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes To verify if it is working, run $ docker run --rm -t arm64v8/ubuntu uname -m Install Graph Composer package. Make sure container_builder executable binary is installed.", "keywords": []}, {"id": 2034, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder#run-container-builder", "display_name": "Run Container Builder", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "run-container-builder", "priority": -1, "content": "The following are a basic set of steps to build a container using an existing Container Builder configuration file and execute the container. Update the config file to start the build. Open /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test1/ds_test1_container_builder_dgpu.yaml Specify the right base image with correct DeepStream SDK version for the graph_files . If base image is not specified, container builder will attempt to auto select it from a pool of predefined base images in /opt/nvidia/graph-composer/container_builder.yaml . The container which matches the graph target closest will be selected base_image: &quot;nvcr.io/nvidia/deepstream:x.x-x&quot; Specify the output image name in docker_build section docker_build: image_name: deepstream_test1_dgpu:nvgcb_test Ensure the gxf server has started by running the following command in a terminal: $ systemctl --user status gxf_server The users can also run the gxf_server on a different port by setting the environment variable GXF_SERVER_PORT . Currently, the Container Builder CLI only supports locally running gxf_server while Windows based users or GUI based Graph Composer users can set the remote address to connect to a remotely running gxf_server . Run Container builder tool to build the image: $ container_builder build -c ds_test1_container_builder_dgpu.yaml -d x86 -wd /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test1/ Verify the image and graph in container, use image in config file $ docker run --gpus all -v /tmp/.X11-unix:/tmp/.X11-unix &lt;image_name&gt;", "keywords": []}, {"id": 2035, "doc_id": 2035, "filename": "graphtools-docs/docs/text/GraphComposer_Container_Builder.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "display_name": "Container Builder", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Container_Builder", "anchor": "", "priority": -1, "content": "Container Builder (CB) is used to build docker images for AI Application graphs created using Composer. In addition to docker images, it can also push the final image into the cloud for deployment. Container Builder interacts with Registry : to: Download extensions and other related files into your local system. Copy other required files specified in the config file to generate an intermediate work folder and an optimized dockerfile. Convert archives/packages dependencies and instructions into docker and try to build a minimal sized local image. For optimization, you can easily configure container builder to support multi-stage docker build. Container Builder supports graph installing and container image building on x86 Ubuntu systems. It can also build arm64 images from x86_64 platforms - to do this, you will need to install QEMU and bintutils .", "keywords": []}, {"id": 2036, "doc_id": 2037, "filename": "graphtools-docs/docs/text/GraphComposer_Containers.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Containers#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Containers", "anchor": "prerequisites", "priority": -1, "content": "Install docker-ce by following the official instructions . Once you have installed docker-ce , follow the post-installation steps to ensure that the docker can be run without sudo . Install nvidia-container-toolkit by following the install-guide . Get an NGC account and API key: Go to NGC and search the GXF in the Container tab. This message is displayed: \u201cSign in to access the PULL feature of this repository\u201d. Enter your Email address and click Next , or click Create an Account . Choose your organization when prompted for Organization/Team . Click Sign In . Log in to the NGC docker registry ( nvcr.io ) using the command docker login nvcr.io and enter the following credentials: a. Username: &quot;$oauthtoken&quot; b. Password: &quot;YOUR_NGC_API_KEY&quot; where YOUR_NGC_API_KEY corresponds to the key you generated from step 3. Sample commands to run a docker container: # Pull the required docker. Refer the table - &quot;Docker Containers details&quot; to get docker container name. $ docker pull &lt;docker container name&gt; # Step to run the docker $ export DISPLAY=:0 $ xhost + $ docker run -it --rm --net=host --gpus all -e DISPLAY=$DISPLAY --device /dev/snd -v /tmp/.X11-unix/:/tmp/.X11-unix &lt;required docker container name&gt; Table below lists the docker containers for GXF runtime and development: Container Container pull commands Multiarch docker for x86 and Jetson that provides all the required external dependencies. graph_composer-runtime-4.1.0_*.deb has to be installed based on the platform docker pull nvcr.io/nvidia/deepstream:7.1-samples-multiarch Triton devel docker that contains Graph composer and DeepStream SDK along with a development environment for building GXF applications docker pull nvcr.io/nvidia/deepstream:7.1-gc-triton-devel", "keywords": []}, {"id": 2037, "doc_id": 2037, "filename": "graphtools-docs/docs/text/GraphComposer_Containers.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Containers", "display_name": "Graph Composer and GXF Containers", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Containers", "anchor": "", "priority": -1, "content": "Docker containers for runtime and development are now available for dGPU - x86_64 platform. These containers provide a convenient, out-of-the-box way to develop/deploy GXF applications by packaging all associated dependencies within the container. The associated Docker images are hosted on the NVIDIA container registry in the NGC web portal at https://ngc.nvidia.com . They use the nvidia-docker package, which enables access to the required GPU resources from containers. This section describes the features supported by the GXF Docker containers.", "keywords": []}, {"id": 2038, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#create-and-test-graph", "display_name": "Create and test graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "create-and-test-graph", "priority": -1, "content": "Drag and drop newly created components from the component list to the graph window and link to other components to create a complete application. Save and execute the graph as demonstrated in Graph Composer", "keywords": []}, {"id": 2039, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#generate-an-extension-for-gxf-wrapper-of-gstelement", "display_name": "Generate an extension for GXF wrapper of GstElement", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "generate-an-extension-for-gxf-wrapper-of-gstelement", "priority": -1, "content": "This requires the DeepStream 7.1 SDK and Reference Graphs package to be installed or use DeepStream 7.1 devel container image. Create a text file containing the list of GStreamer elements for which the extensions are to be generated, with name of one element per line. The listed elements must be installed on the system. Following is an example: timeoverlay filesrc filesink To list all the GStreamer elements installed on the system, run gst-inspect-1.0 Next, to generate the extension source code, run python3 /opt/nvidia/deepstream/deepstream/tools/graph_extension_generator/generate_extensions.py &lt;element_list.txt&gt; &lt;output-directory&gt; Navigate to the output directory cd &lt;output-directory&gt; Run the following command to build and register the extension for x86_64 bazel build ... Run the following command to build and register the extension for Jetson bazel build ... --config=jetson If the extension build fails because of git clone errors from freedesktop gitlab repository with errors like fatal: unable to access &#x27;https://gitlab.freedesktop.org/gstreamer/common.git/&#x27;: server certificate verification failed. CAfile: none CRLfile: none , temporarily disable git SSL verification by running export GIT_SSL_NO_VERIFY=true before running bazel build command", "keywords": []}, {"id": 2040, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#id2", "display_name": "Using Composer UI", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "id2", "priority": -1, "content": "Composer UI currently supports generating DeepStream (GStreamer) based extensions only. If the Deepstream SDK package is not installed, Generate Extension button will be disabled. To start, open the Tools menu from the menubar at the top and select Generate Extension . This will launch the Extension Generator dialog. The extension generator needs some dependencies to be installed. This can be done by clicking on the Install Dependencies button. This only needs to be done once on a machine. This is not required when running from the DeepStreamSDK development docker since the dependencies pre-installed. Next, type in the comma-separated list of GStreamer elements for which corresponding extensions must be generated. Select the output directory using the file browser. Click on Generate first to generate the extension source code at the selected directory and then Build to build and register the extensions. The progress will be reported via logs in the console window. If the extension build fails because of git clone errors from freedesktop gitlab repository with errors like fatal: unable to access &#x27;https://gitlab.freedesktop.org/gstreamer/common.git/&#x27;: server certificate verification failed. CAfile: none CRLfile: none , temporarily disable git SSL verification by: Closing the composer and then export GIT_SSL_NO_VERIFY=true before starting the composer from the same shell session OR git config --global http.sslVerify false to disable git SSL verification machine-wide and retrying Build . This does not require the composer to be restarted. To re-enable, run git config --global http.sslVerify true . After extension build is done, newly added extensions will appear in the component list", "keywords": []}, {"id": 2041, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#running-the-sample-application", "display_name": "Running the sample application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "running-the-sample-application", "priority": -1, "content": "Graph Composer package provides tool to execute applications. The execute_graph.sh script located at /opt/nvidia/graph-composer/execute_graph.sh helps install the graph using registry and then executes it. $ /opt/nvidia/graph-composer/execute_graph.sh --help $ /opt/nvidia/graph-composer/execute_graph.sh -d /opt/nvidia/graph-composer/config/target_x86_64.yaml apps/app.yaml This will print the following logs generated by the test component among others INFO extensions/test/HelloWorld.cpp@9: HelloWorld::start INFO extensions/test/HelloWorld.cpp@14: HelloWorld::tick Replace implementation in tick() and start() with custom implementation.", "keywords": []}, {"id": 2042, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#sample-gxf-application", "display_name": "Sample GXF Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "sample-gxf-application", "priority": -1, "content": "The tool also generates a sample application which executes the HelloWorld codelet 10 times and exits. application yaml file - apps/app.yaml %YAML 1.2 --- dependencies: - extension: test uuid: d8629d82-2909-316d-a9ee-7410c8c1a7b6 version: 1.0.0 --- name: source components: - name: signal type: sample::test::HelloWorld - type: nvidia::gxf::CountSchedulingTerm parameters: count: 10 --- components: - type: nvidia::gxf::GreedyScheduler parameters: realtime: false max_duration_ms: 1000000 Entities are defined in the yaml file. Each entity will have one or more components associated with it. Any entity defined in the yaml file needs to be scheduled by a scheduler. The sample makes use of Greedy Scheduler . All schedulers are associated with a clock and RealtimeClock is chosen.", "keywords": []}, {"id": 2043, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#sample-gxf-extension", "display_name": "Sample GXF Extension", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "sample-gxf-extension", "priority": -1, "content": "Graph Composer package provides a useful tool to help create new extensions and components. The extension-dev project located at /opt/nvidia/graph-composer/extension-dev/ helps create the boiler plate code required to create custom extensions. Check LICENSE.txt for the corresponding licenses. A script has been provided to generate a sample extension with a codelet and a graph to test the extension within an application. The generated extension contains a single codelet component that logs a message in the start() and tick() methods once and the graph finishes execution. To use the script, run the following commands. Generate sample extension called test with a codelet named HelloWorld $ python3 /opt/nvidia/graph-composer/extension-dev/generate_codelet.py \\ --output_dir /tmp/ --extn_name test --codelet_name HelloWorld $ cd /tmp/test Within the target directory, the following files are autogenerated: codelet (component), extension and an application. The BUILD files needed to generate the extension libraries using bazel build system are also generated. . |____WORKSPACE |____.bazelrc |____apps | |____app.yaml |____extensions | |____test | | |____BUILD | | |____HelloWorld.hpp | | |____test.cpp | | |____HelloWorld.cpp Header file - hello_world.hpp #pragma once #include &quot;gxf/std/codelet.hpp&quot; namespace sample { namespace test { // Logs a message in start() and tick() class HelloWorld : public nvidia::gxf::Codelet { public: gxf_result_t start() override; gxf_result_t tick() override; gxf_result_t stop() override { return GXF_SUCCESS; } }; } // namespace test } // namespace sample cpp file - hello_world.cpp #include &quot;HelloWorld.hpp&quot; // NOLINT namespace sample { namespace test { gxf_result_t HelloWorld::start() { GXF_LOG_INFO(&quot;HelloWorld::start&quot;); return GXF_SUCCESS; } gxf_result_t HelloWorld::tick() { GXF_LOG_INFO(&quot;HelloWorld::tick&quot;); return GXF_SUCCESS; } } // namespace test } // namespace sample extension cpp file - test.cpp #include &quot;HelloWorld.hpp&quot; #include &quot;gxf/std/extension_factory_helper.hpp&quot; GXF_EXT_FACTORY_BEGIN() GXF_EXT_FACTORY_SET_INFO(0xd8629d822909316d, 0xa9ee7410c8c1a7b6, &quot;test&quot;, &quot;A Dummy Example&quot;, &quot;&quot;, &quot;1.0.0&quot;, &quot;NVIDIA&quot;); GXF_EXT_FACTORY_ADD(0xd39d70014cab3ecf, 0xb397c9d200cf9e8d, sample::test::HelloWorld, nvidia::gxf::Codelet, &quot;Dummy example source codelet.&quot;); GXF_EXT_FACTORY_END() Build the extension for both x86 (default) and the aarch64 (jetson) platforms. The tool also generates a workspace file which creates a bazel workspace to compile and execute the extension. It also includes a target for registering the extension to the local workspace. The extension can then be used from Composer to create graph or by container builder to deploy the graph. ` $ cd &lt;extension_path&gt; $ bazel build ... # For building x86 variant $ bazel build ... --config=jetson # For building jetson(aarch64) variant `", "keywords": []}, {"id": 2044, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#sync-extensions", "display_name": "Sync Extensions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "sync-extensions", "priority": -1, "content": "Before any extension can be built or graph created, extensions from NGC public repo must be sync\u2019ed. Follow the steps below to sync the extensions:", "keywords": []}, {"id": 2045, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#using-commandline", "display_name": "Using commandline", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "using-commandline", "priority": -1, "content": "Sync published extensions from NVIDIA Cloud repository using following command: registry repo sync -n ngc-public Check the extensions using following commands: registry extn list registry comp list Refer to the Registry Command Line Interface for more commands.", "keywords": []}, {"id": 2046, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow#using-composer-ui", "display_name": "Using Composer UI", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "using-composer-ui", "priority": -1, "content": "Open the Registry menu from the menubar at the top and click on Sync Repo Select ngc-public from the drop-down list and click on Sync Composer will report the current status using a progress bar Once the extension sync is complete, composer will display a success message. On clicking close, composer will automatically refresh component list and the refreshed list can be seen in the component list window on the right", "keywords": []}, {"id": 2047, "doc_id": 2047, "filename": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "display_name": "Extension Development Workflow", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Dev_Workflow", "anchor": "", "priority": -1, "content": "The graph composer tool can be used to create an application using GXF standard or public extensions. However, quite often, a custom codelet may also be required to be developed based on specific needs. This workflow is for custom extension developers. It allows developers to implement new functionality and add business logic to applications through graph. There are two options to for developing extensions and application graphs: Native workstation DeepStream SDK devel container image When developing on native workstation, install pre-requisites for extension generation and build: /opt/nvidia/graph-composer/extension-dev/install_dependencies.sh sudo apt-get update &amp;&amp; sudo apt-get -y install libtool autoconf gtk-doc-tools Using the DeepStreamSDK development container image. The image has all the dependencies already installed: docker pull nvcr.io/nvidia/deepstream:7.1-gc-triton-devel xhost + docker run -it --entrypoint /bin/bash --gpus all --rm --network=host -e DISPLAY=${DISPLAY} -v /tmp/.X11-unix/:/tmp/.X11-unix --privileged -v /var/run/docker.sock:/var/run/docker.sock nvcr.io/nvidia/deepstream:7.1-gc-triton-devel In both the cases, either commandline or Composer UI can used. To launch composer, run: composer When using the Composer from the devel container image, users could have a problem browsing the \u201c/\u201d folder from the file browser, in this case they can just type the file path directly or copy and paste it.", "keywords": []}, {"id": 2048, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#can-i-run-composer-on-igpu", "display_name": "Can I run Composer on iGPU?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "can-i-run-composer-on-igpu", "priority": -1, "content": "Yes, Composer is supported on Intel GPUs (HD Graphics 540) or higher. It can be run using command prompt or terminal, by running command composer.exe --enable-vulkan .", "keywords": []}, {"id": 2049, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#composer-throws-the-error-registry-model-update-failed-in-the-console", "display_name": "Composer throws the error Registry Model update failed in the console", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "composer-throws-the-error-registry-model-update-failed-in-the-console", "priority": -1, "content": "You need to run the gxf_server systemd service in order for Composer to sync extensions from Registry, for Container Builder to run and to execute graphs.", "keywords": []}, {"id": 2050, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#container-builder-fails-to-run-with-the-following-error", "display_name": "Container builder fails to run with the following error:", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "container-builder-fails-to-run-with-the-following-error", "priority": -1, "content": "ContainerBuilder.__main__ - ERROR - gRPC client: StatusCode.UNAVAILABLE- failed to connect to all addresses. Please check if connecting to the correct port or close all connections to the port and restart the server. You need to start gxf server for Container Builder to run. Use systemctl --user start gxf_server to start the gxf server.", "keywords": []}, {"id": 2051, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#during-container-builder-installing-graphs-sometimes-there-are-unexpected-errors-happening-while-downloading-manifests-or-extensions-from-registry-and-once-it-happens-container-builder-may-return-errors-again-and-again-how-to-clean-and-restart", "display_name": "During container builder installing graphs, sometimes there are unexpected errors happening while downloading manifests or extensions from registry. And once it happens, container builder may return errors again and again. How to clean and restart?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "during-container-builder-installing-graphs-sometimes-there-are-unexpected-errors-happening-while-downloading-manifests-or-extensions-from-registry-and-once-it-happens-container-builder-may-return-errors-again-and-again-how-to-clean-and-restart", "priority": -1, "content": "Some timeout errors during extensions downloads in the registry might cause information loss. This could stop container builder to re-add repos into registry. Just restarting the container builder may not solve the issue. When it happens, users need to manually clean up the registry repo and restart container builder again. For example, use cmdline gxf_registry repo remove --name [repo_name] to remove the repo. Read more details from Registry section.", "keywords": []}, {"id": 2052, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#how-can-i-change-the-location-of-the-registry-logs", "display_name": "How can I change the location of the registry logs?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "how-can-i-change-the-location-of-the-registry-logs", "priority": -1, "content": "Currently, registry logs are located at /tmp . You can change this location by setting an environment variable called TMPDIR to an existing directory. e.g. $mkdir -p /home/$USER/tmp &amp;&amp; export TMPDIR=/home/$USER/tmp", "keywords": []}, {"id": 2053, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#how-can-i-know-which-extensions-synchronized-to-registry-cache-correspond-to-a-specific-repository", "display_name": "How can I know which extensions synchronized to registry cache correspond to a specific repository?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "how-can-i-know-which-extensions-synchronized-to-registry-cache-correspond-to-a-specific-repository", "priority": -1, "content": "The extn list -r &lt;repo-name&gt; cli command lists all the extension for a specific repository.", "keywords": []}, {"id": 2054, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#how-can-i-view-the-logs-for-the-gxf-server", "display_name": "How can I view the logs for the GXF Server?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "how-can-i-view-the-logs-for-the-gxf-server", "priority": -1, "content": "To troubleshoot or monitor the GXF Server, you can view its logs using the journalctl command: journalctl --user-unit=gxf_server This command will display all the logs related to the gxf server, including startup messages, error reports, and other runtime information. Additionally, To view the most recent logs: journalctl --user-unit=gxf_server -n 50 To follow the logs in real-time: journalctl --user-unit=gxf_server -f To search for specific terms or patterns within the logs: journalctl --user-unit=gxf_server | grep &quot;keyword&quot; ( Replace \u201ckeyword\u201d with the term you\u2019re looking for )", "keywords": []}, {"id": 2055, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#how-do-i-start-stop-and-restart-the-gxf-server", "display_name": "How do I start, stop and restart the GXF Server?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "how-do-i-start-stop-and-restart-the-gxf-server", "priority": -1, "content": "The GXF Server is managed by systemd, which controls the starting, stopping, and restarting of the service. You can use the following systemctl commands to interact with the gxf server. Start the GXF Server: systemctl --user start gxf_server Stop the GXF Server: systemctl --user stop gxf_server Restart the GXF Server: systemctl --user restart gxf_server", "keywords": []}, {"id": 2056, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#how-to-add-new-extension", "display_name": "How to add new extension?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "how-to-add-new-extension", "priority": -1, "content": "See the Extension Development Workflow for information on adding new extension.", "keywords": []}, {"id": 2057, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#in-the-list-of-local-copy-files-if-src-is-a-folder-any-difference-for-dst-ends-with-or-not", "display_name": "In the list of local_copy_files, if src is a folder, Any difference for dst ends with \u2018/\u2019 or not?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "in-the-list-of-local-copy-files-if-src-is-a-folder-any-difference-for-dst-ends-with-or-not", "priority": -1, "content": "No. There is no difference for dst . It must be a folder to store src content.", "keywords": []}, {"id": 2058, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#in-the-main-control-section-why-is-the-field-container-builder-required", "display_name": "In the main control section, why is the field container_builder required?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "in-the-main-control-section-why-is-the-field-container-builder-required", "priority": -1, "content": "It is used to distinguish the main control and the stage sections. Any name for container_builder should be ok.", "keywords": []}, {"id": 2059, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#is-the-gxf-server-automatically-restarted-if-it-fails", "display_name": "Is the GXF Server automatically restarted if it fails?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "is-the-gxf-server-automatically-restarted-if-it-fails", "priority": -1, "content": "Yes, the GXF Server is configured to automatically restart if it fails or stops for any reason.", "keywords": []}, {"id": 2060, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#regarding-git-source-code-compiling-in-compile-stage-is-it-possible-to-compile-source-from-http-archives", "display_name": "Regarding git source code compiling in compile_stage, Is it possible to compile source from HTTP archives?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "regarding-git-source-code-compiling-in-compile-stage-is-it-possible-to-compile-source-from-http-archives", "priority": -1, "content": "You may add compile cmdline into post_cmd . Then copy the compiled binary into the final stage. --- unique_stage: compile base_image: &quot;ubuntu:22.04&quot; stage_model: compile_stage http_archives: - url: https://host:port/source.tar.bz2 post_cmd: &quot;tar -jxvf source.tar.bz2 &amp;&amp; make &amp;&amp; make install&quot; --- unique_stage: final base_image: &quot;ubuntu:22.04&quot; stage_model: clean_stage stage_copy_files: - src_stage: &quot;compile&quot; src: &quot;/usr/local/bin/binary&quot; src: &quot;/usr/bin/binary\u201d", "keywords": []}, {"id": 2061, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#the-registry-failed-to-perform-an-operation-and-reported-an-error-message-how-can-i-get-more-information-on-why-the-operation-failed", "display_name": "The registry failed to perform an operation and reported an error message. How can I get more information on why the operation failed?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "the-registry-failed-to-perform-an-operation-and-reported-an-error-message-how-can-i-get-more-information-on-why-the-operation-failed", "priority": -1, "content": "The registry logs all of its operations in /tmp/gxf_registry.log file. You can use this to view the debug logs.", "keywords": []}, {"id": 2062, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#unable-to-right-click-in-composer-when-run-through-ov-streaming", "display_name": "Unable to right-click in composer when run through ov-streaming?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "unable-to-right-click-in-composer-when-run-through-ov-streaming", "priority": -1, "content": "This is a known limitation of omniverse streaming. Users are advised to use the Menu bar and the Toolbar.", "keywords": []}, {"id": 2063, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#unable-to-start-the-composer-in-deepstream-development-docker", "display_name": "Unable to start the composer in deepstream development docker?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "unable-to-start-the-composer-in-deepstream-development-docker", "priority": -1, "content": "Allow access to X server using xhost + . Launch the docker using the following arguments: docker run -it --rm --net=host --gpus all -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix --privileged -v /var/run/docker.sock:/var/run/docker.sock &lt;DOCKER-REPOSITORY&gt;:&lt;TAG&gt; Launch the composer using composer .", "keywords": []}, {"id": 2064, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#what-happens-if-unsupported-fields-are-added-into-each-section-of-the-yaml-file", "display_name": "What happens if unsupported fields are added into each section of the YAML file?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "what-happens-if-unsupported-fields-are-added-into-each-section-of-the-yaml-file", "priority": -1, "content": "Container builder would skip all unsupported fields in YAML config. Users should take responsibility to set correct fields and values. For example, if entrypoint is added into compile_stage , it would be skipped.", "keywords": []}, {"id": 2065, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#what-is-the-gpu-requirement-for-running-the-composer", "display_name": "What is the GPU requirement for running the Composer?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "what-is-the-gpu-requirement-for-running-the-composer", "priority": -1, "content": "There is no specific GPU requirement to run the Composer. A more powerful NVIDIA dGPU will provide better user experience.", "keywords": []}, {"id": 2066, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#why-am-i-getting-error-libcudart-so-12-cannot-open-shared-object-file-no-such-file-or-directory", "display_name": "Why am I getting Error: libcudart.so.12: cannot open shared object file: No such file or directory?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "why-am-i-getting-error-libcudart-so-12-cannot-open-shared-object-file-no-such-file-or-directory", "priority": -1, "content": "Most likely you don\u2019t have CUDA 12 installed. Please follow the instructions here to install it.", "keywords": []}, {"id": 2067, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#why-cant-i-paste-a-component-after-copied-one", "display_name": "Why can\u2019t I paste a component after copied one?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "why-cant-i-paste-a-component-after-copied-one", "priority": -1, "content": "To successfully paste a component, you must first select its containing node.", "keywords": []}, {"id": 2068, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_FAQ#why-i-cannot-run-websocket-streaming-with-composer", "display_name": "Why I cannot run WebSocket Streaming with Composer?", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "why-i-cannot-run-websocket-streaming-with-composer", "priority": -1, "content": "WebSocket Streaming is no longer supported with Composer.", "keywords": []}, {"id": 2069, "doc_id": 2069, "filename": "graphtools-docs/docs/text/GraphComposer_FAQ.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_FAQ", "display_name": "FAQ", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_FAQ", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2070, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::connect", "display_name": "Application::connect", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4N11Application7connectENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  Application :: connect std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  source std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  target std :: vector &lt; SegmentPortPair &gt;  port_maps Segments are connected via SegmentPortPair to form a global segment connection map. It\u2019s a vector of connection because we support more than one connection between a pair of segments. For the most common case, the port_maps size is 1, i.e. there is only one connection between source and target segment. Please note it is normal that source and target segments are not enabled in the same application instance, the app instance that enables the segment automatically completes corresponding ucx components. And GraphDriver later resolves the connection address between the two instances. Segment config Segment config is a YAML file consisting of one node with identifier segment_config . There are 3 member types: segment_config.member: enabled_segments Mandatory. Specify the segment by name when create in source code. segment_config.member: worker Mandatory. Specify driver IP and port; optionally specify its own port. segment_config.member: driver Optional. Driver member can be enabled in any app instance or a standalone instance. For example, we can run the same SampleSegmentApp executable binary in 3 remote processes and each process executes one segment from the app. Process 1 to run TxSegment; Process 2 to run FwdSegment; Process 3 to run RxSegment. segment config for instance in process 1: --- segment_config: - member: enabled_segments parameters: enabled: - TxSegment - member: worker parameters: enabled: True name: worker_Tx port: 50001 driver_ip: &quot;localhost&quot; driver_port: 50000 - member: driver parameters: enabled: True name: driver_50000 port: 50000 segment config for instance in process 2: --- segment_config: - member: enabled_segments parameters: enabled: - FwdSegment - member: worker parameters: enabled: True name: worker_Fwd port: 50002 driver_ip: &quot;localhost&quot; driver_port: 50000 segment config for instance in process 3: --- segment_config: - member: enabled_segments parameters: enabled: - RxSegment - member: worker parameters: enabled: True name: worker_Rx port: 50003 driver_ip: &quot;localhost&quot; driver_port: 50000 The distributed execution in C++ App API is facing segfault after finishing execution during destroy; The equivalent YAML API execution doesn\u2019t observe the issue. The same Python App API for distributed execution will be available in future release. [Coming Soon] More sample applications will be available in GXF github repo https://github.com/NVIDIA-AI-IOT/deepstream_gxf_ref_apps", "keywords": []}, {"id": 2071, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::connect::port_maps", "display_name": "Application::connect::port_maps", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4N11Application7connectENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  Application :: connect std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  source std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  target std :: vector &lt; SegmentPortPair &gt;  port_maps Segments are connected via SegmentPortPair to form a global segment connection map. It\u2019s a vector of connection because we support more than one connection between a pair of segments. For the most common case, the port_maps size is 1, i.e. there is only one connection between source and target segment. Please note it is normal that source and target segments are not enabled in the same application instance, the app instance that enables the segment automatically completes corresponding ucx components. And GraphDriver later resolves the connection address between the two instances. Segment config Segment config is a YAML file consisting of one node with identifier segment_config . There are 3 member types: segment_config.member: enabled_segments Mandatory. Specify the segment by name when create in source code. segment_config.member: worker Mandatory. Specify driver IP and port; optionally specify its own port. segment_config.member: driver Optional. Driver member can be enabled in any app instance or a standalone instance. For example, we can run the same SampleSegmentApp executable binary in 3 remote processes and each process executes one segment from the app. Process 1 to run TxSegment; Process 2 to run FwdSegment; Process 3 to run RxSegment. segment config for instance in process 1: --- segment_config: - member: enabled_segments parameters: enabled: - TxSegment - member: worker parameters: enabled: True name: worker_Tx port: 50001 driver_ip: &quot;localhost&quot; driver_port: 50000 - member: driver parameters: enabled: True name: driver_50000 port: 50000 segment config for instance in process 2: --- segment_config: - member: enabled_segments parameters: enabled: - FwdSegment - member: worker parameters: enabled: True name: worker_Fwd port: 50002 driver_ip: &quot;localhost&quot; driver_port: 50000 segment config for instance in process 3: --- segment_config: - member: enabled_segments parameters: enabled: - RxSegment - member: worker parameters: enabled: True name: worker_Rx port: 50003 driver_ip: &quot;localhost&quot; driver_port: 50000 The distributed execution in C++ App API is facing segfault after finishing execution during destroy; The equivalent YAML API execution doesn\u2019t observe the issue. The same Python App API for distributed execution will be available in future release. [Coming Soon] More sample applications will be available in GXF github repo https://github.com/NVIDIA-AI-IOT/deepstream_gxf_ref_apps", "keywords": []}, {"id": 2072, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::connect::source", "display_name": "Application::connect::source", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4N11Application7connectENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  Application :: connect std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  source std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  target std :: vector &lt; SegmentPortPair &gt;  port_maps Segments are connected via SegmentPortPair to form a global segment connection map. It\u2019s a vector of connection because we support more than one connection between a pair of segments. For the most common case, the port_maps size is 1, i.e. there is only one connection between source and target segment. Please note it is normal that source and target segments are not enabled in the same application instance, the app instance that enables the segment automatically completes corresponding ucx components. And GraphDriver later resolves the connection address between the two instances. Segment config Segment config is a YAML file consisting of one node with identifier segment_config . There are 3 member types: segment_config.member: enabled_segments Mandatory. Specify the segment by name when create in source code. segment_config.member: worker Mandatory. Specify driver IP and port; optionally specify its own port. segment_config.member: driver Optional. Driver member can be enabled in any app instance or a standalone instance. For example, we can run the same SampleSegmentApp executable binary in 3 remote processes and each process executes one segment from the app. Process 1 to run TxSegment; Process 2 to run FwdSegment; Process 3 to run RxSegment. segment config for instance in process 1: --- segment_config: - member: enabled_segments parameters: enabled: - TxSegment - member: worker parameters: enabled: True name: worker_Tx port: 50001 driver_ip: &quot;localhost&quot; driver_port: 50000 - member: driver parameters: enabled: True name: driver_50000 port: 50000 segment config for instance in process 2: --- segment_config: - member: enabled_segments parameters: enabled: - FwdSegment - member: worker parameters: enabled: True name: worker_Fwd port: 50002 driver_ip: &quot;localhost&quot; driver_port: 50000 segment config for instance in process 3: --- segment_config: - member: enabled_segments parameters: enabled: - RxSegment - member: worker parameters: enabled: True name: worker_Rx port: 50003 driver_ip: &quot;localhost&quot; driver_port: 50000 The distributed execution in C++ App API is facing segfault after finishing execution during destroy; The equivalent YAML API execution doesn\u2019t observe the issue. The same Python App API for distributed execution will be available in future release. [Coming Soon] More sample applications will be available in GXF github repo https://github.com/NVIDIA-AI-IOT/deepstream_gxf_ref_apps", "keywords": []}, {"id": 2073, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::connect::target", "display_name": "Application::connect::target", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4N11Application7connectENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt10shared_ptrIN6nvidia3gxf7SegmentEEENSt6vectorI15SegmentPortPairEE", "priority": 1, "content": "Expected &lt; void &gt;  Application :: connect std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  source std :: shared_ptr &lt; nvidia :: gxf :: Segment &gt;  target std :: vector &lt; SegmentPortPair &gt;  port_maps Segments are connected via SegmentPortPair to form a global segment connection map. It\u2019s a vector of connection because we support more than one connection between a pair of segments. For the most common case, the port_maps size is 1, i.e. there is only one connection between source and target segment. Please note it is normal that source and target segments are not enabled in the same application instance, the app instance that enables the segment automatically completes corresponding ucx components. And GraphDriver later resolves the connection address between the two instances. Segment config Segment config is a YAML file consisting of one node with identifier segment_config . There are 3 member types: segment_config.member: enabled_segments Mandatory. Specify the segment by name when create in source code. segment_config.member: worker Mandatory. Specify driver IP and port; optionally specify its own port. segment_config.member: driver Optional. Driver member can be enabled in any app instance or a standalone instance. For example, we can run the same SampleSegmentApp executable binary in 3 remote processes and each process executes one segment from the app. Process 1 to run TxSegment; Process 2 to run FwdSegment; Process 3 to run RxSegment. segment config for instance in process 1: --- segment_config: - member: enabled_segments parameters: enabled: - TxSegment - member: worker parameters: enabled: True name: worker_Tx port: 50001 driver_ip: &quot;localhost&quot; driver_port: 50000 - member: driver parameters: enabled: True name: driver_50000 port: 50000 segment config for instance in process 2: --- segment_config: - member: enabled_segments parameters: enabled: - FwdSegment - member: worker parameters: enabled: True name: worker_Fwd port: 50002 driver_ip: &quot;localhost&quot; driver_port: 50000 segment config for instance in process 3: --- segment_config: - member: enabled_segments parameters: enabled: - RxSegment - member: worker parameters: enabled: True name: worker_Rx port: 50003 driver_ip: &quot;localhost&quot; driver_port: 50000 The distributed execution in C++ App API is facing segfault after finishing execution during destroy; The equivalent YAML API execution doesn\u2019t observe the issue. The same Python App API for distributed execution will be available in future release. [Coming Soon] More sample applications will be available in GXF github repo https://github.com/NVIDIA-AI-IOT/deepstream_gxf_ref_apps", "keywords": []}, {"id": 2074, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::createSegment", "display_name": "Application::createSegment", "type": "function", "display_type": "C++ function", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4I0EN11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT &gt; std :: shared_ptr &lt; SegmentT &gt;  Application :: createSegment const  char  * name In a distributed application, the same application binary is executed on multiple nodes. This does not necessarily mean that a node has to execute all the segment in an application. Each application binary instance enables only a subset of of all the segments created in the source code. Each node can be configured with the specific segments that it is supposed to execute. This is done by the segment config file as shown below. If no segment config file provided to execute the app, all segments get enabled in that instance. Connecting Segments", "keywords": []}, {"id": 2075, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::createSegment::SegmentT", "display_name": "Application::createSegment::SegmentT", "type": "templateParam", "display_type": "C++ template parameter", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4I0EN11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT &gt; std :: shared_ptr &lt; SegmentT &gt;  Application :: createSegment const  char  * name In a distributed application, the same application binary is executed on multiple nodes. This does not necessarily mean that a node has to execute all the segment in an application. Each application binary instance enables only a subset of of all the segments created in the source code. Each node can be configured with the specific segments that it is supposed to execute. This is done by the segment config file as shown below. If no segment config file provided to execute the app, all segments get enabled in that instance. Connecting Segments", "keywords": []}, {"id": 2076, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "cpp", "name": "Application::createSegment::name", "display_name": "Application::createSegment::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "_CPPv4I0EN11Application13createSegmentENSt10shared_ptrI8SegmentTEEPKc", "priority": 1, "content": "template &lt; typename  SegmentT &gt; std :: shared_ptr &lt; SegmentT &gt;  Application :: createSegment const  char  * name In a distributed application, the same application binary is executed on multiple nodes. This does not necessarily mean that a node has to execute all the segment in an application. Each application binary instance enables only a subset of of all the segments created in the source code. Each node can be configured with the specific segments that it is supposed to execute. This is done by the segment config file as shown below. If no segment config file provided to execute the app, all segments get enabled in that instance. Connecting Segments", "keywords": []}, {"id": 2077, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#application", "display_name": "Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "application", "priority": -1, "content": "The Application class is a scaffolding layer to create applications imperatively in GXF. It provides a virtual compose() function where individual building blocks of an application can be constructed, configured, and connected with each other. The Application class also provides functions to set the configuration file, load extensions, create segments, and run the application. The application class extends the Segment class and provides all the benefits of the segment apis in the application layer as well. In its most simplest form, an application does not have any segments. It has multiple graph entities governed by a scheduler. The following example creates two graph entities and connects them with each other. class PingSimpleApp : public Application { public: void compose() override { // create a codelet to generate 10 messages auto tx_entity = makeEntity&lt;PingTx&gt;(&quot;Tx&quot;, makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 10))); // create a codelet to receive the messages auto rx_entity = makeEntity&lt;PingRx&gt;(&quot;Rx&quot;); // add data flow connection tx -&gt; rx connect(tx_entity, rx_entity); // configure the scheduler setScheduler(SchedulerType::kGreedy); } }; int main(int argc, char** argv) { auto app = create_app&lt;PingSimpleApp&gt;(); app-&gt;loadExtensionManifest(kManifestFilename); app-&gt;compose(); auto result = app-&gt;run(); return ToResultCode(result); } A manifest file in the above example is a YAML file with a single top-level entry \u2018extensions\u2019 followed by a list of filenames of GXF extension shared libraries. Example: extensions: - gxf/std/libgxf_std.so - gxf/sample/libgxf_sample.so The Application class supports different modes of execution, which are represented by the ExecutionMode enum. The different modes are: kUnset : The default mode, which is unset. kSingleSegment : This mode is used when the application contains only one segment. kMultiSegment : This mode is used when the application contains multiple segments being executed in parallel in a single process. kDistributed : This mode is used when the application is distributed across multiple nodes, and the segments are executed in parallel on different nodes. Large applications with complex execution patterns can be broken down into a application containing multiple segments. The example below refactors the single segment application into a multi segment application. Individual graph entities are composed in the segment, and those segments are composed and configured in the application. class PingTxSegment : public Segment { public: void compose() override { // create a codelet to generate 10 messages auto tx_entity = makeEntity&lt;PingTx&gt;(&quot;Tx&quot;, makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 10))); // add a scheduler component and configure the clock auto scheduler = setScheduler&lt;Greedy&gt;(Arg(&quot;stop_on_deadlock&quot;, false), Arg(&quot;max_duration_ms&quot;, 5000)); } }; class PingRxSegment : public Segment { public: void compose() override { // create a codelet to receive the messages auto rx_entity = makeEntity&lt;PingRx&gt;(&quot;Rx&quot;); // add a scheduler component and configure the clock auto scheduler = setScheduler&lt;Greedy&gt;(Arg(&quot;max_duration_ms&quot;, 5000), Arg(&quot;stop_on_deadlock&quot;, false)); } }; class PingSegmentApp : public Application { public: void compose() override { auto tx_segment = createSegment&lt;PingTxSegment&gt;(&quot;TxSegment&quot;); auto rx_segment = createSegment&lt;PingRxSegment&gt;(&quot;RxSegment&quot;); // add data flow connection tx -&gt; rx connect(tx_segment, rx_segment, {SegmentPortPair(&quot;Tx.signal&quot;, &quot;Rx.signal&quot;)}); } }; int main(int argc, char** argv) { auto app = create_app&lt;PingSegmentApp&gt;(); app-&gt;loadExtensionManifest(kManifestFilename); app-&gt;compose(); auto result = app-&gt;run(); return ToResultCode(result); }", "keywords": []}, {"id": 2078, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#c-application-development", "display_name": "C++ Application Development", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "c-application-development", "priority": -1, "content": "The traditional method of creating GXF applications via YAML documents included composing entities in a yaml file which was executed by the GXE runtime along with an extension manifest. The GXF Application layer simplifies this process by allowing a user to create applications programmatically. The implementation of this layer is compiled in a shared dynamic library libgxf_app.so and packaged in the GXF runtime debian installers. See GXF App C++ APIs for the API reference of the C++ application layer. The basic building blocks of this layer include Graph Entity, Segment &amp; Application.", "keywords": []}, {"id": 2079, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#computeentity", "display_name": "ComputeEntity", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "computeentity", "priority": -1, "content": "ComputeEntity automatically adds an entity in the graph with basic scheduling terms. A codelet implemented in c++ with python binding can be added to a ComputeEntity. Steps to compose a graph: Create a GXF graph object Set clock and scheduler to the graph object Add ComputeEntity with codelet Connect the transmitter and receiver from the ComputeEntity Graph to load extensions, run, and destroy Example graph: import os from gxf.core import Graph from gxf import std from gxf.std import RealtimeClock from gxf.std import GreedyScheduler from gxf.std import ComputeEntity from gxf.sample import PingTx from gxf.sample import PingRx def main(): g = Graph() clock = std.set_clock(g, RealtimeClock(name=&#x27;clock&#x27;)) std.set_scheduler(g, GreedyScheduler( max_duration_ms=1000000, clock=clock)) g.add(ComputeEntity(&quot;tx&quot;, count=5)).add_codelet(PingTx(clock=clock)) g.add(ComputeEntity(&quot;rx&quot;)).add_codelet(PingRx()) std.connect(g.tx.signal, g.rx.signal) g.load_extensions() g.run() g.destroy() if __name__ == &quot;__main__&quot;: main()", "keywords": []}, {"id": 2080, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#connecting-graph-entities", "display_name": "Connecting Graph Entities", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "connecting-graph-entities", "priority": -1, "content": "The simplest connection api accepts only the source and destination graph entities. For such entities, it is assumed that their interfaces are comparable. i.e The sender entity must have a codelet with only one Parameter&lt;Handle&lt;Transmitter&gt;&gt; and the receiving entity must have a codelet with only one registered Parameter&lt;Handle&lt;Receiver&gt;&gt; . The scheduling terms related to the transmitter and receiver are also added automatically by the connect apis. The names of auto added message queues and scheduling terms are the same as the corresponding parameter key of the codelet to which it is connected to. // create a codelet to generate 10 messages auto tx_entity = makeEntity&lt;PingTx&gt;(&quot;Tx&quot;, makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 10))); // create a codelet to receive the messages auto rx_entity = makeEntity&lt;PingRx&gt;(&quot;Rx&quot;); // add data flow connection tx -&gt; rx connect(tx_entity, rx_entity); For entities with codelets having multiple inputs and outputs, the connection mapping can be specified in the connect api. void compose() override { // create a codelet to generate 10 messages auto left_tx = makeEntity&lt;PingTx&gt;( &quot;Left Tx&quot;, makeTerm&lt;PeriodicSchedulingTerm&gt;(&quot;periodic&quot;, Arg(&quot;recess_period&quot;, &quot;50Hz&quot;)), makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 100))); auto right_tx = makeEntity&lt;PingTx&gt;( &quot;Right Tx&quot;, makeTerm&lt;PeriodicSchedulingTerm&gt;(&quot;periodic&quot;, Arg(&quot;recess_period&quot;, &quot;50Hz&quot;)), makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 100))); // create a codelet to receive the messages auto multi_ping_rx = makeEntity&lt;MultiPingRx&gt;(&quot;Multi Rx&quot;); // add data flow connection tx -&gt; rx connect(left_tx, multi_ping_rx, PortPair{&quot;signal&quot;, &quot;receivers&quot;}); connect(right_tx, multi_ping_rx, PortPair{&quot;signal&quot;, &quot;receivers&quot;}); }", "keywords": []}, {"id": 2081, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#create-a-graph", "display_name": "Create a Graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "create-a-graph", "priority": -1, "content": "Now, let\u2019s create a simple graph and run it. For this example we will create a simple Ping Graph using components present in the Sample Extension and Standard Extension. In this Ping Graph, we simply send a message from one entity to another periodically for certain number of counts. It uses the following components: Transmitter: DoubleBufferTransmitter - This is a queue which is holds a message being transmitted. PingTx - This component creates and publishes a message every time it\u2019s executed. PeriodicSchedulingTerm - Scheduling Terms determine when to execute an entity in this case Transmitter. PeriodicSchedulingTerm is used to execute entities periodically. CountSchedulingTerm - CountSchedulingTerm is used to stop the execution after a certain count. If you want to keep it running then skip adding this component. Receiver: DoubleBufferReceiver - This is a queue which hold the messages sent by other components. PingRx - This component receives a message on DoubleBufferReceiver every time it\u2019s executed. MessageAvailableSchedulingTerm - This Scheduling Term determines if a new message has arrived and only then PingRx codelet is ticked. Scheduler: GreedyScheduler - Scheduler determines the order in which components are executed. GreedyScheduler is a simple single-threaded scheduler which executes components one after another. RealtimeClock - A clock used by Scheduler to track time. Follow the steps: Add PingTx, PingRx and GreedyScheduler by dragging and dropping them from the components panel the graph window. Add the rest of the components such as CountSchedulingTerm, PeriodicSchedulingTerm and MessageAvailableSchedulingTerm by dragging and dropping into the respective entity node. Now, right click on the signal in PingTx and click Create DoubleBufferTransmitter. Follow the same steps for PingRx\u2019s signal and GreedyScheduler\u2019s clock. We can create a graph by simply dragging and dropping components from the Component Panel and add more components to it. After adding the components your graph will look like the image below: Now we make connections between components. For instance, you will have to connect a DoubleBufferTransmitter to a DoubleBufferReceiver to pass messages between them. PingTx/clock needs to be linked to GreedyScheduler/RealtimeClock . These connections are made by creating an edge between the components as shown below: Finally, we have to set the required parameters for the components: In PingRx/MessageAvailableSchedulingTerm : set min_size to 1 In PingTx/CountSchedulingTerm : set count to 5 In PingTx/PeriodicSchedulingTerm : set recess_period to 5 Now you can save the graph using File -&gt; Save Graph (as) . This will create a yaml file with all the components and the connections. application: name: MyGraph --- dependencies: - extension: SampleExtension uuid: a6ad78b6-1682-11ec-9621-0242ac130002 version: 1.5.0 - extension: StandardExtension uuid: 8ec2d5d6-b5df-48bf-8dee-0252606fdd7e version: 2.5.0 --- components: - name: ping_tx0 parameters: clock: GreedyScheduler/realtime_clock12 signal: double_buffer_transmitter10 type: nvidia::gxf::PingTx - name: periodic_scheduling_term3 type: nvidia::gxf::PeriodicSchedulingTerm - name: count_scheduling_term4 type: nvidia::gxf::CountSchedulingTerm - name: double_buffer_transmitter10 type: nvidia::gxf::DoubleBufferTransmitter name: PingTx ui_property: position: x: 56.0 y: 103.0 --- components: - name: ping_rx1 parameters: signal: double_buffer_receiver11 type: nvidia::gxf::PingRx - name: message_available_scheduling_term5 parameters: receiver: double_buffer_receiver11 type: nvidia::gxf::MessageAvailableSchedulingTerm - name: double_buffer_receiver11 type: nvidia::gxf::DoubleBufferReceiver name: PingRx ui_property: position: x: 489.0 y: 106.0 --- components: - name: greedy_scheduler2 parameters: clock: realtime_clock12 type: nvidia::gxf::GreedyScheduler - name: realtime_clock12 type: nvidia::gxf::RealtimeClock name: GreedyScheduler ui_property: position: x: 486.0 y: 314.0 --- components: - name: connection13 parameters: source: PingTx/double_buffer_transmitter10 target: PingRx/double_buffer_receiver11 type: nvidia::gxf::Connection name: node1", "keywords": []}, {"id": 2082, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#create-container-image-from-graph-composer", "display_name": "Create Container Image from Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "create-container-image-from-graph-composer", "priority": -1, "content": "Container image can be created for Ubuntu 22.04 x86_64 or Jetson but creation is supported only on Ubuntu 22.04 x86_64. Following scenarios are supported for it. To build a container, first click on the Build Container button from the toolbar on the top. This will open the Build Container window.", "keywords": []}, {"id": 2083, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#deepstream-application", "display_name": "DeepStream Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "deepstream-application", "priority": -1, "content": "Previous application was simple demonstrating application workflow. Similar workflow can be used to create, load and run DeepStream applications using GXF. It requires that DeepStream 7.1 and reference graphs packages are installed on the system with all the dependencies. Open the File menu from the menubar at the top and click on Open Graph to launch the file browser. You may alternatively use the Ctrl + O key combination. Browse to a valid graph file, select it and click on Okay to open the graph. Composer should now show the application graph. To load component parameters from a separate file, right-click on the graph and select Load parameters from the context menu to launch the file browser. Browse to an appropriate parameters file for the currently open and visible graph, select it and click on Okay to load parameter values from the file. Rest of the steps to run the application or build container image are same as demonstrated earlier.", "keywords": []}, {"id": 2084, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#distributed-application", "display_name": "Distributed Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "distributed-application", "priority": -1, "content": "A multi segment application, can also be distributed across multiple nodes in a distributed application. As introduced in Distributed Execution section, a segment is the basic unit being distributed. Segments communicate each other via UCX transmitters and receivers. However users do not need to worry about adding the UCX connection. The Application API implementation automatically completes the connection, when calling connect() API on the pair of segments. The connected pair of segments can run in single node / single process, single node / multi process or on multi nodes / multi process. No matter which way, since UCX transmitter and receiver are use between the connected pair of segment, it is considered as distributed execution use case. As compared to a single segment application, in a multi segment or a distributed application, instead of creating and connecting entities, segments are created and connected with each as show in the example below. class SampleSegmentApp : public Application { public: void compose() override { // create segments auto tx_segment = createSegment&lt;PingTxSegment&gt;(&quot;TxSegment&quot;); auto fwd_segment = createSegment&lt;ForwardSegment&gt;(&quot;FwdSegment&quot;); auto rx_segment = createSegment&lt;PingRxSegment&gt;(&quot;RxSegment&quot;); // connect segments connect(tx_segment, fwd_segment, {SegmentPortPair(&quot;Tx.signal&quot;, &quot;Fwd.in&quot;)}); connect(fwd_segment, rx_segment, {SegmentPortPair(&quot;Fwd.out&quot;, &quot;Rx.signal&quot;)}); } }; Creating a Segment", "keywords": []}, {"id": 2085, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#example-application", "display_name": "Example Application", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "example-application", "priority": -1, "content": "import os import cupy as cp import numpy as np import gxf.std as std from gxf.core import ( Graph, MessageEntity ) from gxf.std import ( Entity, GPUDevice, GreedyScheduler, RealtimeClock, Tensor, ) from gxf.python_codelet import ( PyComputeEntity, CodeletAdapter, ) class TensorPairGenerator(CodeletAdapter): &quot;&quot;&quot;Python codelet to generate a stream of tensors on tick() Transmitter: * host_out Transmits one message containing one pair of GXF Tensors zero-copied from NumPy, on every tick() * cuda_out Transmits one message containing one pair of GXF Tensors zero-copied from CuPy, on every tick() &quot;&quot;&quot; def __init__(self): super().__init__() self.txs = [&quot;host_out&quot;, &quot;cuda_out&quot;] def start(self): self.params = self.get_params() rows = self.params.get(&quot;rows&quot;, 16) cols = self.params.get(&quot;cols&quot;, 64) self.shape = (rows, cols) self.dtype = np.float32 return def tick(self): gxf_msg_out_cuda = MessageEntity(self.context()) gxf_msg_out_host = MessageEntity(self.context()) # Initialize a pair of tensors using NumPy np1 = np.arange(self.shape[0] * self.shape[1], dtype=self.dtype).reshape(self.shape) np2 = np.ascontiguousarray(np1.transpose()) # Convert NumPy tensors to GXF tensors # GXF implements zero-copy from NumPy tensor for i, arr in enumerate([np1, np2]): gxf_tensor = Tensor.as_tensor(arr) Tensor.add_to_entity(gxf_msg_out_host, gxf_tensor, f&quot;host_tensor{i + 1}&quot;) # Initialize a pair of cuda tensors using CuPy cp1 = cp.asarray(np1) cp2 = cp.asarray(np2) # Convert CuPy tensors to GXF tensors # GXF implements zero-copy from CuPy tensor, via gxf.Tensor as_tensor() and from_dlpack() for i, dev_arr in enumerate([cp1, cp2]): gxf_tensor_cuda = Tensor.as_tensor(dev_arr) Tensor.add_to_entity(gxf_msg_out_cuda, gxf_tensor_cuda, f&quot;cuda_tensor{i + 1}&quot;) self.host_out.publish(gxf_msg_out_host) self.cuda_out.publish(gxf_msg_out_cuda) return def stop(self): pass class DotProduct(CodeletAdapter): &quot;&quot;&quot;Python codelet to do dot product of a pair of tensors. Receiver: * rx Receives one message containing one pair of GXF Tensors zero-copied from NumPy or CuPy, on every tick() Transmitter: * tx Transmits one message containing one GXF Tensor zero-copied from NumPy or CuPy, on every tick() The `device` parameter can be set to either &#x27;cpu&#x27; or &#x27;gpu&#x27;. &quot;&quot;&quot; def __init__(self): super().__init__() self.txs = [&quot;tx&quot;] self.rxs = [&quot;rx&quot;] def start(self): self.params = self.get_params() # use NumPy or CuPy based on the &#x27;device&#x27; parameter device = self.params.get(&quot;device&quot;, &quot;cpu&quot;) if (not isinstance(device, str) or device.lower() not in [&quot;cpu&quot;, &quot;gpu&quot;]): raise ValueError(&quot;device parameter must be one of {&#x27;cpu&#x27;, &#x27;gpu&#x27;}&quot;) self.xp = cp if device == &quot;gpu&quot; else np def tick(self): xp = self.xp gxf_msg_in = self.rx.receive() # Get GXF tensors from GXF graph gxf_tensors = Tensor.find_all_from_entity(gxf_msg_in) np.testing.assert_equal(len(gxf_tensors), 2) # Convert GXF tensor to NumPy / CuPy tensor # GXF implements zero-copy interface to NumPy / CuPy tensor, via NumPy / CuPy asarray() or from_dlpack() xp_tensor_in0 = xp.asarray(gxf_tensors[0]) xp_tensor_in1 = xp.asarray(gxf_tensors[1]) # NumPy / CuPy libraries to process NumPy / CuPy tensors xp_tensor_out = xp.dot(xp_tensor_in0, xp_tensor_in1) gxf_msg_out = MessageEntity(self.context()) # Convert NumPy / CuPy tensor back to GXF Graph # GXF implements zero-copy from NumPy / CuPy tensor, via gxf.Tensor as_tensor() and from_dlpack() gxf_tensor = Tensor.as_tensor(xp_tensor_out) Tensor.add_to_entity(gxf_msg_out, gxf_tensor, &quot;&quot;) self.tx.publish(gxf_msg_out) def stop(self): pass class VerifyEqual(CodeletAdapter): &quot;&quot;&quot;Python codelet to compare a GPU tensor to a CPU tensor to within a tolerance. Receiver: * host_in Receives one message containing one GXF Tensor zero-copied from NumPy, on every tick() * cuda_in Receives one message containing one GXF Tensor zero-copied from CuPy, on every tick() &quot;&quot;&quot; def __init__(self): super().__init__() self.rxs = [&quot;host_in&quot;, &quot;cuda_in&quot;] def start(self): self.params = self.get_params() def tick(self): gxf_msg_in_host = self.host_in.receive() gxf_msg_in_cuda = self.cuda_in.receive() # Get GXF tensors from GXF graph gxf_tensors_cuda = Tensor.find_all_from_entity(gxf_msg_in_cuda) np.testing.assert_equal(len(gxf_tensors_cuda), 1) gxf_tensors_host = Tensor.find_all_from_entity(gxf_msg_in_host) np.testing.assert_equal(len(gxf_tensors_host), 1) # Convert GXF tensor to NumPy / CuPy tensor # GXF implements zero-copy interface to NumPy / CuPy tensor, via NumPy / CuPy asarray() or from_dlpack() cp_tensor = cp.asarray(gxf_tensors_cuda[0]) np_tensor = np.asarray(gxf_tensors_host[0]) # NumPy / CuPy libraries to process NumPy / CuPy tensors # Check if the two arrays are element-wise equal within a tolerance cp.testing.assert_allclose(cp_tensor, np_tensor, rtol=1e-5) return def stop(self): pass class DLPackSimpleApp: def run(self, count=20): g = Graph() clock = std.set_clock(g, RealtimeClock(name=&quot;clock&quot;)) std.set_scheduler(g, GreedyScheduler(max_duration_ms=1000000, clock=clock)) std.enable_job_statistics(g, clock=clock) # create the tensor generator entity source_entity = g.add(PyComputeEntity(&quot;TensorPairGenerator&quot;, count=count)) source_entity.add_codelet( &quot;tensor_pair_generator&quot;, TensorPairGenerator(), # Codelet own params rows=16, cols=64, ) # create the host matrix multiply entity process_entity_host = g.add(PyComputeEntity(&quot;DotProductHost&quot;, count=-1)) process_entity_host.add_codelet( &quot;host_dot_product&quot;, DotProduct(), # Codelet own params device=&quot;cpu&quot;, ) # create the device matrix multiply entity process_entity_cuda = g.add(PyComputeEntity(&quot;DotProductCuda&quot;, count=-1)) process_entity_cuda.add_codelet( &quot;cuda_dot_product&quot;, DotProduct(), # Codelet own params device=&quot;gpu&quot;, ) # create the tensor verification entity sink_entity = g.add(PyComputeEntity(&quot;VerifyEqual&quot;, count=-1)) sink_entity.add_codelet( &quot;verify_equal&quot;, VerifyEqual(), ) std.connect(source_entity.host_out, process_entity_host.rx) std.connect(source_entity.cuda_out, process_entity_cuda.rx) std.connect(process_entity_host.tx, sink_entity.host_in) std.connect(process_entity_cuda.tx, sink_entity.cuda_in) # add a GPUDevice for use by the default entity group g.add(Entity(&quot;GPU_0&quot;)).add(GPUDevice(name=&quot;GPU_0&quot;, dev_id=0)) g.load_extensions(workspace=self._get_default_extensions_path()) g.run_async() g.wait() g.destroy() # default gxf extension path base, /var/tmp/gxf/.cache/gxf_workspace def _get_default_extensions_path(self): home_dir = os.path.expanduser(&quot;~&quot;) return os.path.join(home_dir, &quot;.cache&quot;, &quot;gxf_workspace&quot;) if __name__ == &quot;__main__&quot;: app = DLPackSimpleApp() app.run()", "keywords": []}, {"id": 2086, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#from-gxf-to-other-frameworks", "display_name": "From GXF to other frameworks", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "from-gxf-to-other-frameworks", "priority": -1, "content": "NumPy / CuPy asarray() np_tensor = np.asarray(gxf_tensor_host) cp_tensor = cp.asarray(gxf_tensor_cuda) NumPy / CuPy from_dlpack() np_tensor = np.from_dlpack(gxf_tensor_host) cp_tensor = cp.from_dlpack(gxf_tensor_cuda)", "keywords": []}, {"id": 2087, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#from-other-frameworks-to-gxf", "display_name": "From other frameworks to GXF", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "from-other-frameworks-to-gxf", "priority": -1, "content": "import numpy as np import cupy as cp np_tensor = np.random.rand(3, 4) cp_tensor = cp.random.rand(3, 4) from gxf.std import Tensor gxf_tensor_host = Tensor.as_tensor(np_tensor) gxf_tensor_cuda = Tensor.as_tensor(cp_tensor) Then the tensor data can travel in GXF graph wrapped by a message entity, eg gxf_msg_out in below example Tensor.add_to_entity(gxf_msg_out, gxf_tensor_host, &quot;out_tensor_on_host&quot;) Tensor.add_to_entity(gxf_msg_out, gxf_tensor_cuda, &quot;out_tensor_on_cuda&quot;)", "keywords": []}, {"id": 2088, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#graph-composer", "display_name": "Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "graph-composer", "priority": -1, "content": "This section helps you get familiar with the application development workflow using Graph Composer which includes the following: Launch Graph Composer Sync extensions from NVIDIA Cloud repository Create simple application using Graph Composer Run application Create container image for the application We will start by first setting up the system and explain the basic layout of the Composer on Ubuntu 22.04 x86_64. Then, we will load, understand, and run a simple application. This will provide an understanding of how the Composer works. Finally, we will create a simple application without writing a single line of code. Graph development is currently supported only on x86. Graph Composer package for arm64 can be used to deploy or execute graph on Jetson. Installation step installs all tools in the /opt/nvidia/graph-composer directory with links to tools in /usr/bin directory. You can access the tools without switching to the installation directory. After installation, check if the installation was successful using the following commands in a terminal: registry --help usage: registry [-h] [-v] ... positional arguments: cache Perform actions on cache repo Perform actions on repositories comp Perform actions on components extn Perform actions on extensions graph Perform actions on graph optional arguments: -h, --help show this help message and exit -v, --version Print registry tool and GXF Spec version container_builder --help usage: container_builder [-h] [-v] [--log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL}] [--log-file LOG_FILE] ... build docker images from config file positional arguments: build Build container image using config files push Push local container image to remote repo optional arguments: -h, --help show this help message and exit -v, --version Container Builder Version --log-level {DEBUG,INFO,WARNING,ERROR,CRITICAL} set log level, default is INFO --log-file LOG_FILE Optional, set log output file If you still don\u2019t see the components, check the FAQ section.", "keywords": []}, {"id": 2089, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#graph-entity", "display_name": "Graph Entity", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "graph-entity", "priority": -1, "content": "A GXF graph consists of one or more entities composed of multiple components. These components typically include a codelet along with other components like resources, scheduling terms and messages queues (transmitters and receivers). The nvidia::gxf::GraphEntity class simplifies the process of creating and managing programmable graph entities in an application. Graph Entities in an application are created using the nvidia::gxf::Segment::makeEntity&lt;T&gt;(...) api. This is a templated api that accepts a parameter pack of arguments. The template type is used to specify the type of codelet to be added in the entity and the parameter pack is used to specify the rest of the components to be added and also the arguments for the codelet itself. Here is an example of an entity containing a PingTx codelet represented in a yaml The example below creates a simple graph entity consisting of the nvidia::gxf::PingTx codelet. // create a codelet to generate 10 messages auto tx_entity = makeEntity&lt;PingTx&gt;(&quot;Tx&quot;, makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 10))); Scheduling terms are created with the makeTerm api and a list of parameter values are passed in the form of Args. // create an entity to copy messages from device to host auto copier = makeEntity&lt;TensorCopier&gt;(&quot;Copier&quot;, Arg(&quot;allocator&quot;) = makeResource&lt;UnboundedAllocator&gt;(&quot;allocator&quot;), Arg(&quot;mode&quot;, 1)); Resources like memory pools and allocators can be created with the makeResource api. In this example the TensorCopier codelet is being configured with an UnboundedAllocator. The transmitter and receiver queues of an entity are not specified while creating an graph entity. These components are auto added by the connect apis when an entity is being connected with another. The scheduling terms related to the transmitter and receiver are also added automatically by the connect apis.", "keywords": []}, {"id": 2090, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#graph-with-ucx-rx", "display_name": "Graph with UCX Rx", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "graph-with-ucx-rx", "priority": -1, "content": "Remote process 2 receiving tensor with device data, via UCX Receiver. UCX context, UCX Receiver receives data onto local host or device from remote host or device. Below comopnents are needed on top of a regular graph UCX entity containing UCX context UCXSource entity containing UCX Receiver class PyPingRx(CodeletAdapter): &quot;&quot;&quot; Python codelet to send a msg on tick() Python implementation of Ping Tx. Sends a message to the transmitter on every tick() &quot;&quot;&quot; def __init__(self): super().__init__() self.rxs = [&quot;rx&quot;] def start(self): self.params = self.get_params() self.shape_expected = self.params.get(&quot;shape_expected&quot;, [1, 2]) self.expected_ones = cp.ones(self.shape_expected) self.expected_zeros = cp.zeros(self.shape_expected) def tick(self): msg = self.rx.receive() ones_tensor = Tensor.get_from_entity(msg, &quot;ones_tensor&quot;) actual_ones = cp.asarray(ones_tensor) cp.testing.assert_allclose(actual_ones, self.expected_ones, rtol=1e-5) print(&quot;Correctly received tensor from remote CuPy over UCX:\\n&quot; + str(actual_ones)) zeros_tensor = Tensor.get_from_entity(msg, &quot;zeros_tensor&quot;) actual_zeros = cp.asarray(zeros_tensor) cp.testing.assert_allclose(actual_zeros, self.expected_zeros, rtol=1e-5) print(&quot;Correctly received tensor from remote Allocator over UCX:\\n&quot; + str(actual_zeros)) return def stop(self): return def run_ucx_rx_graph(): g = Graph() g.set_severity(logging.DEBUG) clock = std.set_clock(g, RealtimeClock(name=&quot;clock&quot;)) std.enable_job_statistics(g, clock=clock) std.set_scheduler(g, GreedyScheduler( max_duration_ms=5000, clock=clock, stop_on_deadlock=False)) g.add(Entity(&quot;mem_pool&quot;)).add( BlockMemoryPool( &quot;device_image_pool&quot;, storage_type=1, block_size=1920 * 1080 * 4, num_blocks=150, ) ) g.add(UCX(&quot;ucx&quot;, allocator=g.mem_pool.device_image_pool)) g.add(UCXSource(&quot;source&quot;, address=&quot;localhost&quot;, port=13338)) g.add(PyComputeEntity(&quot;PingRx&quot;, count=-1)).add_codelet( &quot;pingrx&quot;, PyPingRx(), allocator=g.mem_pool.device_image_pool, shape_expected=[2, 3], ) std.connect(g.source.output, g.PingRx.rx) g.load_extensions() g.run() g.destroy() if __name__ == &#x27;__main__&#x27;: run_ucx_rx_graph()", "keywords": []}, {"id": 2091, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#graph-with-ucx-tx", "display_name": "Graph with UCX Tx", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "graph-with-ucx-tx", "priority": -1, "content": "Remote process 1 sending tensor with device data, via UCX Transmitter. Local data with memory on host or device is transmitted via UCX context, UCX Transmitter to remote host or device. Below comopnents are needed on top of a regular graph UCX entity containing UCX context UCXSink entity containing UCX Transmitter class PyPingTx(CodeletAdapter): &quot;&quot;&quot; Python codelet to send a msg on tick() Python implementation of Ping Tx. Sends a message to the transmitter on every tick() &quot;&quot;&quot; def __init__(self): super().__init__() self.txs = [&quot;tx&quot;] def start(self): self.params = self.get_params() self.allocator = Allocator.get(self.context(), self.cid(), self.params[&quot;allocator&quot;]) self.shape = self.params.get(&quot;shape&quot;, [1, 2]) def tick(self): msg = MessageEntity(self.context()) # add ones tensor allocated on cupy cp_tensor = cp.ones(self.shape) gxf_tensor = Tensor.as_tensor(cp_tensor) Tensor.add_to_entity(msg, gxf_tensor, &quot;ones_tensor&quot;) # add uninitialized tensor allocated by gxf allocator tensor_on_allocator = Tensor.add_to_entity(msg, &quot;zeros_tensor&quot;) td = TensorDescription( name=&quot;zeros_tensor&quot;, storage_type=MemoryStorageType.kDevice, shape=Shape(self.shape), element_type=PrimitiveType.kFloat32, bytes_per_element=4 ) tensor_on_allocator.reshape(td, self.allocator) self.tx.publish(msg, 1) return def stop(self): pass def run_ucx_tx_graph(): g = Graph() g.set_severity(logging.DEBUG) clock = std.set_clock(g, RealtimeClock(name=&#x27;clock&#x27;)) std.enable_job_statistics(g, clock=clock) std.set_scheduler(g, GreedyScheduler( max_duration_ms=5000, clock=clock, stop_on_deadlock=False)) g.add(Entity(&quot;mem_pool&quot;)).add( BlockMemoryPool( &quot;device_image_pool&quot;, storage_type=1, block_size=1920 * 1080 * 4, num_blocks=150, ) ) # g.add(UCX(&quot;ucx&quot;, allocator=g.mem_pool.device_image_pool)) g.add(UCX(&quot;ucx&quot;)) g.add(PyComputeEntity(&quot;PingTx&quot;, count=5)).add_codelet( &quot;pingtx&quot;, PyPingTx(), allocator=g.mem_pool.device_image_pool, shape=[2, 3], ) g.add(UCXSink(&quot;sink&quot;, count=-1, address=&quot;localhost&quot;, port=13338)) std.connect(g.PingTx.tx, g.sink.input) g.load_extensions() g.run() g.destroy() if __name__ == &#x27;__main__&#x27;: run_ucx_tx_graph()", "keywords": []}, {"id": 2092, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#id1", "display_name": "Local System", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "id1", "priority": -1, "content": "For creating a container on the local system, Make sure gxf_server is running on the local system and the IP address in the Edit/Preferences is of local host. Launch the file browser using the button next to the Configuration File input. Select a container builder configuration file and open it. Click the button next to the Platform config File input to launch the file browser. Select a platform config file and open it. Click on Build to start the build process. Composer reports the container build status using a progress bar. On successful completion, composer will show a success message.", "keywords": []}, {"id": 2093, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#launch-graph-composer", "display_name": "Launch Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "launch-graph-composer", "priority": -1, "content": "There are two options to launch Composer: Native workstation: Launch Composer from native workstation using following command: composer DeepStream SDK devel container image: Launch Composer from DeepStream SDK devel container image, installation on local system is not required for it: docker pull nvcr.io/nvidia/deepstream:7.1-gc-triton-devel xhost + docker run -it --entrypoint /bin/bash --gpus all --rm --network=host -e DISPLAY=${DISPLAY} -v /tmp/.X11-unix/:/tmp/.X11-unix --privileged -v /var/run/docker.sock:/var/run/docker.sock nvcr.io/nvidia/deepstream:7.1-gc-triton-devel composer When using the Composer from the devel container image, users could have a problem browsing the \u201c/\u201d folder from the file browser, in this case they can just type the file path directly or copy and paste it.", "keywords": []}, {"id": 2094, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#local-system", "display_name": "Local System", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "local-system", "priority": -1, "content": "Make sure gxf_server is running on the local system and the IP address in the Edit/Preferences is of local host. Select appropriate Platform config file using the file browser. Click on Run . The graph execution progress will be reported via logs in the console window.", "keywords": []}, {"id": 2095, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#pycomputeentity", "display_name": "PyComputeEntity", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "pycomputeentity", "priority": -1, "content": "PyComputeEntity automatically adds an entity in the graph with basic scheduling terms. Python codelet can be added in a PyComputeEntity. Steps to compose a graph: Implement a python codelet by inheriting CodeletAdapter Create a GXF graph object Set clock and scheduler to the graph object Add PyComputeEntity with python codelet Connect the transmitter and receiver from the ComputeEntity Graph to load extensions, run, and destroy Example graph with Python codelet implement: import os import numpy as np from gxf.core import Graph import gxf.std as std from gxf.std import RealtimeClock from gxf.std import GreedyScheduler from gxf.python_codelet import CodeletAdapter from gxf.core import MessageEntity from gxf.python_codelet import PyComputeEntity from gxf.std import Tensor # implement a GXF Codelet class PyPingTx(CodeletAdapter): def __init__(self, some_param=&quot;what&quot;): super().__init__() self.txs = [&quot;tx&quot;] self.some_param = some_param def start(self): self.params = self.get_params() self.count = 1 pass def tick(self): msg = MessageEntity(self.context()) t = Tensor(np.array([1+self.count, 2+self.count, 3+self.count])) Tensor.add_to_entity(msg, t) self.tx.publish(msg, 1) print(&quot;PyPingTx &quot; + self.name() + &quot;: Message Sent: &quot; + str(self.count)) self.count+=1 return def stop(self): pass # implement a GXF Codelet class PyPingRx(CodeletAdapter): def __init__(self): super().__init__() self.rxs = [&quot;input&quot;] def start(self): self.count = 1 pass def tick(self): msg = self.input.receive() t = Tensor.get_from_entity(msg) assert(np.array_equal(np.array(t), [1+self.count, 2+self.count, 3+self.count])) print(&quot;PyPingRx &quot; + self.name() + &quot;: Message Received: &quot; + str(self.count)) self.count +=1 return def stop(self): return def main(): g = Graph() clock = std.set_clock(g, RealtimeClock(name=&#x27;clock&#x27;)) std.set_scheduler(g, GreedyScheduler(max_duration_ms=1000000, clock=clock)) ptx = g.add(PyComputeEntity(&quot;PingTx&quot;, count=5)) ptx.add_codelet(&quot;somename&quot;, PyPingTx(some_param=&quot;some_value&quot;)) prx = g.add(PyComputeEntity(&quot;PingRx&quot;, count = 5)) prx.add_codelet(&quot;codelet&quot;, PyPingRx()) std.connect(g.PingTx.tx, prx.input) g.load_extensions() g.run() g.destroy() if __name__ == &quot;__main__&quot;: main()", "keywords": []}, {"id": 2096, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#python-api-setup", "display_name": "Python API Setup", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "python-api-setup", "priority": -1, "content": "Prerequisites (skip if already finished): After installing the Graph Composer runtime debian, GXF Python core APIs at /opt/nvidia/graph-composer/core . See Installation Sync user required GXF extensions using tool registry . See Sync Extensions Steps: install user required GXF extensions Eg, for frequently used extensions: registry extn install -e StandardExtension registry extn install -e PythonCodeletExtension registry extn install -e MultimediaExtension registry extn install -e SampleExtension The extensions will be installed to default GXF workspace path at /var/tmp/gxf/.cache/gxf_workspace . /var/tmp/gxf/.cache/gxf_workspace \u2514\u2500\u2500 gxf \u251c\u2500\u2500 core -&gt; /opt/nvidia/graph-composer/core \u251c\u2500\u2500 multimedia \u251c\u2500\u2500 python_codelet \u251c\u2500\u2500 sample \u2514\u2500\u2500 std Add the workspace path to python path Suggested practice: Create a gxf.pth file at /home/$USER/.local/lib/python&lt;VERSION&gt;/site-packages/gxf.pth , and add the GXF workspace path to this file. Example commands in python: import os import site # /var/tmp/gxf/.cache/gxf_workspace default_extensions_path = get_default_extensions_path() # /home/&lt;USER_NAME&gt;/.local/lib/python&lt;VERSION&gt;/site-packages user_site_packages_dir = site.getusersitepackages() # Construct the path to the .pth file # /home/&lt;USER_NAME&gt;/.local/lib/python&lt;VERSION&gt;/site-packages/gxf.pth pth_file_path = os.path.join(user_site_packages_dir, &quot;gxf.pth&quot;) # Write the path to the .pth file with open(pth_file_path, &quot;w&quot;) as pth_file: pth_file.write(default_extensions_path) print(f&quot;Created gxf.pth file at {pth_file_path} with the following content:&quot;) print(default_extensions_path) Alternatively, the GXF workspace can be added to python path by updating the PYTHONPATH env variable export PYTHONPATH=$PYTHONPATH:/var/tmp/gxf/.cache/gxf_workspace", "keywords": []}, {"id": 2097, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#python-application-development", "display_name": "Python Application Development", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "python-application-development", "priority": -1, "content": "The GXF framework provides a rich python API to create graphs with ease. The following section describes the workflow to create GXF applications in python.", "keywords": []}, {"id": 2098, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#remote-system", "display_name": "Remote System", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "remote-system", "priority": -1, "content": "Execute on Jetson or another remote system Make sure gxf_server is running on the remote system and the IP address in the Edit/Preferences is of remote host. Select appropriate Platform config file (aarch64 or x86_64) based on the remote machine configuration. Click on Run . The graph execution progress will be reported via logs in the console window. Please note that this requires Graph Composer package be installed on the remote system. Execute on Jetson or another remote system through Windows Executing graph through Windows is very similar to executing graph on Jetson or another remote system. Please note that this requires Graph Composer package be installed on the remote system.", "keywords": []}, {"id": 2099, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#remote-system-windows", "display_name": "Remote System (Windows)", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "remote-system-windows", "priority": -1, "content": "Building container image through Windows is very similar to building container image on Linux system. Add remote system\u2019s IP address and port number in the Server tab in Edit/Preferences window. For creating a container on the remote system, Choose the container builder config file and target config file and click on Build Image . Please note that this requires Graph Composer package be installed on the remote system.", "keywords": []}, {"id": 2100, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#run-graph-from-command-line", "display_name": "Run Graph from Command line", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "run-graph-from-command-line", "priority": -1, "content": "Execute Graph using commandline (execute_graph.sh script) The execute_graph.sh script provided with the graph composer helps with graph execution and provides added functionality. Complete usage reference: Usage: /opt/nvidia/graph-composer/execute_graph.sh [options] &lt;graph-file&gt; [additional graph files] Options: -d, --graph-target &quot;&lt;graph-target-file&gt;&quot; [Required] Graph target config file -s, --subgraphs &lt;subgraph1&gt;,&lt;subgraph2&gt;,... [Optional] Paths of subgraphs used by the application, comma-separated list --resources &lt;graph-resources-file&gt; [Optional] Graph resources file -f, --fresh-manifest [Optional] Re-install graph and generate a new manifest file -g, --with-gdb [Optional] Execute the graph under gdb -m, --use-manifest &lt;existing-manifest&gt; [Optional] Use an existing manifest file -r, --remove-install-dir [Optional] Remove graph installation directory during exit -t, --target &lt;username@host&gt; [Optional] Target to execute the graph on. SSH will be used --target-env-vars &quot;&lt;env-vars&gt;&quot; [Optional] Separated list of environment variables to be set before running on target -a --app-root &lt;app-root&gt; [Optional] Root path for gxe to search subgraphs To execute graphs on a remote target: * Graph Composer package must already be installed on the target * It is recommended that a password-less login method be used for SSH To execute a graph locally, run: /opt/nvidia/graph-composer/execute_graph.sh &lt;graph-file&gt; -d &lt;graph-target&gt; For example, on dGPU host, run: .. code-block:: text /opt/nvidia/graph-composer/execute_graph.sh &lt;graph-file&gt; -d /opt/nvidia/graph-composer/config/target_x86_64.yaml To execute on a remote Jetson target, run: /opt/nvidia/graph-composer/execute_graph.sh &lt;graph-file&gt; -d /opt/nvidia/graph-composer/config/target_aarch64.yaml \\ -t &lt;username@host&gt; --target-env-vars &quot;DISPLAY=:0&quot; If a graph has resources associated with it described in a resources YAML file, an additional argument --resources &lt;resources.yaml&gt; can be passed to the script. The resources would be copied to the remote target before graph execution When executing a graph that uses subgraphs, you must pass additional argument -s &lt;subgraph1&gt;,&lt;subgraph2&gt;,... containing paths to the subgraph files. You must not pass the subgraphs as graph file arguments without an option. To run the graph on the remote machine, install the following packages: openssh-client sshfs Use ssh-keygen to generate an ssh key pair. Copy key to target using ssh-copy-id ${TARGET}", "keywords": []}, {"id": 2101, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#run-graph-from-graph-composer", "display_name": "Run Graph from Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "run-graph-from-graph-composer", "priority": -1, "content": "You can deploy the graph using one of the following methods: To execute the currently open graph, click on the Run Graph button from the toolbar on the left. This will open the Run Graph dialog.", "keywords": []}, {"id": 2102, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#runtime-codelet-registration", "display_name": "Runtime Codelet Registration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "runtime-codelet-registration", "priority": -1, "content": "The application layer further simplifies the process of creating apps by enabling runtime registration of codelets. All the prior examples made use of pre-defined codelets from the sample extension which was pre-loaded by the application. The application layer also has support for registering new codelets on the fly as shown in the following example. A new codelet PingTxRuntime is defined along with the sample application it is used in. The new codelet does not have to be wrapped in an extension library to be used in the application. class PingTxRuntime : public Codelet { public: virtual ~PingTxRuntime() = default; gxf_result_t registerInterface(Registrar* registrar) override { Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter(signal_, &quot;signal&quot;, &quot;Signal&quot;, &quot;Transmitter channel publishing messages to other graph entities&quot;); return ToResultCode(result); } gxf_result_t tick() override { auto message = Entity::New(context()); if (!message) { GXF_LOG_ERROR(&quot;Failure creating message entity.&quot;); return message.error(); } auto result = signal_-&gt;publish(message.value()); GXF_LOG_INFO(&quot;Message Sent: %d&quot;, this-&gt;count); this-&gt;count = this-&gt;count + 1; return ToResultCode(message); } private: Parameter&lt;Handle&lt;Transmitter&gt;&gt; signal_; int count = 1; }; class PingRuntimeApp : public Application { public: void compose() override { // create a codelet to generate 10 messages auto tx_entity = makeEntity&lt;PingTxRuntime&gt;(&quot;Tx&quot;, makeTerm&lt;CountSchedulingTerm&gt;(&quot;count&quot;, Arg(&quot;count&quot;, 10))); // create a codelet to receive the messages auto rx_entity = makeEntity&lt;PingRx&gt;(&quot;Rx&quot;); // add data flow connection tx -&gt; rx connect(tx_entity, rx_entity); // configure the scheduler component setScheduler(SchedulerType::kGreedy); } }; int main(int argc, char** argv) { auto app = create_app&lt;PingRuntimeApp&gt;(); app-&gt;loadExtensionManifest(kManifestFilename); app-&gt;compose(); auto result = app-&gt;run(); return ToResultCode(result); }", "keywords": []}, {"id": 2103, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#segment", "display_name": "Segment", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "segment", "priority": -1, "content": "The segment interface is an individual runtime context consisting of one or more graph entities. Each segment has its own scheduler and its corresponding clock component. The Segment::Compose() api is a virtual function used to create the entities of a segment and customize their properties. The Segment layer provides multiple api\u2019s to make the process of creating graph entities simpler. A complex distributed application can consist of multiple segments working with each other. The intra segment connections between entities of a segment make use of double buffer transmitters and receivers and all inter segment connections make of the UCX transmitters and receivers.", "keywords": []}, {"id": 2104, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#sync-extensions", "display_name": "Sync Extensions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "sync-extensions", "priority": -1, "content": "Before any graph can be executed or container built, extensions from NGC public repo must be synced. Follow the steps below to sync the extensions: Ensure the gxf_server has started by running the following command in a terminal: systemctl --user status gxf_server If the service is currently running. You\u2019ll see \u201cActive: active (running)\u201d in the output. If the service is not running, run command systemctl --user start gxf_server to start it. By default, gxf_server runs on port 50051 . It can be changed by export GXF_SERVER_PORT=&lt;port_number&gt; before installation of graph-composer. To change the port after the service has already started automatically post-installation, use command sudo systemctl set-environment GXF_SERVER_PORT=&lt;port_number&gt; to set new port. Then, restart the service to apply the changes using command: systemctl --user restart gxf_server Also change the port number in Composer. Open the Preferences window. Change the port number in the server tab. Be sure no graph is opened. If there is an graph being opened, it must be closed to make the registry menu usable. Open the Registry menu from the menubar at the top and click on Sync Repo Select ngc-public from the drop-down list and click on Sync The composer reports the current status using a progress bar. Once the extension sync is complete, the composer displays a success message. On clicking \u2018OK\u2019, the composer automatically refreshes component list. You can see the refreshed list in the component list window on the right.", "keywords": []}, {"id": 2105, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#tensor-zero-copy-with-other-frameworks", "display_name": "Tensor zero-copy with other frameworks", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "tensor-zero-copy-with-other-frameworks", "priority": -1, "content": "GXF supports zero-copy tensor data exchange between different deep learning frameworks and libraries, like NumPy, CuPy, PyTorch, Tensorflow, etc. see Tensor for API details", "keywords": []}, {"id": 2106, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#ucx-transmit-receive", "display_name": "UCX Transmit / Receive", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "ucx-transmit-receive", "priority": -1, "content": "Transmit and receive data on remote host or device. Eg, System 1 transmit Tensor with device data to remote system 2. entity UCXSource, UCXSink, and UCX are referred in the example app future App API wraps UCXSource, UCXSink, UCX entity implementation, and exposes more concise higher level APIs for distributed execution", "keywords": []}, {"id": 2107, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started#ucxsource-ucxsink-and-context-implementation-for-reference", "display_name": "UCXSource, UCXSink, and context implementation for reference", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "ucxsource-ucxsink-and-context-implementation-for-reference", "priority": -1, "content": "from gxf.serialization import Endpoint from gxf.multimedia import VideoBuffer from gxf.core import Entity from gxf.std import Forward from gxf.std import DoubleBufferTransmitter, DoubleBufferReceiver from gxf.std import DownstreamReceptiveSchedulingTerm, CountSchedulingTerm from gxf.std import UnboundedAllocator from gxf.std import MessageAvailableSchedulingTerm class UCXSource(Entity): &quot;&quot;&quot;UCXSource Entity containing all the requied components to receive data on ucx address:port&quot;&quot;&quot; def __init__(self, name, address=&quot;0.0.0.0&quot;, port=13337, count=-1, capacity=1, min_message_reception=1, allocator_type=None, **kwargs): super().__init__(name, True) self._address = address self._port = port self._count = count self._capacity = capacity self._min_message_reception = min_message_reception self._allocator_type = allocator_type self._kwargs = kwargs self.add(UnboundedAllocator(name=&quot;allocator&quot;)) self.add(UcxSerializationBuffer( name=&quot;serialization_buffer&quot;, allocator=self.allocator)) self.add(UcxReceiver(name=&quot;input&quot;, port=self._port, address=self._address, buffer=self.serialization_buffer)) self.add(MessageAvailableSchedulingTerm(name=&#x27;mast&#x27;, receiver=self.input, min_size=min_message_reception)) self.add(DoubleBufferTransmitter(name=&quot;output&quot;, capacity=capacity)) # &#x27;in&#x27; is a keyword in python. can&#x27;t access as an attribute self.add(Forward(name=&quot;forward&quot;)) self.forward._params[&quot;in&quot;] = self.input self.forward._params[&quot;out&quot;] = self.output self.add(DownstreamReceptiveSchedulingTerm(name=&#x27;drst&#x27;, transmitter=self.output, min_size=min_message_reception)) if count &gt;= 0: self.add(CountSchedulingTerm(name=&quot;cst&quot;, count=self.count)) class UCXSink(Entity): &quot;&quot;&quot;UCXSink Entity containing all the required components to push data on a ucx address:port&quot;&quot;&quot; def __init__(self, name, address=&quot;0.0.0.0&quot;, port=13337, count=-1, capacity=1, min_message_available=1, allocator_type=None, **kwargs): super().__init__(name, True) self._address = address self._port = port self._count = count self._capacity = capacity self._min_message_available = min_message_available self._allocator_type = allocator_type self._kwargs = kwargs self.add(UnboundedAllocator(name=&quot;allocator&quot;)) self.add(UcxSerializationBuffer( name=&quot;serialization_buffer&quot;, allocator=self.allocator)) self.add(UcxTransmitter(name=&quot;output&quot;, port=self._port, buffer=self.serialization_buffer, receiver_address=self._address)) self.add(DoubleBufferReceiver(name=&quot;input&quot;, capacity=capacity)) # in is a keyword in python. can&#x27;t access as an attribute self.add(Forward(name=&quot;forward&quot;)) self.forward._params[&quot;in&quot;] = self.input self.forward._params[&quot;out&quot;] = self.output self.add(MessageAvailableSchedulingTerm(name=&#x27;mast&#x27;, receiver=self.input, min_size=min_message_available)) if count &gt;= 0: self.add(CountSchedulingTerm(name=&quot;cst&quot;, count=self._count)) class UCX(Entity): &quot;&quot;&quot;UCX Entity requied to add UCXSource and UCXSink&quot;&quot;&quot; def __init__(self, name, allocator=None): super().__init__(name, True) if not allocator: allocator = self.add(UnboundedAllocator(name=&quot;allocator&quot;)) self.add(UcxComponentSerializer( name=&quot;component_serializer&quot;, allocator=allocator)) self.add(UcxEntitySerializer(name=&quot;entity_serializer&quot;, component_serializers=[self.component_serializer])) self.add(UcxContext(name=&quot;ucx_context&quot;, serializer=self.entity_serializer)) On top of existing Python API, Python App API will be available in future release. Python App API will be similar to C++ App API [Coming Soon] More sample applications will be available in GXF github repo https://github.com/NVIDIA-AI-IOT/deepstream_gxf_ref_apps", "keywords": []}, {"id": 2108, "doc_id": 2108, "filename": "graphtools-docs/docs/text/GraphComposer_Getting_Started.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "display_name": "Application Development Workflow", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Getting_Started", "anchor": "", "priority": -1, "content": "GXF Applications, also called as graphs, can be created by programming them in python / C++ and also in a no-code environment using the Graph Composer tool. All of these approaches are described below.", "keywords": []}, {"id": 2109, "doc_id": 2111, "filename": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime#multiple-subgraph-files", "display_name": "2. Multiple subgraph files", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime", "anchor": "multiple-subgraph-files", "priority": -1, "content": "When multiple subgraph files are used, then the entity names of various subgraphs are delimited by . until the componet name is reached whose parameter has to be overriden. Hereafter the component type and the parameter will be delimited by / Below is the snippet of multiple sub graph files test_subgraph.yaml --- name: gather_subgraph components: - type: nvidia::gxf::Subgraph name: gather_subgraph parameters: location: &quot;gxf/test/apps/gather_subgraph.yaml&quot; prerequisites: monitored_rx: rx/signal - name: output parameters: max_capacity: 2 - name: forward1_buf_term parameters: min_size: 1 --- gather_subgraph.yaml --- name: forward_subgraph_1 components: - name: forward type: nvidia::gxf::Subgraph parameters: location: gxf/test/apps/forward_subgraph.yaml prerequisites: monitored_rx: prerequisites/monitored_rx --- forward_subgraph.yaml --- name: counter components: - name: step_counter type: nvidia::gxf::test::StepCount parameters: expected_count: 100 --- To override the expected_count of step_counter below command line option can be used. --param=gather_subgraph.forward_subgraph_1.counter/nvidia::gxf::test::StepCount/expected_count=101", "keywords": []}, {"id": 2110, "doc_id": 2111, "filename": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime#single-graph-file", "display_name": "1. Single graph file", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime", "anchor": "single-graph-file", "priority": -1, "content": "Command line option --param of gxe can be used to override the parameters specified in the graph file. Complete path is delimited by / only exception being the last literal whose value has to be overridden is delimited by = Below is the snippet of a graph file --- name: Entity1 components: - type: nvidia::gxf::PeriodicSchedulingTerm parameters: recess_period: 2000000 - type: nvidia::gxf::CountSchedulingTerm parameters: count: 100 - type: nvidia::gxf::test::StepCount parameters: expected_count: 100 --- To override the count of CountSchedulingTerm below command line option can be used. --param=Entity1/nvidia::gxf::CountSchedulingTerm/count=101", "keywords": []}, {"id": 2111, "doc_id": 2111, "filename": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime", "display_name": "Graph Execution Engine", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Graph_Runtime", "anchor": "", "priority": -1, "content": "Graph Execution Engine is used to execute AI application graphs. It accepts multiple graph files as input, and all graphs are executed in same process context. It also needs manifest files as input which includes list of extensions to load. It must list all extensions required for the graph. Registry graph install command can be used to download all required extensions and generate manifest file. /opt/nvidia/graph-composer/gxe --help Flags from gxf/gxe/gxe.cpp: -app (GXF app file to execute. Multiple files can be comma-separated) type: string default: &quot;&quot; -app_root (Root path for GXF app and subgraph files with relative path) type: string default: &quot;&quot; -graph_directory (Path to a directory for searching graph files.) type: string default: &quot;&quot; -log_file_path (Path to a file for logging.) type: string default: &quot;&quot; -manifest (GXF manifest file with extensions. Multiple files can be comma-separated) type: string default: &quot;&quot; -severity (Set log severity levels: 0=None, 1=Error, 2=Warning, 3=Info, 4=Debug. Default: Info) type: int32 default: 3 Other options", "keywords": []}, {"id": 2112, "doc_id": 2115, "filename": "graphtools-docs/docs/text/GraphComposer_Legal.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Legal#copyright", "display_name": "Copyright", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Legal", "anchor": "copyright", "priority": -1, "content": "\u00a9 2021-2024 by NVIDIA CORPORATION &amp; AFFILIATES. All rights reserved.", "keywords": []}, {"id": 2113, "doc_id": 2115, "filename": "graphtools-docs/docs/text/GraphComposer_Legal.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Legal#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Legal", "anchor": "notice", "priority": -1, "content": "ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201dMATERIALS\u201d) ARE BEING PROVIDED \u201dAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OR CONDITION OF TITLE, MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT, ARE HEREBY EXCLUDED TO THE MAXIMUM EXTENT PERMITTED BY LAW. Information furnished is believed to be accurate and reliable. However, NVIDIA Corporation assumes no responsibility for the consequences of use of such information or for any infringement of patents or other rights of third parties that may result from its use. No license is granted by implication or otherwise under any patent or patent rights of NVIDIA Corporation. Specifications mentioned in this publication are subject to change without notice. This publication supersedes and replaces all information previously supplied. NVIDIA Corporation products are not authorized for use as critical components in life support devices or systems without express written approval of NVIDIA Corporation.", "keywords": []}, {"id": 2114, "doc_id": 2115, "filename": "graphtools-docs/docs/text/GraphComposer_Legal.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Legal#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Legal", "anchor": "trademarks", "priority": -1, "content": "NVIDIA, the NVIDIA logo, CUDA, Jetson, Jetson Nano, NVIDIA AGX, Tegra, TensorRT, Tesla and Xavier are trademarks or registered trademarks of NVIDIA Corporation in the United States and other countries. Other company and product names may be trademarks of the respective companies with which they are associated. The Android robot is reproduced or modified from work created and shared by Google and is used according to terms described in the Creative Commons 3.0 Attribution License. HDMI, the HDMI logo, and High-Definition Multimedia Interface are trademarks or registered trademarks of HDMI Licensing LLC. ARM, AMBA, and ARM Powered are registered trademarks of ARM Limited. Cortex, MPCore and Mali are trademarks of ARM Limited. All other brands or product names are the property of their respective holders. \u201dARM\u201d is used to represent ARM Holdings plc; its operating company ARM Limited; and the regional subsidiaries ARM Inc.; ARM KK; ARM Korea Limited.; ARM Taiwan Limited; ARM France SAS; ARM Consulting (Shanghai) Co. Ltd.; ARM Germany GmbH; ARM Embedded Technologies Pvt. Ltd.; ARM Norway, AS and ARM Sweden AB.", "keywords": []}, {"id": 2115, "doc_id": 2115, "filename": "graphtools-docs/docs/text/GraphComposer_Legal.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Legal", "display_name": "Graph Composer Legal Information", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Legal", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2116, "doc_id": 2117, "filename": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form#request-documentation-fix", "display_name": "Request Documentation Fix", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form", "anchor": "request-documentation-fix", "priority": -1, "content": "We apologize you found an error in our documentation and thank you in advance for helping us correct it. Below is a form which you can use to pinpoint the problem for us so corrections happen quickly.", "keywords": []}, {"id": 2117, "doc_id": 2117, "filename": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form", "display_name": "Feedback form", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Main_Feedback_Form", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2118, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#dependencies", "display_name": "Dependencies", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "dependencies", "priority": -1, "content": "Depends on Graph Composer Runtime", "keywords": []}, {"id": 2119, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#features-supported", "display_name": "Features Supported", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "features-supported", "priority": -1, "content": "Modules Version High-level Features Composer 4.1.0 User friendly editor view Registry list in view Graph edit with various options Graph open/save Property editor Graph Launcher Container Builder Launcher Registry options Extension Generator", "keywords": []}, {"id": 2120, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#graph-composer", "display_name": "Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "graph-composer", "priority": -1, "content": "Download Graph Composer Debian package for x86 from [ here ]", "keywords": []}, {"id": 2121, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#graph-composer-runtime", "display_name": "Graph Composer Runtime", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "graph-composer-runtime", "priority": -1, "content": "Download Graph Composer Runtime Debian package for x86 from [ here ]", "keywords": []}, {"id": 2122, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id10", "display_name": "Features Supported", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id10", "priority": -1, "content": "Modules Version High-level Features Graph execution engine 4.1.0 Load and execute graph files Registry 1.1.0 NVIDIA Cloud repository Variants for CUDA 12.6 (aarch64) Version management based on Semantic versioning Command Line Interface tool Graph install for graph deploy Container Builder 1.2.0 Command Line Interface tool Create container image for graphs Supports .deb/PyPi/.tgz packages", "keywords": []}, {"id": 2123, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id11", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id11", "priority": -1, "content": "Platform Jetson OS Ubuntu 22.04 Python 3.10 Jetpack 6.1 CUDA 12.6 GPU iGPU DeepStream SDK 7.1 (for DeepStream extensions)", "keywords": []}, {"id": 2124, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id12", "display_name": "Install", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id12", "priority": -1, "content": "sudo dpkg -i graph_composer-runtime-4.1.0_arm64.deb", "keywords": []}, {"id": 2125, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id13", "display_name": "Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id13", "priority": -1, "content": "Download Graph Composer Windows Installer from [ here ]", "keywords": []}, {"id": 2126, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id15", "display_name": "Features Supported", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id15", "priority": -1, "content": "Modules Version High-level Features Composer 4.1.0 User friendly editor view Registry list in view Graph edit with various options Graph open/save Property editor Graph Launcher Container Builder Launcher Registry options Extension Generator", "keywords": []}, {"id": 2127, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id16", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id16", "priority": -1, "content": "Platform x86_64 OS Windows 10 2 GPU CUDA-capable GPU, iGPU 3  2 (Alpha) With remote execution only  3 (Alpha) Need Vulkan support ( Intel Iris Graphics 540 or later )", "keywords": []}, {"id": 2128, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id4", "display_name": "Features Supported", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id4", "priority": -1, "content": "Modules Version High-level Features Graph execution engine 4.1.0 Load and execute graph files Registry 1.1.0 Local and NVIDIA Cloud repository Variants CUDA 12.6 (x86_64) Version management based on Semantic versioning Command Line Interface tool Graph install for graph deploy Container Builder 1.2.0 Command Line Interface tool Create container image for graphs Supports .deb/PyPi/.tgz packages", "keywords": []}, {"id": 2129, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id5", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id5", "priority": -1, "content": "Platform x86_64 OS Ubuntu 22.04 Python 3.10 CUDA 12.6 GPU CUDA-capable GPU(GPU,RTX2080/RTX3080/T4/A100) 1 Docker &gt;=19.03.3 2  1 (Alpha) Need Vulkan support ( Intel Iris Graphics 540 or later )  2  https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker", "keywords": []}, {"id": 2130, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id7", "display_name": "Install", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id7", "priority": -1, "content": "sudo dpkg -i graph_composer-runtime-4.1.0_x86_64.deb", "keywords": []}, {"id": 2131, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#id8", "display_name": "Graph Composer Runtime", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "id8", "priority": -1, "content": "Download Graph Composer Runtime Debian package for for ARM64 from [ here ]", "keywords": []}, {"id": 2132, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#install", "display_name": "Install", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "install", "priority": -1, "content": "sudo dpkg -i graph_composer-4.1.0_x86_64.deb", "keywords": []}, {"id": 2133, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#system-requirements", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "system-requirements", "priority": -1, "content": "Platform x86_64 OS Ubuntu 22.04 Python 3.10 CUDA 12.6 GPU CUDA-capable GPU(GPU,RTX2080/RTX3080/T4/A100) 1 DeepStream SDK 7.1 (for DeepStream extensions) Docker &gt;=19.03.3 2  1 (Alpha) Need Vulkan support ( Intel Iris Graphics 540 or later )  2  https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker", "keywords": []}, {"id": 2134, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Platforms#wsl-ubuntu-22-04-lts-x86-64", "display_name": "WSL Ubuntu 22.04 LTS (x86_64)", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "wsl-ubuntu-22-04-lts-x86-64", "priority": -1, "content": "For installation of the debian packages, refer to Ubuntu 22.04 LTS (x86_64) . Same process of installation as on native Ubuntu-22.04 is followed. Composer UI is not supported from WSL", "keywords": []}, {"id": 2135, "doc_id": 2135, "filename": "graphtools-docs/docs/text/GraphComposer_Platforms.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Platforms", "display_name": "Supported platforms", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Platforms", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2136, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#cache", "display_name": "Cache", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "cache", "priority": -1, "content": "Registry maintains metadata for all extensions synchronized from Nvidia Cloud repository or added locally by Extension Development Workflow . It allows quick access to extension metadata on query from tools. Users can clean cache or refresh cache using Registry Command Line Interface commands. Users has to sync repositories again after cleaning cache to query extension information from registry. Registry maintains two types of cache. The extension metadata contains extension interfaces from all the extensions that were synced along with their corresponding variants which have been uploaded to NGC. This cache is populated by the registry by registry repo sync command. The extension variants are cached by the registry graph install command. The variant archive containing the extension library along with any other headers, source or data files are cached the first time they are downloaded from a NGC repo and reused for subsequent registry graph install operations. /var/tmp/gxf/ is considered as the registry root which is configurable using the GXF_REGISTRY_ROOT environment variable. Optionally, registry cache --set command can be used to set a specific path for the registry cache. If Composer is being lauched from a docker, the registry cache from the host can be accessed in the docker by mounting the registry cache path. Sample Command for docker launch: :: docker run -it \u2013rm \u2013net=host \u2013runtime nvidia -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix -v /var/tmp/gxf/.cache/gxf_registry/:/var/tmp/gxf/.cache/gxf_registry/ \u2013privileged &lt;DOCKER-REPOSITORY&gt;:&lt;TAG&gt;", "keywords": []}, {"id": 2137, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#extension-registration", "display_name": "Extension Registration", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "extension-registration", "priority": -1, "content": "Extension registration adds a new extension to the registry\u2019s cache and default repository. register_extension macro can be used to register a new extension with the registry. Mandatory fields: name - Name of the extension registration target. It must follow register_&lt;extension-name&gt;_ext naming convention. extension \u2013 Extension target complied using the graph_cc_extension(\u2026) rule uuid \u2013 Universally unique identifier used to register the extension. Format should follow the standard uuid convention version \u2013 Extension version. A string that specifies the version of the extension in the following format MAJOR.MINOR.PATCH. Extension developers are expected to follow the semantic versioning concept where a new update in version should follow these guidelines: MAJOR version update when there are API-breaking changes MINOR version update when features are added in backward compatible manner PATCH version update when bugs are fixed in backward compatible manner license \u2013 Extension license. A string naming the type of license associated with the extension. For example \u2013 MIT, Apache-2.0, BSD. license_file \u2013 Path to a text file which has the complete licensing terms and specifications. Optional fields: url \u2013 A link to the web address of the extension project repository \u2013 A link to the web address of the extension source code labels \u2013 A list of strings which can be used to categorize the extension in NGC. For example, [\u201cnvidia\u201d, \u201cgpu\u201d, \u201cnvgraph\u201d] priority \u2013 A value between 0-100 used to indicate the priority of the extension to be used during deployment. target \u2013 Target configuration for the extension variant. A dictionary containing the following keys - arch , os and distribution . If the target info is not specified, it will be automatically deduced based on the bazel build configs used. Accepted values: arch \u2013 x86_64, aarch64, sbsa os \u2013 linux distribution \u2013 ubuntu_22.04 local_dependencies \u2013 A list of registration targets of the dependent repositories. Extensions specified here will be registered prior to the current extension. For example: local_dependencies = [&quot;//gxf/sample_extension:register_sample_ext&quot;] compute_dependencies \u2013 A list of compute dependencies needed to build the extension library. The required versions of these compute dependencies will be deduced automatically using the bazel build configs used. Accepted values - cuda , cudnn , tensorrt , deepstream , vpi . Example usage: compute_dependencies = [&quot;cuda&quot;, &quot;tensorrt&quot;, &quot;deepstream&quot;] headers \u2013 A list of strings containing the paths to the header files of the extension. binaries \u2013 A list of strings containing the paths to any optional binary files the extension needs during deployment. data \u2013 A list of strings containing the paths to any optional data files the extension needs during deployment. Once register_extension macro has been invoked, a manifest file would be auto generated and the registry CLI tool would be used to run extn add command along with the corresponding arguments. This rule further adds this extension to the registry\u2019s local cache and updates the default repository with the extension library, manifest, metadata, and any of the optional files that were specified during registration. The registration process also generates an output file which contains metadata regarding the extension\u2019s interface. More specifically, it contains information regarding various components and the parameters used in those components, header files, dependencies, labels, author, description etc. Here are the guidelines for registering an extension: x86_64 version of an extension must be registered first before any cross complied (aarch64) variant of the extension is registered. Since the cross complied extension cannot be queried for the extension interface (types of components and parameters) the registry considers the x86_64 variant of the extension as the reference for its interface. In case the cache and/or default repository has been cleaned since the extension was previously registered, the x86_64 variant of the extension must be registered again to repopulate the cache and default repository. If the extension getting registered depends on other extensions in the source code then it must be listed as a dependency in the \u201cdependencies\u201d field. Specifically, the registration target name of the dependent extension must be listed as the dependency so that registry can query the dependent extension\u2019s metadata for its uuid, name and version. If the same extension variant is registered twice, the previously registered variant in the default repository is removed and updated with the contents in the new manifest. Similarly, registering any of the x86_64 variants will update the extension interface in registry cache and hence it is important that extensions interface remains the same across all the variants of the same extension and version. Registering an extension and its variants is only supported on linux x86_64 platforms.", "keywords": []}, {"id": 2138, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#installing-graphs-for-deployment", "display_name": "Installing graphs for deployment", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "installing-graphs-for-deployment", "priority": -1, "content": "The registry can also be used to deploy graphs locally or containerize the graph using container builder. To execute a graph using gxe, the registry provides a functionality to prepare a manifest and a corresponding archive package containing all the extensions that are required. An example manifest for the sample graph above is shown here: An example archive for the sample graph above is shown here: To install a graph: Create a graph using the nvgraph composer and save it to the local filesystem. Use the graph install command in the CLI tool along with the target platform configuration that decides the variant of the extensions that should be used to for deployment. Registry will auto select the best matching variant for each extension based on the target platform. The output of the graph install command is a gxe manifest along with an archive which contains all the extension libraries and files that were packaged with the extension variant. There\u2019s an option to unpack the deployment package in a local directory which can be used to run the graph locally. Use registry CLI tool with graph install --help to view all the arguments that are supported. All the extensions used in the graph must be present in the registry\u2019s local cache to install the graph successfully. The version of the extension used in the graph must also match the versions of the extension found in the registry cache. Suppose an extension A is listed as a dependency for extension B and extension C. If a graph is created using extensions B and extension C, it needs to be ensured that both B and C are dependent on the same version of extension A and that version of extension A should be synchronized with the registry to install the graph. Using multiple versions of the same extension in a graph is not supported and is not advisable to create such dependencies. The registry performs version management while installing graphs to ensure the latest versions of extensions are being deployed. Suppose a graph was created using version 1.0.0 of extension A, while there was a newer version of extension 1.1.0 available during graph install stage. It is ensured only the latest minor.patch version corresponding to the same major of the extension is added in the archive.", "keywords": []}, {"id": 2139, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#local-workspace", "display_name": "Local Workspace", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "local-workspace", "priority": -1, "content": "Local workspace is provided for Extension Development Workflow . Registry stores current development version of extension in local workspace. Default workspace path used by Registry is /var/tmp/gxf/.cache/gxf_workspace . It stores only one version so it will overwrite whenever user updates version of extension and adds it to registry. /var/tmp/gxf/` is considered as the registry root on local disk which is configurable using the GXF_REGISTRY_ROOT environment variable.", "keywords": []}, {"id": 2140, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#nvidia-cloud-repository", "display_name": "NVIDIA Cloud Repository", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "nvidia-cloud-repository", "priority": -1, "content": "Extensions from Nvidia for public access are published in Nvidia Cloud repository. External users can access these extensions using registry repo sync -n ngc-public command. This command downloads all published extensions metadata to Cache on local disk.", "keywords": []}, {"id": 2141, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry#repository-manager", "display_name": "Repository Manager", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "repository-manager", "priority": -1, "content": "Repository manager is responsible to communicating with NVIDIA Cloud repository or local workspace based on operation or arguments to operation.", "keywords": []}, {"id": 2142, "doc_id": 2142, "filename": "graphtools-docs/docs/text/GraphComposer_Registry.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Registry", "display_name": "Registry", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Registry", "anchor": "", "priority": -1, "content": "The Registry is an integral part of the Graph Composer ecosystem and is responsible for providing unified interface between the extensions and tools. Registry service can be accessed using registry CLI: Registry Command Line Interface In the backend, Registry communicates with Nvidia Cloud repository and Local workspace for extension management while it uses local database as cache of extension metadata.", "keywords": []}, {"id": 2143, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#cache", "display_name": "cache", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "cache", "priority": -1, "content": "This command is used to interact with the cache content. Command syntax registry cache [args] Optional arguments: -h/--help - Print help and exit. -s/--set &lt;new_cache_path&gt; - Set an absolute path where the cache must be located. -c/--clean - Clean the cache. -r/--refresh - Refresh the cache. -v/--view - View the cache location.", "keywords": []}, {"id": 2144, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#comp", "display_name": "comp", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "comp", "priority": -1, "content": "This command is used to interact with components. Each component contains a list of parameters. A parameter contains a key, a headline, a description, a gxf_parameter_type , a default value, a handle type and flags. Command syntax : registry comp [args] Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2145, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#comp-info", "display_name": "comp info", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "comp-info", "priority": -1, "content": "This command is used to provide information about a component. Command syntax : registry comp info [args] Required arguments: -t/--type &lt;component_type&gt; - Select a component type. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2146, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#comp-list", "display_name": "comp list", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "comp-list", "priority": -1, "content": "This command is used to list components. Filters are available as it is the case for components. Command syntax : registry comp list [args] Optional arguments: -h/--help - Print help and exit. -b/--base-type &lt;base_type&gt; - Select a base type. -r/--repo-name &lt;repository_name&gt; - Select a repository name. -t/--typename &lt;typename&gt; - Select a typename.", "keywords": []}, {"id": 2147, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn", "display_name": "extn", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn", "priority": -1, "content": "An extension references headers, shared libraries, binary files and data files. It is referenced by uuid (Universally unique identifier), a name and a version. It can depend on other extensions for which their name, uuid and version must be specified. Also, an extension contains a list of components. An extension can be implemented for several targets with differences in architecture, operating system, distribution and CUDA version. Each one of these combinations is called a variant. Each extension has an interface, this interface is composed of an extension.yaml file along with optional header files. These files are common for all variants of that extension. Each extension contains a list of components. A component contains a typename , a type_id , a base typename , a description and a boolean telling if the component is abstract. Command syntax : registry extn [args] Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2148, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-add", "display_name": "extn add", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-add", "priority": -1, "content": "This command is used to add an extension. Command syntax : registry extn add [args] Required arguments: -m/--manifest-name &lt;manifest_name&gt; - Set a manifest path. Optional arguments: -h/--help - Print help and exit. Here is an example of &lt;manifest_name&gt; argument: name: cuda extension_library: libgxf_cuda.so uuid: d63a98fa-7882-11eb-a917-b38f664f399c version: 2.5.0 license_file: gxf/cuda/LICENSE url: www.nvidia.com git_repository: null labels: - gxf priority: 1 platform: arch: x86_64 os: linux distribution: ubuntu_22.04 compute: cuda: 12.6 tensorrt: null cudnn: null deepstream: null triton: null vpi: null dependencies: - extension: std uuid: 8ec2d5d6-b5df-48bf-8dee-0252606fdd7e version: 2.5.0 manifest: std/register_std_ext_manifest.yaml headers: - cuda_common.hpp - cuda_event.hpp - cuda_stream.hpp - cuda_stream_id.hpp - cuda_stream_pool.hpp binaries: [] python_alias: cuda namespace: gxf python_bindings: - gxf/cuda/cuda_pybind.so python_sources: - __init__.py - Components.py data: []", "keywords": []}, {"id": 2149, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-dependencies", "display_name": "extn dependencies", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-dependencies", "priority": -1, "content": "This command is used to display all dependencies of an extension. Command syntax : registry extn dependencies [args] Required arguments: -n/--name &lt;extension_name&gt; - Select an extension name. -s/--select-version &lt;extension_version&gt; - Select an extension version. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2150, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-import", "display_name": "extn import", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-import", "priority": -1, "content": "This command is used to import extension packages from NGC. A specific version of an extension contains an interface and multiple variants. Interface Command syntax : registry extn import interface [args] Required arguments: -d/--output-directory &lt;directory&gt; - Select an output directory. -s/--select-version &lt;extension_version&gt; - Select an extension version. -n/--extn-name &lt;extension_name&gt; - Select an extension name. Optional arguments: -h/--help - Print help and exit. Variant Command syntax : :: registry extn import variant [args] Required arguments: * -d/--output-directory &lt;directory&gt; - Select an output directory. * -s/--select-version &lt;extension_version&gt; - Select an extension version. * -n/--extn-name &lt;extension_name&gt; - Select an extension name. * -a/--arch &lt;architecture&gt; - Set an architecture. * -f/--distro &lt;distribution&gt; - Set a distribution. * -o/--os &lt;os&gt; - Select an operating system. Optional arguments: --cuda &lt;cuda&gt; - Select a CUDA version. --cudnn &lt;cudnn&gt; - Select a CUDNN version --tensorrt &lt;tensorrt&gt; - Select a TensorRT version. --deepstream &lt;deepstream&gt; - Select a DeepStream version --triton &lt;triton&gt; - Select a Triton version. --vpi &lt;vpi&gt; - Select a VPI version. -h/--help - Print help and exit. Supported values for the required arguments: Arguments Supported Default Architecture aarch64, x86_64, sbsa x86_64 Distribution ubuntu_22.04 ubuntu_22.04 Operating System linux linux", "keywords": []}, {"id": 2151, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-info", "display_name": "extn info", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-info", "priority": -1, "content": "This command is used to provide information about an extension. Command syntax : registry extn info [args] Required arguments: -n/--extn-name &lt;extension_name&gt; - Select an extension name. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2152, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-list", "display_name": "extn list", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-list", "priority": -1, "content": "This command is used to list extensions. Once extensions are present in cache, it is possible to list them and obtain details about them. Also, it is possible to filter extensions to display only the ones matching some characteristics. The filtering is optional. Command syntax : registry extn list [args] Optional arguments: -h/--help - Print help and exit. -r/--repo-name &lt;repository_name&gt; - Select a repository name. -n/--name &lt;extension_name&gt; - Select an extension name. -a/--author &lt;extension_author&gt; - Select an author. -l/--labels &lt;label1&gt; [ &lt;label2&gt;...] - Select one or multiple labels.", "keywords": []}, {"id": 2153, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-sync", "display_name": "extn sync", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-sync", "priority": -1, "content": "This command is used to synchronize an extension. Command syntax : registry extn sync [args] Required arguments: -r/--repo-name &lt;repository_name&gt; - Set a repository name. -e/--extension-name &lt;extension_name&gt; - Set an extension name. -s/--select-version &lt;extension_version&gt; - Select a version. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2154, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-variants", "display_name": "extn variants", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-variants", "priority": -1, "content": "This command is used to display variants of an extension. Command syntax : registry extn variants [args] Required arguments: -n/--name &lt;extension_name&gt; - Select an extension name. -v/--version &lt;version&gt; - Select an extension version. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2155, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#extn-versions", "display_name": "extn versions", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "extn-versions", "priority": -1, "content": "This command is used to display versions of an extension. Command syntax : registry extn versions [args] Required arguments: -n/--name &lt;extension_name&gt; - Select an extension name. Optional arguments: -h/--help - Print help and exit. -r/--repo-name &lt;repository_name&gt; - Select a repository name.", "keywords": []}, {"id": 2156, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#graph", "display_name": "graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "graph", "priority": -1, "content": "This command is used to interact with the graph. Command syntax : registry graph [args] Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2157, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#graph-install", "display_name": "graph install", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "graph-install", "priority": -1, "content": "This command is used to install graph and generate a manifest with the list of extensions needed to execute the graph and in the order in which they must be loaded. Also generates an archive of the extensions and their files corresponding to the variant arguments specified using the target file. For every extension used in the graph, the registry will choose the closest matching variant from its cache and create the archive. The variant chosen by the registry will be specified in the output manifest file. Generated archive can also be unpacked locally into a directory specified by --archive-dir-path . Command syntax : registry graph install [args] Required arguments: -g/--graph-file &lt;graph_file&gt; - Set the graph file to be used. -d/--target-file-path &lt;target_file_path&gt; - Set the target file path -m/--manifest-file-path &lt;manifest_file_path&gt; - Set the manifest file path. Optional arguments: -h/--help - Print help and exit. -u/--output-directory &lt;output_directory&gt; - Set the output directory. -r/--archive-dir-path &lt;archive_directory_path&gt; - Set the archive directory path. -i/--in-export-dir-path &lt;in_export_dirpath&gt; - Set the export directory path. Sample Target File : platform: arch: x86_64 os: linux distribution: ubuntu_22.04 compute: cuda: 12.6 cudnn: 9.3.0 tensorrt: 10.3.0 deepstream: 7.1 triton: 2.49.0 vpi: 2.3.1", "keywords": []}, {"id": 2158, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#repo", "display_name": "repo", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "repo", "priority": -1, "content": "This command is used to interact with the repositories. Command syntax registry repo [args] Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2159, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#repo-clean", "display_name": "repo clean", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "repo-clean", "priority": -1, "content": "This command is used to clean the default repository. Command syntax registry repo clean [args] Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2160, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#repo-info", "display_name": "repo info", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "repo-info", "priority": -1, "content": "This command is used to provide information about a repository. Command syntax : registry repo info [args] Required arguments: -n/--name &lt;repository_name&gt; - Provide details a repository. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2161, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#repo-list", "display_name": "repo list", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "repo-list", "priority": -1, "content": "This command is used to list repositories. Command syntax : registry repo list [args] Optional arguments: -h/--help - Print help and exit. -d/--details - Provide details about repositories.", "keywords": []}, {"id": 2162, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI#repo-sync", "display_name": "repo sync", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "repo-sync", "priority": -1, "content": "This command is used to synchronize a repository. Also synchronizes each extension of the provided repository to the cache. Command syntax : registry repo sync [args] Required arguments: -n/--name &lt;repository_name&gt; - Set the name of repository to be used. Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2163, "doc_id": 2163, "filename": "graphtools-docs/docs/text/GraphComposer_Registry_CLI.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "display_name": "Registry Command Line Interface", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_Registry_CLI", "anchor": "", "priority": -1, "content": "The Registry command line interface (CLI) can be invoked by registry command with the following options: registry \u2013help registry --version registry command [args] Where -h/--help brings up the help options and exit -v/--version prints the version and exits. The sections below provide details about the command options that can be used with the registry .", "keywords": []}, {"id": 2164, "doc_id": 2167, "filename": "graphtools-docs/docs/text/GraphComposer_gxf_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_gxf_CLI#config", "display_name": "config", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_gxf_CLI", "anchor": "config", "priority": -1, "content": "This command is used to set the parameter of a specific component in a running graph Command syntax gxf_cli config [-h] cid key value cid : cid is the uid of the target component, can be replaced by \u201centity_name/component_name\u201d if the names are available key : the parameter name value : the value to be set, in JSON format Optional arguments: -h/--help - Print help and exit.", "keywords": []}, {"id": 2165, "doc_id": 2167, "filename": "graphtools-docs/docs/text/GraphComposer_gxf_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_gxf_CLI#dump", "display_name": "dump", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_gxf_CLI", "anchor": "dump", "priority": -1, "content": "This command is used to dump the entities in the current running graph in parsable YAML format. command syntax gxf_cli dump [-h] [-u UID] Optional arguments: -u/--uid : only dump the data on the entity with specified uid -h/--help - Print help and exit. Sample content dumped from a running graph : --- name: rx id: 8 components: - name: signal id: 9 type: nvidia::gxf::DoubleBufferReceiver parameters: capacity: 1 policy: 2 - name: nvidia::gxf::MessageAvailableSchedulingTerm_rx id: 10 type: nvidia::gxf::MessageAvailableSchedulingTerm parameters: receiver: rx/signal min_size: 1 - name: ping_rx id: 11 type: nvidia::gxf::test::PingRx parameters: signal: rx/signal - name: step_count_rx id: 12 type: nvidia::gxf::test::StepCount parameters: use_assert: false expected_start_count: 1 expected_count: 100", "keywords": []}, {"id": 2166, "doc_id": 2167, "filename": "graphtools-docs/docs/text/GraphComposer_gxf_CLI.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_gxf_CLI#stat", "display_name": "stat", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_gxf_CLI", "anchor": "stat", "priority": -1, "content": "This command is used to continuous monitor the statistic information from a running gxe process. Command syntax gxf_cli stat [-h] [-u UID] target The target can be one of the follows: entity - Monitor the entity statistics codelet - Monitor the codelet statistics event - Monitor the scheduling event statistics term - Monitor the scheduling term statistics Optional arguments: -u/--uid : only monitor data on an entity or component with specified uid -h/--help - Print help and exit.", "keywords": []}, {"id": 2167, "doc_id": 2167, "filename": "graphtools-docs/docs/text/GraphComposer_gxf_CLI.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_gxf_CLI", "display_name": "GXF Command Line Interface", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_gxf_CLI", "anchor": "", "priority": -1, "content": "The GXF command line interface (CLI) can be invoked by gxf_cli command with the following options: gxf_cli \u2013help gxf_cli --version gxf_cli [-s SERVER] [-t TRANSPORT] command [args] Where -h/--help brings up the help options and exit -v/--version prints the version and exits. Optional arguments: -s/--server : specify the server address, bed default it is \u2018localhost:8000\u2019, which is the default address used by the http server in the GXF graph. -t/--transport : specify the transport type, by default it is \u2018http\u2019, can also be set to \u2018grpc\u2019 if the GXF graph enables GRPC server The sections below provide details about the command options that can be used with the gxf_cli .", "keywords": []}, {"id": 2168, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#codelets", "display_name": "Codelets", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "codelets", "priority": -1, "content": "The most common component is a codelet which is used for data processing and code execution. In order to implement a custom codelet the developer implements a certain set of functions like start and stop. A special system called scheduler - The GXF Scheduler - will call these functions at the appropriate time as specified by the developer. Typical examples of triggering code execution are: receiving a new message from another node, or performing work on a regular schedule based on a time trigger.", "keywords": []}, {"id": 2169, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#components", "display_name": "Components", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "components", "priority": -1, "content": "Components are the main functional blocks of an application. GXF provides a couple of standard components such as transmitter, receiver, codelet, subgraph. GXF also allows a developer to extend the GXF runtime by injecting its own custom components with custom features to fit a specific use case.", "keywords": []}, {"id": 2170, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#container-builder", "display_name": "Container Builder", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "container-builder", "priority": -1, "content": "Container Builder (CB) is used to build docker images for AI Application graphs created using Composer. In addition to docker images, it can also push the final image into the cloud for deployment. Container Builder interacts with Registry : to: Download extensions and other related files into your local system. Copy other required files specified in the config file to generate an intermediate work folder and an optimized dockerfile. Convert archives/packages dependencies and instructions into docker and try to build a minimal sized local image. For optimization, you can easily configure container builder to support multi-stage docker build. Container Builder supports graph installing and container image building on x86 Ubuntu systems. It can also build arm64 images from x86_64 platforms - to do this, you will need to install QEMU and bintutils . Additionally, CB tool can now build multiarch images with the prerequisite that the user needs to specify a remote docker repository where the images can be pushed.", "keywords": []}, {"id": 2171, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#edges-connection", "display_name": "Edges / Connection", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "edges-connection", "priority": -1, "content": "A GXF dataflow edge is a GXF entity. Thus an edge is a light-weight, uniquely identifiable container of (edge) components. By default every edge has a DirectedEdge component which stores source and target. By default all edges of a compute graph are governed by the MessageRouter. A developer can inject custom (edge) components and (edge) systems into GXE.", "keywords": []}, {"id": 2172, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#extension", "display_name": "Extension", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "extension", "priority": -1, "content": "An extension is a compiled shared library of a logical group of component type definitions and their implementations along with any other asset files that are required for execution of the components. Some examples of asset files are model files, shared libraries that the extension library links to and hence required to run, header and development files that enable development of additional components and extensions that use components from the extension. An extension library is a runtime loadable module compiled with component information in a standard format that allows the graph runtime to load the extension and retrieve further information from it to: Allow the runtime to create components using the component types in the extension. Query information regarding the component types in the extension: The component type name The base type of the component A string description of the component Information of parameters of the component \u2013 parameter name, type, description etc., Query information regarding the extension itself - Name of the extension, version, license, author and a string description of the extension. The section Extension Development Workflow talks more about this with a focus on developing extensions and components.", "keywords": []}, {"id": 2173, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#graph", "display_name": "Graph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "graph", "priority": -1, "content": "A graph is a data-driven representation of an AI application. Implementing an application by using programming code to create and link objects results in a monolithic and hard to maintain program. Instead a graph object is used to structure an application. The graph can be created using specialized tools and it can be analyzed to identify potential problems or performance bottlenecks. The graph is loaded by the GXF runtime in order to be executed. The functional blocks of a graph are defined by the set of nodes which the graph is owning. Nodes can be queried via the graph using certain query functions. For example it is possible to search for a node by its name.", "keywords": []}, {"id": 2174, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#graph-composer", "display_name": "Graph Composer", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "graph-composer", "priority": -1, "content": "The Composer is an GUI application designed to create AI Application pipeline through an easy-to-use graphic interface, reducing the complexity of application development significantly and thus reducing time to market. The Composer is based on the https://docs.omniverse.nvidia.com/ Kit which provides a highly responsive hardware-accelerated GUI.", "keywords": []}, {"id": 2175, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#graph-execution-engine-gxe", "display_name": "Graph eXecution Engine (GXE)", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "graph-execution-engine-gxe", "priority": -1, "content": "GXE accepts an application file which has the GXF components listed and a manifest file that has dependent extensions. GXE loads the graph and the dependent extensions and activates all the entities that are defined in the application file. Below are the steps that describes the functionality of GXE. Create GXF context Load the manifest file containing the GXF extensions Load the application file containing the GXF entities and their connections Activate the entities Wait for the graph to complete Destroy GXF context", "keywords": []}, {"id": 2176, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#gxf-cli", "display_name": "GXF CLI", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "gxf-cli", "priority": -1, "content": "GXF CLI tool is used to connect GXF runtime remotely for monitoring or configuring tasks.", "keywords": []}, {"id": 2177, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#gxf-graph-execution-format", "display_name": "GXF (Graph eXecution Format)", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "gxf-graph-execution-format", "priority": -1, "content": "GXF specification follow an entity-component design pattern implementing the \u201ccomposition over inheritance\u201d paradigm. An entity itself is just a light-weight object which owns components. Components define how an entity interacts with the rest of the application. The GXF specification consists of five things: A definition of a compute graph using an extensible entity-component architecture A definition of APIs which allow developers to attach code and data to a compute graph A specification of scheduling rules and the data flow between sources and sinks A file format description for storing a compute graph in a file A list of analytics, monitoring and debugging info produced during runtime GXF framework streamlines the process of application development by Enabling code reuse amongst developers with minimal integration overhead Establishes common streaming media data types with customization hooks / interfaces A rich tool suite to help analyze, debug, optimize and deploy high performance AI applications", "keywords": []}, {"id": 2178, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#gxf-server", "display_name": "GXF Server", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "gxf-server", "priority": -1, "content": "The GXF server is a grpc server that integrates multiple tools, including registry and container builder, and provides services for various command line tools such as container builder cli, and the graph composer. The gxf server starts automatically on installation of graph composer debian. The server starts using 50051 as the default port. The users can change this by setting the environment variable GXF_SERVER_PORT prior to running the server.", "keywords": []}, {"id": 2179, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#messages", "display_name": "Messages", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "messages", "priority": -1, "content": "A GXF message is an entity. Thus a message is a light-weight, uniquely identifiable container of (message) components. Standard message components are: Header, Checksum, GPU Buffer, CPU Buffer. A typical message systems is a data pool which handels buffer allocation. Standard message systems provided by GXE are: GPU Buffer Pool, CPU Buffer Pool. A developer can inject custom (message) components and (message) systems into GXE.", "keywords": []}, {"id": 2180, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#node", "display_name": "Node", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "node", "priority": -1, "content": "GXF uses an entity-component design principle for nodes and a GXF compute node is a GXF entity. This means that a node is a light-weight object whose main purpose is to own components. A node is a composition of components. Components are the \u201cthings\u201d which define the aspects and behavior of the node. In order to customize a GXF node a developer does not derive from node as a base class, but instead composes objects out of components. Components can be used to provide a rich set of functionality to a node and thus to an application. Every node in the graph is uniquely identifiable as described in more detail in the section about object identification.", "keywords": []}, {"id": 2181, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#registry", "display_name": "Registry", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "registry", "priority": -1, "content": "The Registry is an integral part of the Graph Composer ecosystem and is responsible for providing unified interface between the extensions and tools. Registry service can be accessed using registry CLI.", "keywords": []}, {"id": 2182, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#subgraph", "display_name": "Subgraph", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "subgraph", "priority": -1, "content": "Subgraph allows a node to wrap a whole graph and treat it like a sub-processing unit. Such subgraphs help greatly to increase the modularity of an application and allow reuse of compute graphs across applications. A subgraph\u2019s internals are opaque to the outside world, and it can employ its own scheduler.", "keywords": []}, {"id": 2183, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#system", "display_name": "System", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "system", "priority": -1, "content": "Systems are used to create, govern and destroy components. Standard systems provided by GXF are for example: Greedy Scheduler, Multi-thread scheduler, Event Based Scheduler, GraphWorker, GraphDriver.", "keywords": []}, {"id": 2184, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "page", "name": "graphtools-docs/docs/text/GraphComposer_intro#workflow", "display_name": "Workflow", "type": "section", "display_type": "Page section", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "workflow", "priority": -1, "content": "Graph Composer workflow enables AI application development using extensions from different contributors along with custome extension development. They enable AI Application developers to create the applications using GUI based tool and deploy them using Container Builder tool without developing any code. It provides central repository of NVIDIA \ufffd optimized extensions for different hardware platforms.", "keywords": []}, {"id": 2185, "doc_id": 2185, "filename": "graphtools-docs/docs/text/GraphComposer_intro.html", "domain_name": "std", "name": "graphtools-docs/docs/text/GraphComposer_intro", "display_name": "Overview", "type": "doc", "display_type": "Page", "docname": "graphtools-docs/docs/text/GraphComposer_intro", "anchor": "", "priority": -1, "content": "Graph Composer is a tool suite to enable users to build and deploy high-performance and low-latency AI applications from edge to the cloud. These applications can be created using a rich C++ or Python API\u2019s and also in a GUI environment. These API\u2019s and tools are based on the core principles of GXF GXF (Graph eXecution Format) provide a complete ecosystem for a developer to create and deploy AI applications with ease.", "keywords": []}, {"id": 2186, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#application-development-using-graph-composer", "display_name": "Application Development Using Graph Composer", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "application-development-using-graph-composer", "priority": -1, "content": "Overview Concepts GXF (Graph eXecution Format) Graph Node Components Codelets Subgraph System Edges / Connection Messages Extension Graph eXecution Engine (GXE) Tools Graph Composer Registry Container Builder GXF Server GXF CLI Workflow Supported platforms Ubuntu 22.04 LTS (x86_64) Ubuntu 22.04 LTS (ARM64 Jetson) Windows 10 (x86_64) WSL Ubuntu 22.04 LTS (x86_64) Application Development Workflow Python Application Development Python API Setup ComputeEntity PyComputeEntity Tensor zero-copy with other frameworks From other frameworks to GXF From GXF to other frameworks Example Application UCX Transmit / Receive Graph with UCX Tx Graph with UCX Rx UCXSource, UCXSink, and context implementation for reference C++ Application Development Graph Entity Segment Connecting Graph Entities Application Runtime Codelet Registration Distributed Application createSegment() connect() Graph Composer Launch Graph Composer Sync Extensions Create a Graph Run Graph from Graph Composer Local System Remote System Run Graph from Command line Create Container Image from Graph Composer Local System Remote System (Windows) DeepStream Application Creating an AI Application Launch Composer Drag and Drop Components Configure Components Connect Components Add GStreamer Scheduler Count Number Of People Save Graph Use Multiple inputs Runtime add/remove inputs Reference graphs Installing the reference graphs deepstream-test1 deepstream-test2 deepstream-test3 deepstream-test4 deepstream-test5 deepstream-runtime-src-add-del deepstream-template-plugin deepstream-app deepstream-triton deepstream-camera deepstream-action-recognition deepstream-subgraph deepstream-3d-camera deepstream-ucx-test1 deepstream-ucx-test2 Extension Development Workflow Sync Extensions Develop New Extension Create and test graph Developing Extensions for DeepStream Extension and component factory registration boilerplate A simple DeepStream component Implementation of INvDsInPlaceDataHandler Controlling Properties Triggering Actions Handling signal callbacks Implementation of an Configuration Provider component DeepStream Components Interfaces Data Components Basic Components Connections Probes GXF Internals LifeCycle of a Codelet The GXF Scheduler Greedy Scheduler Greedy Scheduler Configuration Multithread Scheduler Multithread Scheduler Configuration Event Based Scheduler Messaging and Events Event Based Scheduler Configuration Epoch Scheduler SchedulingTerms PeriodicSchedulingTerm CountSchedulingTerm MessageAvailableSchedulingTerm MultiMessageAvailableSchedulingTerm BooleanSchedulingTerm AsynchronousSchedulingTerm DownstreamReceptiveSchedulingTerm TargetTimeSchedulingTerm ExpiringMessageAvailableSchedulingTerm MessageAvailableFrequencyThrottler MemoryAvailableSchedulingTerm BTSchedulingTerm Combining SchedulingTerms Cuda based scheduling terms Cuda Stream SchedulingTerm Cuda Event SchedulingTerm Connection Topologies Messages Transmitter Receiver Transmitter Example Receiver Example Memory Management Cuda Stream Order Allocator RMM: RAPIDS Memory Manager Distributed Execution GraphWorker GraphDriver Logging GXF_LOG_VERBOSE() GXF_LOG_DEBUG() GXF_LOG_INFO() GXF_LOG_WARNING() GXF_LOG_ERROR() Component Factory GXF_EXT_FACTORY_BEGIN() GXF_EXT_FACTORY_SET_INFO() GXF_EXT_FACTORY_SET_DISPLAY_INFO() GXF_EXT_FACTORY_END() GXF_EXT_FACTORY_ADD() GXF_EXT_FACTORY_ADD_VERBOSE() GXF_EXT_FACTORY_ADD_LITE() GXF_EXT_FACTORY_ADD_0() GXF_EXT_FACTORY_ADD_0_VERBOSE() GXF_EXT_FACTORY_ADD_0_LITE() Graph Execution Engine 1. How to override the parameters that are specified in the graph file using command line options? Graph Composer and GXF Containers Prerequisites GXF Component Interfaces Codelet Codelet ~Codelet() start() tick() stop() getExecutionTimestamp() getExecutionTime() getDeltaTime() getExecutionCount() isFirstTick() beforeStart() beforeTick() beforeStop() Allocator MemoryStorageType kHost kDevice kSystem AllocatorStage kUninitialized kInitializationInProgress kInitialized kDeinitializationInProgress Allocator ~Allocator() is_available_abi() allocate_abi() free_abi() block_size_abi() allocate() free() allocator_stage_str() CudaAllocator CudaAllocator ~CudaAllocator() allocate() free() allocate_async_abi() free_async_abi() get_pool_size() Receiver Receiver receive_abi() back_size_abi() peek_back_abi() sync_abi() sync_io_abi() wait_abi() receive() back_size() sync() sync_io() wait() peekBack() setTransmitter() Transmitter Transmitter publish_abi() back_size_abi() sync_abi() sync_io_abi() pop_io_abi() publish() publish() back_size() sync() sync_io() pop_io() pop() System System schedule_abi() unschedule_abi() runAsync_abi() stop_abi() wait_abi() event_notify_abi() schedule() unschedule() runAsync() stop() wait() event_notify() Scheduler Scheduler prepare_abi() SchedulingTerm SchedulingTerm ~SchedulingTerm() check_abi() onExecute_abi() update_state_abi() check() onExecute() Router Router addRoutes() removeRoutes() syncInbox() wait() syncOutbox() setClock() addNetworkContext() Clock Clock time() timestamp() sleepFor() sleepUntil() Benchmark BenchmarkController BenchmarkController BenchmarkPublisher BenchmarkPublisher getEntityBuffer() getPublishedTimestamps() getAsyncSchedulingterm() setNumOfMessagesToPublish() clearRecordedTimestamps() BenchmarkSink BenchmarkSink begin() end() reset() compute() conclude() getReceivedTimestamps() getPerformanceCalculators() clearRecordedTimestamps() GXF App C++ APIs Arg ArgInfo ArgOverride Arg Arg Parse parseArgsOfType() applyArg() findArg() Application Application Segment PortPair SegmentPort SegmentPortPair SchedulerType Segment Graph Entity GraphEntity GXF App Python APIs Node Node Graph Graph Entity Entity Component Component EntityGroup EntityGroup ComputeEntity ComputeEntity PyComputeEntity PyComputeEntity standard_methods connect() enable_job_statistics() set_scheduler() set_clock() _generate_name() Tensor GXF Core C++ APIs Expected Expected Component Component Entity Entity Handle UntypedHandle Class Handle Class Parameters Parameter Parameter Types Parameter Registration GXF Core C APIs Context Create context Create a context from a shared context Get a shared context from a context Destroy context Extensions GxfLoadExtensionsInfo Load Extension libraries Load Extension from a pointer Load Metadata files Register component Register a component during runtime Graph Execution Loads a list of entities from YAML file Set the root folder for searching YAML files during loading Loads a list of entities from YAML text Activate all system components Deactivate all System components Starts the execution of the graph asynchronously Interrupt the execution of the graph Waits for the graph to complete execution Runs all System components and waits for their completion Entities Create an entity Activate an entity Deactivate an entity Destroy an entity Find an entity Find all entities Increase reference count of an entity Decrease reference count of an entity Get the reference count of an entity Get status of an entity Gets the name of the entity Get state of an entity Notify entity of an event Notify entity of an event including the event type Check if an entity is valid Components Get component type identifier Get component type name Get component type name from component UID Get component name Get unique identifier of the entity of given component Gets the pointer to an entity item Add a new component Adds a new component to an entity and returns the pointer to the component Remove a component Add component to entity interface Find a component in an entity Finds a component in an entity and returns pointer to component Find all components in an entity Get type identifier for a component Gets pointer to component Check if a component is derived from another component Parameter 64-bit floating point 64-bit signed integer 64-bit unsigned integer 32-bit signed integer 32-bit unsigned integer 16-bit unsigned integer 16-bit signed integer 8-bit unsigned integer 8-bit signed integer String parameter Boolean Handle Vector Parameters Set 1-D Vetor Parameters Set 2-D Vetor Parameters Get 1-D Vetor Parameters Get 2-D Vetor Parameters YAML Parameters Sets a parameter from YAML File Parameters Sets a FilePath parameter EntityGroup kDefaultEntityGroupName Create an entity group Update entity\u2019s EntityGroup Find all resources from an EntityGroup Find the EntityGroup gid that the entity belongs to Get name of an EntityGroup Get resource component id from EntityGroup Information Queries Get Meta Data about the GXF Runtime Get description and list of components in loaded Extension Get description and list of parameters of Component Get parameter type description Get flag type description Get parameter description Redirect logs to a file Miscellaneous Get string description of error Check if a result is successful Set log severity Get log severity GXF Core Python APIs Context context_create context_destroy Extensions load_extensions get_extension_list get_extension_info Graph graph_load_file set_root_filepath _subgraph_load_file graph_activate graph_run graph_run_async graph_interrupt graph_wait graph_save graph_deactivate gxf_set_severity Entities gxf_entity_create_info entity_create entity_activate entity_deactivate entity_destroy entity_find entity_find_all entity_ref_count_inc entity_ref_count_dec entity_get_state entity_event_notify entity_notify_event_type entity_get_status EntityGroup entity_group_create entity_group_add Components gxf_tid_t gxf_uid_t get_component_list get_component_info get_param_list get_param_info component_add component_find component_type_id component_type_name component_add_to_interface Primitive Parameters 64-bit floating point (double) 32-bit floating point 64-bit signed integer 64-bit unsigned integer 32-bit signed integer parameter_set_str parameter_get_str parameter_set_handle parameter_get_handle parameter_set_bool parameter_get_bool parameter_set_path parameter_set_from_yaml_node Vector Parameters Set 1-D Vetor Parameters Set 2-D Vetor Parameters Get 1-D Vetor Parameters Get 2-D Vetor Parameters Extensions CudaExtension Components GXF Stream Sync Signaler Waiter GxfStreamExtension Components GXF Stream Sync Workflow At the Waiter Codelet Example StandardExtension Interfaces Components Python Bindings Python Codelets General Concepts Implenting a Python Codelet NetworkExtension Interfaces Components NvTritonExt Components SerializationExtension Interfaces Components MultimediaExtension Components VideoEncoderExtension Components VideoDecoderExtension Components Behavior Trees General Concept Behavior Tree Codelets UCX Extension Description Requirements Components Example HttpExtension Interfaces Components GrpcExtension Interfaces Components TensorRTExtension Components NvDs3dProcessingExt Components NvDsActionRecognitionExt Components NvDsAnalyticsExt Components NvDsBaseExt Interfaces Components NvDsCloudMsgExt Components NvDsConverterExt Components NvDsDewarperExt Components NvDsInferenceExt Components NvDsInferenceUtilsExt Components NvDsInterfaceExt Interfaces Components NvDsMuxDemuxExt Components NvDsOpticalFlowExt Components NvDsOutputSinkExt Components NvDsSampleExt Components NvDsSampleModelsExt Components NvDsSourceExt Components NvDsTemplateExt Components NvDsTrackerExt Components NvDsTranscodeExt Components NvDsTritonExt Components NvDsUcxExt Components NvDsUdpExt Components NvDsVisualizationExt Components Registry Repository Manager NVIDIA Cloud Repository Local Workspace Cache Extension Registration Installing graphs for deployment Registry Command Line Interface cache repo repo clean repo list repo info repo sync extn extn add extn sync extn import extn list extn info extn versions extn variants extn dependencies comp comp list comp info graph graph install Composer User Interface Menu Bar Context Menu Toolbar Component List Create New Application Open and Save Application Graphs Compose an Application Graph Finding the right component Creating a Component Instance Understanding the Component Handles Linking and Unlinking components Entity Node Setting up a Connection from an Input to an Output Changing the Component Properties Editor Features Subgraph Backdrop Extend a Graph Run Graph Options Build Container Image Options Generate Gstreamer Extension Options Remote Access Comparison of available options Omniverse Streaming Client Installation and Usage Configuration Server Client WebRTC streaming Current Limitations: Restrictions Trouble Shooting Container Builder Prerequisites Container Builder Features Container Builder Tool Usage Multiarch Build Run Container Builder Container Builder Configuration A Basic Example of Container Builder Configuration A Multi-Stage Example Container builder main control section specification Container dockerfile stage section specification GXF Command Line Interface stat config dump Pipetuner Guide Introduction Prerequisites System Requirements NGC Setup Sample Data Setup DeepStream Tuning Case MTMC Tuning Case Quick Start Launch Tuning Process DS Perception Tuning MTMC Tuning with Frozen Perception MTMC E2E Tuning Output Stop PipeTuner Retrieve and Visualize Tuning Results Custom Tuning Understanding PipeTuner Config Path Custom Dataset Create Video Files Create Ground Truth Labels Launch PipeTuner with the New Config File Data Augmentation Video Generation Use in DS Perception Tuning Custom Models Custom Algorithms Customize Parameters Changelog Version 1.0 FAQ General Registry Container Builder Composer Extension Developement GXF server DeepStream End User License Agreement Feedback form Request Documentation Fix", "keywords": []}, {"id": 2187, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#deepstream-api-reference-documentation", "display_name": "DeepStream API Reference Documentation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "deepstream-api-reference-documentation", "priority": -1, "content": "DeepStream API Guides", "keywords": []}, {"id": 2188, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#deepstream-libraries", "display_name": "Deepstream Libraries", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "deepstream-libraries", "priority": -1, "content": "DeepStream Libraries (Developer Preview) DeepStream Libraries Installation DeepStream Libraries Repository Setup Getting Started with DeepStream Libraries APIs Sample Applications Additional References and Applications", "keywords": []}, {"id": 2189, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#deepstream-setup-on-wsl2", "display_name": "Deepstream Setup On WSL2", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "deepstream-setup-on-wsl2", "priority": -1, "content": "DeepStream On WSL Pre-Requisites: Install Ubuntu OS for WSL : Install Docker Engine And Dependencies Inside Ubuntu: Run Deepstream Container: FAQ for Deepstream On WSL 1. Do we need to install nvidia driver inside Ubuntu Image with WSL? 2. While installing driver, should you choose \u2018Clean Installation\u2019? 3. While starting docker, I face error:\u201cdocker: Error response from daemon: could not select device driver \u201c\u201d with capabilities: [[gpu]]. What should I do? 4. While starting docker, I get error \u201cGPU access blocked by operating system\u201d. What should I do? 5. While installing Ubuntu image for WSL2, I get error: \u201cThe service cannot be started, either because it is disabled or because it has no enabled devices associated with it\u201d. What should I do? 6. While running deepstream-app for the first time, I get an error: \u201cGLib (gthread-posix.c): Unexpected error from C library during \u2018pthread_setspecific\u2019: Invalid argument. Aborting.\u201d. What should I do? 7. There is no video on the screen while running gstreamer or deepstream video pipelines. But pipeline seems to be running in terminal without any error. What is the reason? 8. Warning prints are coming while running deepstream-app for first time after starting docker. For e.g: \u201cdeepstream-app \u2013version\u201d shows below warnings. Is that an issue?", "keywords": []}, {"id": 2190, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#nvidia-deepstream-service-maker", "display_name": "Nvidia Deepstream Service Maker", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvidia-deepstream-service-maker", "priority": -1, "content": "What is Deepstream Service Maker Overview Key Features Service Maker for C/C++ Developers Getting Started with Service Maker C++ APIs Application Developer Fundamentals Sample Applications Migrating Traditional Deepstream Apps to Service Maker Service Maker for Python Developers(alpha) Python Service Maker Installation What is a Deepstream Service Maker Plugin Getting Started with Your Factory and Plugin Incorporating properties to a plugin Sample Plugins Message Metadata Generator KITTI Dump Plugin Framerate Measurement Plugin Latency Measurement Plugin Sample Video Probe Plugin Sample Signal Handler Plugin Sample Video Feeder Plugin Sample Video Receiver Plugin Smart Recording Action Plugin Smart Recording Signal Plugin Plugin Search Path", "keywords": []}, {"id": 2191, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#plugins-development-guide", "display_name": "Plugins Development Guide", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "plugins-development-guide", "priority": -1, "content": "GStreamer Plugin Overview MetaData in the DeepStream SDK NvDsBatchMeta: Basic Metadata Structure User/Custom Metadata Addition inside NvDsBatchMeta Adding Custom Meta in Gst Plugins Upstream from Gst-nvstreammux Adding metadata to the plugin before Gst-nvstreammux New metadata fields Gst-nvdspreprocess (Alpha) Inputs and Outputs Features Custom library Interfaces Gst-nvdspreprocess File Configuration Specifications Gst Properties Sample pipelines Gst-nvinfer Inputs and Outputs Features Gst-nvinfer File Configuration Specifications Gst Properties Clustering algorithms supported by nvinfer cluster-mode = 0 | GroupRectangles cluster-mode = 1 | DBSCAN cluster-mode = 2 | NMS cluster-mode = 3 | Hybrid cluster-mode=4 | No clustering Tensor Metadata To read or parse inference raw tensor data of output layers Segmentation Metadata Gst-nvinferserver Inputs and Outputs Gst-nvinferserver Configuration File Specifications Features Low Level libnvds_infer_server.so Configuration File Specifications Gst Properties DeepStream Triton samples DeepStream Triton gRPC support Triton Ensemble Models Custom Process interface IInferCustomProcessor for Extra Input, LSTM Loop, Output Tensor Postprocess Tensor Metadata Output for Downstream Plugins To read or parse inference raw tensor data of output layers Segmentation Metadata Gst-nvtracker Sub-batching (Alpha) Inputs and Outputs Gst Properties NvDsTracker API for Low-Level Tracker Library NvMultiObjectTracker : A Reference Low-Level Tracker Library Unified Tracker Architecture for Composable Multi-Object Tracker Workflow and Core Modules in The NvMultiObjectTracker Library Data Association Target Management and Error Handling State Estimation Object Re-Identification Target Re-Association Bounding-box Unclipping Single-View 3D Tracking (Alpha) Configuration Parameters Low-Level Tracker Comparisons and Tradeoffs IOU Tracker NvSORT Tracker NvDeepSORT Tracker Data Association Configuration Parameters Implementation Details and Reference NvDCF Tracker Visual Tracking Data Association Configuration Parameters Miscellaneous Data Output Terminated Track List Shadow Tracking Target Data Past-frame Target Data Setup and Usage of Re-ID Model Setup Sample Re-ID Models Customize Re-ID Model Re-ID Feature Output Setup and Usage of Sub-batching (Alpha) Use-case 1 Use-case 2 Setup and Visualization of Tracker Sample Pipelines People Tracking Vehicle Tracking Tracker Accuracy Tuning How to Implement a Custom Low-Level Tracker Library Gst-nvstreammux Inputs and Outputs Features Gst Properties Known Issues with Solutions and FAQ 1. gst-inspect is not updated properly when switching between legacy and new streammux Gst-nvstreammux New Inputs and Outputs Features Gst Properties Mux Config Properties NvStreamMux Tuning Solutions for specific use cases Aim Important Tuning parameters Video and Audio muxing Use cases Troubleshooting Metadata propagation through nvstreammux and nvstreamdemux Cascaded Muxing Known Issues with Solutions and FAQ Observing video and/or audio stutter (low framerate) Sink plugin shall not move asynchronously to PAUSED Heterogeneous batching Adaptive Batching Optimizing nvstreammux config for low-latency vs Compute Latency Measurement API Usage guide for audio gst-inspect is not updated properly when switching between legacy and new streammux Gst-nvstreamdemux Inputs and Outputs Use case 1 Use case 2 Use case 3 Gst-nvmultistreamtiler Inputs and Outputs Features Gst Properties Gst-nvdsosd Inputs and Outputs Features Gst Properties Gst-nvdsmetautils Gst-nvdsmetainsert Inputs and Outputs Features customlib_impl Interfaces Gst Properties Use Cases &amp; Sample Pipelines Gst-nvdsmetaextract Inputs and Outputs Features customlib_impl Interfaces Gst Properties Use Cases &amp; Sample Pipelines Gst-nvdsvideotemplate Inputs and Outputs Features customlib_impl Interfaces Gst Properties Sample pipelines Gst-nvdsaudiotemplate Inputs and Outputs Features customlib_impl Interfaces Gst Properties Sample pipelines Gst-nvvideoconvert Inputs and Outputs Features Gst Properties Gst-nvdewarper Inputs and Outputs Features Configuration File Parameters Gst Properties Gst-nvof Inputs and Outputs Features Gst Properties Gst-nvofvisual Inputs and Outputs Features Gst Properties Gst-nvsegvisual Inputs and Outputs Features Gst Properties Gst-nvvideo4linux2 Decoder Inputs and Outputs Features Gst Properties Encoder Inputs and Outputs Features Gst Properties Gst-nvjpegdec Inputs and Outputs Features Gst Properties Gst-nvimagedec Inputs and Outputs Features Gst Properties Gst-nvjpegenc Inputs and Outputs Features Gst Properties Gst-nvimageenc Inputs and Outputs Features Gst Properties Gst-nvmsgconv Inputs and Outputs Features Gst Properties NvMsgConv low level library API\u2019s Schema Customization Payload with Custom Objects Gst-nvmsgbroker Inputs and Outputs Features Gst Properties nvds_msgapi: Protocol Adapter Interface nvds_msgapi_connect(): Create a Connection nvds_msgapi_send() and nvds_msgapi_send_async(): Send an event nvds_msgapi_subscribe(): Consume data by subscribing to topics nvds_msgapi_do_work(): Incremental Execution of Adapter Logic nvds_msgapi_disconnect(): Terminate a Connection nvds_msgapi_getversion(): Get Version Number nvds_msgapi_get_protocol_name(): Get name of the protocol nvds_msgapi_connection_signature(): Get Connection signature nvds_kafka_proto: Kafka Protocol Adapter Installing Dependencies Using the Adapter Configuring Protocol Settings Programmatic Integration Security for Kafka Azure MQTT Protocol Adapter Libraries Installing Dependencies Setting Up Azure IoT Configuring Adapter Settings Using the Adapter Monitor Adapter Execution Message Topics and Routes AMQP Protocol Adapter Installing Dependencies AMQP broker Configure Adapter Settings Using the Adapter User authentication Programmatic Integration Monitor Adapter Execution REDIS Protocol Adapter Installing Dependencies REDIS server Configure Adapter Settings User Authentication Using the Adapter Programmatic Integration Monitor Adapter Execution MQTT Protocol Adapter Installing Dependencies Eclipse Mosquitto Configure Adapter Settings Using the Adapter Programmatic Integration Monitor Adapter Execution nv_msgbroker: Message Broker interface nv_msgbroker_connect(): Create a Connection nv_msgbroker_send_async(): Send an event asynchronously nv_msgbroker_subscribe(): Consume data by subscribing to topics nv_msgbroker_disconnect(): Terminate a Connection nv_msgbroker_version(): Get Version Number Autoreconnect feature Work-interval configuration nvds_logger: Logging Framework Gst-nvdsanalytics Inputs and Outputs Features Gst Properties Configuration File Parameters Gst-nvdsudpsrc Inputs and Outputs Features Gst Properties Example pipelines Gst-nvdsudpsink Inputs and Outputs Features Gst Properties Example pipelines Gst-nvdspostprocess (Alpha) Inputs and Outputs Features Gst-nvdspostprocess File Configuration Specifications Gst Properties Sample pipelines Gst-nvds3dfilter Custom library Interfaces Inputs and Outputs Configuration file Gst-nvds3dfilter properties Specifications Supported DS3D filter custom libs Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so Inputs and Outputs Configuration file Configuration options Custom ds3d::datafilter library: libnvds_3d_depth2point_datafilter.so Gst-nvds3dbridge Gst-nvds3dbridge properties Specifications Custom library Interfaces Supported DS3D Data bridges Custom low level library: libnvds_3d_video_databridge.so Inputs and Outputs Configuration file Video bridge configuration options Gst-nvds3dmixer Gst-nvds3dmixer properties Specifications Custom library Interfaces Supported DS3D Data mixers Custom low level library: libnvds_3d_multisensor_mixer.so Inputs and Outputs Configuration file Video mixer configuration options Gst-NvDsUcx Description Requirements Inputs and Outputs Gst Properties Examples Gst-nvdsxfer Inputs and Outputs Gst Properties How to test Use cases Single Stream + Multi-dGPUs Setup Multiple Streams + Multi-dGPU Setup Gst-nvvideotestsrc Outputs Gst Properties How to test Gst-nvmultiurisrcbin 1. Introduction 2. Features 3. How to use nvmultiurisrcbin in a pipeline REST API payload definitions and sample curl commands for reference 4. Gst Properties Gst Properties directly configuring nvmultiurisrcbin Gst Properties to configure each instance of nvurisrcbin created inside this bin Gst Properties to configure the instance of nvstreammux created inside this bin 5. Important Notes nvmultiurisrcbin config recommendations and notes on expected behavior 6. Limitations Gst-nvurisrcbin 1. Introduction 2. How to use nvurisrcbin in a pipeline 3. Gst Properties 3.1 Gst Properties to configure nvurisrcbin", "keywords": []}, {"id": 2192, "doc_id": 2193, "filename": "index.html", "domain_name": "page", "name": "index#troubleshooting-and-faq-guide", "display_name": "Troubleshooting and FAQ Guide", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "troubleshooting-and-faq-guide", "priority": -1, "content": "Troubleshooting You are migrating from DeepStream 6.0 to DeepStream 7.1 Inference Performance Triton Troubleshooting in Tracker Setup and Parameter Tuning Graph Composer Troubleshooting Miscellaneous Frequently Asked Questions DeepStream General topics Smart Record Triton", "keywords": []}, {"id": 2193, "doc_id": 2193, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "NVIDIA DeepStream SDK Developer Guide", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "Welcome to the DeepStream Documentation NVIDIA DeepStream Overview Migration Guide Additional Resources Installation Jetson Setup dGPU Setup for Ubuntu IGX/dGPU on ARM Setup for Ubuntu (Alpha) dGPU on ARM Setup for Ubuntu (Alpha) dGPU Setup for RedHat Enterprise Linux (RHEL) Platform and OS Compatibility Quickstart Guide Jetson [Not applicable for NVAIE customers] dGPU for Ubuntu How to visualize the output if the display is not attached to the system DeepStream Triton Inference Server Usage Guidelines Using DLA for inference Docker Containers Prerequisites A Docker Container for dGPU A Docker Container for Jetson A Docker Container for dGPU on ARM (IGX/dGPU, GH100, GH200, SBSA) Creating custom DeepStream dockers for dGPU or Jetson using DeepStreamSDK package Recommended Minimal L4T Setup necessary to run the new docker images on Jetson C/C++ Sample Apps Source Details Plugin and Library Source Details Python Sample Apps and Bindings Source Details Sample Application Source Details Python Bindings and Application Development MetaData Access DeepStream Reference Application - deepstream-app Application Architecture Reference Application Configuration Configuration Groups Application Tuning for DeepStream SDK DeepStream Reference Application - deepstream-test5 app IoT Protocols supported and cloud configuration Message consumer Smart Record - Event based recording OTA model update Sensor Provisioning Support over REST API (Runtime sensor add/remove capability) DeepStream Reference Application - deepstream-nmos app Application Architecture Using Easy-NMOS for NMOS Registry and Controller DeepStream Reference Application on GitHub Use case applications AI models with DeepStream DeepStream features sample Sample Configurations and Streams Contents of the package Implementing a Custom GStreamer Plugin with OpenCV Integration Example Description of the Sample Plugin: gst-dsexample Enabling and configuring the sample plugin Using the sample plugin in a custom application/pipeline Implementing Custom Logic Within the Sample Plugin Adding NVTX APIs for sample plugin Accessing NvBufSurface memory in OpenCV TAO Toolkit Integration with DeepStream Pre-trained models DeepStream-3D Custom Apps and Libs Tutorials DS3D Application Examples DS3D data format ds3d/datamap ds3d::dataloader - Load Custom Lib for Data Capture ds3d::databridge - Loads Custom Lib for data conversion to and from DS3D. ds3d::datafilter - DS3D Custom DataFilter ds3d::datarender - Loads DS3D Custom DataRender Custom Libs Configuration Specifications Performance TAO Pre-trained models DeepStream reference model and tracker Configuration File Settings for Performance Measurement DeepStream reference model Accuracy Tuning Tools PipeTuner for Automatic Tuning (Developer Preview) Multi-Object Tracking Parameter Functionalities for Manual Tuning Using a Custom Model with DeepStream Custom Model Implementation Interface Custom Output Parsing IPlugin Implementation Input Layer Initialization CUDA Engine Creation for Custom Models IModelParser Interface for Custom Model Parsing DeepStream-3D Sensor Fusion Multi-Modal Application and Framework Example 1. BEVFusion Multi-Modal with 6-Camera Plus 1-LiDAR Data Fusion Pipeline Example 2. V2XFusion multi-modal batched 4-Camera and 4-LiDAR Inference Pipeline: Quick Start Build application From Source DS3D Components used in this sample application DS3D Custom Components Configuration Specifications DeepStream-3D Multi-Modal BEVFusion Setup Prerequisites Getting Started Prepare DeepStream Triton BEVFusion Container and Models on X86 with a dGPU Usage: IoT Messaging: Build from source: NuScenes Dataset Setup for DS3D BEVFusion Pipeline Dataset Generation for DS3D BEVFusion How to use other nuScenes scene samples: Citation DeepStream-3D Multi-Modal V2XFusion Setup Prerequisites Getting Started Build from source: Smart Video Record Smart Video Record Module APIs Smart Video Record Configurations IoT Secure Edge-to-Cloud Messaging Bidirectional Messaging Autoreconnect feature On the Fly Model Update Assumptions NTP Timestamp in DeepStream AV Sync in DeepStream Setup for RTMP/RTSP Input streams for testing AVSync Reference Pipelines DeepStream With REST API Sever Features nvds_rest_server deepstream-server-app Sensor provisioning with deepstream-test5-app How to add custom REST API support Schema and endpoints Limitations DeepStream 3D Action Recognition App Getting Started DeepStream 3D Action Recognition App Configuration Specifications Build Custom sequence preprocess lib and application From Source DeepStream 3D Depth Camera App Prerequisites Depth Color Capture to 2D Rendering Pipeline Overview Depth Color Capture to 3D Point Cloud Processing and Rendering Getting Started Run 3D Depth Capture, Point Cloud filter, and 3D Points Rendering Examples DeepStream 3D Depth Camera App Configuration Specifications DeepStream 3D Lidar Inference App Prerequisites Lidar Point Cloud to 3D Point Cloud Processing and Rendering Getting Started Networked Media Open Specifications (NMOS) in DeepStream Supported Specifications Prerequisites NvDsNmos API Sample Application Gst-nvdspostprocess in DeepStream Detector models Primary Classification model Mask RCNN Model Custom Parsing functions DeepStream Can Orientation App Getting Started DeepStream Can Orientation App Configuration Specifications Build application From Source Application Migration to DeepStream 7.1 from DeepStream 7.0 Running DeepStream 7.0 compiled Apps in DeepStream 7.1 Compiling DeepStream 7.0 Apps in DeepStream 7.1 Migrating DeepStream 7.0 Gst-nvtracker to DeepStream 7.1", "keywords": []}, {"id": 2194, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#build-custom-sequence-preprocess-lib-and-application-from-source", "display_name": "Build Custom sequence preprocess lib and application From Source", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "build-custom-sequence-preprocess-lib-and-application-from-source", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-3d-action-recognition . Run the following commands: $ make $ make install Check the source code and comments to learn about implementation of other order formats, for example, NSCHW (NDCHW).", "keywords": []}, {"id": 2195, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#custom-lib-and-gst-nvdspreprocess-settings-for-action-recognition", "display_name": "Custom lib and `gst-nvdspreprocess` Settings for Action Recognition", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "custom-lib-and-gst-nvdspreprocess-settings-for-action-recognition", "priority": -1, "content": "You\u2019ll need to set input order as CUSTOM network-input-order=2 for this custom sequence preprocess lib. 3D models NCDHW(NCSHW) require network-input-shape with 5-dimension shape. For example: network-input-shape= 4;3;32;224;224 It means max_batch_size: 4, channels 3, sequence_len: 32, height 224, width 224. 2D models NSHW require network-input-shape with 4-dimension shape. For example: network-input-shape= 4;96;224;224 It means max_batch_size: 4, channels 3, sequence_len: 32, height 224, width 224. where 96 = channels x sequence_len. Assume incoming frame numbers are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\u2026 When subsample=1 , the preprocessing custom lib will pick up frame numbers: 1,3,5,7,9\u2026 to preprocess sequentially and pass it onto inference as a next-step. Assuming same incoming frame numbers above, For example, when subsample=0, stride=1 , the 2 consecutive sliding sequences are: Batch A: [1,2,3,4,5...] Batch B: [2,3,4,5,6...] When subsample=0, stride=2 , the 2 consecutive sliding sequences are: Batch A: [1,2,3,4,5...] Batch B: [3,4,5,6,7...] When subsample=1, stride=2 , the subsample is performed first, and sliding sequences are on top of subsample results. The processing frame numbers after subsample are: 1,3,5,7,9,11,13,15,17,19\u2026 The consecutive sliding sequences on top of them are: Batch A: [1,3,5,7,9...] Batch B: [5,7,9,11,13...] # 1st frame sliding from frame 1 of Batch A to frame 5 Batch C: [9,11,13,15,17...] # 1st frame sliding from frame 5 of Batch C to frame 9 The image below shows the frame batches with different subsample and stride settings.", "keywords": []}, {"id": 2196, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#custom-sequence-preprocess-lib-user-settings-user-configs-for-gst-nvdspreprocess", "display_name": "Custom sequence preprocess lib user settings [user-configs] for gst-nvdspreprocess", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "custom-sequence-preprocess-lib-user-settings-user-configs-for-gst-nvdspreprocess", "priority": -1, "content": "The table below demonstrates the config_preprocess_3d_custom.txt setting of libnvds_custom_sequence_preprocess.so as an example. Property Meaning Type and Range Example channel-scale-factors scale factor list for each channel Semicolon delimited float array channel-scale-factors= 0.007843137;0.007843137;0.007843137 channel-mean-offsets data mean offsets for each channel Semicolon delimited float array channel-mean-offsets=127.5;127.5;127.5 stride sequence sliding stride for each batched sequnece Unsigned Integer, value &gt;= 1 stride=1 subsample Subsample rates for inference images in each sequence Unsigned Integer, value &gt;= 0 subsample=0", "keywords": []}, {"id": 2197, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#deepstream-3d-action-recognition-action-recognition-group-settings", "display_name": "deepstream-3d-action-recognition [action-recognition] group settings", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "deepstream-3d-action-recognition-action-recognition-group-settings", "priority": -1, "content": "The table below demonstrates the group settings for deepstream_action_recognition_config.txt as an example. Property Meaning Type and Range Example uri-list source video file or stream list Semicolon delimited string list file:///path/to/sample_action1.mp4;file:///path/to/sample_action2.mp4 ; display-sync Indicate display synchronization on timestamp or not Boolean display-sync=1 preprocess-config Gst-nvdspreprocess plugin config file path String preprocess-config=config_preprocess_3d_custom.txt infer-config Gst-nvinfer plugin config file path String infer-config=config_infer_primary_2d_action.txt muxer-height Gst-nvstreammux height Unsigned Integer muxer-height=720 muxer-width Gst-nvstreammux width Unsigned Integer muxer-width=1280 muxer-batch-timeout Gst-nvstreammux batched push timeout in usec Unsigned Integer muxer-batch-timeout=40000 tiler-height Gst-nvmultistreamtiler height Unsigned Integer tiler-height=720 tiler-width Gst-nvmultistreamtiler width Unsigned Integer tiler-width=1280 debug Log print debug level Integer, 0: disabled. 1: debug. 2: verbose debug=0 enable-fps Indicate whether print fps on screen Boolean enable-fps=1", "keywords": []}, {"id": 2198, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "prerequisites", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-3d-action-recognition . Search and Download 3D and 2D RGB based tao_iva_action_recognition_pretrained models from NGC https://ngc.nvidia.com/catalog/models/nvidia:tao:actionrecognitionnet (Version 5): resnet18_3d_rgb_hmdb5_32 resnet18_2d_rgb_hmdb5_32 These Models support following classes : push ; fall_floor ; walk ; run ; ride_bike . Update source streams uri-list in action recognition config file: deepstream_action_recognition_config.txt . uri-list=file:///path/to/sample_action1.mov;file:///path/to/sample_action2.mov;file:///path/to/sample_action3.mov;file:///path/to/sample_action4.mov; Export DISPLAY environment to correct display. e.g. export DISPLAY=:0.0 .", "keywords": []}, {"id": 2199, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#run-2d-action-recognition-examples", "display_name": "Run 2D Action Recognition Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "run-2d-action-recognition-examples", "priority": -1, "content": "Make sure 2D preprocess config and 2D inference config are enabled in deepstream_action_recognition_config.txt . # Enable 2D preprocess and inference preprocess-config=config_preprocess_2d_custom.txt infer-config=config_infer_primary_2d_action.txt Run the following command: $ deepstream-3d-action-recognition -c deepstream_action_recognition_config.txt Run with DS-Triton, update application config file deepstream_triton_action_recognition_config.txt . preprocess-config=config_preprocess_2d_custom.txt triton-infer-config=config_triton_infer_primary_2d_action.txt Run 2D test with DS-Triton: $ ./deepstream-3d-action-recognition -c deepstream_triton_action_recognition_config.txt Check sources/TritonOnnxYolo/README for more details how to switch action recognition DS-Triton tests between CAPI and gRPC.", "keywords": []}, {"id": 2200, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "page", "name": "text/DS_3D_Action#run-3d-action-recognition-examples", "display_name": "Run 3D Action Recognition Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Action", "anchor": "run-3d-action-recognition-examples", "priority": -1, "content": "Make sure 3D preprocess config and 3D inference config are enabled in deepstream_action_recognition_config.txt . # Enable 3D preprocess and inference preprocess-config=config_preprocess_3d_custom.txt infer-config=config_infer_primary_3d_action.txt Run the following command: $ deepstream-3d-action-recognition -c deepstream_action_recognition_config.txt Run with DS-Triton, update application config file deepstream_triton_action_recognition_config.txt . preprocess-config=config_preprocess_3d_custom.txt triton-infer-config=config_triton_infer_primary_3d_action.txt Run 3D test with DS-Triton: $ ./deepstream-3d-action-recognition -c deepstream_triton_action_recognition_config.txt Check sources/TritonOnnxYolo/README for more details how to switch action recognition DS-Triton tests between CAPI and gRPC.", "keywords": []}, {"id": 2201, "doc_id": 2201, "filename": "text/DS_3D_Action.html", "domain_name": "std", "name": "text/DS_3D_Action", "display_name": "DeepStream 3D Action Recognition App", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_Action", "anchor": "", "priority": -1, "content": "The deepstream-3d-action-recognition sample application is provided at app/sample_apps/deepstream-3d-action-recognition for your reference. This example demonstrates a sequence batching based 3D or 2D model inference pipeline for action recognition. The image below shows the architecture of this reference app. Gst-nvdspreprocess plugin re-processses the input tensors for Gst-nvinfer plugin. Gst-nvdspreprocess loads a custom_sequence_preprocess lib (subfolder) to perform temporal sequence batching and ROI spatial batching. It delivers the preprocessed batched tensor buffers into downstream plugin Gst-nvinfer for inference. This application probes the tensor data and action classification result, converts them into display metadata to print on screen. This 3D/2D model is pretrained by NVIDIA TAO toolkit. The 3D model has NCDHW (NCSHW) input and the 2D model has NSHW shapes. N: Max batch size of total number of ROIs in all streams, value &gt; 0. C: Channel numbers, must be 3. D/S: sequence length of consecutive frames, value &gt; 1 H: height, value &gt; 0 W: width, value &gt; 0 2D S: channels x sequence_length, reshaped from [C, D] A custom sequence preprocessing lib: libnvds_custom_sequence_preprocess.so is also provided at sources/apps/sample_apps/deepstream-3d-action-recognition/custom_sequence_preprocess to demonstrate how to implement a sequence batching and preprocessing methods with Gst-nvdspreprocess plugin. This custom lib normalizes each incoming ROI cropped image and accumulates the data into buffer sequence for temporal batching. When temporal batching is ready, it continues to do spacial batching on multi-ROIs and multi-streams. Finally it returns the temporal and spacial batched buffer(tensor) to Gst-nvdspreprocess plugin which would attach the buffer as preprocess input metadata and deliver to downstream Gst-nvinfer plugin to do inference.", "keywords": []}, {"id": 2202, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#components-common-configuration-specifications", "display_name": "Components Common Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "components-common-configuration-specifications", "priority": -1, "content": "Property Meaning Type and Range Example type Custom processor type String, [ds3d::dataloader, ds3d::datafilter, ds3d::datarender] type: ds3d::dataloader name Indicate user-defined component name String name: depthloader in_caps Indicate Gst sink caps for the component String in_caps: ds3d/datamap out_caps Indicate Gst sink caps for the component String out_caps: ds3d/datamap custom_lib_path Indicate custom lib path String custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function Indicate custom function to create the specific ds3d processing component String custom_create_function: createPointCloudDataRender config_body Indicate YAML specific content for the custom comonent String config_body: in_streams: [color, depth] max_points: 407040 These custom libs are part of DeepStream release package.", "keywords": []}, {"id": 2203, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#create-and-manage-ds3d-datafilter-in-deepstream-app", "display_name": "Create And Manage DS3D Datafilter in DeepStream App", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "create-and-manage-ds3d-datafilter-in-deepstream-app", "priority": -1, "content": "Examples: #include &lt;ds3d/common/config.h&gt; #include &lt;ds3d/gst/nvds3d_gst_ptr.h&gt; #include &lt;ds3d/gst/nvds3d_gst_plugin.h&gt; std::string yamlStr = R&quot;( name: fusion_inference type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter config_body: mem_pool_size: 2 model_inputs: config_file: model_config_files/config_triton_bev_fusion_infer_grpc.pbtxt - name: input_image_0 datatype: UINT8 shape: [1, 900, 1600, 4] from: DS3D::ColorFrame_0+1 is_2d_frame: true - name: input_lidar datatype: FP32 shape: [242180, 4] from: DS3D::LidarXYZI+0 )&quot;; gst::ElePtr gstPlugin = gst::elementMake(&quot;nvds3dfilter&quot;, &quot;ds3d-custom-filter&quot;); g_object_set(G_OBJECT(gstPlugin.get()), &quot;config-content&quot;, yamlStr.c_str(), nullptr); GstElement* ele = gstPlugin.get(); A custom datafilter must have type: ds3d::datafilter . It is loaded through the nvds3dfilter  Gst-plugin . It is started by gst_element_set_state(GST_STATE_READY) . During this call, the custom_lib_path is loaded and a specific data filter is created by custom_create_function . nvds3dfilter  Gst-plugin has config-content and config-file properties. One of them must be set to create a datafilter object.", "keywords": []}, {"id": 2204, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-datafilter-libnvds-3d-alignment-datafilter-specifications", "display_name": "Custom Datafilter libnvds_3d_alignment_datafilter Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-datafilter-libnvds-3d-alignment-datafilter-specifications", "priority": -1, "content": "Data alignment for lidar and video data can be done using a custom library provided with DeepStreamSDK. More details on this is here: Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so .", "keywords": []}, {"id": 2205, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-datafilter-libnvds-3d-depth2point-datafilter-configuration-specifications", "display_name": "Custom datafilter libnvds_3d_depth2point_datafilter Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-datafilter-libnvds-3d-depth2point-datafilter-configuration-specifications", "priority": -1, "content": "Convert 2D depth data into 3D point-cloud(XYZ) data into ds3d::datamap Configuration for Depth to Points Header: name: depth2points type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_3d_depth2point_datafilter.so custom_create_function: createDepth2PointFilter Property Meaning Type and Range Example streams Specify which streams to enable List[String], select from [color, depth] streams: [color, depth] max_points Indicate maximum 3d points to allocate Uint32 max_points: 407040 mem_pool_size Indicate max buffer pool size Uint32 mem_pool_size: 8", "keywords": []}, {"id": 2206, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-datafilter-libnvds-3d-lidar-preprocess-datafilter-specifications", "display_name": "Custom Datafilter libnvds_3d_lidar_preprocess_datafilter Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-datafilter-libnvds-3d-lidar-preprocess-datafilter-specifications", "priority": -1, "content": "LiDAR data preprocess into voxel data format before V2X model sensor fusion inference. Source files located at /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/datafilter/lidar_preprocess Configuration for Lidar data preprocess ds3d::datafilter Header: name: lidarpreprocess type: ds3d::datafilter out_caps: ds3d/datamap custom_lib_path: libnvds_3d_lidar_preprocess_datafilter.so custom_create_function: createLidarPreprocessFilter Config Body Specifications For example: config_body: mem_pool_size: 4 filter_input_datamap_key: DS3D::LidarXYZI_0 model_inputs: - name: feats datatype: FP16 shape: [4, 8000, 10, 9] - name: coords datatype: INT32 shape: [4, 8000, 4] - name: N datatype: INT32 shape: [4, 1] gpu_id: 0 input_tensor_mem_type: GpuCuda lidar_data_from: [DS3D::LidarXYZI_0, DS3D::LidarXYZI_1, DS3D::LidarXYZI_2, DS3D::LidarXYZI_3] output_features_tensor_key: DS3D::LidarFeatureTensor output_coords_tensor_key: DS3D::LidarCoordTensor output_num_tensor_key: DS3D::LidarPointNumTensor Property Description Type and Range Example mem_pool_size memory buffer pool size Integer mem_pool_size: 4 filter_input_datamap_key Specify input lidar data key name String filter_input_datamap_key: DS3D::LidarXYZI_0 model_inputs Specify model input layers info Dict see exmaple in deepstrem-3d-lidar-sensor-fusion/ds3d_lidar_video_sensor_v2xfusion.yml gpu_id Specify GPU ID Integer gpu_id: 0 input_tensor_mem_type Specify model input tensors memory type String, select value from [GpuCuda, CpuCuda] input_tensor_mem_type: GpuCuda lidar_data_from Specify lidar data key name List of String lidar_data_from: [DS3D::LidarXYZI_0] output_features_tensor_key Specify output lidar feature tensor key name String DS3D::LidarFeatureTensor output_coords_tensor_key Specify output lidar coordinate tensor key name String output_coords_tensor_key: DS3D::LidarCoordTensor output_num_tensor_key Specify keyname of numbers of ldiar data into tensor String output_num_tensor_key: DS3D::LidarPointNumTensor", "keywords": []}, {"id": 2207, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-dataloader-libnvds-3d-dataloader-realsense-configuration-specifications", "display_name": "Custom Dataloader libnvds_3d_dataloader_realsense Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-dataloader-libnvds-3d-dataloader-realsense-configuration-specifications", "priority": -1, "content": "Configuration for Realsense  Dataloader Header: name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader libnvds_3d_dataloader_realsense.so requires you to install librealsense2 SDK. For x86, follow the instructions from IntelRealSense/librealsense . For Jetson platform, follow the instructions from IntelRealSense/librealsense . Property Meaning Type and Range Example streams Specify which streams to enable List[String], select from [color, depth] streams: [color, depth] aligned_image_to_depth Indicate whether color image is aligned to depth Boolean aligned_image_to_depth: False", "keywords": []}, {"id": 2208, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-dataloader-libnvds-lidarfileread-configuration-specifications", "display_name": "Custom Dataloader libnvds_lidarfileread Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-dataloader-libnvds-lidarfileread-configuration-specifications", "priority": -1, "content": "The lib reads lidar data file frame by frame, it creates a new ds3d::datamap per frame and deliver to next compoment. Source files located at /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/dataloader/lidarsource Configuration for Lidar file reader ds3d::dataloader Header: name: ds3d_lidar_file_source type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_lidarfileread.so custom_create_function: createLidarFileLoader Config Body Specifications For example: config_body: data_config_file: lidar_nuscene_data_list.yaml points_num: 242180 fixed_points_num: True lidar_datatype: FP32 mem_type: gpu gpu_id: 0 mem_pool_size: 6 element_size: 4 output_datamap_key: DS3D::LidarXYZI file_loop: True Property Description Type and Range Example data_config_file lidar data list file path Path String, or List of Path String data_config_file: lidar_data_list.yaml source_id Specify the unique source id of the loader instance Integer source_id: 0 points_num Specify point number of each frame Integer points_num: 70000 fixed_points_num Indicate the point number is always same as points_num Bool fixed_points_num: False lidar_datatype Specify Lidar data type String, Only FP32 supported for now. lidar_datatype: FP32 mem_type Specify memory type of process data, supports [cpu, gpu] String, [cpu, gpu] mem_type: gpu mem_pool_size Specify buffer pool size allocated for frames Integer mem_pool_size: 16 gpu_id Specify GPU ID in the case of mem_type: gpu Integer gpu_id: 0 element_size Specify how manay elements will be read per each point. 3, means XYZ, 4, means XYZI. Integer element_size: 4 element_stride Specify element stride between 2 continous points. e.g. XYZI, stride:4, XYZIT,5 Integer element_stride: 4 file_loop Indicate whether loop the file list without EOS Bool file_loop: True output_datamap_key Specify output frame keyname into the ds3d::datamap String or List of String output_datamap_key: DS3D::LidarXYZI_0 lidar data config file The lib reads frames from data_config_file which is a seperate file containers multiple lidar files. each lidar file is a single lidar frame file which are listed inside of source-list . Each item\u2019s keyname is the timestamp(millisecond) of the lidar frame. An example of data_config_file . source-list: - 0: /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/data/nuscene/LIDAR_TOP/000000-LIDAR_TOP.bin - 50: /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/data/nuscene/LIDAR_TOP/000001-LIDAR_TOP.bin - 100: /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/data/nuscene/LIDAR_TOP/000002-LIDAR_TOP.bin", "keywords": []}, {"id": 2209, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-datarender-libnvds-3d-gl-datarender-configuration-specifications", "display_name": "Custom datarender libnvds_3d_gl_datarender Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-datarender-libnvds-3d-gl-datarender-configuration-specifications", "priority": -1, "content": "Configuration Common header for libnvds_3d_gl_datarender : name: depth-point-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so Configuration Body for Common Part: Property Meaning Type and Range Example title Specify window title String title: ds3d-point-cloud-test streams Indicate which streams to render. depth render must have [depth], 3D points render must have [points] List[String], select from [color, depth, points] streams: [color, depth] width Specify window width UINT32 width: 1280 height Specify window height UINT32 height: 720 block Indicate rendering thread as block mode Boolean block: True Configuration Header for Point Cloud Render: name: point-3D-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createPointCloudDataRender # specific function for 3D point rendering Configuration Header for Lidar data Render: name: lidar-data-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createLidarDataRender # specific function for Lidar point cloud rendering Configuration Body for 3D Point Cloud and Lidar Render Part: For more details on 3D coordinate system, refer to https://learnopengl.com/Getting-started/Coordinate-Systems . To know the value meanings for view_position , view_target and view_up ,refer to the gluLookAt here: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml . To know the value meanings for near , far and fov , refer to the gluPerspective here: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml . Property Meaning Type and Range Example view_position Specify view position [x, y, z]coordinates List[Float] view_position: [0, 0, -1] view_target Specify view target [x, y, z]coordinates List[Float] view_target: [0, 0, 1] view_up Specify view up direction [x, y, z]coordinates List[Float] view_up: [0, -1.0, 0] near Specify perspective projection near plane Float near: 0.01 far Specify perspective projection far plane Float far: 10.0 fov Specify perspective projection field of view, degree angle Float fov: 40.0 coord_y_opposite Specify texture map V direction, Realsense coordinates is different from GLES default coordinates Boolean coord_y_opposite: False positive_z_only Specify whether display negtive depth values Boolean positive_z_only: False Configuration Body for Lidar Render Specific Part: Property Meaning Type and Range Example view_position Specify view position [x, y, z]coordinates List[Float] view_position: [0, 0, -1] view_target Specify view target [x, y, z]coordinates List[Float] view_target: [0, 0, 1] view_up Specify view up direction [x, y, z]coordinates List[Float] view_up: [0, -1.0, 0] near Specify perspective projection near plane Float near: 0.01 far Specify perspective projection far plane Float far: 10.0 fov Specify perspective projection field of view, degree angle Float fov: 40.0 lidar_color Specify lidar data color for display List[Uint32] lidar_color: [0, 255, 0] element_size Specify lidar data element size. e.g. 4 for XYZI or 3 for XYZ Uint32 element_size: 4 lidar_data_key Specify lidar data frame in datamap, default value is DS3D::LidarXYZI String lidar_data_key: DS3D::LidarXYZI lidar_bbox_key Specify lidar 3D bounding box data in datamap, default value is DS3D::Lidar3DBboxRawData String lidar_bbox_key: DS3D::Lidar3DBboxRawData Configuration Header for Depth and Color 2D Render: name: depth-2D-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createDepthStreamDataRender # specific function for 2D depth rendering Configuration Body for Depth and Color 2D Specific Part: Property Meaning Type and Range Example min_depth Specify minimum depth value. other values less that it will be removed in rendering Float min_depth: 0.3 max_depth Specify maximum depth value. other values less that it will be removed in rendering Float max_depth: 2.0 min_depth_color Specify minimum depth rendering color in [R, G, B] List[Uint32] min_depth_color: [255, 128, 0] max_depth_color Specify maximum depth rendering color in [R, G, B] Float max_depth_color: [0, 128, 255]", "keywords": []}, {"id": 2210, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#custom-datarender-libnvds-3d-gles-ensemble-render-configuration-specifications", "display_name": "Custom datarender libnvds_3d_gles_ensemble_render Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "custom-datarender-libnvds-3d-gles-ensemble-render-configuration-specifications", "priority": -1, "content": "Renders 3D scene using OpenGL ES (GLES) with various elements (textures, LiDAR points, bounding boxes) within a single window, allowing for flexible layout customization. Users can split the windows into multiple views, and project each tensor data or frame from ds3d::datamap into a seperate view or into multiple views at the same time. It could also support overlay if multi frames rendered into a single view positon overlap, it depends on the render graph order. Configuration Header name: ds3d_sensor_fusion_render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gles_ensemble_render.so custom_create_function: NvDs3D_CreateGlesEnsembleRender Configuration Body An example of a multi-view config with render_graph . There are 2 views rendered with different frames inside the same ds3d::datamap . The 2D color image is rendered by texture3d_render into view area [0, 0, 640, 360] ; The Lidar data is rendered by lidar3d_render into view area [640, 0, 1280, 360] . config_body: window_width: 1280 # window size window_height: 360 # window size color_clear: true window_title: DS3D-Lidar-6-Cameras-BEVFusion render_graph: - texture3d_render: # 2D texture view layout: [0, 0, 640, 360] # layout [x0, y0, x1, y1] max_vertex_num: 6 color_clear: false texture_frame_key: DS3D::ColorFrame_2 # image data key - lidar3d_render: # lidar top view layout: [640, 0, 1280, 360] # layout [x0, y0, x1, y1] color_clear: false view_position: [0, 0, 30] view_target: [0, 0, 0] view_up: [0, 1, 0] lidar_color: [0, 0, 255] lidar_data_key: DS3D::LidarXYZI lidar_bbox_key: DS3D::Lidar3DBboxRawData element_size: 4 Property Meaning Type and Range Example window_title Specify window title string window_title: DS3D-Lidar-6-Cameras-BEVFusion window_width Specify window width uint32 window_width: 1920 window_height Specify window height uint32 window_height: 1080 color_clear Specify whether to clear up the whole window when new frame arrive bool color_clear: true render_graph Specify a list of multiple renders in different views List[Dict] render_graph: - texture3d_render: layout: [0, 0, 640, 360] color_clear: false texture_frame_key: DS3D::ColorFrame - lidar3d_render: layout: [640, 0, 1280, 360] color_clear: false lidar_data_key: DS3D::LidarXYZI Render graph render_graph It supports 2 different modes of views texture3d_render , it renders 2D image data into a specified view area. lidar3d_render , it renders lidar data and 3D bbox data into a specified view area. Each mode could be configured multiple times in the same render_graph . Multiple camera data inside a single ds3d::datamap could be configured into different view area. Similarly, multiple lidar data insdie the same ds3d::datamap could also be configured at different viewpoint(topview, front-view, side-view) into different view area. Configuration Specifications of texture3d_render Property Meaning Type and Range Example layout Specify the view location for [x0, y0, x1, y1] List[Float] layout: [0, 0, 640, 360] x0 = 0; y0 = 0; x1 = 640; y1 = 360; color_clear Indicate whether to clear up this view before new frame came. bool color_clear: false texture_frame_key Specify texture image keyname from ds3d::datamap string texture_frame_key: DS3D::ColorFrame_1+1 max_vertex_num Specify vertex_num used for the texture drawing, default value 6 uint32 max_vertex_num: 6 texture_vetex_key Specify 3D vertex key name from ds3d::datamap , it\u2019s used for the texture drawing, there are 6 values by default. string texture_vetex_key: DS3D::TextureVertexKey texture_coord_key Specify texture coordinate key name from ds3d::datamap , it\u2019s used for the texture drawing, there are 6 values by default. string texture_coord_key: DS3D::TextureCoordKey Configuration Specifications of lidar3d_render Property Meaning Type and Range Example layout Specify the view location for [x0, y0, x1, y1] List[Float] layout: [0, 0, 640, 360] x0 = 0; y0 = 0; x1 = 640; y1 = 360; color_clear Indicate whether to clear up this view before new frame came. bool color_clear: false lidar_color Specify lidar data color RGB list[uint8] lidar_color: [0, 0, 255] lidar_data_key Specify lidar data keyname from ds3d::datamap string lidar_data_key: DS3D::LidarXYZI+0 element_size Specify lidar data element size. choose from [3, 4], default value 4 is for xyzi. value 3 is for xyz. uint32 element_size: 4 lidar_bbox_key Specify 3D detection bounding-box key name from ds3d::datamap string lidar_bbox_key: DS3D::Lidar3DBboxRawData project_lidar_to_image Indicate whether need project lidar data and bounding-box into camera image, default value: false bool project_lidar_to_image: false intrinsics_mat_key Specify camera intrinsics matrix key name from ds3d::datamap , It\u2019s needed when project_lidar_to_image: true intrinsics_mat_key: DS3D::Cam2_IntrinsicMatrix extrinsics_mat_key Specify lidar extrinsics matrix key name from ds3d::datamap extrinsics_mat_key: DS3D::LidarToCam2_ExtrinsicMatrix image_width Specify original camera intrinsic image width, this is needed when project_lidar_to_image: true image_width: 1600 image_height Specify original camera intrinsic image height, this is needed when project_lidar_to_image: true image_height: 900 view_position Specify view position [x, y, z]coordinates List[Float] view_position: [0, 0, -1] view_target Specify view target [x, y, z]coordinates List[Float] view_target: [0, 0, 1] view_up Specify view up direction [x, y, z]coordinates List[Float] view_up: [0, -1.0, 0] perspective_near Specify perspective projection near plane Float perspective_near: 0.1 perspective_far Specify perspective projection far plane Float perspective_far: 10.0 perspective_fov Specify perspective projection field of view, degree angle Float perspective_fov: 40.0 perspective_ratio Specify perspective ratio for width/height. default 0.0f means view-width/view-height Float perspective_ratio: 0.0 enable_label Indicate whether label text render enabled. default value: false bool enable_label: true", "keywords": []}, {"id": 2211, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-application-examples", "display_name": "DS3D Application Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-application-examples", "priority": -1, "content": "DeepStream-3D Multi-Modal Lidar and Camera Sensor Fusion App sample application showcases a multi-modal sensor fusion pipeline for LiDAR and camera data using the DS3D framework. There are 2 examples of multi-modal sensor fusion pipelines inside the samples. The sample app is located at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion . Refer to DeepStream 3D Multi-Modal Lidar and Camera Sensor Fusion App to see more details of deepstream-3d-lidar-sensor-fusion DS3D BEVFusion pipeline shows the overview of 6-camera plus 1-LiDAR data fusion inference and rendering pipeline through deepstream-3d-lidar-sensor-fusion . DS3D V2XFusion pipeline shows the overview of 1-camera plus 1-LiDAR with batch 4 data input fusion inference and rendering pipeline through deepstream-3d-lidar-sensor-fusion . deepstream-lidar-inference has the sample code to load these custom libs and to connect these components together in simple ways. Besides that, DS3D has a simple C++ safe pointer for Gstreamer components. The interfaces are found in header files located at /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/gst/ . The image below shows the overview of lidar 3D data inference and rendering pipeline in deepstream-lidar-inference . See more details in the DeepStream 3D Lidar Inference App . deepstream-3d-depth-camera is another example for ds3d pipeline. The image below shows the overview of depth to 3D point processing pipeline in deepstream-3d-depth-camera . See more details in the DeepStream 3D Depth Camera App . All the components are configured in YAML format. They are loaded by Gst-plugins .There are 3 major components, they may all be loaded into the deepstream pipeline.", "keywords": []}, {"id": 2212, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-data-format-ds3d-datamap", "display_name": "DS3D data format ds3d/datamap", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-data-format-ds3d-datamap", "priority": -1, "content": "ds3d/datamap recognizes the data format used in DS3D framework. Data buffers flowing between GStreamer plugins will be of this data-type. ds3d/datamap are key-value pairs where key is a string and value, a pointer, structure or tensor frame to data. All of the operations on the buffer is managed by GuardDataMap . Examples: Create GuardDataMap datamap and set scaler key-values. #include &lt;ds3d/common/hpp/datamap.hpp&gt; using namespace ds3d; GuardDataMap datamap(NvDs3d_CreateDataHashMap(), true); // creat a empty datamap TimeStamp ts{0}; datamap.setData(&quot;DS3D::Timestamp&quot;, ts); // set timestamp float score = 0.1; datamap.setData(&quot;DS3D::Score&quot;, score); // copy score into datamap User-defined structure added into ds3d datamap . ds3d datamap requires each data type having a typeid: uint64_t before adding the data into datamap. This could prevent any wrong datatype casting in runtime. To achieve that, there are 2 ways to enable a typeid for a structure. Example 1, use REGISTER_TYPE_ID directly in custom data structure definition. this is mostly used when users define a new structure. #define DS3D_TYPEID_TIMESTAMP 0x20002 struct TimeStamp { uint64_t t0 = 0; uint64_t t1 = 0; uint64_t t2 = 0; REGISTER_TYPE_ID(DS3D_TYPEID_TIMESTAMP) }; // Add the shared_ptr into datamap std::shared_ptr&lt;TimeStamp&gt; timePtr(new TimeStamp); datamap.setPtrData(&quot;DS3D::Timestamp0&quot;, timePtr); // Add a copy of the TimeStamp into datamap TimeStamp time1; datamap.setData(&quot;DS3D::Timestamp1&quot;, time1); Example 2, Instantiate template struct TpId&lt;&gt; { static constexpr TIdType __typeid(); } , this is helpful when adding a 3rdparty data structure into datamap and not able to modify the 3rd-party existing DataStructure. // this is the 3rd-party structure struct Existing3rdpartData { float v0; int v1; }; // derive ds3d::__TypeID for any 3rdparty data structure. #incude &quot;ds3d/common/type_trait.h&quot; #define DS3D_TYPEID_EXISTING_3RDPART_DATA 0x80001 namespace ds3d { template &lt;&gt; struct TpId&lt;Existing3rdpartData&gt;: __TypeID&lt;DS3D_TYPEID_EXISTING_3RDPART_DATA&gt; {}; } // Add the shared_ptr into datamap std::shared_ptr&lt;Existing3rdpartData&gt; dataPtr(new Existing3rdpartData); datamap.setPtrData(&quot;3rdpartyData0&quot;, dataPtr); // Add a copy of the Existing3rdpartData into datamap Existing3rdpartData data3rdparty{0.0f, 0}; datamap.setData(&quot;3rdpartyData1&quot;, data3rdparty); Create LiDAR tensor frame and add into GuardDataMap datamap . std::vector&lt;vec4f&gt; lidardata = { {{-5.0f, -5.0f, -3.0f, 0.6f}}, {{-5.0f, -5.0f, -3.0f, 0.85f}}, {{1.0f, 0.5f, -1.0f, 0.82f}}, {{-5.0f, -5.0f, -3.0f, 0.8f}}, }; void* pointPtr = (void*)(&amp;lidardata[0]); uint32_t pointsN = lidardata.size(); FrameGuard lidarFrame = wrapLidarXYZIFrame&lt;float&gt;( (void*)pointPtr, pointsN, MemType::kCpu, 0, [holder = std::move(lidardata)](void*) {}); // lambda deleter const std::string keyName = &quot;DS3D::LidarXYZI&quot;; // user define a key name. // setGuardData holds a reference_count on the lidarFrame without deep-copy datamap.setGuardData(keyName, lidarFrame); Create 2D-Image tensor frame and add into GuardDataMap datamap . std::vector&lt;vec4b&gt; imagedata = { {{255, 0, 0, 255}}, {{0, 255, 0, 255}}, {{0, 255, 0, 255}}, {{0, 0, 255, 255}}, {{255, 255, 0, 255}}, {{0, 255, 0, 255}}, }; uint32_t width = 3, height = 2; Frame2DPlane colorPlane = {width, height, (uint32_t)sizeof(vec4b) * width, sizeof(vec4b), 0}; void* colorPtr = (void*)(&amp;imagedata[0]); uint32_t bytes = colorPlane.pitchInBytes * colorPlane.height; Frame2DGuard imageFrame = impl::Wrap2DFrame&lt;uint8_t, FrameType::kColorRGBA&gt;( colorPtr, {colorPlane}, bytes, MemType::kCpu, 0, [holder = std::move(imagedata)](void*) {}); // lambda deleter const std::string keyName = &quot;DS3D::ColorFrame&quot;; // user define a key name. // setGuardData holds a reference_count on the imageFrame without deep-copy datamap.setGuardData(keyName, imageFrame); Create custom shaped tensor frame and add into GuardDataMap datamap . std::vector&lt;float&gt; tensordata = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11.0f }; void* tensorPtr = (void*)(&amp;tensordata[0]); Shape tensorShape{3, {1, 3, 4}}; // tensor shape (1, 3, 4) uint32_t bytes = tensordata.size() * sizeof(tensordata[0]); FrameGuard tensorFrame = impl::WrapFrame&lt;float, FrameType::kCustom&gt;( tensorPtr, bytes, tensorShape, MemType::kCpu, 0, [holder = std::move(imagedata)](void*) {}); // lambda deleter const std::string keyName = &quot;DS3D::dataarray&quot;; // user define a key name. // setGuardData holds a reference_count on the tensorFrame without deep-copy datamap.setGuardData(keyName, tensorFrame); Query data values from GuardDataMap datamap GuardDataMap::getGuardData , return a safe reference counted guard data GuardDataT&lt;DataStructure&gt; e.g. Frame2DGuard, FrameGuard, GuardDataT&lt;TimeStamp&gt; GuardDataMap::getPtrData , return a reference counted std::shared_ptr&lt;DataStructure&gt; e.g. std::shared_ptr&lt;TimeStamp&gt; GuardDataMap::getData , return a copy of the DataStructure. e.g. TimeStamp // example to use different ways to get timestamp. std::string timeKey = &quot;DS3D::Timestamp&quot;; if (datamap.hasData(timeKey)) { // get a COPY of Timestamp TimeStamp t0; DS_ASSERT(isGood(datamap.getData(timeKey, t0)); // get a std::shared_ptr of Timestamp std::shared_ptr&lt;TimeStamp&gt; tPtr; DS_ASSERT(isGood(datamap.getPtrData(timeKey, tPtr)); // get a reference-counted GuardDataT&lt;Timestamp&gt; GuardDataT&lt;TimeStamp&gt; timeGuard; DS_ASSERT(isGood(datamap.getPtrData(timeKey, timeGuard)); // example to get a lidar tensor frame FrameGuard pointFrame; std::string lidarKey = &quot;DS3D::LidarXYZI&quot;; if (datamap.hasData(lidarKey)) { // get lidar tensor frame // pointFrame holds a reference count DS_ASSERT(isGood(dataMap.getGuardData(lidarKey, pointFrame))); DataType dType = pointFrame-&gt;dataType(); FrameType frameType = pointFrame-&gt;frameType(); MemType memType = pointFrame-&gt;memType(); Shape pShape = pointFrame-&gt;shape(); void *dataPtr = pointFrame-&gt;base(); size_t dataBytes = pointFrame-&gt;bytes(); } // example to get a RGBA image tensor frame Frame2DGuard rgbaImage; std::string imageKey = &quot;DS3D::ColorFrame&quot;; if (datamap.hasData(imageKey)) { // get 2D image tensor frame // rgbaImage holds a reference count DS_ASSERT(isGood(dataMap.getGuardData(imageKey, rgbaImage))); DataType dType = rgbaImage-&gt;dataType(); FrameType frameType = rgbaImage-&gt;frameType(); MemType memType = rgbaImage-&gt;memType(); Shape pShape = rgbaImage-&gt;shape(); void *dataPtr = rgbaImage-&gt;base(); size_t dataBytes = rgbaImage-&gt;bytes(); DS_ASSERT(rgbaImage-&gt;planes() == 1); // RGBA image has 1 plane. Frame2DPlane plane = rgbaImage-&gt;getPlane(0); } // example to get a custom shaped tensor frame, e.g. data_array FrameGuard tensorFrame; std::string tensorKey = &quot;DS3D::dataarray&quot;; if (datamap.hasData(tensorKey)) { // get any tensor frame // tensorFrame holds a reference count DS_ASSERT(isGood(dataMap.getGuardData(tensorKey, tensorFrame))); DataType dType = tensorFrame-&gt;dataType(); FrameType frameType = tensorFrame-&gt;frameType(); MemType memType = tensorFrame-&gt;memType(); Shape pShape = tensorFrame-&gt;shape(); void *dataPtr = tensorFrame-&gt;base(); size_t dataBytes = tensorFrame-&gt;bytes(); }", "keywords": []}, {"id": 2213, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-databridge-loads-custom-lib-for-data-conversion-to-and-from-ds3d", "display_name": "ds3d::databridge - Loads Custom Lib for data conversion to and from DS3D.", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-databridge-loads-custom-lib-for-data-conversion-to-and-from-ds3d", "priority": -1, "content": "This plugin and custom lib helps convert data type to and from ds3d/datamap More details: Gst-nvds3dbridge .", "keywords": []}, {"id": 2214, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-datafilter-ds3d-custom-datafilter", "display_name": "ds3d::datafilter-  DS3D Custom DataFilter", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-datafilter-ds3d-custom-datafilter", "priority": -1, "content": "DS3D DataFilter is processing inputs from ds3d::datamap and producing outputs input new ds3d::datamap . Users can implement custom datafilter lib for their own use case.", "keywords": []}, {"id": 2215, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-dataloader-in-deepstream-user-application", "display_name": "DS3D Dataloader in DeepStream User Application", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-dataloader-in-deepstream-user-application", "priority": -1, "content": "DS3D Custom Dataloaders are agnostic from Gstreamer/Glib Framework. But it could be working with Gstramer as well. The ds3d::dataloader could interactively work with GstAppSrc together. They could be created by NvDs3D_CreateDataLoaderSrc . Examples: #include &lt;ds3d/common/config.h&gt; #include &lt;ds3d/gst/nvds3d_gst_plugin.h&gt; std::string yamlStr = R&quot;( name: ds3d_lidar_file_source type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_lidarfileread.so custom_create_function: createLidarFileLoader config_body: data_config_file: lidar_data_list.yaml points_num: 242180 mem_type: gpu # choose [cpu gpu] gpu_id: 0 mem_pool_size: 6 element_size: 4 output_datamap_key: DS3D::LidarXYZI )&quot;; ErrCode c = ErrCode::kGood; ComponentConfig config; c = parseComponentConfig(yamlStr.c_str(), &quot;./config_lidar_loader.yaml&quot;, config); DS_ASSERT(config.type == ComponentType::kDataLoader); DS_ASSERT(config.customLibPath == &quot;libnvds_lidarfileread.so&quot;); DS_ASSERT(config.customCreateFunction == &quot;createLidarFileLoader&quot;); gst::DataLoaderSrc appLoader; c = NvDs3D_CreateDataLoaderSrc(c, appLoader, true); // get DS3D custom dataloader. GuardDataLoader dataLoader = appLoader.customProcessor; // get GstAppSrc from this appLoader; GstElement* appsrc = appLoader.gstElement.get(); // gstreamer pipeline setup and running. // during each read_data from GstAppSrc callback. it would simultaneously reading data from dataloader // GuardDataMap datamap; // dataloader.read_data(datamap); // DS3D dataloader would stop qutomatically when Gstpipeline is stopped. // But in the case if user want to stop it early or manually. // Obtain DS3D custom dataloader and stop manually. c = dataloader.flush(); c = dataloader.stop(); GuardDataLoader provides safe access to abiDataLoader . Once it\u2019s created, it will maintain the reference pointer to the dataloader .", "keywords": []}, {"id": 2216, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-datamap-interoperate-with-gstbuffer", "display_name": "DS3D DataMap interoperate with GstBuffer", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-datamap-interoperate-with-gstbuffer", "priority": -1, "content": "DS3D DataMap has ABI-compatible class ds3d::abiRefDataMap . With that, NvDs3DBuffer is defined for storing DS3D datamap along with GstBuffer . Header file is ds3d/gst/nvds3d_meta.h . struct NvDs3DBuffer { uint32_t magicID; // must be &#x27;DS3D&#x27; ds3d::abiRefDataMap* datamap; }; Do not use the datamap directly. The easy and safe way to access that is through GuardDataMap . see examples below Example to get datamap from GstBuffer #include &lt;ds3d/common/hpp/datamap.hpp&gt; #include &lt;ds3d/common/hpp/frame.hpp&gt; using namespace ds3d; GstBuffer *gstBuf = ; // get the gstBuf from probe function or Gstreamer plugins if (NvDs3D_IsDs3DBuf(gstBuf)) { const abiRefDataMap* refDataMap = nullptr; ErrCode c = NvDs3D_Find1stDataMap(gstBuf, refDataMap); if (refDataMap) { GuardDataMap dataMap(*refDataMap); FrameGuard lidarFrame; c = dataMap.getGuardData(&quot;DS3D::LidarXYZI&quot;, pointFrame); // get lidar points reference. FrameGuard uvCoord; c = dataMap.getGuardData(&quot;DS3D::TextureCoordKey&quot;, uvCoord); // get 3D points UV coordinates reference. Frame2DGuard depthFrame; c = dataMap.getGuardData(&quot;DS3D::DepthFrame&quot;, depthFrame); // get depth frame reference. DepthScale scale; c = dataMap.getData(&quot;DS3D::DepthScaleUnit&quot;, scale); // copy depth scale } } Example to createa a ds3d::datamap into a new GstBuffer #include &lt;ds3d/common/hpp/datamap.hpp&gt; #include &lt;ds3d/common/hpp/frame.hpp&gt; #include &lt;ds3d/common/impl/impl_frames.h&gt; GuardDataMap datamap(NvDs3d_CreateDataHashMap(), true); // set true to take the reference ownership. /* Create color image frame and store them into ds3d datamap. */ // Assume format is RGBA { Frame2DPlane colorPlane = {1920, 1080, 1920 * sizeof(uint8_t) , sizeof(uint8_t), 0}; uint32_t colorBytesPerFrame = colorPlane.pitchInBytes * colorPlane.height; std::vector&lt;uint8_t&gt; data(colorBytesPerFrame); // Image data void* dataPtr = &amp;data[0]; // create color 2D frame Frame2DGuard frame = Wrap2DFrame&lt;uint8_t, FrameType::kColorRGBA&gt;( dataPtr, {_config.colorPlane}, bytesPerFrame, MemType::kCpu, 0, [data = std::move(data)](void*) {}); c = datamap.setGuardData(kColorFrame, colorFrame); // store colorFrame reference into datamap. ... // check error code } Once datamap is ready, you can create a new GstBuffer with DS3D datamap. // ``GuardDataMap datamap`` is ready GstBuffer* gstBuf = nullptr; ErrCode c = NvDs3D_CreateGstBuf(gstBuf, datamap.abiRef(), false); // set false to increase reference count. ... // check error code Example to update an existing DS3D  GstBuffer with a new ds3d  datamap . // Assume ``GuardDataMap datamap`` is ready // Assume ``GstBuffer* gstBuf`` is created by another compoment ErrCode c = NvDs3D_UpdateDataMap(gstBuf, datamap.abiRef(), false); // set false to increase reference count. ... // check error code", "keywords": []}, {"id": 2217, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#ds3d-datarender-loads-ds3d-custom-datarender", "display_name": "ds3d::datarender - Loads DS3D Custom DataRender", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "ds3d-datarender-loads-ds3d-custom-datarender", "priority": -1, "content": "DS3D Custom DataRenders are agnostic from Gstreamer/Glib Framework. But it could be working with Gstramer as well. The ds3d::datarender could interactively work with GstAppSink together. They could be created by NvDs3D_CreateDataRenderSink . Examples:", "keywords": []}, {"id": 2218, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#implement-a-custom-ds3d-datafilter", "display_name": "Implement a Custom DS3D Datafilter", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "implement-a-custom-ds3d-datafilter", "priority": -1, "content": "Examples: #include &lt;ds3d/common/impl/impl_datafilter.h&gt; class TestFakeDataFilter : public impl::BaseImplDataFilter { public: TestFakeDataFilter() = default; protected: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override { setInputCaps(kFakeCapsMetaName); setOutputCaps(kFakeCapsMetaName); return ErrCode::kGood; } ErrCode processImpl( GuardDataMap datamap, OnGuardDataCBImpl outputDataCb, OnGuardDataCBImpl inputConsumedCb) override { DS_ASSERT(datamap); TimeStamp t; ErrCode c = datamap.getData(&quot;time&quot;, t); if (!isGood(c)) { return c; } t.t0 += 1; inputConsumedCb(ErrCode::kGood, datamap); c = datamap.setData(&quot;time&quot;, t); if (!isGood(c)) { return c; } outputDataCb(ErrCode::kGood, datamap); return ErrCode::kGood; } ErrCode flushImpl() override { return ErrCode::kGood; } ErrCode stopImpl() override { return ErrCode::kGood; } }; DS3D_EXTERN_C_BEGIN DS3D_EXPORT_API abiRefdatafilter* createTestFakeDatafilter() { return NewAbiRef&lt;abidatafilter&gt;(new TestFakeDataFilter); } DS3D_EXTERN_C_END As shown in the example above, you\u2019ll need to derive the datafilter from the ds3d::impl::BaseImplDataFilter class, and implement interfaces for the following: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override; ErrCode processImpl( GuardDataMap datamap, OnGuardDataCBImpl outputDataCb, OnGuardDataCBImpl inputConsumedCb) override; ErrCode stopImpl() override; ErrCode flushImpl() override; To load this custom lib through nvds3dfilter  Gst-plugin , you\u2019ll also need to export a specific symbol createTestFakeDatafilter .", "keywords": []}, {"id": 2219, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#implement-a-ds3d-custom-dataloader", "display_name": "Implement a DS3D Custom Dataloader", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "implement-a-ds3d-custom-dataloader", "priority": -1, "content": "Examples: #include &lt;ds3d/common/impl/impl_dataloader.h&gt; class TestTimeDataLoader : public ds3d::impl::SyncImplDataLoader { public: TestTimeDataLoader() = default; protected: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override { setOutputCaps(&quot;ds3d/datamap&quot;); return ErrCode::kGood; } ErrCode readDataImpl(GuardDataMap&amp; datamap) override { datamap.reset(NvDs3d_CreateDataHashMap()); static uint64_t iTime = 0; TimeStamp t{iTime++, 0, 0}; datamap.setData(&quot;time&quot;, t); emitError(ErrCode::kGood, &quot;timstamp added&quot;); return ErrCode::kGood; } ErrCode stopImpl() override { return ErrCode::kGood; } ErrCode flushImpl() override { return ErrCode::kGood; } }; DS3D_EXTERN_C_BEGIN DS3D_EXPORT_API abiRefDataLoader* createTestTimeDataloader() { return NewAbiRef&lt;abiDataLoader&gt;(new TestTimeDataLoader); } DS3D_EXTERN_C_END A shown in the example above, You\u2019ll need to derive dataloader from the ds3d::impl::SyncImplDataLoader class, and implement interfaces for the following: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override; ErrCode readDataImpl(GuardDataMap&amp; datamap) override; ErrCode stopImpl() override; ErrCode flushImpl() override;", "keywords": []}, {"id": 2220, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#implement-a-ds3d-custom-datarender", "display_name": "Implement a DS3D Custom Datarender", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "implement-a-ds3d-custom-datarender", "priority": -1, "content": "Examples: #include &lt;ds3d/common/impl/impl_datarender.h&gt; class TestFakeDataRender : public impl::BaseImplDataRender { public: TestFakeDataRender() = default; protected: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override { setInputCaps(&quot;ds3d/datamap&quot;); return ErrCode::kGood; } ErrCode prerollImpl(GuardDataMap datamap) override { return ErrCode::kGood; } ErrCode renderImpl(GuardDataMap datamap, OnGuardDataCBImpl dataDoneCb) override { DS_ASSERT(datamap); emitError(ErrCode::kGood, &quot;data rendered&quot;); dataDoneCb(ErrCode::kGood, datamap); return ErrCode::kGood; } ErrCode flushImpl() override { return ErrCode::kGood; } ErrCode stopImpl() override { return ErrCode::kGood; } }; DS3D_EXTERN_C_BEGIN DS3D_EXPORT_API abiRefdatarender* createTestFakedatarender() { return NewAbiRef&lt;abiDataRender&gt;(new TestFakeDataRender()); } DS3D_EXTERN_C_END As shown in the example above, you\u2019ll need to derive datarender from the ds3d::impl::BaseImplDataRender class, and implement interfaces for the following: ErrCode startImpl(const std::string&amp; content, const std::string&amp; path) override; ErrCode prerollImpl(GuardDataMap datamap) override; ErrCode renderImpl(GuardDataMap datamap, OnGuardDataCBImpl dataDoneCb) override; ErrCode stopImpl() override; ErrCode flushImpl() override; To load this custom lib through NvDs3D_CreateDataRenderSink , you\u2019ll also need to export a specific symbol createTestFakedatarender .", "keywords": []}, {"id": 2221, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#libnvds-3d-depth-datasource-depth-file-source-specific-configuration-specifications", "display_name": "libnvds_3d_depth_datasource Depth file source Specific Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "libnvds-3d-depth-datasource-depth-file-source-specific-configuration-specifications", "priority": -1, "content": "Configuration header: name: depthfilesource type: ds3d::dataloader out_caps: ds3d/datamap, framerate=30/1 custom_lib_path: libnvds_3d_depth_datasource.so custom_create_function: createDepthColorLoader Configuration body: Property Meaning Type and Range Example depth_source Specify file path for depth source String depth_source: depth_uint16_640x480.bin color_source Specify file path for color image source String color_source: color_rgba_1920x1080.bin depth_scale Indicate depth unit in meters per each depth value Float depth_scale: 0.0010 depth_datatype Indicate depth datatype, only [uint16] is supported for this version String, Values must be uint16 depth_datatype: uint16 depth_size Indicate depth resolutions in [width, height] List[Uint32], must be [width, height] depth_size: [640, 480] color Indicate color format. only rgba is supported String. Value must be rgba color: rgba color_size Indicate color resolutions in [width, height] List[Uint32], must be [width, height] color_size: [1920, 1080] depth_intrinsic Indicate depth sensor intrinsic parameter groups Intrinsic Configuration Group depth_intrinsic: width: 848 height: 480 centerX: 424.06073 centerY: 237.75032 fx: 422.513062 fy: 422.513062 color_intrinsic Indicate color sensor intrinsic parameter groups Intrinsic Configuration Group color_intrinsic: width: 1920 height: 1080 centerX: 964.288086 centerY: 533.287354 fx: 1358.21423 fy: 1358.2533 depth_to_color_extrinsic Indicate extrinsic parameters from depth sensor to color sensor Extrinsic Configuration Group depth_to_color_extrinsic: rotation: [1, -0.0068, 0.0010, 0.0068, 1, 0, -0.0010, 0, 1] translation: [0.01481, -0.0001, 0.0002] Configuration Body for Intrinsic Parameters : Property Meaning Type and Range Example width Specify sensor width in pixels Uint32 width: 848 height Specify sensor height in pixels Uint32 height: 480 centerX Specify coordinate axis position in pixels in horizontal direction Float centerX: 424.06 centerY Specify coordinate axis position in pixels in vertical direction Float centerY: 533.28 fx Specify focal length in pixels in X direction Float fx: 1358.21 fy Specify focal length in pixels in Y direction Float fy: 1358.25 Configuration Body for Extrinsic Parameters: Property Meaning Type and Range Example rotation Specify an extrinsic 3x3 matrix for rotation. Values in Column-major order List[Float], Values in Column-major order rotation: [1, -0.0068, 0.0010, 0.0068, 1, 0, -0.0010, 0, 1] translation Specify an extrinsic 3x1 matrix for translation. Values in Column-major order List[Float], Values in Column-major order translation: [0.01481, -0.0001, 0.0002]", "keywords": []}, {"id": 2222, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#libnvds-tritoninferfilter-configuration-specifications", "display_name": "libnvds_tritoninferfilter Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "libnvds-tritoninferfilter-configuration-specifications", "priority": -1, "content": "Multi-modal tensors Triton inference with key-value pairs in ds3d::datamap , Supports user defined custom preprocess and postprocess. Configuration for multi-modal triton inference Header: name: multimodal_triton_infer type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter Config body specifications Property Meaning Type and Range Example in_streams which data type will be processed List of String, Optional in_streams: [lidar] gpu_id GPU device ID Integer, default value:\uff10 gpu_id: 0 config_file nvinferserver(triton) low level lib config file, supports gRPC and CAPI, see more details Low Level libnvds_infer_server.so Configuration File Specifications String of Path config_file: model_config_files/config_triton_bev_fusion_infer_grpc.pbtxt mem_pool_size Size of the input tensor pool Integer mem_pool_size: 8 model_inputs model \u2018s input layers information, If there is no custom_preprocess defined, inferencefilter would forward the key-value frames from ds3d::datamap to triton\u2019s input tensor List of Dict name: input_image_0 datatype: UINT8 shape: [1, 900, 1600, 4] from: DS3D::ColorFrame_0+1 is_2d_frame: true input_tensor_mem_type input tensor memory type after preprocess String:[GpuCuda CpuCuda] input_tensor_mem_type: GpuCuda custom_preprocess_lib_path custom preprocessing library path String custom_preprocess_lib_path: /opt/nvidia/deepstream/deepstream/lib/libnvds_lidar_custom_preprocess_impl.so custom_preprocess_func_name customized preprocessing function name String custom_preprocess_func_name: CreateInferServerCustomPreprocess postprocess User defined postprocessing information Dict postprocess: score_threshold: 0.5 labels User defined labels for custom postprocess List of Dict labels: car: color: [255, 158, 0] truck: color: [255, 99, 71] model_inputs has all input layers information. If there is custom preprocess function/lib specfied inside config body. The lib would search from keyname of the input ds3d::datamap , and forward the frame/tensor data into Triton server\u2019s input tensors. The from keyname must be a frame, 2D-frame or tensor inside the ds3d::datamap Configuration Specifications of the model_inputs Property Description Type and Range Example name Model\u2019s input tensor name String name: input_image_0 datatype Model\u2019s input data type String values in [FP32, FP16, INT8, INT32, INT16, UINT8, UINT16, UINT32, FP64, INT64, UINT64, BYTES, BOOL] datatype: FP32 shape Model\u2019s input tensor shape List of Integer shape: [1, 900, 1600, 4] from The keyname of the input ds3d::datamap , the value must be a frame/2D-frame/tensor. If custom_preprocess is not existing, the frame would be forwarded into Triton\u2019s input tensors directly. String from: DS3D::ColorFrame_5 is_2d_frame Indicate the from inside of ds3d::datamap is a 2D frame. Bool is_2d_frame: true Custom preprocess before triton inference If custom_preprocess_lib_path and custom_preprocess_func_name are specified, Custom processing will be loaded and parse the config body and get all common and user defined information. then process each input ds3d::datamap and generate batchArray for triton inference inputs. Users can derive interface IInferCustomPreprocessor from sources/includes/ds3d/common/hpp/lidar_custom_process.hpp See examples in sources/libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_preprocess/nvinferserver_custom_preprocess.cpp #include &lt;ds3d/common/hpp/datamap.hpp&gt; #include &lt;ds3d/common/hpp/frame.hpp&gt; #include &lt;ds3d/common/hpp/lidar_custom_process.hpp&gt; using namespace ds3d; using namespace nvdsinferserver; class NvInferServerCustomPreProcess : public IInferCustomPreprocessor { public: // process key-values from datamap and generate into model inputs batchArray. NvDsInferStatus preproc(GuardDataMap &amp;datamap, SharedIBatchArray batchArray, cudaStream_t stream) override {...} }; extern &quot;C&quot; { IInferCustomPreprocessor *CreateInferServerCustomPreprocess() { return new NvInferServerCustomPreProcess(); } } Custom postprocess after triton inference Postprocessing is quite specific for each model. You\u2019ll need to implement your own postprocessing functions based on inference output tensors results. Custom postprocess libs and functions are specfied from nvdsinferserver\u2019s config. for example in apps/sample_apps/deepstream-3d-lidar-sensor-fusion/model_config_files/config_triton_bev_fusion_infer_grpc.pbtxt infer_config { backend { triton { model_name: &quot;bevfusion&quot; grpc {...} } } extra { output_buffer_pool_size: 4 # specify custom postprocess function custom_process_funcion: &quot;Nvds3d_CreateLidarDetectionPostprocess&quot; } custom_lib { # specify custom postprocess library path: &quot;libnvds_3d_infer_postprocess_lidar_detection.so&quot; } } An example of custom postprocess implementation is provided here: sources/libs/ds3d/inference_custom_lib/ds3d_lidar_detection_postprocess/ds3d_infer_postprocess_lidar_detection.cpp #include &quot;infer_custom_process.h&quot; #include &lt;ds3d/common/hpp/frame.hpp&gt; #include &lt;ds3d/common/hpp/datamap.hpp&gt; using namespace ds3d; using namespace nvdsinferserver; class DS3DTritonLidarInferCustomPostProcess : public IInferCustomProcessor { public: // process key-values from datamap and generate into model inputs batchArray. NvDsInferStatus inferenceDone(const IBatchArray* batchArray, const IOptions* inOptions) override { ... // get ``ds3d::datamap`` from ``inOptions`` abiRefDataMap* refDataMap = nullptr; if (inOptions-&gt;hasValue(kLidarRefDataMap)) { INFER_ASSERT(inOptions-&gt;getObj(kLidarRefDataMap, refDataMap) == NVDSINFER_SUCCESS); } GuardDataMap dataMap(*refDataMap); ... // parsing output tensors from batchArray TensorMap outTensors; for (uint32_t i = 0; i &lt; batchArray-&gt;getSize(); ++i) { auto buf = batchArray-&gt;getSafeBuf(i); outTensors[buf-&gt;getBufDesc().name] = buf; } std::vector&lt;Lidar3DBbox&gt; bboxes; ret = parseLidar3Dbbox(outTensors, bboxes); // warp data into ds3d frame ``bboxFrame`` size_t bufBytes = sizeof(Lidar3DBbox) * bboxes.size(); void* bufBase = (void*)bboxes.data(); Shape shape{3, {1, (int)bboxes.size(), sizeof(Lidar3DBbox)}}; FrameGuard bboxFrame = impl::WrapFrame&lt;uint8_t, FrameType::kCustom&gt;( bufBase, bufBytes, shape, MemType::kCpu, 0, [outdata = std::move(bboxes)](void*) {}); // add key-value fram into ds3d::datamap ErrCode code = dataMap.setGuardData(_3dBboxKey, bboxFrame); ... return ret; } }; extern &quot;C&quot; { IInferCustomProcessor *Nvds3d_CreateLidarDetectionPostprocess() { return new DS3DTritonLidarInferCustomPostProcess(); } }", "keywords": []}, {"id": 2223, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#load-and-manage-ds3d-dataloader", "display_name": "Load and Manage DS3D Dataloader", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "load-and-manage-ds3d-dataloader", "priority": -1, "content": "Examples: name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader config_body: streams: [color, depth] A custom dataloader must have type: ds3d::dataloader . It is created by explicit call of NvDs3D_CreateDataLoaderSrc(srcConfig, loaderSrc, start) with the full compoment YAML content. During this call, the custom_lib_path is loaded and a specific data loader is created via custom_create_function . A GstAppsrc object is also created into loaderSrc.gstElement . GstAppsrc manages the ds3d::dataloader dataflows. This ds3d::dataloader component could be started automatically by gst-pipeline or manually by the application call. GuardDataLoader dataloader = loaderSrc.customProcessor; ErrCode c = dataloader.start(); To stop the dataloader , user can set GstAppsrc states to GST_STATE_READY or stop it manually. GuardDataLoader dataloader = loaderSrc.customProcessor; ErrCode c = dataloader.stop();", "keywords": []}, {"id": 2224, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#load-and-manage-ds3d-datarender", "display_name": "Load And Manage DS3D Datarender", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "load-and-manage-ds3d-datarender", "priority": -1, "content": "Examples: #include &lt;ds3d/common/config.h&gt; #include &lt;ds3d/gst/nvds3d_gst_plugin.h&gt; std::string yamlStr = R&quot;( name: lidar_render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createLidarDataRender gst_properties: sync: True async: False drop: False config_body: title: ds3d-lidar-render streams: [lidardata] width: 1280 height: 720 block: True view_position: [0, 0, 60] view_target: [0, 0, 0] view_up: [0, 1, 0] near: 0.3 far: 100 fov: 50 lidar_color: [0, 255, 0] lidar_data_key: DS3D::LidarXYZI element_size: 4 lidar_bbox_key: DS3D::Lidar3DBboxRawData enable_label: True )&quot;; ErrCode c = ErrCode::kGood; ComponentConfig config; c = parseComponentConfig(yamlStr.c_str(), &quot;./config_lidar_loader.yaml&quot;, config); DS_ASSERT(config.type == ComponentType::kDataRender); DS_ASSERT(config.customLibPath == &quot;libnvds_3d_gl_datarender.so&quot;); DS_ASSERT(config.customCreateFunction == &quot;createLidarDataRender&quot;); gst::DataRenderSink appRender; c = NvDs3D_CreateDataRenderSink(config, appRender, true); // get DS3D custom datarender. GuardDataRender datarender = appRender.customProcessor; // get GstAppSink from this appRender; GstElement* appsink = appRender.gstElement.get(); // gstreamer pipeline setup and running. // during each render_data from GstAppSink callback. it would simultaneously reading data from datarender // datarender.render(datamap, consumed_callback); // DS3D datarender would stop qutomatically when Gstpipeline is stopped. // But in the case if user want to stop it early or manually. // Obtain DS3D custom datarender and stop manually. c = datarender.stop(); A custom datarender must have type: ds3d::datarender . It is created by explicit call of NvDs3D_CreateDataRenderSink(sinkConfig, renderSink, start) with the full compoment YAML content. During this call, the custom_lib_path is loaded and a specific data loader is created via custom_create_function . A GstAppsink object is also created into renderSink.gstElement . GstAppsink manages the ds3d::datarender dataflows. This ds3d::datarender component could be automatically started by the gst-pipeline , or manually by the application call. GuardDataRender datarender = renderSink.customProcessor; ErrCode c = datarender.start(); To stop the datarender , you can set GstAppsink states to GST_STATE_READY , or stop manually. .. code-block:: text GuardDataRender datarender = renderSink.customProcessor; ErrCode c = datarender.stop(); GuardDataRender provides safe access to abidatarender . Once it\u2019s created, it will maintain the reference pointer to datarender. preroll is called only once to initialize some resources.", "keywords": []}, {"id": 2225, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "page", "name": "text/DS_3D_Custom_Manual#supported-ds3d-custom-process-libraries", "display_name": "Supported DS3D Custom Process libraries", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Custom_Manual", "anchor": "supported-ds3d-custom-process-libraries", "priority": -1, "content": "DS3D Process Type Functionality DS3D custom library DS3D Creating Instance Function Description dataloader lidar-file-reader libnvds_lidarfileread.so createLidarFileLoader Lidar file data reader library, see details in Custom Dataloader libnvds_lidarfileread Configuration Specifications dataloader realsense camera depth/image capture libnvds_3d_dataloader_realsense.so createRealsenseDataloader RealSense Camera capture dataloader library, see details in Custom Dataloader libnvds_3d_dataloader_realsense Configuration Specifications datafilter multi sensor triton inference lib libnvds_tritoninferfilter.so createLidarInferenceFilter Multi-modal sensor triton inference library, see details in libnvds_tritoninferfilter Configuration Specifications datafilter data_alignment libnvds_3d_alignment_datafilter.so createLidarAlignmentFilter lidar/camera Sensor Intrinsic and Extrinsic parameters and alignment, see details in Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so datafilter lidar_data_preprocess libnvds_3d_lidar_preprocess_datafilter.so createLidarPreprocessFilter lidar data voxel processing, see details in Custom Datafilter libnvds_3d_lidar_preprocess_datafilter Specifications datafilter depth-to-point-cound libnvds_3d_depth2point_datafilter.so createDepth2PointFilter Convert Image Depth data into 3D Point Cloud data, see details in Custom datafilter libnvds_3d_depth2point_datafilter Configuration Specifications databridge bridge 2D into DS3D libnvds_3d_video_databridge.so createVideoBridge2d3d Convert DeepStream 2D batchmeta and surface into ds3d::datamap , see details in Configuration file datamixer mixer for video and lidar/radar libnvds_3d_multisensor_mixer.so createMultiSensorMixer Combines video data (2D) and LiDAR data (3D) into a single ds3d::datamap , see details in Configuration file datarender 3D multiview scene render libnvds_3d_gles_ensemble_render.so NvDs3D_CreateGlesEnsembleRender Renders a 3D multi-view scene using GLES with with various elements (textures, LiDAR points, bounding boxes) inside ds3d::datamap , see details in Custom datarender libnvds_3d_gles_ensemble_render Configuration Specifications datarender 3D point-cloud data render with texture libnvds_3d_gl_datarender.so createPointCloudDataRender Renders 3D(Scene construction) PointCould(XYZ) data with RGBA color textures inside ds3d::datamap , see details in Custom datarender libnvds_3d_gl_datarender Configuration Specifications datarender 3D lidar(XYZI/XYZ) data render libnvds_3d_gl_datarender.so createLidarDataRender Renders 3D Lidar(XYZI/XYZ) data inside ds3d::datamap , see details in Custom datarender libnvds_3d_gl_datarender Configuration Specifications datarender depth image 2D render libnvds_3d_gl_datarender.so createDepthStreamDataRender Renders 2D depth and Camera RGBA data inside ds3d::datamap , see details in Custom datarender libnvds_3d_gl_datarender Configuration Specifications", "keywords": []}, {"id": 2226, "doc_id": 2226, "filename": "text/DS_3D_Custom_Manual.html", "domain_name": "std", "name": "text/DS_3D_Custom_Manual", "display_name": "DeepStream-3D Custom Apps and Libs Tutorials", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_Custom_Manual", "anchor": "", "priority": -1, "content": "ds3d framework, interfaces and custom-libs are designed for DeepStream-3D processing. ds3d is agnostic from Gstreamer/Glib frameworks. These interfaces are capble of different types of data fusion. Developers can implement different types of custom libraries for dataloader , datafilter and datarender . The interface has ABI compatible layers and modern C++ interface. Developers only need to focus on the modern C++ interface for application or custom lib development. DS3D dataloader is loaded by GstAppSrc , enabling its utilization for depth cameras like stereo cameras and Time-of-Flight cameras to capture image/depth data or load data from the file system. Additionally, it can be employed for capturing lidar data from sensors or lidar data files. datafilter is loaded by the nvds3dfilter  Gst-plugin . It could be used for 2D depth data processing , 3D point-cloud data extraction from depth, other 2D-depth or 3D-points data filters and lidar or 3D data inference. datarender is loaded by GstAppSink . It could be used for 2D depth rendering and 3D point-cloud and lidar data rendering. It also could be used for file dump.", "keywords": []}, {"id": 2227, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#build-application-from-source", "display_name": "Build application From Source", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "build-application-from-source", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-3d-depth-camera . Run the following commands: $ Set CUDA_VER in the MakeFile as per platform. For both Jetson &amp; x86, CUDA_VER=12.2 $ make $ make install Check the source code for more details on how to load dataloader/datarender through Gst-appsrc and Gst-appsink . datafilter is loaded by the nvds3dfilter  Gst-plugin .", "keywords": []}, {"id": 2228, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#deepstream-3d-depth-camera-ds3d-userapp-group-settings", "display_name": "deepstream-3d-depth-camera [ds3d::userapp] group settings", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "deepstream-3d-depth-camera-ds3d-userapp-group-settings", "priority": -1, "content": "The table below demonstrates the group settings for ds_3d_realsense_depth_to_point_cloud.yaml as an example. Property Meaning Type and Range Example type Specify type ds3d::userapp Component type for user debug Must be type: ds3d::userapp name Indicate user-defined component name String name: debugdump enable_debug Indicate whether enable debug log Boolean enable_debug: False dump_depth Indicate file location to dump depth raw data String dump_depth: depth_uint16_640x480.bin dump_color Indicate file location to dump color raw data String dump_color: color_rgba_1920x1080.bin dump_points Indicate file location to dump 3D points raw data. datatype is Float and XYZ packed String dump_points: pointxyz.bin", "keywords": []}, {"id": 2229, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#depth-color-capture-to-2d-rendering-pipeline-overview", "display_name": "Depth Color Capture to 2D Rendering Pipeline Overview", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "depth-color-capture-to-2d-rendering-pipeline-overview", "priority": -1, "content": "This is the first pipeline from the depth capture to 2D based depthmap to direct rendering with linear colors configured by the user. The pipeline is setup by ds_3d_realsense_depth_capture_render.yaml . It has 2 components, ds3d::dataloader for depth/color and datarender for GLES 2D render. ds3d::dataloader loads custom lib libnvds_3d_dataloader_realsense.so and creates a RealSense dataloader through the createRealsenseDataloader function. This specific loader is configured for output streams of [color, depth] . Gst-appsrc connects the dataloader into the deepstream pipeline. name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader ds3d::datarender loads custom lib libnvds_3d_gl_datarender.so and create a GLES render through the createDepthStreamDataRender function. This specific loader is configured for 2D depth and color images. Gst-appsink connects the datarender into the deepstream pipeline. name: depth-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createDepthStreamDataRender realsense_dataloader captures color and depth streams in ds3d/datamap , then delivers the data to ds3d::datarender component depth-render .", "keywords": []}, {"id": 2230, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#depth-color-capture-to-3d-point-cloud-processing-and-rendering", "display_name": "Depth Color Capture to 3D Point Cloud Processing and Rendering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "depth-color-capture-to-3d-point-cloud-processing-and-rendering", "priority": -1, "content": "The 2nd pipeline is from depth capture, 3D point cloud processing and alignment, to the 3D point cloud rendering with colors. The 2nd pipeline is setup by the ds_3d_realsense_depth_to_point_cloud.yaml . It has 3 components: ds3d::dataloader for depth/color capture, ds3d::datafilter for depth-to-point-cloud processing, and datarender for GLES 3D points render. ds3d::dataloader is the same as the 1st pipeline for depth and color capture. It also outputs the intrinsic parameters of the color/depth sensors, and extrinsic parameters from depth to color sensor module. name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader ds3d::datafilter loads custom lib libnvds_3d_depth2point_datafilter.so and creates a depth-to-3D-point processing filter through the createDepth2PointFilter function. This specific filter generates the 3D point-cloud dataset from depth, and calculates a UV-coordinate map for correspondence between points and color position. It requires sensors\u2019 intrinsic and extrinsic data from dataloader to make the alignment. name: point2cloud_datafilter type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_3d_depth2point_datafilter.so custom_create_function: createDepth2PointFilter ds3d::datafilter is loaded by the nvds3dfilter  Gst-plugin which accepts in_caps as sink_caps and out_caps as src_caps . It creates a custom ds3d::datafilter instance and processess data as ds3d/datamap . ds3d::datarender loads custom lib libnvds_3d_gl_datarender.so and create a GLES render through the createPointCloudDataRender function . This specific loader is configured for 3D points and colors rendering. It also supports 3D scene rotation based on mouse-drag. name: point-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createPointCloudDataRender realsense_dataloader captures color and depth streams along with the intrinsic and extrinsic parameters of the sensor in ds3d/datamap . It then delivers the data to the next component point2cloud_datafilter . This component generates 3D point-cloud data and UV coordination map into new output data ds3d/datamap . Finally, the data is delivered to ds3d::datarender component point-render for 3D rendering. Inside the configuration files, in_caps and out_caps correspond to Gstreamer\u2019s sink_caps and src_caps .", "keywords": []}, {"id": 2231, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#ds3d-custom-components-configuration-specifications", "display_name": "DS3D Custom Components Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "ds3d-custom-components-configuration-specifications", "priority": -1, "content": "See more details in the DS_3D supported custom components specifications section in the DeepStream-3D Custom Apps and Libs Tutorials .", "keywords": []}, {"id": 2232, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "prerequisites", "priority": -1, "content": "You must have the following development packages installed: GStreamer-1.0 GStreamer-1.0 Base Plugins GStreamer-1.0 gstrtspserver X11 client-side library libyaml-cpp-dev RealSense SDK To install these packages, execute the following command: sudo apt-get install libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev \\ libgstrtspserver-1.0-dev libx11-dev libyaml-cpp-dev Follow the RealSense SDK documentation to add RealSense public key and list of repositories. For x86, refer to IntelRealSense/librealsense . For Jetson platforms, refer to IntelRealSense/librealsense . You may use Ubuntu 20.04 source path into apt-repository to install dependencies. sudo add-apt-repository &quot;deb https://librealsense.intel.com/Debian/apt-repo bionic main&quot; -u Then install librealsense2 package to build and test. sudo apt-get install librealsense2-utils librealsense2-dev Make sure RealSense SDK version is not earlier than 2.48. Plugin in Intel RealSense Depth D400 series USB camera. To verify the camera and upgrade firmware, run realsense-viewer and update from the UI. Navigate to the folder sources/apps/sample_apps/deepstream-3d-depth-camera . If you are running these commands inside deepstream container, make sure camera devices are mounted in the docker run command. For example: docker run --rm -it --gpus &#x27;&quot;device=0&quot;&#x27; --device /dev/video0 --device /dev/video1 --device /dev/video2 ... Export DISPLAY environment to the correct display. for example, export DISPLAY=:0.0 .", "keywords": []}, {"id": 2233, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#run-3d-depth-capture-point-cloud-filter-and-3d-points-rendering-examples", "display_name": "Run 3D Depth Capture, Point Cloud filter, and 3D Points Rendering Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "run-3d-depth-capture-point-cloud-filter-and-3d-points-rendering-examples", "priority": -1, "content": "Run the depth capture and 3D processing pipeline: $ deepstream-3d-depth-camera -c ds_3d_realsense_depth_to_point_cloud.yaml This sets up a realsense dataloader (same as 2D depth). It then streams ds3d/datamap to the downstream datafilter component point2cloud_datafilter . name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader It streams ds3d/datamap to the nvds3dfilter  Gst-plugin which loads point2cloud_datafilter to convert 2D depth into 3D points. For more details on nvds3dfilter  Gst-plugin , See Gst-nvds3dfilter . name: point2cloud_datafilter type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_3d_depth2point_datafilter.so custom_create_function: createDepth2PointFilter Finally the data stream as ds3d/datamap is delivered to the render component point-render . name: point-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createPointCloudDataRender Fields of view_* are the eyes of the view position, similar to the OpenGL  gluLookAt() . view_position: [0, 0, -1] # view position in xyz coordinates view_target: [0, 0, 1] # view target which is the direction pointing to view_up: [0, -1.0, 0] # view up direction Fields of near/far/fov are the perspective range of the eye, similar to the OpenGL  gluPerspective() . near: 0.01 # nearest points of perspective far: 10.0 # farmost points of perspective fov: 40.0 # FOV of perspective", "keywords": []}, {"id": 2234, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "page", "name": "text/DS_3D_Depth_Camera#run-realsense-camera-for-depth-capture-and-2d-rendering-examples", "display_name": "Run RealSense Camera for Depth Capture and 2D Rendering Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Depth_Camera", "anchor": "run-realsense-camera-for-depth-capture-and-2d-rendering-examples", "priority": -1, "content": "Run the depth capture 2D render pipeline: $ deepstream-3d-depth-camera -c ds_3d_realsense_depth_capture_render.yaml This sets up a realsense  dataloader . name: realsense_dataloader type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_3d_dataloader_realsense.so custom_create_function: createRealsenseDataloader It then streams ds3d/datamap to final the rendering component: depth-render . name: depth-render type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createDepthStreamDataRender The depth-render custom lib shall display the depth data and color data together in same window. Update min_depth/max_depth to remove foreground and background objects in the depth rendering. From RealSense specification, D435 Camera depth range is between 0.3 and 3 meters. min_depth: 0.3 # in meters max_depth: 2.0 # in meters Update min_depth_color/min_depth_color [R, G, B] values to visualize color map of depth. min_depth_color: [255, 128, 0] # RGB color value for mininum depth max_depth_color: [0, 128, 255] # RGB color value for maximum depth The other colors are linearly interpolated between ``min_depth_color`` and ``max_depth_color``", "keywords": []}, {"id": 2235, "doc_id": 2235, "filename": "text/DS_3D_Depth_Camera.html", "domain_name": "std", "name": "text/DS_3D_Depth_Camera", "display_name": "DeepStream 3D Depth Camera App", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_Depth_Camera", "anchor": "", "priority": -1, "content": "The deepstream-3d-depth-camera sample application is provided at app/sample_apps/deepstream-3d-depth-camera for your reference. This example demonstrates two different pipelines which bring depth camera from 2D into 3D world. The depth and color data capture component is produced by Intel \u00ae  RealSense \u2122 Depth Camera D435 series. For more details, see https://www.intelrealsense.com/depth-camera-d435/ .", "keywords": []}, {"id": 2236, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#build-application-from-source", "display_name": "Build application From Source", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "build-application-from-source", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-lidar-inference-app . Run the following commands: $ sudo make $ sudo make install Check the source code for more details on how to load dataloader/datarender through Gst-appsrc and Gst-appsink . datafilter is loaded by the nvds3dfilter  Gst-plugin .", "keywords": []}, {"id": 2237, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#deepstream-lidar-inference-app-ds3d-userapp-group-settings", "display_name": "deepstream-lidar-inference-app [ds3d::userapp] group settings", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "deepstream-lidar-inference-app-ds3d-userapp-group-settings", "priority": -1, "content": "The table below demonstrates the group settings for config_lidar_triton_infer.yaml and config_lidar_source_triton_render.yaml as the examples. Group Property Meaning Type and Range Example LidarFileLoader data_config_file lidar data list file path string data_config_file: lidar_data_list.yaml LidarFileLoader points_num number of the points in pointcloud file fixed value points_num: 204800 LidarFileLoader lidar_datatype data type of the dataset String:FP32 FP16 INT8 INT32 lidar_datatype: FP32 LidarFileLoader mem_type memory type of process data:just support cpu now String:gpu cpu mem_type: cpu LidarFileLoader mem_pool_size Size of the data read pool Integer: &gt;0 mem_pool_size: 4 LidarFileLoader output_datamap_key datamap key in lidarsource string output_datamap_key: DS3D::LidarXYZI LidarFileLoader file_loop flag for file reading loop boolean file_loop: False LidarInferenceFilter in_streams which data type will be processed fixed value in_streams: [lidar] LidarInferenceFilter mem_pool_size Size of the input tensor pool Integer mem_pool_size: 8 LidarInferenceFilter model_inputs model \u2018s input layers Array refer to config_lidar_triton_infer.yaml LidarInferenceFilter model_outputs model \u2018s output layers Array refer to config_lidar_triton_infer.yaml LidarInferenceFilter input_tensor_mem_type input tensor memory type after preprocess String:GpuCuda CpuCuda input_tensor_mem_type: GpuCuda LidarInferenceFilter custom_preprocess_lib_path preprocessing library path String custom_preprocess_lib_path: /opt/nvidia/deepstream/deepstream/lib/libnvds_lidar_custom_preprocess_impl.so LidarInferenceFilter custom_preprocess_func_name customized preprocessing function name String custom_preprocess_func_name: CreateInferServerCustomPreprocess LidarInferenceFilter labels label list for the detection model Array refer to config_lidar_triton_infer.yaml LidarInferenceFilter postprocess_nms_iou_thresh NMS IOU threshold Float postprocess_nms_iou_thresh: 0.01 LidarInferenceFilter postprocess_pre_nms_top_n number of TOPs of NMS Integer postprocess_nms_top_n: 4096 LidarInferenceFilter config_file nvinferserver configuration file String config_file: triton_mode_CAPI.txt LidarInferenceFilter gpu_id GPU id for the tensor memory(for native Triton Server Inferencing) Integer gpu_id: 0 LidarInferenceFilter filter_input_datamap_key input datamap key from lidarsource String filter_input_datamap_key: DS3D::LidarXYZI LidarFileDataRender frames_save_path the path of the dump file String frames_save_path: ../data/ LidarFileDataRender input_datamap_key input key from the custom_postprocess for inferencing objects String input_datamap_key: DS3D::Lidar3DBboxRawData LidarDataRender title the title of the render String title: ds3d-lidar-render LidarDataRender streams the stream key(s) for the input to be rendered List streams: [lidardata] LidarDataRender width render area width Integer width: 1280 LidarDataRender height render area height Integer height: 720 LidarDataRender block the flag of enabling block function Boolean block: True LidarDataRender view_position the view position for lookat vector List view_position: [0, 0, 80] LidarDataRender view_target the view target for lookat vector List view_target: [0, 0, 0] LidarDataRender view_up the up vector of the visualizer List view_up: [1, 0, 0] LidarDataRender near the near z-plane of the visualizer constance Float near: 0.3 LidarDataRender far the far z-plane of the visualizer constance Float far: 100 LidarDataRender fov degree for field of view Integer fov: 45 LidarDataRender lidar_color the RGB color description of the lidar data List,lidar_color: [0, 255, 0] LidarDataRender lidar_data_key the lidar data key name in datamap String lidar_data_key: DS3D::LidarXYZI LidarDataRender element_size the lidar data element size (4, XYZI or 3, XYZ) Integer element_size: 4 LidarDataRender lidar_bbox_key the 3D bbox data key name in datamap String DS3D::Lidar3DBboxRawData LidarDataRender enable_label Indicate flag to enable labels rendering Boolean enable_label: True", "keywords": []}, {"id": 2238, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#ds3d-custom-components-configuration-specifications", "display_name": "DS3D Custom Components Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "ds3d-custom-components-configuration-specifications", "priority": -1, "content": "See more details in the DS_3D supported custom components specifications section in the DeepStream-3D Custom Apps and Libs Tutorials .", "keywords": []}, {"id": 2239, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#lidar-point-cloud-to-3d-point-cloud-processing-and-rendering", "display_name": "Lidar Point Cloud to 3D Point Cloud Processing and Rendering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "lidar-point-cloud-to-3d-point-cloud-processing-and-rendering", "priority": -1, "content": "The application can be configured as different pipelines according to the application configuration file. Lidar data inference and 3D bounding box dump pipeline: This pipeline is from lidar point cloud, 3D point cloud inferencing, to the 3D objects data dump. This pipeline is setup by the config_lidar_triton_infer.yaml . It has 3 components: ds3d::dataloader for lidar pointcloud data file reading, ds3d::datafilter for point-cloud Triton inferencing, and ds3d::datarender for 3D Bounding Box file dump. ds3d::dataloader loads custom lib libnvds_lidarfileread.so and creates a dataloader through the createLidarFileLoader function. This specific loader is configured by lidar dataset file list data_config_file . Gst-appsrc connects the dataloader into the deepstream pipeline. name: lidarsource type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_lidarfileread.so custom_create_function: createLidarFileLoader ds3d::datafilter loads custom lib libnvds_tritoninferfilter.so and creates a lidar point cloud Triton inferencing filter through the createLidarInferenceFilter function. For this specific configuration, The Lidar Triton filter inferences the point cloud data with TAO model PointPillarNet model and return the 3D bounding boxes around each object. name: lidarfilter type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter ds3d::datafilter is loaded by the nvds3dfilter  Gst-plugin which accepts in_caps as sink_caps and out_caps as src_caps . It creates a custom ds3d::datafilter instance and processess data as ds3d/datamap . ds3d::datarender loads custom lib libnvds_lidarfilewrite.so to dump the detected 3D bounding boxes to a file. name: lidarrender type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_lidarfilewrite.so custom_create_function: createLidarFileDataRender Lidar data inference and Lidar data rendering with 3D bounding box display pipeline: This pipeline is from lidar point cloud data file, 3D point cloud inferencing, to the 3D point cloud rendering with colors. This pipeline is setup by the config_lidar_source_triton_render.yaml . It has 3 components: ds3d::dataloader for lidar pointcloud data file reading, ds3d::datafilter for point-cloud Triton inferencing, and ds3d::datarender for Lidar 3D data LidarXYZI and 3D Bounding Box rendering. ds3d::dataloader loads custom lib libnvds_lidarfileread.so and creates a dataloader through the createLidarFileLoader function. This specific loader is configured by lidar dataset file list data_config_file . Gst-appsrc connects the dataloader into the deepstream pipeline. name: lidarsource type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_lidarfileread.so custom_create_function: createLidarFileLoader ds3d::datafilter loads custom lib libnvds_tritoninferfilter.so and creates a lidar point cloud Triton inferencing filter through the createLidarInferenceFilter function. For this specific configuration, The Lidar Triton filter inferences the point cloud data with TAO model PointPillarNet model and return the 3D bounding boxes around each object. name: lidarfilter type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter ds3d::datafilter is loaded by the nvds3dfilter  Gst-plugin which accepts in_caps as sink_caps and out_caps as src_caps . It creates a custom ds3d::datafilter instance and processess data as ds3d/datamap . ds3d::datarender loads custom lib libnvds_3d_gl_datarender.so and creates GLES Lidar point cloud rendering context to display XYZI or XYZ lidar data and 3D bounding boxes with custom_create_function: createLidarDataRender . name: lidarrender type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createLidarDataRender", "keywords": []}, {"id": 2240, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "prerequisites", "priority": -1, "content": "You must have the following development packages installed: GStreamer-1.0 GStreamer-1.0 Base Plugins X11 client-side library libyaml-cpp-dev To install these packages, execute the following command: sudo apt-get install libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev \\ libgstrtspserver-1.0-dev libx11-dev libyaml-cpp-dev", "keywords": []}, {"id": 2241, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "page", "name": "text/DS_3D_Lidar_Inference#run-lidar-point-cloud-data-file-reader-point-cloud-inferencing-filter-and-point-cloud-3d-rendering-and-data-dump-examples", "display_name": "Run Lidar Point Cloud Data File reader, Point Cloud Inferencing filter, and Point Cloud 3D rendering and data dump Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_Lidar_Inference", "anchor": "run-lidar-point-cloud-data-file-reader-point-cloud-inferencing-filter-and-point-cloud-3d-rendering-and-data-dump-examples", "priority": -1, "content": "Prepare PointPillarNet model and Triton environment, this app will use Triton to do inference, for more details of Triton Inferencing Server, refer to https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvinferserver.html . Follow instructions in deepstream-lidar-inference-app/README to prepare testing resources and Triton CAPI and gRPC environments. Run the lidar point cloud data inference pipeline in 2 modes. Run lidar data reader, point cloud 3D objects detection inference and 3D data GLES rendering pipeline: $ deepstream-lidar-inference-app -c configs/config_lidar_source_triton_render.yaml Run lidar data reader, point cloud 3D objects inference and 3D objects file dump pipeline: $ deepstream-lidar-inference-app -c configs/config_lidar_triton_infer.yaml This part sets up a lidar point cloud loader dataloader . It then streams ds3d/datamap to the downstream datafilter component lidarfilter . name: lidarsource type: ds3d::dataloader out_caps: ds3d/datamap custom_lib_path: libnvds_lidarfileread.so custom_create_function: createLidarFileLoader It streams ds3d/datamap to the nvds3dfilter  Gst-plugin which loads lidarfilter to do Triton inferencing on point cloud. For more details on nvds3dfilter  Gst-plugin , See Gst-nvds3dfilter . name: lidarfilter type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter Field of model_inputs is the description of the model input layers. Includes layer name, layer data type and layer dimensions. model_inputs: - name: points # name of the 1st layer datatype: FP32 # data type of the 1st layer shape: [1, 204800, 4] # data dimension of the 1st layer - name: num_points # name of the 2nd layer datatype: INT32 # data type of the 2nd layer shape: [1] # data dimension of the 2nd layer Field of model_outputs is the description of the model output layers. Includes layer name, layer data type and layer dimensions. model_outputs: - name: output_boxes # name of the 1st layer datatype: FP32 # data type of the 1st layer shape: [1, 393216, 9] # data dimension of the 1st layer - name: num_boxes # name of the 2nd layer datatype: INT32 # data type of the 2nd layer shape: [1] # data dimension of the 2nd layer Field of labels is the label list of the point cloud inferencing model. labels: # YAML list for object labels - Vehicle - Pedestrian - Cyclist Finally the data stream as ds3d/datamap is delivered to the render component. 3D detection file dump component lidarfiledump . name: lidarfiledump type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_lidarfilewrite.so custom_create_function: createLidarFileDataRender GLES lidar data rendering component lidardatarender . name: lidardatarender type: ds3d::datarender in_caps: ds3d/datamap custom_lib_path: libnvds_3d_gl_datarender.so custom_create_function: createLidarDataRender Check the /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-lidar-inference-app/README file for more details.", "keywords": []}, {"id": 2242, "doc_id": 2242, "filename": "text/DS_3D_Lidar_Inference.html", "domain_name": "std", "name": "text/DS_3D_Lidar_Inference", "display_name": "DeepStream 3D Lidar Inference App", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_Lidar_Inference", "anchor": "", "priority": -1, "content": "The deepstream-lidar-inference-app sample application is provided at app/sample_apps/deepstream-lidar-inference-app/ for your reference. The deepstream_lidar_inference_app provides an end-to-end inference sample for lidar pointcloud data. The sample application reads the point cloud data from dataset files and send the data to Triton Inferencing filter with PointPillarNet model , the inferencing result is the group of 3D bounding boxes of the objects. The sample application loads different pipelines based on different application config files. There are 2 pipelines configured in the sample app. Lidar Triton inference for 3D objects detection and file dump. Lidar Triton inference and 3D objects detection and GLES 3D rendering. Inside these sample configurations, the inference model is a 3D TAO model based on PointPillar. For more details about PointPillar, see https://arxiv.org/abs/1812.05784 . TensorRT 8.5 has a bug for FP16 mode when converting this specific TAO model to TensorRT engine file. DeepStream fallback to FP32 mode for this release. This is a snapshot for deepstream-lidar-inference-app running with lidar data inference objects detection and GLES 3D rendering with 3D bounding box display on screen.", "keywords": []}, {"id": 2243, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#build-from-source", "display_name": "Build from source:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "build-from-source", "priority": -1, "content": "To compile the sample app deepstream-3d-lidar-sensor-fusion inside of container: $ make $ sudo make install (sudo not required in the case of docker containers) Build custom components from source, check DeepStream 3D Multi-Modal Lidar and Camera Sensor Fusion App To compile the sources, run make with sudo -E or root permission.", "keywords": []}, {"id": 2244, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#build-the-docker-target-image-for-deepstream-triton-bevfusion-x86", "display_name": "Build the Docker Target Image for deepstream-triton-bevfusion [x86]", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "build-the-docker-target-image-for-deepstream-triton-bevfusion-x86", "priority": -1, "content": "Build the docker target image named deepstream-triton-bevfusion:{DS_VERSION_NUM} . Ensure that the DeepStream version number, represented by {DS_VERSION_NUM}, is greater than or equal to 7.0. Run the following script to build the target image on top of the DeepStream Triton base image: # The following commands are require to enable Docker-in-Docker functionality if anyone want to run # DeepStream docker inside another docker. # Please start the container using a command like the following, adding your own parameters as needed: # docker run --gpus all -it --rm --net=host --privileged \\ # -v /usr/bin/docker:/usr/bin/docker \\ # -v /usr/libexec/docker:/usr/libexec/docker \\ # -v /var/run/docker.sock:/var/run/docker.sock \\ # -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch $ bevfusion/docker_build_bevfusion_image.sh nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch Replace {xx.xx.xx} with a version number greater than or equal to 7.0. The latest base image can be found at: https://catalog.ngc.nvidia.com/orgs/nvidia/containers/deepstream", "keywords": []}, {"id": 2245, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#calibration-data-generation-for-ds3d-sensor-fusion", "display_name": "Calibration Data Generation for DS3D Sensor Fusion", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "calibration-data-generation-for-ds3d-sensor-fusion", "priority": -1, "content": "The --print_calibration argument in the previous command outputs the following calibration data, Camera intrinsic matrix(4x4). Camera-to-LiDAR extrinsic matrix(4x4). LiDAR-to-Camera extrinsic matrix(4x4). LiDAR-to-Image matrix(4x4)", "keywords": []}, {"id": 2246, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#citation", "display_name": "Citation", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "citation", "priority": -1, "content": "BEVFusion model is originally from github bevfusion . @inproceedings{liu2022bevfusion, title={BEVFusion: Multi-Task Multi-Sensor Fusion with Unified Bird&#x27;s-Eye View Representation}, author={Liu, Zhijian and Tang, Haotian and Amini, Alexander and Yang, Xingyu and Mao, Huizi and Rus, Daniela and Han, Song}, booktitle={IEEE International Conference on Robotics and Automation (ICRA)}, year={2023} } nuscene dataset is from nuscene.org . @article{nuscenes2019, title={nuScenes: A multimodal dataset for autonomous driving}, author={Holger Caesar and Varun Bankiti and Alex H. Lang and Sourabh Vora and Venice Erin Liong and Qiang Xu and Anush Krishnan and Yu Pan and Giancarlo Baldan and Oscar Beijbom}, journal={arXiv preprint arXiv:1903.11027}, year={2019} } @article{fong2021panoptic, title={Panoptic nuScenes: A Large-Scale Benchmark for LiDAR Panoptic Segmentation and Tracking}, author={Fong, Whye Kit and Mohan, Rohit and Hurtado, Juana Valeria and Zhou, Lubing and Caesar, Holger and Beijbom, Oscar and Valada, Abhinav}, journal={arXiv preprint arXiv:2109.03805}, year={2021} }", "keywords": []}, {"id": 2247, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#dataset-generation-for-ds3d-bevfusion", "display_name": "Dataset Generation for DS3D BEVFusion", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "dataset-generation-for-ds3d-bevfusion", "priority": -1, "content": "Users can modify the script triton_lmm/helper/nuscene_data_setup.py to generate data for the DS3D sensor fusion use case from different NuScenes scenes.", "keywords": []}, {"id": 2248, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#download-cuda-bevfusion-models-and-build-tensorrt-engine-files-x86", "display_name": "Download CUDA-BEVFusion Models and Build TensorRT Engine Files [x86]", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "download-cuda-bevfusion-models-and-build-tensorrt-engine-files-x86", "priority": -1, "content": "Download the model chunks from CUDA-BEVFusion and use trtexec to convert some ONNX model chunks into TensorRT engine files with INT8 precision. The user needs to specify a host directory to store the models. The script will mount this directory to the target container to prepare the model files. First, please visit NVIDIA-AI-IOT/Lidar_AI_Solution for the latest instructions on how to download the models directly. Then move the model.zip you download to the bevfusion/model_root directory before building the models. To move your downloaded model to the default file location: $ mkdir bevfusion/model_root $ sudo cp {PATH TO YOUR model.zip DOWNLOAD} /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/bevfusion/model_root/model.zip Then run the following script based on the target Docker image: $ bevfusion/docker_run_generate_trt_engine_models.sh bevfusion/model_root All models can be found in the host directory bevfusion/model_root .", "keywords": []}, {"id": 2249, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#download-test-data-and-start-ds3d-bevfusion-pipeline", "display_name": "Download Test Data and Start DS3D BEVFusion Pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "download-test-data-and-start-ds3d-bevfusion-pipeline", "priority": -1, "content": "Download the NuScenes subset dataset into the host directory data/nuscene and mount the dataset into the target container to start the BEVFusion pipeline. The script will automatically check and download the dataset. The nuscene dataset for DS3D bevfusion is hosted at GitHub Deepstream Reference Apps bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh script will check and download the dataset into host directory \u2018data/nuscene\u2019 automatically. If you want to download and un-compress the dataset manually, run the scripts: $ export NUSCENE_DATASET_URL=&quot;https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/raw/DS_7.1/deepstream-3d-sensor-fusion/data/nuscene.tar.gz&quot; $ mkdir -p data &amp;&amp; curl -o data/nuscene.tar.gz -L ${NUSCENE_DATASET_URL} $ tar -pxvf data/nuscene.tar.gz -C data/ The nuscene dataset is under a Non-Commercial Use license. Refer to the terms of use at: &lt; https://www.nuscenes.org/terms-of-use &gt; There are 2 BEVFusion config files with same pipeline but with differnt 3D rendering options. - ds3d_lidar_plus_multi_cam_bev_fusion.yaml renders each camera and LiDAR data into a multi-view windows, meanwhile projects LiDAR data and detected 3D bounding-box into each camera\u2019s view to demonstrate LiDAR data alignment. - ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml each camera and LiDAR data into a multi-view windows, meanwhile projects detected 3D bounding-box and labels into each camera\u2019s view. Replace the 2 config files with each other in the following tests to see the difference.", "keywords": []}, {"id": 2250, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#for-jetson-devices", "display_name": "For Jetson Devices:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "for-jetson-devices", "priority": -1, "content": "Follow steps in Start Tritonserver for BEVFusion Model [x86] on an remote x86 machine to set up the BEVFusion Triton inference server. Follow steps in For Tritonserver on Remote machine: , update local config file model_config_files/config_triton_bev_fusion_infer_grpc.pbtxt and mount option as described. Then, run the script on the prebuilt deepstream-triton image: $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion.yaml nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch CTRL + C to terminate.", "keywords": []}, {"id": 2251, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#for-tritonserver-on-remote-machine", "display_name": "For Tritonserver on Remote machine:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "for-tritonserver-on-remote-machine", "priority": -1, "content": "If tritonserver is running on a remote machine/container distinct from the ds3d pipeline, be sure to update the local gRPC config file at model_config_files/config_triton_bev_fusion_infer_grpc.pbtxt to use the IP address of the remote machine running tritonserver instead of localhost: Update config file on local client machine. grpc { url: &quot;[tritonserver_ip_address]:8001&quot; enable_cuda_buffer_sharing: false } Uncomment the following line in bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh to use your local configs: MOUNT_OPTIONS+=&quot; -v ./:${TARGET_WORKSPACE}&quot; Run the script on local machine: $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion.yaml Or $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion.yaml nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch Users can replace yaml config file to ``ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml`` for tests as well.", "keywords": []}, {"id": 2252, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#for-x86", "display_name": "For x86:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "for-x86", "priority": -1, "content": "The script will first check and download the dataset if they are not in data/nuscene . $ export NUSCENE_DATASET_URL=&quot;https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/raw/DS_7.1/deepstream-3d-sensor-fusion/data/nuscene.tar.gz&quot; Run the script to download the dataset and start the pipeline demo: $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh \\ ds3d_lidar_plus_multi_cam_bev_fusion.yaml Or $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh \\ ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml CTRL + C to terminate.", "keywords": []}, {"id": 2253, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#generate-dataset-from-nuscene-samples", "display_name": "Generate dataset from nuscene samples", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "generate-dataset-from-nuscene-samples", "priority": -1, "content": "To reproduce the sample data and obtain the calibration matrix, follow these commands: $ export TARGET_WORKSPACE=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ cd ${TARGET_WORKSPACE} $ mkdir -p dataset/nuscene data $ docker run --rm --net=host \\ -v ./dataset/nuscene:${TARGET_WORKSPACE}/dataset/nuscene \\ -v ./data:${TARGET_WORKSPACE}/data \\ -w ${TARGET_WORKSPACE} --sig-proxy --entrypoint python3 deepstream-triton-bevfusion:xxx \\ python/triton_lmm/helper/nuscene_data_setup.py --data_dir=dataset/nuscene \\ --ds3d_fusion_workspace=${TARGET_WORKSPACE} --print_calibration Replace deepstream-triton-bevfusion:xxx with the latest DeepStream version number (e.g., 7.0) Explanation: The first two lines set the environment variable TARGET_WORKSPACE to the location of the deepstream-3d-lidar-sensor-fusion sample code and then change the directory to that location. The third line creates directories named dataset/nuscene and data inside the target workspace. The docker run command executes the nuscene_data_setup.py script within a Docker container. Options --rm : Removes the container after it finishes. --net=host : Allows the container to use the host network. -v : Mounts volumes to share data between the host and container. -w ${TARGET_WORKSPACE} : Sets the working directory inside the container. --sig-proxy : Enables handling of signals inside the container. --entrypoint python3 : Sets the entrypoint for the container to run python3 . The command mounts the dataset/nuscene and data directories from the host system into the container and then executes nuscene_data_setup.py with the following arguments. --data_dir=dataset/nuscene : Specifies the directory containing the NuScenes dataset. --ds3d_fusion_workspace=${TARGET_WORKSPACE} : Sets the target workspace for the DS3D sensor fusion data. --print_calibration : Instructs the script to print the calibration data. Replace deepstream-triton-bevfusion:xxx with the latest DeepStream version number (e.g., 7.0). The script downloads the original NuScenes data into the dataset/nuscene directory and then converts it into the format required by DS3D sensor fusion, storing the converted data in the ${TARGET_WORKSPACE}/data/nuscene directory.", "keywords": []}, {"id": 2254, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#getting-started", "display_name": "Getting Started", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "getting-started", "priority": -1, "content": "To get started, navigate to the following directory: # run the following commandline outside of the container. $ export DISPLAY=0.0 # set the correct display number if DISPLAY is not exported $ xhost + $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ sudo chmod -R a+rw . # Grant read/write permission for all of the files in this folder All the following commandline for BEVFusion setup are run outside of the container unless other comments specified", "keywords": []}, {"id": 2255, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#how-to-use-other-nuscenes-scene-samples", "display_name": "How to use other nuScenes scene samples:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "how-to-use-other-nuscenes-scene-samples", "priority": -1, "content": "You can seamlessly integrate a different nuScenes scene dataset into the deepstream-3d-sensor-fusion pipeline, ensuring accurate calibration for your specific use case. If you wish to employ an alternative scene samples in nuScenes dataset for setting up a demonstration, follow these steps: Update the nuscene_data_setup.py script to a different scene number and generate the required sample data formats for ds3d-sensor-fusion. Run the same commandline inside the container. $ export TARGET_WORKSPACE=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ cd ${TARGET_WORKSPACE} $ python3 python/triton_lmm/helper/nuscene_data_setup.py --data_dir=dataset/nuscene \\ --ds3d_fusion_workspace=${TARGET_WORKSPACE} --print_calibration Update the new calibration data into DS3D sensor fusion pipeline configuration files Update intrinsic and extrinsic calibration matrix in ds3d::datafilter  lidar_alignment_filter from config file ds3d_lidar_plus_multi_cam_bev_fusion.yaml . each cam_intrinsic and lidar_to_cam_extrisic requires matrix shape: 3x4 with row_major: True , User need copy the first 3x4 matrix from the previous cmdline log output. Update the new calibration data into triton-lmm before startup tritonserver. Update python/triton_lmm/server/pytriton_server.py for all required matrix. Restart tritonserver see instructions in Start Tritonserver for BEVFusion Model [x86] Restart ds3d sensorfusion pipeline see instructions in Download Test Data and Start DS3D BEVFusion Pipeline", "keywords": []}, {"id": 2256, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#iot-messaging", "display_name": "IoT Messaging:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "iot-messaging", "priority": -1, "content": "Follow Kafka Quick Start to setup Kafka server and create topic quick-test for messaging tests. $ docker run -p 9092:9092 apache/kafka:3.7.0 # start kafka server with port 9092 $ bin/kafka-topics.sh --create --topic quick-test --bootstrap-server localhost:9092 # creat topic &#x27;quick-test&#x27; After kafka installed, uers can follow instructions below to check the resutls. $ bin/kafka-console-consumer.sh --topic quick-test --bootstrap-server localhost:9092 # see fusion ds3d messaging results. Start DS3D BEVFusion inference and kafka messaging pipeline inside of deepstream triton container: # run the following commandline inside of the container. $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_plus_multi_cam_bev_fusion_iot.yaml # edit ds3d_lidar_plus_multi_cam_bev_fusion_iot.yaml, search ds3d_fusion_msg_broker block # update payload-type=1 for minimum 3D bbox; 2 for lidar data with protobuf", "keywords": []}, {"id": 2257, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#nuscenes-dataset-setup-for-ds3d-bevfusion-pipeline", "display_name": "NuScenes Dataset Setup for DS3D BEVFusion Pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "nuscenes-dataset-setup-for-ds3d-bevfusion-pipeline", "priority": -1, "content": "The sample dataset, available from GitHub Deepstream Reference Apps , is picked from the official NuScenes dataset ( https://www.nuscenes.org/ ) and licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License (\u201cCC BY-NC-SA 4.0\u201d). This DS3D BEVFusion demo is using data from the NuScenes scene cc8c0bf57f984915a77078b10eb33198 (name: scene-0061 ), containing 39 samples.", "keywords": []}, {"id": 2258, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "prerequisites", "priority": -1, "content": "The following development packages must be installed. GStreamer-1.0 GStreamer-1.0 Base Plugins GLES library libyaml-cpp-dev Download and install DeepStream SDK locally. Dependencies for Triton Server are automatically installed during the building of the DeepStream Triton BEVFusion container. Check dependencies in /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/bevfusion/bevfusion.Dockerfile If scripts are run outside of container or if file read/write permission errors are experienced, please run the commands with sudo -E .", "keywords": []}, {"id": 2259, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#start-tritonserver-for-bevfusion-model-x86", "display_name": "Start Tritonserver for BEVFusion Model [x86]", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "start-tritonserver-for-bevfusion-model-x86", "priority": -1, "content": "Start Tritonserver with localhost:8001 to serve the BEVFusion model. Specify the model root directory from previous steps. The script will initiate the triton_lmm Python module to serve the BEVFusion model with NVIDIA Triton-python backend. Run the following script to start the server: $ bevfusion/docker_run_triton_server_bevfusion.sh bevfusion/model_root [Deprecated] As an alternative to using the Tritonserver, you can start the PyTriton server to host the BEVFusion model. Note that the performance of Triton-python is better than PyTriton on average as it supports a GPU-only data buffer, but PyTriton is still compatible with the DS3D pipeline. To start the PyTriton server, run the following script: $ bevfusion/docker_run_pytriton_server_bevfusion.sh bevfusion/model_root", "keywords": []}, {"id": 2260, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion#usage", "display_name": "Usage:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "usage", "priority": -1, "content": "start tritonserver BEVFusion model on x86: $ bevfusion/docker_run_triton_server_bevfusion.sh bevfusion/model_root The cmdline would docker-run the deepstream-triton-bevfusion container to start tritonserver and listen port 8001 for grpc inference request/response. Start DS3D BEVFusion inference and rendering pipeline inside of the container: # run the following commandline inside of the container. $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_plus_multi_cam_bev_fusion.yaml How to update camera intrinsic/extrinsic parameters from nuscene: following next steps to run triton_lmm/helper/nuscene_data_setup.py to print calibration data and update them into ds3d-sensor-fusion config file. See details in Dataset Generation for DS3D BEVFusion", "keywords": []}, {"id": 2261, "doc_id": 2261, "filename": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion.html", "domain_name": "std", "name": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "display_name": "DeepStream-3D Multi-Modal BEVFusion Setup", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_MultiModal_Lidar_Camera_BEVFusion", "anchor": "", "priority": -1, "content": "The pipeline efficiently processes data from 6 cameras and 1 LiDAR, leveraging a pre-trained PyTorch BEVFusion model. This model is optimized for NVIDIA GPUs using TensorRT and CUDA, as showcased by the CUDA-BEVFusion project. Enhancing integration, a multi-modal inference module ( triton-lmm ) based on PyTriton simplifies the incorporation of the Python BEVFusion model. The pipeline seamlessly employs ds3d::datatfiler for triton inference through gRPC. Ultimately, users can visualize the results by examining the ds3d::datamap with 6 camera views. The pipeline also projects LiDAR data and 3D bounding boxes into each view. Furthermore, the same LiDAR data is thoughtfully visualized in both a top view and a side view for enhanced comprehension. To run the demo, you need to run two processes, either on the same machine or on different machines. Run tritonserver to startup pytriton-hosted BEVFusion model. This model requires an x86 platform with a GPU compute capability of 8.0 or higher. Run the DS3D sensor fusion 3D detection pipeline to request inference from the Triton server. The pipeline can run on any x86 or Jetson platform.", "keywords": []}, {"id": 2262, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion#build-from-source", "display_name": "Build from source:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "build-from-source", "priority": -1, "content": "To compile sample app deepstream-3d-lidar-sensor-fusion: $ make $ sudo make install (sudo not required in case of docker containers) NOTE: To compile the sources, run make with \u201csudo\u201d or root permission. To compile the custom preprocessing and postprocessing libraries for the sample app deepstream-3d-lidar-sensor-fusion from source: $ cd /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_preprocess # sudo not required in case of docker containers $ sudo make install $ cd /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_postprocess # sudo not required in case of docker containers $ sudo make install", "keywords": []}, {"id": 2263, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion#download-v2xfusion-models-and-build-tensorrt-engine-files", "display_name": "Download V2XFusion Models and Build TensorRT Engine Files", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "download-v2xfusion-models-and-build-tensorrt-engine-files", "priority": -1, "content": "Download the pre-trained model from the V2XFusion pre-trained model download link and put it to the folder v2xfusion/models/v2xfusion. Download the V2X-Seq-SPD (V2X-Seq Perception Dataset) example dataset from AIR-THU/DAIR-V2X and put the downloaded V2X-Seq-SPD-Example.zip in the v2xfusion/scripts folder. $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/v2xfusion/scripts $ ls V2X-Seq-SPD-Example.zip # verify the dataset is ready Please ensure you have the latest python packages $ sudo pip install --upgrade setuptools packaging $ sudo pip cache purge Run the script to generate the model TensorRT engine file and ds3d required dataset. $ pip install gdown python-lzf $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/v2xfusion/scripts $ gdown 1gjOmGEBMcipvDzu2zOrO9ex_OscUZMYY $ ./prepare.sh dataset Note: The example dataset is provided by https://thudair.baai.ac.cn/coop-forecast . For each dataset an user elects to use, the user is responsible for checking if the dataset license is fit for the intended purpose.", "keywords": []}, {"id": 2264, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion#getting-started", "display_name": "Getting Started", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "getting-started", "priority": -1, "content": "Start the deepstream-triton base container for V2XFusion tests. Skip this step if users have installed Triton dependencies manually on Jetson host. # running cmdline outside of the container $ xhost + # export DOCKER_GPU_ARG=&quot;--runtime nvidia --privileged&quot; # for Jetson Orin $ export DOCKER_GPU_ARG=&quot;--gpus all&quot; # for x86 # start the container interactively $ docker run $DOCKER_GPU_ARG -it --rm --ipc=host --net=host -v /tmp/.X11-unix:/tmp/.X11-unix \\ -e DISPLAY=$DISPLAY \\ -w /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion \\ nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch # {xx.xx.xx} is deepstream sdk version number To get started, navigate to the following directory: $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion # sudo chmod -R a+rw . # Grant read/write permission if running on Jetson host", "keywords": []}, {"id": 2265, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "prerequisites", "priority": -1, "content": "Follow the instructions in the apps/sample_apps/deepstream-app/README file to install the prerequisites for common DeepStream SDK modules. Follow the instructions in the samples/configs/deepstream-app-triton/README file to prepare the Triton Server environment. The following development packages must be installed for DS3D sample apps: GStreamer-1.0 GStreamer-1.0 Base Plugins GLES library libyaml-cpp-dev", "keywords": []}, {"id": 2266, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion#start-ds3d-v2xfusion-pipeline", "display_name": "Start DS3D V2XFusion Pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "start-ds3d-v2xfusion-pipeline", "priority": -1, "content": "$ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_video_sensor_v2x_fusion.yml", "keywords": []}, {"id": 2267, "doc_id": 2267, "filename": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion.html", "domain_name": "std", "name": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "display_name": "DeepStream-3D Multi-Modal V2XFusion Setup", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_MultiModal_Lidar_Camera_V2XFusion", "anchor": "", "priority": -1, "content": "The pipeline efficiently processes data from 4 cameras and 4 corresponding LiDARs, inferencing the 3D bboxes with a new model which combines the BEVFusion model and the BEVHeight model together to get more accurate detection result. This model is pre-trained by the DAIR-V2X dataset . The pipeline seamlessly employs ds3d::datatfiler for triton inference. Ultimately, users can inferencing 4 cameras\u2019 videos/images and the corresponding LiDARs\u2019 data to detect 3D bboxes of different objects in road. The results can be visualized together with videos/images and projected LiDAR point clouds in different ways by different rendering configurations.", "keywords": []}, {"id": 2268, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#bevfusion-model-inference-with-triton-lmm", "display_name": "BEVFusion Model Inference with Triton-LMM", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "bevfusion-model-inference-with-triton-lmm", "priority": -1, "content": "triton_lmm Python module for bevfusion A Python module based on Triton and PyTriton, designed for multi-modal inference. It simplifies the integration of Python-based inference models into the Triton server. This sample application leverages the BEVFusion model (Python version) using this module. source code resides in app/sample_apps/deepstream-3d-lidar-sensor-fusion/python/triton_lmm Python module license Apache-2.0", "keywords": []}, {"id": 2269, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#bevfusion-pipeline-demo-setup", "display_name": "BEVFusion pipeline Demo Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "bevfusion-pipeline-demo-setup", "priority": -1, "content": "Prepare all required containers, inference models, sample dataset. Refer to the detailed provided instructions in DS3D BEVFusion setup All the following commandline for BEVFusion setup are run outside of the container unless other comments specified BEVFusion pipeline Quick start. Option 1: build bevfusion model container, start triton server and finally run the pipeline. Run the following commandline to build a local bevfusion model container deepstream-triton-bevfusion:{DS_VERSION_NUM} on x86 with dGPU. $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ bevfusion/docker_build_bevfusion_image.sh nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch Run the following commandline to download the model and build TensorRT engine files on x86 with dGPU. $ mkdir -p bevfusion/model_root $ bevfusion/docker_run_generate_trt_engine_models.sh bevfusion/model_root Start triton server with the models built from last step on x86 with dGPU. $ bevfusion/docker_run_triton_server_bevfusion.sh bevfusion/model_root Open another terminal to start deepstream 3d sensor fusion pipeline with bevfusion config on x86. $ export NUSCENE_DATASET_URL=&quot;https://github.com/NVIDIA-AI-IOT/deepstream_reference_apps/raw/DS_7.1/deepstream-3d-sensor-fusion/data/nuscene.tar.gz&quot; $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion # this cmdline is also preparing the dataset for pipeline tests. # this config file would project lidar data back to camera view in display. $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion.yaml # OR # this config file would keep clear lidar and camera data in display, meanwhile show lables in each view. $ bevfusion/docker_run_ds3d_sensor_fusion_bevfusion_pipeline.sh ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml See more details about the instructions in DS3D BEVFusion setup Option 2: Once users setup everything ready from Option 1, and keep tritonserver running, and make sure dataset downloaded, then users can run the cmdline inside deepstream-triton container. Start deepstream triton container after model and dataset are ready in Option 1. export DOCKER_GPU_ARG=&quot;--runtime nvidia&quot; for Jetson. see more details how to modify config file to setup Jetson test DS3D BEVFusion setup $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion # make directory for dataset and model repo in host, it would be mounted into the container for bevfusion tests $ mkdir -p data bevfusion/model_root $ export DOCKER_GPU_ARG=&quot;--gpus all&quot; # for x86 # export DOCKER_GPU_ARG=&quot;--runtime nvidia&quot; # for Jetson # start the container interactively, and mount dataset and model folder into the container for tests $ docker run $DOCKER_GPU_ARG -it --rm --ipc=host --net=host --privileged -v /tmp/.X11-unix:/tmp/.X11-unix \\ -e DISPLAY=$DISPLAY \\ -w /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion \\ -v ./data:/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/data \\ -v ./bevfusion/model_root:/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/bevfusion/model_root \\ nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch Start deepstream bevfusion pipeline, run cmdline inside of the container. # run cmdline inside of this container $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_plus_multi_cam_bev_fusion.yaml # Or render with the 3D-bbox labels. $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_plus_multi_cam_bev_fusion_with_label.yaml BEVFusion Pipeline rendering results with nuscene dataset(nuscene dataset terms of use &lt; https://www.nuscenes.org/terms-of-use &gt; )", "keywords": []}, {"id": 2270, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#build-application-from-source", "display_name": "Build application From Source", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "build-application-from-source", "priority": -1, "content": "To compile the sample app deepstream-3d-lidar-sensor-fusion inside of container: $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ make $ sudo make install (sudo not required in the case of docker containers) To compile the sources, run make with sudo -E or root permission.", "keywords": []}, {"id": 2271, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#custom-post-processing-for-lidar-detection", "display_name": "Custom Post-Processing for LiDAR Detection", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "custom-post-processing-for-lidar-detection", "priority": -1, "content": "ds3d custom postprocessing library (implemented in libnvds_3d_infer_postprocess_lidar_detection.so ) Performs custom post-processing operations on the sensor fusion results (3D detection objects). The interface inherits from nvdsinferserver::IInferCustomProcessor . Source code resides in /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/inference_custom_lib/ds3d_lidar_detection_postprocess . Refer to the README within that directory for compilation and installation instructions. ds3d custom V2XFusion outputs postprocessing library (implemented in libnvds_3d_v2x_infer_custom_postprocess.so ) Parse the output tensor data from V2XFusion model Calculate 3D bboxes from the output tensor data Refer to /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_postprocess/README", "keywords": []}, {"id": 2272, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#data-inference-filtering", "display_name": "Data Inference Filtering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "data-inference-filtering", "priority": -1, "content": "ds3d::datafilter (implemented in libnvds_tritoninferfilter.so ) Executes multi-modal data inference using the Triton Inference Server. Any data element from the ds3d::datamap can be forwarded to Triton. It supports both Triton CAPI and gRPC modes. Custom pre-processing and post-processing might be required depending on the specific inference task. See more details in libnvds_tritoninferfilter Configuration Specifications ds3d custom V2XFusion model inputs preprocessing library (implemented in libnvds_3d_v2x_infer_custom_preprocess.so ) Prepare and copy constant parameters and data for the tensor inputs of the V2XFusion model Copy pointpillar scatter data to the model input tensor Refer to /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_preprocess/README", "keywords": []}, {"id": 2273, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#data-mixing", "display_name": "Data Mixing", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "data-mixing", "priority": -1, "content": "ds3d::datamixer (implemented in libnvds_3d_multisensor_mixer.so ) Combines video data (2D) and LiDAR data (3D) into a single ds3d::datamap . The mixer operates at a user-specified frame rate. The processing speed might be limited by the slowest input source. See more details in DS3D mixer specification Configuration file", "keywords": []}, {"id": 2274, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#ds3d-components-used-in-this-sample-application", "display_name": "DS3D Components used in this sample application", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "ds3d-components-used-in-this-sample-application", "priority": -1, "content": "This section describes the DS3D components used in the deepstream-3d-lidar-sensor-fusion pipeline.", "keywords": []}, {"id": 2275, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#ds3d-custom-components-configuration-specifications", "display_name": "DS3D Custom Components Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "ds3d-custom-components-configuration-specifications", "priority": -1, "content": "See more details in the DS_3D supported custom components specifications section in the DeepStream-3D Custom Apps and Libs Tutorials .", "keywords": []}, {"id": 2276, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#example-1-bevfusion-multi-modal-with-6-camera-plus-1-lidar-data-fusion-pipeline", "display_name": "Example 1. BEVFusion Multi-Modal with 6-Camera Plus 1-LiDAR Data Fusion Pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "example-1-bevfusion-multi-modal-with-6-camera-plus-1-lidar-data-fusion-pipeline", "priority": -1, "content": "Refer to the provided instructions for the setup.  DS3D BEVFusion Setup with Triton Processes data from 6 cameras and 1 LiDAR. Utilizes pre-trained PyTroch BEVFusion model, optimized for NVIDIA GPUs using TensorRT and CUDA by CUDA-BEVFusion . PyTriton multi-modal inference module ( triton-lmm ) simplifies Python model integration, allowing inclusion of any Python inference. The ds3d::datatfiler based triton inference through gRPC. Visualizes the ds3d::datamap through 6 camera views, projecting LiDAR data into each. Additionally, it provides a top view and a front view of the same LiDAR data for easier comprehension.", "keywords": []}, {"id": 2277, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#example-2-v2xfusion-multi-modal-batched-4-camera-and-4-lidar-inference-pipeline", "display_name": "Example 2. V2XFusion multi-modal batched 4-Camera and 4-LiDAR Inference Pipeline:", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "example-2-v2xfusion-multi-modal-batched-4-camera-and-4-lidar-inference-pipeline", "priority": -1, "content": "Refer to the provided instructions for the setup.  DS3D V2XFusion setup Processes data from a single camera and a LiDAR, utilizing a batch size of 4. Utilizes pre-trained V2XFusion model which is based on BEVFusion and BEVHeight. Build the V2X ONNX model into TensorRT for GPU acceleration. Visualizes 4 batched camera and lidar data together into multiviews.", "keywords": []}, {"id": 2278, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#lidar-camera-data-alignment-calibration-filtering", "display_name": "LiDAR/Camera Data Alignment/Calibration Filtering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "lidar-camera-data-alignment-calibration-filtering", "priority": -1, "content": "ds3d::datafilter (implemented in libnvds_3d_alignment_datafilter.so ) Applies a series of transformations to align the LiDAR data with the camera image coordinate system. See more details in DS3D Custom lib specification Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so", "keywords": []}, {"id": 2279, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#lidar-camera-data-gles-rendering", "display_name": "LiDAR/Camera Data GLES Rendering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "lidar-camera-data-gles-rendering", "priority": -1, "content": "ds3d::datarender (implemented in libnvds_3d_gles_ensemble_render.so ) Renders a 3D scene using OpenGL ES (GLES) with various elements (textures, LiDAR points, bounding boxes) within a single window, allowing for flexible layout customization in multi-view mode. See more details in alignment specification Custom datarender libnvds_3d_gles_ensemble_render Configuration Specifications", "keywords": []}, {"id": 2280, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#lidar-data-loading", "display_name": "LiDAR Data Loading", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "lidar-data-loading", "priority": -1, "content": "ds3d::dataloader (implemented in libnvds_lidarfileread.so ) Reads a list of LiDAR point cloud files from disk into a ds3d::datamap format. Source code resides in /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/dataloader/lidarsource . Refer to the README within that directory for compilation and installation instructions. See more details in DS3D Custom lib specification Custom Dataloader libnvds_lidarfileread Configuration Specifications", "keywords": []}, {"id": 2281, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#lidar-data-v2x-preprocess-filtering", "display_name": "LiDAR Data V2X Preprocess Filtering", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "lidar-data-v2x-preprocess-filtering", "priority": -1, "content": "ds3d::datafilter (implemented in libnvds_3d_lidar_preprocess_datafilter.so ) Preprocess lidar data for v2x sensor fusion model. See more details in DS3D Custom lib specification Custom Datafilter libnvds_3d_lidar_preprocess_datafilter Specifications ds3d custom point cloud data to point pillar scatter data conversion (implemented in libnvds_3d_lidar_preprocess_datafilter.so ) Implement the V2XFusion model pointpillar scatter data conversion function to adapt to ds3d lidar preprocess ds3d::datafilter Refer to the /opt/nvidia/deepstream/deepstream/sources/libs/ds3d/datafilter/lidar_preprocess/README", "keywords": []}, {"id": 2282, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#quick-start", "display_name": "Quick Start", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "quick-start", "priority": -1, "content": "The following development packages must be installed. GStreamer-1.0 GStreamer-1.0 Base Plugins GLES library libyaml-cpp-dev Download and install DeepStream SDK locally on the host. Follow instructions at page Install the DeepStream SDK with method 1 or 2 to install DeepStream SDK locally. BEVFusion requires a local installation of DeepStream SDK which includes the scripts to build/run the container, model and dataset for ease of use. Prerequisites before starting the container. # run cmdline outside of the container $ export DISPLAY=0.0 # set the correct display number if DISPLAY is not exported $ xhost + $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion # make directory for dataset and model repo in host, it would be mounted into the container for bevfusion tests $ sudo chmod -R a+rw . # Grant read/write permission for all of the files in this folder $ mkdir -p data bevfusion/model_root If any scripts are run outside of container, or if file read/write permission errors are experienced, please run the commands with sudo -E . Users have to run the following commandline on every terminal outside of the container or seeing errors such as xhost: unable to open display $ export DISPLAY=0.0 # set the correct display number if DISPLAY is not exported $ xhost + Bevfusion and V2XFusion Setup difference. BEVFusion would build a new local docker image deepstream-triton-bevfusion:{xx.xx} on top of deepstream-triton base image nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch to install all CUDA-BEVFusion dependencies, build offline models, and setup triton server for gRPC remote inference on x86 dGPU. and client fusion pipeline could be running on x86 and Jetson. V2XFusion setup instructions inside deepstream-triton base container nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch and inference through Triton CAPI(native) locally. It also supports Jetson test on host without container if Triton dependencies installed manually. deepstream-triton-bevfusion:{xx.xx} , {xx.xx} is from deepstream sdk major.minor version number installed on local. nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch , {xx.xx.xx} is matched from DeepStream X86 containers and DeepStream Jetson containers", "keywords": []}, {"id": 2283, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#v2xfusion-pipeline-demo-setup", "display_name": "V2XFusion pipeline Demo Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "v2xfusion-pipeline-demo-setup", "priority": -1, "content": "Refer to the detailed provided instructions in DS3D V2XFusion Setup Start the deepstream-triton base container for V2XFusion tests. Skip this step if users have installed Triton dependencies manually on Jetson host. # running cmdline outside of the container $ xhost + # export DOCKER_GPU_ARG=&quot;--runtime nvidia --privileged&quot; # for Jetson Orin $ export DOCKER_GPU_ARG=&quot;--gpus all&quot; # for x86 # start the container interactively $ docker run $DOCKER_GPU_ARG -it --rm --ipc=host --net=host -v /tmp/.X11-unix:/tmp/.X11-unix \\ -e DISPLAY=$DISPLAY \\ -w /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion \\ nvcr.io/nvidia/deepstream:{xx.xx.xx}-triton-multiarch # {xx.xx.xx} is deepstream sdk version number With this docker run container, the following instructions of v2XFusion setup are running inside of this container. If this step skipped on Jetson, the following instructions are running on host directly. Install dependencies $ pip install gdown python-lzf # with sudo if running on Jetson host Prepare all required inference models, optimize the models and sample dataset Follow instructions in Download V2XFusion Models and Build TensorRT Engine Files to download the original V2X dataset. Note: The example dataset is provided by https://thudair.baai.ac.cn/coop-forecast . For each dataset an user elects to use, the user is responsible for checking if the dataset license is fit for the intended purpose. $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion/v2xfusion/scripts $ gdown 1gjOmGEBMcipvDzu2zOrO9ex_OscUZMYY $ ./prepare.sh dataset# with sudo if running on Jetson host Start V2XFusion pipeline once models and dataset are ready. # run the cmdline inside deepstream-triton container $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-3d-lidar-sensor-fusion $ deepstream-3d-lidar-sensor-fusion -c ds3d_lidar_video_sensor_v2x_fusion.yml Users could see the pipeline running on display.", "keywords": []}, {"id": 2284, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "page", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion#video-data-bridging-into-ds3d-ds3d-datamap", "display_name": "Video Data Bridging Into DS3D ds3d::datamap", "type": "section", "display_type": "Page section", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "video-data-bridging-into-ds3d-ds3d-datamap", "priority": -1, "content": "ds3d::databridge (implemented in libnvds_3d_video_databridge.so ) Transfers 2D video buffers into the ds3d::datamap format. DeepStream expects the 2D buffer to be in video/x-raw(memory:NVMM) format (e.g., output from nvv4l2decoder ). See more details in DS3D databridge specification Configuration file Note : A ds3d::datamap is a generic data structure consisting of key-value pairs. It serves as the primary input and output buffer format for components within the DeepStream ds3d framework.", "keywords": []}, {"id": 2285, "doc_id": 2285, "filename": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion.html", "domain_name": "std", "name": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "display_name": "DeepStream-3D Sensor Fusion Multi-Modal Application and Framework", "type": "doc", "display_type": "Page", "docname": "text/DS_3D_MultiModal_Lidar_Sensor_Fusion", "anchor": "", "priority": -1, "content": "This deepstream-3d-lidar-sensor-fusion sample application showcases multi-modal sensor fusion pipelines for LiDAR and camera data using the DS3D framework. This application with DS3D framework could setup different LiDAR/RADAR/Camera sensor fusion models, late fusion inference pipelines with several key features. Camera processing pipeline leveraging DeepStream\u2019s generic 2D video pipeline with batchMeta. Custom ds3d::dataloader for LiDAR capture with pre-processing options. Custom ds3d::databridge converts DeepStream NvBufSurface and GstNvDsPreProcessBatchMeta data into shaped based tensor data ds3d::Frame2DGuard and ds3d::FrameGuard formats, and embeds key-value pairs within ds3d::datamap . ds3d::mixer for efficient merging of camera, LiDAR and any sensor data into ds3d::datamap . ds3d::datatfiler followed by libnvds_tritoninferfilter.so for multi-modal ds3d::datamap inference and custom pre/post-processing. ds3d::datasink with ds3d_gles_ensemble_render for 3D detection result visualization with a multi-view display. The deepstream-3d-lidar-sensor-fusion sample application and source code is located at app/sample_apps/deepstream-3d-lidar-sensor-fusion/ for your reference. There are 2 multi-modal sensor fusion pipelines for LiDAR and camera data, enabling 3D detections.", "keywords": []}, {"id": 2286, "doc_id": 2286, "filename": "text/DS_API_Guide.html", "domain_name": "std", "name": "text/DS_API_Guide", "display_name": "DeepStream API Guides", "type": "doc", "display_type": "Page", "docname": "text/DS_API_Guide", "anchor": "", "priority": -1, "content": "Read the DeepStream SDK API reference documentation here . Read the python API documentation here .", "keywords": []}, {"id": 2287, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#avsync-reference-pipelines", "display_name": "AVSync Reference Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "avsync-reference-pipelines", "priority": -1, "content": "RTMP src is not a live source. You\u2019ll need to add fakesrc with is-live=true and connect it to audiomixer . This makes sure it won\u2019t break even if the data from one of the sources is unavailable. A max-latency of 250msec is set on nvstreammux for rtmp input source. The value is set because max latency required for buffers from rtmpsrc to nvstreammux is 250msec. You can tune this value as per your requirement. Same value is set in audio path on audiomixer for the same reason. RTSP output will be available at rtsp://&lt;host_ip_address:8554&gt;/ds-test . You may experience AV sync is out of sync if the file output is played using VLC player. In that case try ffmpeg or gst-launch pipeline. This could be VLC player specific issue. Make sure that audio stream has same encoded configuration. (e.g. sampling rate). If these are different, audiomixer crashes. You may add audioconvert and audioresample before audiomixer for given source so that all inputs to audiomixer have same format and sampling rate. RTMP output on YouTube\u2122 live takes time to appear (~30-40seconds). This could be because of YouTube\u2122 player\u2019s buffering mechanism. In case of RTMP output, before running the pipeline make sure that YouTube\u2122 live page is refreshed and ready to accept incoming data. If case of packet drop, rtsp output may look like it is corrupted. In that case reduce bitrate and try.", "keywords": []}, {"id": 2288, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#command-to-simulate-2-rtmp-streams-using-ffmpeg", "display_name": "Command to simulate 2 RTMP streams using ffmpeg", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "command-to-simulate-2-rtmp-streams-using-ffmpeg", "priority": -1, "content": "$ sudo ffmpeg -re -i &lt;file_name1.mp4&gt; -vcodec copy -1 -c:a aac -b:a 160k -ar 48000 -strict -2 -f flv rtmp://&lt;host ip address:port&gt;/live/test1 $ sudo ffmpeg -re -i &lt;file_name2.mp4&gt; -vcodec copy -1 -c:a aac -b:a 160k -ar 48000 -strict -2 -f flv rtmp://&lt;host ip address:port&gt;/live/test2", "keywords": []}, {"id": 2289, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#file-in-file-out", "display_name": "FILE_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "file-in-file-out", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2290, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#file-in-rtmp-out", "display_name": "FILE_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "file-in-rtmp-out", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 output=&lt;RTMP url&gt; e.g. rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; For Youtube live rtmp://&lt;host ip address:port&gt;/live/test For Host gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2291, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#file-in-rtsp-out", "display_name": "FILE_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "file-in-rtsp-out", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width= 1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2292, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id1", "display_name": "RTMP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id1", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For YouTube\u2122 live rtmp://&lt;host ip address:port&gt;/live/test #For Host gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux max-latency=250000000 batched-push-timeout=33333 width=1920 height=1080 batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvdsosd ! queue ! nvvideoconvert ! queue ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer latency=250000000 ! queue ! avenc_aac ! aacparse ! queue ! mux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 -e Make sure the ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2293, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id10", "display_name": "RTSP_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id10", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp url&gt; USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. -e", "keywords": []}, {"id": 2294, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id11", "display_name": "RTMP_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id11", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 max-latency=250000000 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer latency=250000000 name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2295, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id12", "display_name": "RTMP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id12", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For Youtube live rtmp://&lt;host ip address:port&gt;/live/test #For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux max-latency=250000000 batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvdsosd ! queue ! nvvideoconvert ! queue ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer latency=250000000 ! queue ! avenc_aac ! aacparse ! queue ! mux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 -e Make sure ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2296, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id13", "display_name": "RTSP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id13", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp_url&gt; output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For Youtube live rtmp://&lt;host ip address:port&gt;/live/test #For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=flvmux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri= $input2 name =demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! flvmux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 qos=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 qos=0 -e Make sure ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2297, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id14", "display_name": "FILE_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id14", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For Youtube live rtmp://&lt;host ip address:port&gt;/live/test #For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvdsosd ! queue ! nvvideoconvert ! queue ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 -e Make sure ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2298, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id15", "display_name": "RTMP_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id15", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=1 sync-inputs=1 max-latency=250000000 name=mux1 ! queue ! nvmultistreamtiler ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 demux1. ! queue ! audioconvert ! audiomux.sink_0 nvstreammux name=audiomux batch-size=1 max-latency=250000000 sync-inputs=1 ! nvstreamdemux name=audiodemux audiodemux.src_0 ! audioconvert ! mixer.sink_0 audiomixer latency=250000000 name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2299, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id2", "display_name": "FILE_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id2", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For Youtube live rtmp://&lt;host ip address:port&gt;/live/test #For Host gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvdsosd ! queue ! nvvideoconvert ! queue ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 -e Make sure the ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2300, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id3", "display_name": "RTMP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id3", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 output=&lt;RTMP url&gt; e.g. rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; For Youtube live rtmp://&lt;host ip address:port&gt;/live/test For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 max-latency=250000000 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer latency=250000000 ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2301, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id4", "display_name": "RTSP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id4", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp url&gt; output=&lt;RTMP url&gt; e.g. rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; For Youtube live rtmp://&lt;host ip address:port&gt;/live/test For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. -e", "keywords": []}, {"id": 2302, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id5", "display_name": "FILE_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id5", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2303, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id6", "display_name": "FILE_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id6", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 output=&lt;RTMP url&gt; e.g. rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; For Youtube live rtmp://&lt;host ip address:port&gt;/live/test For Host USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2304, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id7", "display_name": "RTMP_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id7", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 max-latency=250000000 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer latency=250000000 name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2305, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id8", "display_name": "RTSP_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id8", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp url&gt; USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. -e", "keywords": []}, {"id": 2306, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#id9", "display_name": "FILE_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "id9", "priority": -1, "content": "input1=file:///AV_I_frames_1.mp4 input2=file:///AV_I_frames_2.mp4 USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2307, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#pipelines-with-new-nvstreammux-component", "display_name": "Pipelines with New nvstreammux component", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "pipelines-with-new-nvstreammux-component", "priority": -1, "content": "You can enable the new nvstreammux (Beta quality) by exporting USE_NEW_NVSTREAMMUX=yes . For more information, see the :doc: \u201cGst-nvstreammux New (Beta)\u201d section in the NVIDIA DeepStream SDK Developer Guide 6.1 Release . The existing nvstreammux functionality will be deprecated in the future.", "keywords": []}, {"id": 2308, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#reference-avsync-asr-automatic-speech-recognition-pipelines-with-existing-nvstreammux", "display_name": "Reference AVSync + ASR (Automatic Speech Recognition) Pipelines with existing nvstreammux", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "reference-avsync-asr-automatic-speech-recognition-pipelines-with-existing-nvstreammux", "priority": -1, "content": "These pipelines demonstrate how to add ASR plugin in avsync pipeline. To visualize overlaid text output from ASR on video frames, refer to deepstream-avsync-app application.", "keywords": []}, {"id": 2309, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtmp-in-file-out", "display_name": "RTMP_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtmp-in-file-out", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 max-latency=250000000 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer latency=250000000 name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2310, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtmp-in-rtmp-out", "display_name": "RTMP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtmp-in-rtmp-out", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 output=&lt;RTMP url&gt; e.g. rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; For Youtube live rtmp://&lt;host ip address:port&gt;/live/test For Host gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 max-latency=250000000 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer latency=250000000 ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2311, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtmp-in-rtsp-out", "display_name": "RTMP_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtmp-in-rtsp-out", "priority": -1, "content": "input1=rtmp://&lt;host ip address:port&gt;/live/test1 input2=rtmp://&lt;host ip address:port&gt;/live/test2 gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 max-latency=250000000 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer latency=250000000 name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. fakesrc num-buffers=0 is-live=1 ! mixer. -e", "keywords": []}, {"id": 2312, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtmp-server-setup", "display_name": "RTMP Server Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtmp-server-setup", "priority": -1, "content": "$ apt-get update $ apt-get install nginx -y $ apt-get install libnginx-mod-rtmp -y $ vim /etc/nginx/nginx.conf #add below content rtmp { server { listen 1935; chunk_size 4096; application live { live on; record off; } } } $ service nginx restart", "keywords": []}, {"id": 2313, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtsp-in-file-out", "display_name": "RTSP_IN->FILE_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtsp-in-file-out", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp url&gt; gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=mux streamable=true ! filesink location=out.flv async=0 qos=0 sync=1 uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! mux. demux2. ! queue ! audioconvert ! mixer. -e", "keywords": []}, {"id": 2314, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtsp-in-rtmp-out", "display_name": "RTSP_IN->RTMP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtsp-in-rtmp-out", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp_url&gt; output=&lt;RTMP url&gt; e.g.: rtmp://a.rtmp.youtube.com/live2/&lt;key&gt; #For Youtube live rtmp://&lt;host ip address:port&gt;/live/test #For Host gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batched-push-timeout=33333 width=1920 height=1080 batch-size=2 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! nvv4l2h264enc ! h264parse ! queue ! flvmux name=flvmux streamable=true ! rtmpsink location=$output async=0 qos=0 sync=1 uridecodebin3 uri= $input2 name =demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! tee name=t1 t1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! avenc_aac ! aacparse ! queue ! flvmux. t1. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 qos=0 demux2. ! queue ! tee name=t2 t2. ! queue ! audioconvert ! mixer. t2. ! queue ! audioconvert ! &quot;audio/x-raw, format=(string)S16LE, channels=(int)1&quot; ! audioresample ! &quot;audio/x-raw, rate=(int)16000&quot; ! nvdsasr config-file= riva_asr_grpc_jasper_conf.yml customlib-name=&quot;libnvds_riva_asr_grpc.so&quot; create-speech-ctx-func=&quot;create_riva_asr_grpc_ctx&quot; ! fakesink sync=0 async=0 qos=0 -e Make sure the ASR service is running (refer README of deepstream-avsync-app , for detailed information ) . To ensure gRPC libraries are accessible, set LD _LIBRARY_PATH using $source ~/.profile . Update the correct path of riva_asr_grpc_jasper_conf.yml in the above command before running it.", "keywords": []}, {"id": 2315, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtsp-in-rtsp-out", "display_name": "RTSP_IN->RTSP_OUT", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtsp-in-rtsp-out", "priority": -1, "content": "input1=&lt;rtsp url&gt; input2=&lt;rtsp url&gt; gst-launch-1.0 uridecodebin3 uri=$input1 name=demux1 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_0 nvstreammux batch-size=2 batched-push-timeout=33333 width=1920 height=1080 sync-inputs=1 name=mux1 ! queue ! nvmultistreamtiler width=480 height=360 ! nvrtspoutsinkbin name=r uridecodebin3 uri=$input2 name=demux2 ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM)&quot; ! mux1.sink_1 demux1. ! queue ! audioconvert ! mixer.sink_0 audiomixer name=mixer ! queue ! r. demux2. ! queue ! audioconvert ! mixer. -e", "keywords": []}, {"id": 2316, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "page", "name": "text/DS_AVSync#rtsp-server-setup", "display_name": "RTSP Server Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_AVSync", "anchor": "rtsp-server-setup", "priority": -1, "content": "$ cvlc &lt;file_name.mp4&gt; :sout=#gather:rtp{sdp=rtsp://:&lt;port&gt;/file-stream} :network-caching=1500 :sout-all :sout-keep The rtsp stream generated from above command can be accessed using URL: rtsp://&lt;host_ip_address:port&gt;/file-stream .", "keywords": []}, {"id": 2317, "doc_id": 2317, "filename": "text/DS_AVSync.html", "domain_name": "std", "name": "text/DS_AVSync", "display_name": "AV Sync in DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_AVSync", "anchor": "", "priority": -1, "content": "AV Synchronization support is enabled for DeepStream-6.0 release and onwards. Currently it is in alpha development stage. A sample app deepstream-avsync-app is also provided at app/sample_apps/deepstream-avsync for reference. This document provides the sample gstreamer pipelines.", "keywords": []}, {"id": 2318, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#accuracy-performance-tradeoffs", "display_name": "Accuracy-Performance Tradeoffs", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "accuracy-performance-tradeoffs", "priority": -1, "content": "The visual feature size, detection interval and input frame size have impact on both accuracy and performance. They should be properly set for a good accuracy-performance tradeoff.", "keywords": []}, {"id": 2319, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#data-association", "display_name": "Data Association", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "data-association", "priority": -1, "content": "Related Parameters Matching Candidacy minMatchingScore4Overall minMatchingScore4SizeSimilarity minMatchingScore4Iou minMatchingScore4VisualSimilarity Matching Score Weights matchingScoreWeight4VisualSimilarity matchingScoreWeight4SizeSimilarity matchingScoreWeight4Iou In the video frames where the detector performs inference (referred to as the inference frames), the NvDCF tracker performs the data association to match a set of detector objects to a set of existing targets. To reduce the computational cost for matching, it is essential to define a small set of good candidates for each object tracker. That is where the criteria for matching candidacy comes in. For each tracker bbox , only the detector bboxes that are qualified in terms of the minimum size similarity, IOU, and the visual similarity are marked as candidates for matching. The visual similarity is computed based on the correlation response of the tracker at the detector bbox location. If one wants to consider only the detector bboxes that have at least some overlap with the tracker bbox , for example, then minMatchingScore4Iou would need to be set with a non-zero value. One can tune the other parameters in a similar manner. Given a set of candidate detector bboxes for each tracker, the data association matrix is constructed between the detector bbox set and the tracker set with the matching scores as the value for the elements in the matrix. The matching score for each element is computed as a weighted sum of: The visual similarity The size similarity, and IOU score with the corresponding weights in matchingScoreWeight4VisualSimilarity , matchingScoreWeight4SizeSimilarity , and matchingScoreWeight4Iou , respectively. The resulting matching score is put into the data association matrix only if the score exceeds a predefined threshold (i.e., minMatchingScore4Overall )", "keywords": []}, {"id": 2320, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#dcf-core-parameters", "display_name": "DCF Core Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "dcf-core-parameters", "priority": -1, "content": "Apart from the types and sizes of the visual features employed, there are parameters related to how to learn and update the classifier for each object in DCF frameworks, which would affect the accuracy.", "keywords": []}, {"id": 2321, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#dcf-filter-learning", "display_name": "DCF Filter Learning", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "dcf-filter-learning", "priority": -1, "content": "Related Parameters filterLr filterChannelWeightsLr gaussianSigma DCF-based trackers learn a classifier (i.e., discriminative correlation filter) for each object with implicit positive and negative samples. Such learned classifiers are updated on-the-fly for temporal consistency with a predefined learning rate (i.e., filterLr ). If the visual appearance of the target objects is expected to vary quickly over time, one may employ a high learning rate for better adaptation of the correlation filter to the changing appearance. However, there is a risk of learning the background quickly as well, resulting in potentially more frequent track drift. As NvDCF tracker utilizes multi-channel visual features, it is of concern on how to merge those channels for the final correlation response. NvDCF employs an adaptive channel weight approach where the importance of each channel is examined on-the-fly, and the corresponding channel weights are updated over time with a pre-defined learning rate (i.e., filterChannelWeightsLr ). The tuning strategy for this learning rate would be similar to the case of filterLr as described before. When a correlation filter is learned, gaussianSigma determines how tight we want to fit the resulting filter to the positive sample. A lower value means the tighter fit, but it may result in overfitting. On the other hand, a higher value may result in lower discriminative power in the learned filter. See also the Troubleshooting in Tracker Setup and Parameter Tuning section for solutions to common problems in tracker behavior and tuning.", "keywords": []}, {"id": 2322, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#detection-interval", "display_name": "Detection Interval", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "detection-interval", "priority": -1, "content": "Related Parameters Detection interval interval Instead of reducing the visual feature types and sizes, users can explore increasing the detection interval instead (i.e., interval in PGIE config). Thanks to the enhanced accuracy and robustness, the NvDCF tracker allows users to increase the detection interval without sacrificing the accuracy too much. Especially when a heavier neural net model is used for the object detection, the performance gain by increasing the detection interval will be higher. Thus, users may consider increasing the detection interval instead of lowering the accuracy setting for NvDCF tracker.", "keywords": []}, {"id": 2323, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#download", "display_name": "Download", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "download", "priority": -1, "content": "PipeTuner is hosted on NGC. Users need to download the following resources to start. PipeTuner Collection : The collection of all Pipetuner resources, including introduction, user guide and setup instructions; PipeTuner Container : PipeTuner docker container; PipeTuner User Guide and Sample Data : PipeTuner user guide and the sample data to run as an example, including a sample dataset for people tracking, configuration files for tuning, and scripts to launch the pipeline.", "keywords": []}, {"id": 2324, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#features-and-requirements", "display_name": "Features and Requirements", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "features-and-requirements", "priority": -1, "content": "Here is a summary of PipeTuner\u2019s functionalities and requirements: Dataset Users need to provide the typical dataset for their use case. It should include a few sample videos, with bounding box and object ID ground truth annotated Models Users need to provide the required models, including the object detection model (for PGIE) and Re-ID models (Re-ID only required when using NvDCF_accuracy or NvDeepSORT tracker). They can be NVIDIA TAO models in DeepStream container, NGC, or customized pre-trained ONNX models Container Users need to download PipeTuner and DeepStream container from NGC Accuracy KPI Users select one of the multi-object tracking KPIs: HOTA , MOTA or IDF1", "keywords": []}, {"id": 2325, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#kalman-filter", "display_name": "Kalman Filter", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "kalman-filter", "priority": -1, "content": "Related Parameters processNoiseVar4Loc processNoiseVar4Size processNoiseVar4Vel measurementNoiseVar4Detector measurementNoiseVar4Tracker The Kalman Filter (KF) implementation in NvMultiObjectTracker library mostly follows a standard 2D KF approach where the user needs to define the process noise and measurement noise based on the expected uncertainty level. If the object has relatively simple and linear motion, one may set the process noise lower than the measurement noise, effectively putting more trust on the prediction. If the object is expected to have more dynamic motions or abrupt changes of states, it would be more advised to set the measurement noise lower; otherwise, there could be some lagging if the prediction is not correct. One additional consideration that is put in is to allow users to set different measurement noise for detector bbox and tracker bbox for the case where a visual tracker module is enabled (i.e., NvDCF). There is always a possibility of false negatives by the detector or there could be video frames where the inference for object detection is skipped. For such cases, each object tracker makes its own localization using the learned correlation filter, and the results are used to update the Kalman filter. Thus, from KF\u2019s point of view, the measurements are from two different sources: one from the detector and the other from the tracker. In cases that the measurements are expected from multiple sources, such measurements are expected to be fused to estimate the target states properly with appropriate measurement models (i.e., uncertainty modeling for the measurements). Depending on the accuracy characteristics of the detector and the tracker, the measurement noises should be configured accordingly. When a very high accuracy model is used for object detection, one may set measurementNoiseVar4Detector value lower than measurementNoiseVar4Tracker , effectively putting more trust on the detector\u2019s measurement than the tracker\u2019s prediction/localization.", "keywords": []}, {"id": 2326, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#multi-object-tracking-parameter-functionalities-for-manual-tuning", "display_name": "Multi-Object Tracking Parameter Functionalities for Manual Tuning", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "multi-object-tracking-parameter-functionalities-for-manual-tuning", "priority": -1, "content": "This section describes the configuration parameters in each module of the detector and tracker, and their potential impacts on both performance and accuracy. A general introduction to NvMultiObjectTracker tracker library can be found in DeepStream SDK Plugin Manual.", "keywords": []}, {"id": 2327, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#robustness", "display_name": "Robustness", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "robustness", "priority": -1, "content": "To deal with false positives and false negatives from the detector, the NvMultiObjectTracker library utilizes two strategies called Late Activation and Shadow Tracking (more details can be found in DeepStream SDK Plugin Manual). In addition to the config parameters related to those strategies, there are a few config parameters that affect when a tracker for a new object is created and terminated.", "keywords": []}, {"id": 2328, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#setup", "display_name": "Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "setup", "priority": -1, "content": "Overall steps to setup PipeTuner are as below. Download Container : Pull PipeTuner and DeepStream perception container from NGC repository; Download Sample Data : Download and extract sample data from NGC resource; Data Preparation : Users create their own dataset with the same format as sample data, and update configuration files to match their use case; Launch Tuning : Launch the tuning pipeline using the desired configuration and data; Retrieve Results : Retrieve the optimal parameters and visualize the tuning results; Deploy : Deploy the optimal parameters into the desired use case. PipeTuner searches the optimal parameters by iterating the following three steps until the accuracy KPI converges or up to the max number of iterations (i.e., epochs) specified: ParamSearch : Given the accuracy KPI score in the previous iteration, make an educated guess on the set of parameters that would yield a higher accuracy KPI. For the very first iteration, a random sampling in the parameter space would be conducted; PipeExec : Given the sampled/guessed parameter set, execute the pipeline with the params and generates metadata to allow accuracy evaluation; PipeEval : Given the metadata outputs from the pipeline and the dataset, perform the accuracy evaluation based on the accuracy metric and generates accuracy KPI score.", "keywords": []}, {"id": 2329, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#state-estimation", "display_name": "State Estimation", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "state-estimation", "priority": -1, "content": "An object tracker in NvMultiObjectTracker library maintains a set of states for a target like below: Target location (in 2D camera coordinates) Location Location velocity Target Bbox Size Size velocity", "keywords": []}, {"id": 2330, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#target-creation-policy", "display_name": "Target Creation Policy", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "target-creation-policy", "priority": -1, "content": "Related Parameters Target Candidacy minDetectorConfidence minIouDiff4NewTarget Late Activation probationAge earlyTerminationAge If an object detected by a detector meets the minimum qualifications (i.e., target candidacy) specified by the following, a new tracker is instantiated for the object: minDetectorConfidence minIouDiff4NewTarget If spurious false detections are observed with lower detector confidence values, one can increase the minimum detector confidence (i.e., minDetectorConfidence ) to filter them out. If the maxmimum IOU score of a newly detected object to any of the existing targets is lower than minIouDiff4NewTarget , a new target tracker would be created to track the object. Thus, if one wishes to further suppress the creation of duplicate bboxes on the same target that may have a bit different bbox sizes, minIouDiff4NewTarget can be set lower. Once a tracker is instantiated for a new object, it initially starts tracking the object in a temporary mode (i.e., Tentative mode) until further criteria are met during a period specified by probationAge in terms of the number of frames. During this probationary period, whenever the tracker bbox is not matched with detector bbox or the tracker confidence gets lower than minTrackerConfidence , the shadow tracking age (which is an internal variable) is incremented. If the shadow tracking age reaches a predefined threshold (i.e., earlyTerminationAge ), then the tracker will be terminated prematurely, effectively eliminating the false positives. If a higher rate of false detections is expected, then one may consider to increase the probationAge and/or decrease earlyTerminationAge for stricter creation policy. If the expected detector confidence for the false detections is low while that of the true positives is high, one can set minDetectorConfidence accordingly to filter out false detections.", "keywords": []}, {"id": 2331, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#target-termination-policy", "display_name": "Target Termination Policy", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "target-termination-policy", "priority": -1, "content": "Related Parameters Shadow Tracking minTrackerConfidence maxShadowTrackingAge In addition to the aforementioned early termination policy during the probationary period, there are certain criteria to be met when a tracker is terminated. Once a tracker starts tracking in Active mode, its status changes to Inactive mode if: The tracker confidence is lower than minTrackerConfidence or It is not matched with a detector bbox during data association. The shadow tracking age is incremented every frame when a target is not associated with a detector object. If the tracker gets matched again with a detector bbox, then the shadow tracking age is reset to zero, and the tracker\u2019s mode changes to Active mode again if it was in Inactive mode (meaning that the tracker outputs will be reported to the downstream). However, if the shadow tracking age exceeds a predefined threshold (i.e., maxShadowTrackingAge ), the tracker will be terminated. For more robust tracking, one may increase the value for maxShadowTrackingAge because it will allow an object to be re-associated even after missed detections over multiple consecutive frames. However, in case that the visual appearance of the object undergoes a significant change during the missed detections (e.g., prolonged occlusions), the learned correlation filter may not yield a high correlation response when the object reappears. In addition, increasing maxShadowTrackingAge would allow a tracker to live longer (i.e., more delayed termination), resulting in an increased number of trackers present at the memory at a given time, which would in turn increase the computational load.", "keywords": []}, {"id": 2332, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#video-frame-size-for-tracker", "display_name": "Video Frame Size for Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "video-frame-size-for-tracker", "priority": -1, "content": "Related Parameters Video frame size for tracker tracker-width tracker-height The video frame size configured in tracker plugin has some impact on the performance, as a higher resolution video frame would take longer time to transfer between memories. If one sets the frame resolution lower, hoping to achieve a higher performance, however, its negative impact on the accuracy may outweigh the performance gain. Therefore, it is recommended to use at least 960x544 resolution (for 1080p source resolution) to minimize the accuracy degradation.", "keywords": []}, {"id": 2333, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "page", "name": "text/DS_Accuracy#visual-feature-types-and-feature-sizes", "display_name": "Visual Feature Types and Feature Sizes", "type": "section", "display_type": "Page section", "docname": "text/DS_Accuracy", "anchor": "visual-feature-types-and-feature-sizes", "priority": -1, "content": "Related Parameters Visual feature types useColorNames useHog Feature sizes featureImgSizeLevel searchRegionPaddingScale NvDCF tracker can use multiple types of visual features such as Histogram of Oriented Gradient (HOG) and ColorNames. If both features are used (by setting useColorNames: 1 and useHog: 1 ), then the total number of channels would be 28. The more channels of visual features are used, the more accurately the algorithm would track but would increase the computational complexity and reduce performance. In addition to the types of the visual features, we can configure the number of pixels used to represent an object for each feature channel. The corresponding parameter is featureImgSizeLevel , and its range is from 1 to 5. Each level between 1 and 5 corresponds to 12x12, 18x18, 24x24, 36x36, and 48x48, respectively, for each feature channel. Therefore, if one uses both HOG and ColorNames with featureImgSizeLevel: 5 , then the dimension of visual features that represents an object would be 28x48x48. One thing to note is that the visual features for an object are extracted from a region whose size is a bit larger than the object region in order to make sure that the object in the next frame appears within the region even when there is a movement by the object between frames. This region is referred to as the search region , whose size is defined by adding a degree of padding to the object bbox . More details can be found in the section for NvDCF tracker in DeepStream Plugin Manual. Increasing the search region size lowers the probability of missing the object in the next frame; however, given a fixed feature size (i.e., featureImgSizeLevel ), if we increase searchRegionPaddingScale , it would effectively decrease the number of pixels belonging to the object, resulting in lower resolution in terms of object representation in visual features. This may result in lower accuracy in tracking; however, if the degree of movement of an object between two consecutive frames is expected to be small, the object would be highly likely to appear in the search region in the next frame even with a smaller search region size. It would especially be the case if a state estimator is enabled and the prediction by the state estimator is reasonably accurate, because the search region would be defined at the predicted location in the next frame.", "keywords": []}, {"id": 2334, "doc_id": 2334, "filename": "text/DS_Accuracy.html", "domain_name": "std", "name": "text/DS_Accuracy", "display_name": "Accuracy Tuning Tools", "type": "doc", "display_type": "Page", "docname": "text/DS_Accuracy", "anchor": "", "priority": -1, "content": "A typical DeepStream perception pipeline includes a detector and the multi-object tracker, and each module has a number of parameters listed in the detector (PGIE) and tracker configuration files. For example, the clustering thresholds for detection post-processing, the Kalman filter parameters in tracker, etc. When users deploy such data processing pipelines in diverse applications, such as traffic, retail, warehouse etc., a pain point is how to find the optimal parameters with the highest accuracy KPI for each use case. Manual parameter tuning requires in-depth knowledge on the algorithm and how each parameter would affect the functionality. Given the large number of parameters, the complexity of such process would increase exponentially. Starting from DeepStream 7.0, a new tool PipeTuner is released for automatic accuracy tuning. It efficiently explores the (potentially very high-dimensional) parameter space and automatically finds the optimal parameters for the pipelines, which yields the highest KPI on the dataset. The difference between automatic and traditional manual tuning can be summarized as follows: Approach Workflow Pros/Cons Requirements Automatic tuning using PipeTuner Download PipeTuner, and prepare a dataset for the target use case. Define a DeepStream pipeline with required models to be used and initial parameters in the config files. And then register a set of parameters to be tuned with a search range for each parameter. Launch PipeTuner and it will automatically search the parameters with the highest accuracy KPI. Users are not required to have technical knowledge on the pipeline and its parameters. The automatic tuning algorithm find the best parameter set within the search range that would yield the highest accuracy KPI. Users need to provide a dataset, which includes a few video streams with the resolution same as the one that will be used in the actual deployments, and ground truth (i.e. bounding box and object IDs). The videos should have the same resolution, represent the typical use case, and not be too long, otherwise the tuning turn-around time may take too long; we recommend 1-2 min in length. The pipeline tuning would be carried out through a number of iterations of DeepStream pipeline execution, which may take several hours depending on various factors, such as the number of iterations (similar to epochs), the size of the dataset and the HW capabilities. Manual tuning Read the technical documentation to understand how each parameter affects the accuracy. Perform heuristic or random search for the parameters and check the result quality. Manually run DeepStream pipeline multiple times to compare which parameters work the best. If a user is very experienced/skilled in DeepStream tuning, then it could be quick fix. Quick fix on some parameters for a corner case may lead to a regression on other cases. Any manual tuning would be sub-optimal as exploring the high-dimensional parameter space manual is not tractable. Users need special technical knowledge on the pipeline and its parameters, and need to go through a trial-and-error process. For more detailed tutorials, please check out PipeTuner User Guide from NGC for step-to-step setup instructions and all the technical details. In case manual tuning is still needed, we also provide in the following sections the functionality of some of the configuration parameters to give a better understanding on their potential impacts on both performance and accuracy on multi-object tracking operations.", "keywords": []}, {"id": 2335, "doc_id": 2338, "filename": "text/DS_Application_migration.html", "domain_name": "page", "name": "text/DS_Application_migration#compiling-deepstream-7-0-apps-in-deepstream-7-1", "display_name": "Compiling DeepStream 7.0 Apps in DeepStream 7.1", "type": "section", "display_type": "Page section", "docname": "text/DS_Application_migration", "anchor": "compiling-deepstream-7-0-apps-in-deepstream-7-1", "priority": -1, "content": "Before compiling DeepStream 7.0 applications in DeepStream 7.1, modify the Makefiles and set the NVDS_VERSION flag to 7.1 . There are two options to compile DeepStream 7.0 in DeepStream 7.1: Option 1 : Replace existing sources/apps from DeepStream-7.1 and copy the entire `sources/apps directory from DeepStream-7.0. Option 2 : Individual applications in DeepStream SDK have dependency on sources under apps-common directory. Ideally, to compile those applications, you must use the same version of apps-common . In case you want to use the latest version, you may need to adjust some application function calls because of a change in application function definitions.", "keywords": []}, {"id": 2336, "doc_id": 2338, "filename": "text/DS_Application_migration.html", "domain_name": "page", "name": "text/DS_Application_migration#migrating-deepstream-7-0-gst-nvtracker-to-deepstream-7-1", "display_name": "Migrating DeepStream 7.0 Gst-nvtracker to DeepStream 7.1", "type": "section", "display_type": "Page section", "docname": "text/DS_Application_migration", "anchor": "migrating-deepstream-7-0-gst-nvtracker-to-deepstream-7-1", "priority": -1, "content": "In DeepStream 7.1, the past-frame data structure of Gst-nvtracker is renamed as Target Miscellaneous Data in nvds_tracker_meta.h ; and accordingly, NvDsPastFrameObj , NvDsPastFrameObjList , NvDsPastFrameObjStream and NvDsPastFrameObjBatch are renamed as NvDsTargetMiscDataFrame , NvDsTargetMiscDataObject , NvDsTargetMiscDataStream and NvDsTargetMiscDataBatch , respectively. If a DeepStream 7.0 application or custom tracker uses the past-frame data, it should adopt the new miscellaneous data structures and recompile the source code when migrating to DS 7.1. By default, OpenCV is deprecated in DeepStream 6.1. However, you can enable OpenCV in plugins such as nvinfer ( nvdsinfer ) and dsexample ( gst-dsexample ) by setting WITH_OPENCV=1 in the Makefile of these components. Refer to the component README for more instructions.", "keywords": []}, {"id": 2337, "doc_id": 2338, "filename": "text/DS_Application_migration.html", "domain_name": "page", "name": "text/DS_Application_migration#running-deepstream-7-0-compiled-apps-in-deepstream-7-1", "display_name": "Running DeepStream 7.0 compiled Apps in DeepStream 7.1", "type": "section", "display_type": "Page section", "docname": "text/DS_Application_migration", "anchor": "running-deepstream-7-0-compiled-apps-in-deepstream-7-1", "priority": -1, "content": "To run the old app from DeepStream 7.0 in DeepStream 7.1, create symlinks of the libraries so the old application can find them.: mkdir /opt/nvidia/deepstream/deepstream-7.0 mkdir /opt/nvidia/deepstream/deepstream-7.0/lib ln -s /opt/nvidia/deepstream/deepstream-7.1/lib/* /opt/nvidia/deepstream/deepstream-7.0/lib/", "keywords": []}, {"id": 2338, "doc_id": 2338, "filename": "text/DS_Application_migration.html", "domain_name": "std", "name": "text/DS_Application_migration", "display_name": "Application Migration to DeepStream 7.1 from DeepStream 7.0", "type": "doc", "display_type": "Page", "docname": "text/DS_Application_migration", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2339, "doc_id": 2340, "filename": "text/DS_C_Sample_Apps.html", "domain_name": "page", "name": "text/DS_C_Sample_Apps#plugin-and-library-source-details", "display_name": "Plugin and Library Source Details", "type": "section", "display_type": "Page section", "docname": "text/DS_C_Sample_Apps", "anchor": "plugin-and-library-source-details", "priority": -1, "content": "The following table describes the contents of the sources directory except for the reference test applications: Plugin or library Path inside sources directory Description DsExample GStreamer plugin gst-plugins/gst-dsexample Template plugin for integrating custom algorithms into DeepStream SDK graph. GStreamer Gst-nvmsgconv plugin gst-plugins/gst-nvmsgconv Source code for the GStreamer Gst-nvmsgconv plugin to convert metadata to schema format. GStreamer Gst-nvmsgbroker plugin gst-plugins/gst-nvmsgbroker Source code for the GStreamer Gst-nvmsgbroker plugin to send data to the server. GStreamer Gst-nvdspreprocess plugin gst-plugins/gst-nvdspreprocess Source code for the GStreamer Gst-nvdspreprocess plugin for preprocessing on the predefined ROIs. GStreamer Gst-nvinfer plugin gst-plugins/gst-nvinfer Source code for the GStreamer Gst-nvinfer plugin for inference. GStreamer Gst-nvinferserver plugin gst-plugins/gst-nvinferserver Source code for the GStreamer Gst-nvinferserver plugin for inference using Triton Inference Server. GStreamer Gst-nvdsosd plugin gst-plugins/gst-nvdsosd Source code for the GStreamer Gst-nvdsosd plugin to draw bboxes, text and other objects. Gstreamer Gst-nvdewarper plugin gst-plugins/gst-nvdewarper Source code for the GStreamer Gst-nvdewarper plugin to dewarp frames NvDsInfer library libs/nvdsinfer Source code for the NvDsInfer library, used by the Gst-nvinfer GStreamer plugin. NvDsInferServer library libs/nvdsinferserver Source code for the NvDsInferServer library, used by the Gst-nvinferserver GStreamer plugin. NvDsNmos library libs/nvdsnmos Source code for the NvDsNmos library, demonstrated by the DeepStream NMOS Application. NvMsgConv library libs/nvmsgsconv Source code for the NvMsgConv library, required by the Gst-nvmsgconv GStreamer plugin. Kafka protocol adapter libs/kafka_protocol_adapter Protocol adapter for Kafka. nvds_rest_server library libs/nvds_rest_server Source code for the rest server. nvds_customhelper libs/gstnvdscustomhelper Source code for \u201cnvdsmultiurisrcbin helper\u201d and custom \u201cgst-events, gst-messages and common configs\u201d required for rest server. nvdsinfer_customparser libs/nvdsinfer_customparser Custom model output parsing example for detectors and classifiers. Gst-v4l2 See the note below 1 Source code for v4l2 codecs. Gstreamer gst-nvdsvideotemplate plugin gst-plugins/gst-nvdsvideotemplate Source code for template plugin to implement video custom algorithms (non Gstreamer based) NvDsVideoTemplate custom library gst-plugins/gst-nvdsvideotemplate/customlib_impl Source code for custom library to implement video custom algorithms Gstreamer gst-nvdsaudiotemplate plugin gst-plugins/gst-nvdsaudiotemplate Source code for template plugin to implement audio custom algorithms (non Gstreamer based) NvDsVideoTemplate custom library gst-plugins/gst-nvdsaudiotemplate/customlib_impl Source code for custom library to implement audio custom algorithms Gstreamer gst-nvdsmetautils gst-plugins/gst-nvdsmetautils Source code for Gstreamer Gst-nvdsmetainsert and Gst-nvdsmetaextract plugins to process metadata NvDsMetaUtils SEI serialization library gst-plugins/gst-nvdsmetautils/sei_serialization Source code for custom meta de/serialization to embed in encoded bitstream as SEI data, required by Gst-nvdsmetautils plugins NvDsMetaUtils Audio serialization library gst-plugins/gst-nvdsmetautils/audio_metadata_serialization Source code for Audio NvDsFrameMeta de/serialization, required by Gst-nvdsmetautils plugins NvDsMetaUtils Video serialization library gst-plugins/gst-nvdsmetautils/video_metadata_serialization Source code for Video NvDsFrameMeta &amp; NvDsObjectMeta de/serialization, required by Gst-nvdsmetautils plugins Gstreamer gst-nvvideotestsrc plugin gst-plugins/gst-nvvideotestsrc Source code to generate video test data in a variety of formats and patterns that is written directly to GPU output buffers Gstreamer gst-nvdsspeech plugin gst-plugins/gst-nvdsspeech Interface for custom low level Automatic Speech Recognition (ASR) library that can be loaded by the Gst-nvdsasr plugin Gstreamer gst-nvdstexttospeech plugin gst-plugins/gst-nvdstexttospeech Interface for custom low level Text To Speech (TTS) library that can be loaded by the Gst-nvds_text_to_speech plugin Gstreamer gst-nvdspostprocess plugin gst-plugins/gst-nvdspostprocess Source code for the plugin and low level lib to provide a custom library interface for post processing on Tensor output of inference plugins (nvinfer/nvinferserver) Gstreamer gst-nvtracker plugin gst-plugins/gst-nvtracker Source code for the plugin to track the detected objects with persistent (possibly unique) IDs over time Gstreamer gst-nvdsanalytics plugin gst-plugins/gst-nvdsanalytics Interface for performing analytics on metadata attached by nvinfer (primary detector) and nvtracker Gstreamer gst-nvstreammux New plugin gst-plugins/gst-nvmultistream2 Source code for the plugin to form a batch of frames from multiple input sources DS3D lidar file reader custom lib libs/ds3d/dataloader/lidarsource Source code for DS3D lidar file reader with an implementaion of ds3d::dataloader interface, developer could follow it to implement custom lidar device catpure, see lib details in Custom Dataloader libnvds_lidarfileread Configuration Specifications DS3D lidar data reader custom process lib libs/ds3d/datafilter/lidar_preprocess Source code for DS3D lidar data processing with an implementaion of ds3d::datafilter interface DS3D lidar detection postprocess custom lib libs/ds3d/inference_custom_lib/ds3d_lidar_detection_postprocess Source code for DS3D lidar and sensor fusion(bevfusion) postprocessing custom lib DS3D lidar v2xfusion postprocess custom lib libs/ds3d/inference_custom_lib/ds3d_v2x_infer_custom_postprocess Source code for DS3D lidar and sensor fusion(v2xfusion) postprocessing custom lib DS3D lidar v2xfusion preprocess custom lib ds3d/inference_custom_lib/ds3d_v2x_infer_custom_preprocess Source code for DS3D sensor fusion(v2xfusion) preprocess custom lib Gstreamer Gst-nvurisrcbin plugin gst-plugins/gst-nvurisrcbin Source code for the Gstreamer Gst-nvurisrcbin plugin which is is a wrapper over uridecodebin with additional functionality of the file looping, rtsp reconnection and smart record Gstreamer Gst-nvmultiurisrcbin plugin gst-plugins/gst-nvmultiurisrcbin Source code for the Gstreamer Gst-nvmultiurisrcbin plugin which integrates gstnvurisrcbin, nvstreammux plugin with REST server support enabled by default. Footnotes 1 Gst-v4l2 sources are not present in DeepStream package. To download, follow these steps: Go to: https://developer.nvidia.com/embedded/downloads . In the Search filter field, enter L4T Select the appropriate item for L4T Release 36.4 . Search for L4T Driver Package (BSP) Sources Download the file and un-tar it, to get the .tbz2 file. Expand the .tbz2 file. Gst-v4l2 source files are in gst-nvvideo4linux2_src.tbz2 . libnvv4l2 sources are present in v4l2_libs_src.tbz2", "keywords": []}, {"id": 2340, "doc_id": 2340, "filename": "text/DS_C_Sample_Apps.html", "domain_name": "std", "name": "text/DS_C_Sample_Apps", "display_name": "C/C++ Sample Apps Source Details", "type": "doc", "display_type": "Page", "docname": "text/DS_C_Sample_Apps", "anchor": "", "priority": -1, "content": "The DeepStream SDK package includes archives containing plugins, libraries, applications, and source code. The sources directory is located at /opt/nvidia/deepstream/deepstream/sources for both Debian installation (on Jetson or dGPU) and SDK Manager installation. For tar packages the source files are in the extracted deepstream package. DeepStream Python bindings and sample applications are available as separate packages. For more information, see NVIDIA-AI-IOT/deepstream_python_apps . DeepStream graphs created using the Graph Composer are listed under Reference graphs section. For more information, see the Graph Composer Introduction . Reference test application Path inside sources directory Description Sample test application 1 apps/sample_apps/deepstream-test1 Sample of how to use DeepStream elements for a single H.264 stream: filesrc \u2192 decode \u2192 nvstreammux \u2192 nvinfer or nvinferserver (primary detector) \u2192 nvdsosd \u2192 renderer. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 2 apps/sample_apps/deepstream-test2 Sample of how to use DeepStream elements for a single H.264 stream: filesrc \u2192 decode \u2192 nvstreammux \u2192 nvinfer or nvinferserver (primary detector) \u2192 nvtracker \u2192 nvinfer or nvinferserver (secondary classifier) \u2192 nvdsosd \u2192 renderer. This app uses resnet18_trafficcamnet_pruned.onnx for detection and 2 classifier models (i.e., resnet18_vehiclemakenet_pruned.onnx, resnet18_vehicletypenet_pruned.onnx). Sample test application 3 apps/sample_apps/deepstream-test3 Builds on deepstream-test1 (simple test application 1) to demonstrate how to: Use multiple sources in the pipeline. Use a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codec. Configure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilization. Extract the stream metadata, which contains useful information about the frames in the batched buffer. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 4 apps/sample_apps/\u00addeepstream-test4 Builds on deepstream-test1 for a single H.264 stream: filesrc, decode, nvstreammux, nvinfer or nvinferserver, nvdsosd, renderer to demonstrate how to: Use the Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline. Create NVDS_META_EVENT_MSG type metadata and attach it to the buffer. Use NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and person. Implement \u201ccopy\u201d and \u201cfree\u201d functions for use if metadata is extended through the extMsg field. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 5 apps/sample_apps/\u00addeepstream-test5 Builds on top of deepstream-app. Demonstrates: Use of Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline for multistream. How to configure Gst-nvmsgbroker plugin from the config file as a sink plugin (for KAFKA, Azure, etc.). How to handle the RTCP sender reports from RTSP servers or cameras and translate the Gst Buffer PTS to a UTC timestamp. For more details refer the RTCP Sender Report callback function test5_rtcp_sender_report_callback() registration and usage in deepstream_test5_app_main.c . GStreamer callback registration with rtpmanager element\u2019s \u201chandle-sync\u201d signal is documented in apps-common/src/deepstream_source_bin.c . This app uses resnet18_trafficcamnet_pruned.onnx for detection. DeepStream 3D Multi-Modal Lidar Camera Sensor Fusion App apps/sample_apps/deepstream-3d-lidar-sensor-fusion The sample app deepstream-3d-lidar-sensor-fusion showcases a multi-modal sensor fusion pipeline for LiDAR and camera data using the DS3D framework. There are 2 pipelines integrated into this sample, ds3d multi-modal bevfusion with 6 cameras plus a lidar data fusion and 3D detection; v2x model Processes data from a single camera and a LiDAR, utilizing a batch size of 4. AMQP protocol test application libs/amqp_\u00adprotocol_adaptor Application to test AMQP protocol. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Azure MQTT test application libs/azure_protocol_adaptor Test application to show Azure IoT device2edge messaging and device2cloud messaging using MQTT. This app uses resnet18_trafficcamnet_pruned.onnx for detection. DeepStream reference application apps/sample_apps/\u00addeepstream-app Source code for the DeepStream reference application. This app uses resnet18_trafficcamnet_pruned.onnx for detection and 2 classifier models (i.e., resnet18_vehiclemakenet_pruned.onnx, resnet18_vehicletypenet_pruned.onnx). Dewarper example apps/sample_apps/deepstream-dewarper-test Demonstrates dewarper functionality for single or multiple 360-degree camera streams. Reads camera calibration parameters from a CSV file and renders aisle and spot surfaces on the display. Optical flow example apps/sample_apps/deepstream-nvof-test Demonstrates optical flow functionality for single or multiple streams. This example uses two GStreamer plugins (Gst-nvof and Gst-nvofvisual). The Gst-nvof element generates the MV (motion vector) data and attaches it as user metadata. The Gst-nvofvisual element visualizes the MV data using a predefined color wheel matrix. Custom meta data example apps/sample_apps/deepstream-user-metadata-test Demonstrates how to add custom or user-specific metadata to any component of DeepStream. The test code attaches a 16-byte array filled with user data to the chosen component. The data is retrieved in another component. This app uses resnet18_trafficcamnet_pruned.onnx for detection. MJPEG and JPEG decoder and inferencing example apps/sample_apps/deepstream-image-decode-test Builds on deepstream-test3 to demonstrate image decoding instead of video. This example uses a custom decode bin so the MJPEG codec can be used as input. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Handling metadata before Gst-nvstreammux apps/sample_apps/deepstream-gst-metadata-test Demonstrates how to set metadata before the Gst-nvstreammux plugin in the DeepStream pipeline, and how to access it after Gst-nvstreammux. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Gst-nvinfer tensor meta flow example apps/sample_apps/deepstream-infer-tensor-meta-app Demonstrates how to flow and access nvinfer tensor output as metadata. NOTE: This binary is not packaged due to OpenCV deprecation. This app needs to be compiled by the user. This app uses resnet18_trafficcamnet_pruned.onnx for detection and 2 classifier models (i.e., resnet18_vehiclemakenet_pruned.onnx, resnet18_vehicletypenet_pruned.onnx). Preprocess example apps/sample_apps/deepstream-preprocess-test Demonstrates inference on preprocessed ROIs configured for the streams. This app uses resnet18_trafficcamnet_pruned.onnx for detection. 3D action recognition Reference app apps/sample_apps/deepstream-3d-action-recognition Demonstrates a sequence batching based 3D or 2D model inference pipeline for action recognition. It also includes a sequence based preprocess custom lib for NCSHW temporal batching. Refer Prerequisites in README before running the application. This app uses resnet18_2d_rgb_hmdb5_32.etlt for 2D and resnet18_3d_rgb_hmdb5_32.etlt for 3D action recognition. Analytics example apps/sample_apps/deepstream-nvdsanalytics-test Demonstrates batched analytics like ROI filtering, Line crossing, direction detection and overcrowding. This app uses resnet18_trafficcamnet_pruned.onnx for detection. OpenCV example apps/sample_apps/deepstream-opencv-test Demonstrates the use of OpenCV in dsexample plugin. Need to compile dsexample with flag WITH_OPENCV=1 . This app uses resnet18_trafficcamnet_pruned.onnx for detection. Image as Metadata example Apps/sample_apps / deepstream-image-meta-test Demonstrates how to attach encoded image as meta data and save the images in jpeg format. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Appsrc and Appsink example apps/sample_apps/deepstream-appsrc-test Demonstrates AppSrc and AppSink usage for consuming and giving data from non DeepStream code respectively. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Cuda Appsrc and Appsink example apps/sample_apps/deepstream-appsrc-cuda-test Demonstrates how cuda frames acquired from outside DeepStream can be fed to a DeepStream pipeline. Transfer learning example apps/sample_apps/ deepstream-transfer-learning-app Demonstrates a mechanism to save the images for objects which have lesser confidence and the same can be used for training further. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Smart Record example apps/sample_apps/deepstream-testsr Demonstrates event based smart record functionality. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Audio+video+Text Synchronization (Alpha) apps/sample_apps/deepstream-avsync-app Demonstrates synchronization of audio, video and text output from nvdsasr in DeepStream pipeline. Note: This application requires Riva ASR services to be available. Refer prerequisites in README before running the application. This app uses Jasper models for Speech Recognition. DeepStream NMOS Application apps/sample_apps/deepstream-nmos This application demonstrates how to create a DeepStream app as an NMOS Node. It uses a library (NvDsNmos) which provides the APIs to create, destroy and internally manage the NMOS Node. The NMOS Node can automatically discover and register with an NMOS Registry on the network using the AMWA IS-04 Registration API. It also shows how to create various Video and Audio pipelines, run them simultaneously and reconfigure them based on NMOS events such as AMWA IS-05 Connection API requests from an NMOS Controller. DeepStream UCX test apps/sample_apps/deepstream-ucx-test Demonstrates how to use the communication plugin gst-nvdsucx with DeepStream SDK. The application has been validated with kernel-5.15. DeepStream 3D Depth Camera Reference App apps/sample_apps/deepstream-3d-depth-camera Demonstrates how to setup depth capture, depth render, 3D-point-cloud processing and 3D-points render pipelines over DS3D interfaces and custom-libs of ds3d::dataloader , ds3d::datafilter and ds3d::datarender . See more details in DeepStream 3D Depth Camera App DeepStream 3D Lidar Data Inferencing Reference App apps/sample_apps/deepstream-lidar-inference-app Demonstrates how to read in point cloud data, inference pont cloud data with pointpillar 3D objects detection model with Triton, render point cloud data and 3D objects with GLES. The whole application is based on DS3D interfaces and custom-libs of ds3d::dataloader , ds3d::datafilter and ds3d::datarender . See more details in DeepStream 3D Lidar Inference App Deepstream Server Application apps/sample_apps/deepstream-server Demonstrates REST API support to control DeepStream pipeline on-the-fly. DeepStream Can Orientation Sample App apps/sample_apps/deepstream-can-orientation-app Demonstrates can orientation detection with CV-based VPI template matching algorithm. VPI template matching is implemented with DeepStream video template plugin. See more details in apps/sample_apps/deepstream-can-orientation-app/README Triton Ensemble Model Example sources/TritonBackendEnsemble Configuration files, Triton custom C++ backend implementation and custom library implementation for Triton ensemble model example. Demonstrates use of Triton ensemble models with gst-nvinferserver plugin and how to implement custom Triton C++ backend to access DeespStream metadata like stream ID using multi-input tensors. deepstream-multigpu-nvlink-test apps/sample_apps/deepstream-multigpu-nvlink-test Uses gst-nvdsxfer plugin to simulate pipelines with NVLINK enabled multi-gpu setup to achieve better performance. User can use \u201cposition\u201d param of nvxfer config section from dsmultigpu_config.yml file to simulate gst-nvxfer plugin supported various multi-gpu usecase pipelines. deepstream-ipc-test-app apps/sample_apps/deepstream-ipc-test-app Demonstrates decoder buffer sharing IPC use-case on Jetson platform for live streams to optimize NVDEC HW utilization. This example uses IPC sink and IPC source element to interconnect GStreamer pipelines that run in different processes. Apps which write output files (example: deepstream-image-meta-test , deepstream-testsr , deepstream-transfer-learning-app ) should be run with sudo permission.", "keywords": []}, {"id": 2341, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "page", "name": "text/DS_Can_Orientation#build-application-from-source", "display_name": "Build application From Source", "type": "section", "display_type": "Page section", "docname": "text/DS_Can_Orientation", "anchor": "build-application-from-source", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-can-orientation-app . Run the following commands: $ make $ make install", "keywords": []}, {"id": 2342, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "page", "name": "text/DS_Can_Orientation#custom-lib-libnvds-vpicanmatch-so-settings-for-can-template-matching", "display_name": "Custom lib libnvds_vpicanmatch.so Settings for Can Template Matching", "type": "section", "display_type": "Page section", "docname": "text/DS_Can_Orientation", "anchor": "custom-lib-libnvds-vpicanmatch-so-settings-for-can-template-matching", "priority": -1, "content": "The table below indicates the group settings for config_video_template_can_match.yaml . Property Meaning Type and Range Example radius Indicate radius of the can, unit in cm Float radius: 3.3 distance Indicate distance from camera to can, unit in cm Float distance: 12.7 center Indicate center of the can in input raw image normalized by width Float center: 0.5 can_width Indicate width of the can in input raw image normalized by width Float can_width: 1.0 input_width Indicate width of input raw image, It should be the input image width Uint32 input_width: 870 input_height Indicate height of input raw image, It should be the input image height Uint32 input_height: 1200 crop_width Indicate width of dewarped inference image to be used to match with reference image Uint32 crop_width: 500 target_x Indicate target center in reference image in pixels Uint32 target_x: 250 ref_image Specify reference image paramaters YAML node ref_image.perimeter Indicate can circumference in reference image in pixels Uint32 ref_image: perimeter: 1689 ref_image.image_path Indicate refernece image path, must be in color format GREY ref_image: image_path: data/reference_sample.grey ref_image.image_format Indicate refernece image color format, only GREY supported in this version String: fourcc ref_image: image_format: GREY ref_image.image_width Indicate refernece image width Uint32 ref_image: image_width: 2508 ref_image.image_height Indicate refernece image height Uint32 ref_image: image_height: 625", "keywords": []}, {"id": 2343, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "page", "name": "text/DS_Can_Orientation#deepstream-can-orientation-app-settings", "display_name": "deepstream-can-orientation-app settings", "type": "section", "display_type": "Page section", "docname": "text/DS_Can_Orientation", "anchor": "deepstream-can-orientation-app-settings", "priority": -1, "content": "The table below indicates the group settings for ds_can_orientation_jpg.yaml and ds_can_orientation_raw.yaml . Group Property Meaning Type and Range Example source source settings YAML node source uri decodebin uri string uri: multifile:///opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-can-orientation-app/data/sample1/test_sample_%2504d.jpg source framerate framerate for multifile source and raw format data source string framerate: 10/1 source frame_settings Raw frame setting description YAML node frame_settings: format: GREY width: 870 height: 1200 source.frame_settings format color format, choose from [GREY, RGBA] String: [GREY, RGBA] format: GREY source.frame_settings width width of input raw frame Integer: &gt;0 width: 870 source.frame_settings height height of input raw frame Integer: &gt;0 height: 1200 source camera Basler camera settings YAML node camera: device_serial_number: 0815-0000 pfs_path: basler_cam_emulation_0815-0000.pfs width: 870 height: 1200 source.camera device_serial_number Basler camera serial number String device_serial_number: 0815-0000 source.camera pfs_path Basler PFS setting file path String pfs_path: basler_cam_emulation_0815-0000.pfs source.camera width Basler camera capture image width Integer: &gt;0 width: 870 source.camera height Basler camera capture image height Integer: &gt;0 height: 1200 video_template deepstream video template plugin settings YAML node video_template customlib_name Indicate custom-lib location for video template to load String customlib_name: /opt/nvidia/deepstream/deepstream/lib/libnvds_vpicanmatch.so video_template customlib_props Indicate the configuration settings for the custom-lib String customlib_props: config-file:config_video_template_can_match.yaml sink sink settings YAML node sink: egl_display: true sink egl_display Indicate whether enable EGL display bool egl_display: true sink sync Indicate whether do snchronization on timestamp bool sync: true debug debug settings YAML node debug print_result Indicate whether print orientation result bool print_result: true", "keywords": []}, {"id": 2344, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "page", "name": "text/DS_Can_Orientation#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_Can_Orientation", "anchor": "prerequisites", "priority": -1, "content": "Go to the folder sources/apps/sample_apps/deepstream-can-orientation-app Prepare all test sample images and reference images. Run the following command to un-compress can test and reference images into folder data , and generate raw sample image data files. Run command $ ./prepare_sample_data.sh If there is file permission issues, try with sudo . Export DISPLAY environment to correct display. e.g. export DISPLAY=:0.0 . For Basler camera emulation test, follow instructions in deepstream-can-orientation-app/README to install and build all dependencies. This emulation does not require a physical Basler camera. Users can modify and configure their Basler cameras through Pylon Viewer to create new PFS and then use it in this app.", "keywords": []}, {"id": 2345, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "page", "name": "text/DS_Can_Orientation#run-deepstream-can-orientation-examples", "display_name": "Run DeepStream Can Orientation Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_Can_Orientation", "anchor": "run-deepstream-can-orientation-examples", "priority": -1, "content": "Run tests for JPEG files with EGL display: $ deepstream-can-orientation-app -c ds_can_orientation_jpg.yaml Run tests for GREY raw datafile with EGL display: $ deepstream-can-orientation-app -c ds_can_orientation_raw.yaml -r data/test_samples_raw.grey Run tests for performance tests without display. Update ds_can_orientation_raw.yaml . sink: egl_display: false sync: false debug: print_result: fasle Run performance tests: $ deepstream-can-orientation-app -c ds_can_orientation_raw.yaml -r data/test_samples_raw.grey -l Run Basler Camera Emulation tests: $ deepstream-can-orientation-app -c ds_can_orientation_basler_cam.yaml", "keywords": []}, {"id": 2346, "doc_id": 2346, "filename": "text/DS_Can_Orientation.html", "domain_name": "std", "name": "text/DS_Can_Orientation", "display_name": "DeepStream Can Orientation App", "type": "doc", "display_type": "Page", "docname": "text/DS_Can_Orientation", "anchor": "", "priority": -1, "content": "The deepstream-can-orientation-app sample application is provided at app/sample_apps/deepstream-can-orientation-app for your reference. This example demonstrates can orientation detection for industrial can position and rotation angles. There are several configurations for raw data input, JPEG input and Basler camera emulation input settings. The image below shows the architecture of this reference app. video template would load custom lib libnvds_vpicanmatch.so to do CV-based VPI template matching for industrial can orientation detection.", "keywords": []}, {"id": 2347, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#are-multiple-parallel-records-on-same-source-supported", "display_name": "Are multiple parallel records on same source supported?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "are-multiple-parallel-records-on-same-source-supported", "priority": -1, "content": "No. Only single record at a time on the same source is supported. You need to stop the ongoing record to start the new recording again.", "keywords": []}, {"id": 2348, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#can-gst-nvinferserver-support-inference-on-multiple-gpus", "display_name": "Can Gst-nvinferserver support inference on multiple GPUs?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "can-gst-nvinferserver-support-inference-on-multiple-gpus", "priority": -1, "content": "Not yet. When running on multiple-gpu platform, you\u2019ll need a specific single gpu-id for GPU instances. If no gpu-id is specified, all GPU instances would be running together by default. This could cause unexpected behaviors. Update config.pbtxt and specify single gpu-id explicitly. instance_group { count: 1 gpus: 0 kind: KIND_GPU } Or specify single GPU in docker cmdline: docker run -it --rm --gpus &#x27;&quot;&#x27;device=0&#x27;&quot;&#x27; ...", "keywords": []}, {"id": 2349, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#can-gst-nvinferserver-support-models-across-processes-or-containers", "display_name": "Can Gst-nvinferserver support models across processes or containers?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "can-gst-nvinferserver-support-models-across-processes-or-containers", "priority": -1, "content": "The plugin can be configured to use gRPC API to access Triton Inference server using the Triton Client library. In this mode, the Triton server is run as a separate process, on same or different machine / container. When the plugin is configured for Triton Server C-APIs, it doesn\u2019t support client/server architecture. But the single process could run a standalone Triton model repo no matter how many models running together.", "keywords": []}, {"id": 2350, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#can-i-record-the-video-with-bounding-boxes-and-other-information-overlaid", "display_name": "Can I record the video with bounding boxes and other information overlaid?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "can-i-record-the-video-with-bounding-boxes-and-other-information-overlaid", "priority": -1, "content": "To have better performance and optimization, smart record avoids transcoding and caches only encoded frames. To that extent recording the video with overlaid bounding boxes is not possible. But you can implement that use case in two ways: Run the inference pipeline on recorded video and save the output in a file using sink ( type = filesink ) Add encoding components in the pipeline after OSD and then add smart record module.", "keywords": []}, {"id": 2351, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#can-jetson-platform-support-the-same-features-as-dgpu-for-triton-plugin", "display_name": "Can Jetson platform support the same features as dGPU for Triton plugin?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "can-jetson-platform-support-the-same-features-as-dgpu-for-triton-plugin", "priority": -1, "content": "Not exactly. dGPU can support most models such as TensorRT, Tensorflow (and TF-TRT), ONNX(and with TRT optimization), Pytorch. Jetson can support TensorRT, Tensorflow (and TF-TRT). Support for other models are coming in future releases. For more details, see Deepstream Plugin Guide section.", "keywords": []}, {"id": 2352, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#can-users-set-different-model-repos-when-running-multiple-triton-models-in-single-process", "display_name": "Can users set different model repos when running multiple Triton models in single process?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "can-users-set-different-model-repos-when-running-multiple-triton-models-in-single-process", "priority": -1, "content": "No. All config files for a same deepstream-app process must have same model_repo. Otherwise GSt-nvinferserver may report error or use random config on model_repo . infer_config { triton { model_repo { root: \u201cpath/to/model_repo\u201d strict_model_config: true tf_gpu_memory_fraction: 0.35 ... } } }", "keywords": []}, {"id": 2353, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#deepstream-apps-fails-while-encoding-on-orin-nano", "display_name": "DeepStream apps fails while encoding on Orin Nano", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "deepstream-apps-fails-while-encoding-on-orin-nano", "priority": -1, "content": "Orin does not have HW encoder. You should modify the application code to use SW encoder.", "keywords": []}, {"id": 2354, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#does-deepstream-support-10-bit-video-streams", "display_name": "Does DeepStream Support 10 Bit Video streams?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "does-deepstream-support-10-bit-video-streams", "priority": -1, "content": "Decoder supports 10-bit as well as 12bit 4:2:0 semiplanar decoding (P010_10LE/I420_12LE), although most of the components work on 8-bit input. 10 and 12bit 4:4:4 planar decoding (Y444_10LE/Y444_12LE) is also supported, but limited to x86/dGPU platforms. It is suggested to use nvvideoconvert to transform stream from 10-bit to 8-bit, and then add the relevant components, if they do not support 10/12 bit streams. Sometimes, RTSP output from DeepStream is not observed remotely Try running following pipeline to see if there is issue in network. With this you\u2019ll be able to see output. gst-launch-1.0 uridecodebin uri=rtsp://&lt;rtsp link&gt; ! nveglglessink sync=0 on remote machine. For 12bit NV12 format, the output caps shows I420_12LE. But the data is handled as semiplanar 12 bit data. This is a workaround since gstreamer v1.16 does not have the particular caps for 12 bit NV12. Downstream component should process it considering as 12bit NV12 only.", "keywords": []}, {"id": 2355, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#does-gst-nvinferserver-support-triton-multiple-instance-groups", "display_name": "Does Gst-nvinferserver support Triton multiple instance groups?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "does-gst-nvinferserver-support-triton-multiple-instance-groups", "priority": -1, "content": "Yes, you can configure Triton model config.pbtxt with multiple instances on single GPU or CPU to make them run in parallel. If multiple instances are configured on different settings (e.g. run an instance on GPU, and another instance on GPU), warmup of the instances is recommended. This is to avoid timeout or other live streaming errors in case the specific instance takes too long to initialize on the first frame. To enable multiple instances, see: https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_configuration.html#instance-groups To enable warmup, see: https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_configuration.html#model-warmup", "keywords": []}, {"id": 2356, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#does-smart-record-module-work-with-local-video-streams", "display_name": "Does smart record module work with local video streams?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "does-smart-record-module-work-with-local-video-streams", "priority": -1, "content": "Yes. Smart record module expects encoded frames which can be from either local video or RTSP stream. But deepstream-test5-app only supports RTSP sources for smart record.", "keywords": []}, {"id": 2357, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-check-gpu-and-memory-utilization-on-a-dgpu-system", "display_name": "How can I check GPU and memory utilization on a dGPU system?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-check-gpu-and-memory-utilization-on-a-dgpu-system", "priority": -1, "content": "Enter nvidia-smi or nvidia-settings on the console.", "keywords": []}, {"id": 2358, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-construct-the-deepstream-gstreamer-pipeline", "display_name": "How can I construct the DeepStream GStreamer pipeline?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-construct-the-deepstream-gstreamer-pipeline", "priority": -1, "content": "Here are few examples of how to construct the pipeline. To run these example pipelines as-is, run the applications from the samples directory: V4l2 decoder \u2192 nvinfer \u2192 nvtracker \u2192 nvinfer (secondary) \u2192 nvmultistreamtiler \u2192 nvdsosd \u2192 nveglglessink For multistream (4x1080p) operation on dGPU: $ gst-launch-1.0 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m batch-size=4 width=1920 height=1080 ! nvinfer config-file-path= configs/deepstream-app/config_infer_primary.txt \\ batch-size=4 unique-id=1 ! nvtracker ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so \\ ! nvinfer config-file-path= configs/deepstream-app/config_infer_secondary_vehicletypes.txt batch-size=16 unique-id=2 infer-on-gie-id=1 infer-on-class-ids=0 \\ ! nvmultistreamtiler rows=2 columns=2 width=1280 height=720 ! nvvideoconvert ! nvdsosd ! nveglglessink filesrc location= streams/sample_1080p_h264.mp4 \\ ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_2 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_3 For multistream (4x1080p) operation on Jetson: $ gst-launch-1.0 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m batch-size=4 width=1920 height=1080 ! nvinfer config-file-path= configs/deepstream-app/config_infer_primary.txt \\ batch-size=4 unique-id=1 ! nvtracker ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so \\ ! nvinfer config-file-path= configs/deepstream-app/config_infer_secondary_vehicletypes.txt batch-size=16 unique-id=2 infer-on-gie-id=1 infer-on-class-ids=0 \\ ! nvmultistreamtiler rows=2 columns=2 width=1280 height=720 ! nvvideoconvert ! nvdsosd ! nv3dsink \\ filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_1 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_2 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_3 For single stream (1080p) operation on dGPU: $ gst-launch-1.0 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path= configs/deepstream-app/config_infer_primary.txt \\ batch-size=1 unique-id=1 ! nvtracker ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so \\ ! nvinfer config-file-path= configs/deepstream-app/config_infer_secondary_vehicletypes.txt batch-size=16 unique-id=2 infer-on-gie-id=1 infer-on-class-ids=0 \\ ! nvmultistreamtiler rows=1 columns=1 width=1280 height=720 ! nvvideoconvert ! nvdsosd ! nveglglessink For single stream (1080p) operation on Jetson: $ gst-launch-1.0 filesrc location= streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path= configs/deepstream-app/config_infer_primary.txt \\ batch-size=1 unique-id=1 ! nvtracker ll-lib-file=/opt/nvidia/deepstream/deepstream /lib/libnvds_nvmultiobjecttracker.so \\ ! nvinfer config-file-path= configs/deepstream-app/config_infer_secondary_vehicletypes.txt batch-size=16 unique-id=2 infer-on-gie-id=1 infer-on-class-ids=0 \\ ! nvmultistreamtiler rows=1 columns=1 width=1280 height=720 ! nvvideoconvert ! nvdsosd ! nv3dsink JPEG decode Using nvv4l2decoder on Jetson: $ gst-launch-1.0 filesrc location= ./streams/sample_720p.jpg ! jpegparse ! nvv4l2decoder ! nv3dsink Using nvv4l2decoder on dGPU: $ gst-launch-1.0 filesrc location= ./streams/sample_720p.jpg ! jpegparse ! nvv4l2decoder ! nveglglessink Using nvjpegdec on Jetson: $ gst-launch-1.0 filesrc location= ./streams/sample_720p.jpg ! nvjpegdec ! nv3dsink Using nvjpegdec on dGPU: $ gst-launch-1.0 filesrc location= ./streams/sample_720p.jpg ! nvjpegdec ! nveglglessink Dewarper On dGPU: $ gst-launch-1.0 uridecodebin uri= file://`pwd`/../../../../samples/streams/sample_cam6.mp4 ! nvvideoconvert \\ ! nvdewarper source-id=6 num-output-buffers=4 config-file=config_dewarper.txt ! m.sink_0 nvstreammux name=m width=1280 height=720 batch-size=4 \\ batched-push-timeout=100000 num-surfaces-per-frame=4 ! nvmultistreamtiler rows=1 columns=1 width=720 height=576 ! nvvideoconvert ! nveglglessink On Jetson: $ gst-launch-1.0 uridecodebin uri= file://`pwd`/../../../../samples/streams/sample_cam6.mp4 ! nvvideoconvert ! nvdewarper source-id=6 num-output-buffers=4 \\ config-file=config_dewarper.txt ! m.sink_0 nvstreammux name=m width=1280 height=720 batch-size=4 batched-push-timeout=100000 \\ num-surfaces-per-frame=4 ! nvmultistreamtiler rows=1 columns=1 width=720 height=576 ! nvvideoconvert ! nv3dsink This Gst pipeline must be run from the dewarper test application directory, sources/apps/sample_apps/deepstream-dewarper-test . This pipeline runs only for four surfaces. To run for one, two, or three surfaces, use the dewarper test application. Dsexample On dGPU: $ gst-launch-1.0 filesrc location = ./streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m width=1280 height=720 batch-size=1 ! nvinfer config-file-path= ./configs/deepstream-app/config_infer_primary.txt \\ ! dsexample full-frame=1 ! nvvideoconvert ! nvdsosd ! nveglglessink sync=0 On Jetson: $ gst-launch-1.0 filesrc location = ./streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m width=1280 height=720 batch-size=1 ! nvinfer config-file-path= ./configs/deepstream-app/config_infer_primary.txt \\ ! dsexample full-frame=1 ! nvvideoconvert ! nvdsosd ! nv3dsink sync=0", "keywords": []}, {"id": 2359, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-display-graphical-output-remotely-over-vnc-how-can-i-determine-whether-x11-is-running", "display_name": "How can I display graphical output remotely over VNC? How can I determine whether X11 is running?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-display-graphical-output-remotely-over-vnc-how-can-i-determine-whether-x11-is-running", "priority": -1, "content": "If the host machine is running X, starting VNC is trivial. Otherwise you must start X, then start VNC. To determine whether X is running, check the DISPLAY environment variable. If X is not running you must start it first, then run DeepStream with GUI, or set type to 1 or 3 under sink groups to select fakesink or save to a file. If you are using an NVIDIA\u00ae Tesla\u00ae GPU Accelerators (compute-only cards without a display), you can set type to 4 for DeepStream output RTSP streaming. See the NVIDIA DeepStream SDK Development Guide for sink settings or create a virtual display to visualize the output using VNC. Refer to How to visualize the output if the display is not attached to the system in Quickstart Guide for more details", "keywords": []}, {"id": 2360, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-interpret-frames-per-second-fps-display-information-on-console", "display_name": "How can I interpret frames per second (FPS) display information on console?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-interpret-frames-per-second-fps-display-information-on-console", "priority": -1, "content": "The FPS number shown on the console when deepstream-app runs is an average of the most recent five seconds. The number in brackets is average FPS over the entire run. The numbers are displayed per stream. The performance measurement interval is set by the perf-measurement-interval-sec setting in the configuration file.", "keywords": []}, {"id": 2361, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-run-the-deepstream-sample-application-in-debug-mode", "display_name": "How can I run the DeepStream sample application in debug mode?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-run-the-deepstream-sample-application-in-debug-mode", "priority": -1, "content": "Enter this command: $ deepstream-app -c &lt;config&gt; --gst-debug=&lt;debug#&gt; Where: &lt;config&gt; is the pathname of the configuration file &lt;debug#&gt; is a number specifying the amount of detail in the debugging output For information about debugging tools, see: https://gstreamer.freedesktop.org/documentation/tutorials/basic/debugging-tools.html Running Deepstream app over SSH (via putty) with X11 forwarding does not work.", "keywords": []}, {"id": 2362, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-specify-rtsp-streaming-of-deepstream-output", "display_name": "How can I specify RTSP streaming of DeepStream output?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-specify-rtsp-streaming-of-deepstream-output", "priority": -1, "content": "You can enable remote display by adding an RTSP sink in the application configuration file. The sample configuration file source30_1080p_dec_infer-resnet_tiled_display_int8.txt has an example of this in the [sink2] section. You must set the enable flag to 1 . Once you enable remote display, the application prints the RTSP URL, which you can open in any media player like VLC. Note: When using VLC to view DeepStream RTSP sink output remotely, please force usage of TCP to avoid unnecessary packet drops. Example command to force TCP: $ vlc --rtsp-tcp rtsp://path/to/stream", "keywords": []}, {"id": 2363, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-can-i-verify-that-cuda-was-installed-correctly", "display_name": "How can I verify that CUDA was installed correctly?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-can-i-verify-that-cuda-was-installed-correctly", "priority": -1, "content": "Check the CUDA version: $ nvcc --version", "keywords": []}, {"id": 2364, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-do-i-configure-the-pipeline-to-get-ntp-timestamps", "display_name": "How do I configure the pipeline to get NTP timestamps?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-do-i-configure-the-pipeline-to-get-ntp-timestamps", "priority": -1, "content": "To get NTP timestamps, set attach-sys-ts property to FALSE on nvstreammux component.", "keywords": []}, {"id": 2365, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-do-i-obtain-individual-sources-after-batched-inferencing-processing-what-are-the-sample-pipelines-for-nvstreamdemux", "display_name": "How do I obtain individual sources after batched inferencing/processing? What are the sample pipelines for nvstreamdemux?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-do-i-obtain-individual-sources-after-batched-inferencing-processing-what-are-the-sample-pipelines-for-nvstreamdemux", "priority": -1, "content": "Some sample nvstreamdemux pipelines: gst-launch-1.0 filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_0 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_1 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_2 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_3 \\ nvstreammux name=m width=1920 height=1080 batch-size=4 batched-push-timeout=40000 ! \\ queue ! nvinfer config-file-path=&lt;config&gt; batch-size=4 ! \\ queue ! nvtracker ll-lib-file=&lt;lib-file&gt; ! \\ nvstreamdemux name=d \\ d.src_0 ! queue ! nvvideoconvert ! nvdsosd ! nveglglessink \\ d.src_1 ! queue ! nvvideoconvert ! nvdsosd ! nveglglessink \\ d.src_2 ! queue ! nvvideoconvert ! nvdsosd ! nveglglessink \\ d.src_3 ! queue ! nvvideoconvert ! nvdsosd ! nveglglessink Queue element should be inserted after every nvstreamdemux src pad. It is not required to demux all sources / create all nvstreamdemux src pad. Also, the downstream pipeline for every source may be different. Sample pipeline: gst-launch-1.0 filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_0 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_1 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_2 \\ filesrc location = sample_1080p_h264.mp4 ! decodebin ! m.sink_3 \\ nvstreammux name=m width=1920 height=1080 batch-size=4 batched-push-timeout=40000 ! \\ queue ! nvinfer config-file-path=&lt;config&gt; batch-size=4 ! \\ queue ! nvtracker ll-lib-file=&lt;lib-file&gt; ! \\ vstreamdemux name=d \\ d.src_1 ! queue ! nvvideoconvert ! nvdsosd ! nvvideoconvert ! nvv4l2h264enc ! h264parse ! qtmux ! filesink location=out.mp4 \\ d.src_2 ! queue ! nvvideoconvert ! nvdsosd ! nveglglessink", "keywords": []}, {"id": 2366, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-do-i-profile-deepstream-pipeline", "display_name": "How do I profile DeepStream pipeline?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-do-i-profile-deepstream-pipeline", "priority": -1, "content": "You can use NVIDIA \u00ae  Nsight \u2122 Systems, a system-wide performance analysis tool. See https://developer.nvidia.com/nsight-systems for more details.", "keywords": []}, {"id": 2367, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-do-i-uninstall-deepstream", "display_name": "How do I uninstall DeepStream?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-do-i-uninstall-deepstream", "priority": -1, "content": "For dGPU: To remove all previous DeepStream 3.0 or prior installations, enter the command: $ sudo rm -rf /usr/local/deepstream /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstnv* /usr/bin/deepstream* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libnvdsgst* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/deepstream* /opt/nvidia/deepstream/deepstream* $ sudo rm -rf /usr/lib/x86_64-linux-gnu/libv41/plugins/libcuvidv4l2_plugin.so To remove DeepStream 4.0 or later installations: Open the uninstall.sh file in /opt/nvidia/deepstream/deepstream/ Set PREV_DS_VER as 4.0 Run the script as sudo: ./uninstall.sh For Jetson: Flash the target device with the latest release of JetPack.", "keywords": []}, {"id": 2368, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-does-secondary-gie-crop-and-resize-objects", "display_name": "How does secondary GIE crop and resize objects?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-does-secondary-gie-crop-and-resize-objects", "priority": -1, "content": "SGIE will crop the object from NvStreamMux buffer using the object\u2019s bbox detected by the Primary GIE. The crop is then scaled/converted to the network resolution/color format. For example, if the NvStreamMux resolution is 1920x1080, SGIE will crop using object bbox co-ordinates (e.g. x=1000, y=20, w=400, y=500) from the 1920x1080 image and then scale it to the SGIE network resolution (say 224x224). In practice, the object crop + scaling + color conversion happens in one go.", "keywords": []}, {"id": 2369, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-enable-tensorrt-optimization-for-tensorflow-and-onnx-models", "display_name": "How to enable TensorRT optimization for Tensorflow and ONNX models?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-enable-tensorrt-optimization-for-tensorflow-and-onnx-models", "priority": -1, "content": "To learn details TensorRT optimization setting in Triton models, see: triton-inference-server/server TF-TRT is supported on both dGPU and Jetson platforms. 1. Open the model\u2019s Triton config.pbtxt file 2. Make sure GPU instance enabled 3. Append tensorrt accelerator.(e.g. triton_model_repo/ssd_mobilenet_v1_coco_2018_01_28/config.pbtxt ) optimization { execution_accelerators { gpu_execution_accelerator : [ { name : &quot;tensorrt&quot; parameters { key: &quot;precision_mode&quot; value: &quot;FP16&quot; } }] }} For more on TF-TRT parameters, see TF-TRT API in Tensorflow 1.x. is_dynamic_op is set to True natively in Triton. Additionally, you can generate offline TF-TRT models by their own script running with Tensorflow environment. Read TF-TRT User guide to generate offline(static) models. Once the original online model is replaced by offline model, remove optimization block in case TF-TRT online runs again to overwrite offline TF-TRT caches. ONNX is supported on dGPU only. TensorRT optimization can be enabled by optimization { execution_accelerators { gpu_execution_accelerator : [ { name : &quot;tensorrt&quot; } ] }} The TensorRT engine caches will be generated at run time. It is getting started during initialization or first frame come. This might take from several seconds even to minutes depends on how heavy the model is and how good platform it is.", "keywords": []}, {"id": 2370, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-find-out-the-maximum-number-of-streams-supported-on-given-platform", "display_name": "How to find out the maximum number of streams supported on given platform?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-find-out-the-maximum-number-of-streams-supported-on-given-platform", "priority": -1, "content": "DeepStream can support as many streams as possible as long as application under run is not limited by memory/decode/compute capability.", "keywords": []}, {"id": 2371, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-find-the-performance-bottleneck-in-deepstream", "display_name": "How to find the performance bottleneck in DeepStream?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-find-the-performance-bottleneck-in-deepstream", "priority": -1, "content": "On dGPU (X86) : Run following command to check GPU, decoder, encoder, memory utilization: $nvidia-smi dmon You need to check the temperature and power usage as well. Performance is limited by the temperature and power numbers beyond the allowed limits for a given platform. To check if CPU is the bottleneck, run htop command on the console to see if any of the CPU core utilizations is ~100% On Jetson : Run following command to check CPU, GPU, and memory utilization: sudo./tegrastats For more details, see the link: https://docs.nvidia.com/jetson/l4t/index.html#page/Tegra%2520Linux%2520Driver%2520Package%2520Development%2520Guide%2FAppendixTegraStats.html%23wwpID0E0SB0HA .", "keywords": []}, {"id": 2372, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-fix-cannot-allocate-memory-in-static-tls-block-error", "display_name": "How to fix \u201ccannot allocate memory in static TLS block\u201d error?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-fix-cannot-allocate-memory-in-static-tls-block-error", "priority": -1, "content": "On Jetson, sometimes the following error might occur: (gst-plugin-scanner:21845): GStreamer-WARNING **: 04:34:02.887: Failed to load plugin &#x27;/usr/lib/aarch64-linux-gnu/gstreamer-1.0/libgstlibav.so&#x27;: /usr/lib/aarch64-linux-gnu/libgomp.so.1: cannot allocate memory in static TLS block This error can be fixed by running the following: export LD_PRELOAD=/usr/lib/aarch64-linux-gnu/libgomp.so.1", "keywords": []}, {"id": 2373, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-get-camera-calibration-parameters-for-usage-in-dewarper-plugin", "display_name": "How to get camera calibration parameters for usage in Dewarper plugin?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-get-camera-calibration-parameters-for-usage-in-dewarper-plugin", "priority": -1, "content": "Using calibrations algorithms like the one in OpenCV. For more details, please refer the following OpenCV links: For perspective input : https://docs.opencv.org/2.4.13.7/doc/tutorials/calib3d/camera_calibration/camera_calibration.html For fisheye input : https://docs.opencv.org/3.4/db/d58/group__calib3d__fisheye.html The mapping from dewarper configuration parameters to OpenCV parameters is: \u201cfocal-length\u201d =&gt; fx,fy \u201csrc-x0\u201d =&gt; cx \u201csrc-y0\u201d =&gt; cy Distortion coefficients: For perspective input : (k0,k1,k2,k3,k4) =&gt; (k1,k2,k3,p1,p2) For fisheye input : (k0,k1,k2,k3) =&gt; (k1,k2,k3,k4) EXIF data: The focal length (in pixels or pixels/radian) can also be acquired from the image EXIF data, by multiplying the focal length in millimeters by the pixel density in pixels per millimeter. The relevant EXIF tags are as follows: FocalLength (37386) FocalPlaneXResolution (41486) FocalPlaneYResolution (41487) FocalPlaneResolutionUnit (41488)", "keywords": []}, {"id": 2374, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-handle-operations-not-supported-by-triton-inference-server", "display_name": "How to handle operations not supported by Triton Inference Server?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-handle-operations-not-supported-by-triton-inference-server", "priority": -1, "content": "For details on handling unsupported operations, see: https://docs.nvidia.com/deeplearning/sdk/triton-inference-server-guide/docs/user_guide/custom_operations.html . The custom library mentioned in the document can be loaded in the DeepStream application by one of the following methods: Running the application as LD_PRELOAD=./libcustomOp.so deepstream-app -c &lt;app-config&gt; Add the custom-lib path in \u201cnvinferserver\u201d config file as infer_config { ... custom_lib { path: &quot;./libcustomOp.so&quot; } }", "keywords": []}, {"id": 2375, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-measure-pipeline-latency-if-pipeline-contains-open-source-components", "display_name": "How to measure pipeline latency  if pipeline contains open source components", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-measure-pipeline-latency-if-pipeline-contains-open-source-components", "priority": -1, "content": "If the open source component cannot be modified to measure latency using APIs mentioned in https://docs.nvidia.com/metropolis/deepstream/dev-guide/sdk-api/group__ee__nvlatency__group.html , then following approach can be used. You can insert a probe on sink pad of the decoder, measure the time at which input buffer arrives. Insert another probe on sink pad of the sink component and measure the time at which output buffer arrives corresponding to the input buffer . Time difference between these two will give you the latency of the buffer.", "keywords": []}, {"id": 2376, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-minimize-fps-jitter-with-ds-application-while-using-rtsp-camera-streams", "display_name": "How to minimize FPS jitter with DS application while using RTSP Camera Streams?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-minimize-fps-jitter-with-ds-application-while-using-rtsp-camera-streams", "priority": -1, "content": "Below are the few DeepStream application tuning parameters that can help to lower the FPS Jitter. Set the kernel receive max window size rmem_max to 52428800 or higher value: $ sudo sysctl -w net.core.rmem_max=52428800 $ sudo sysctl -p Also try to set DeepStream config file parameter under source section as udp-buffer-size=2000000 . Set Latency=1000 under the DeepStream Config File Source section. Set rtsp-reconnect-interval-sec=30 or 60 , so that it can wait for sufficient time required for camera to reboot and start before. DS application attempts camera reconnection after waiting for this duration. If deepstream-test5 application is used, then try running application with \u2013no-force-tcp parameter, which will use to RTP over UDP streaming instead of RTP over TCP streaming. Set perf-measurement-interval-sec=5 so that better average FPS reported over 5 seconds duration where few cameras transmits the packets in bursts. Sample DeepStream configuration file snippet with above tuning parameters as below: [application] enable-perf-measurement=1 mux-pool-size=8 perf-measurement-interval-sec=5 [source0] enable=1 #Type - 1=CameraV4L2 2=URI 3=MultiURI type=4 uri=rtsp://&lt;Camera URL&gt; num-sources=1 gpu-id=0 nvbuf-memory-type=0 latency=1000 rtsp-reconnect-interval-sec=30 udp-buffer-size=2000000", "keywords": []}, {"id": 2377, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-run-higher-number-of-streams-200-on-hopper-ampere-and-ada", "display_name": "How to run higher number of streams (200+) on Hopper,Ampere and ADA?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-run-higher-number-of-streams-200-on-hopper-ampere-and-ada", "priority": -1, "content": "To run higher number of streams, follow below steps: $sudo service display-manager stop #Make sure no process is running on GPU i.e. Xorg or trition server etc $ sudo pkill -9 Xorg #Remove kernel modules $ sudo rmmod nvidia_drm nvidia_modeset nvidia #Load Modules with Regkeys $ sudo modprobe nvidia NVreg_RegistryDwords=&quot;RMDebugOverridePerRunlistChannelRam = 1;RMIncreaseRsvdMemorySizeMB = 1024;RMDisableChIdIsolation = 0x1;RmGspFirmwareHeapSizeMB = 256&quot; $ sudo service display-manager start Note that these steps are applicable only in testing environment and not for production. This is a known issue with the driver.", "keywords": []}, {"id": 2378, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-save-frames-from-gstbuffer", "display_name": "How to save frames from GstBuffer?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-save-frames-from-gstbuffer", "priority": -1, "content": "To save frames from gst buffer you need to Map gst buffer using gst_buffer_map () API. Here is the pseudo code: GstMapInfo in_map_info; NvBufSurface *surface = NULL; memset (&amp;in_map_info, 0, sizeof (in_map_info)); if (!gst_buffer_map (inbuf, &amp;in_map_info, GST_MAP_READ)) { g_print (&quot;Error: Failed to map gst buffer\\n&quot;); } surface = (NvBufSurface *) in_map_info.data; Now that you have access to NvBufSurface structure, you can access actual frame memory and save it. At the end you need to unmap gst buffer using gst_buffer_unmap (inbuf, &amp;in_map_info) For more details, see gst_dsexample_transform_ip() in gst-dsexample plugin source code.", "keywords": []}, {"id": 2379, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-set-camera-calibration-parameters-in-dewarper-plugin-config-file", "display_name": "How to set camera calibration parameters in Dewarper plugin config file?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-set-camera-calibration-parameters-in-dewarper-plugin-config-file", "priority": -1, "content": "Focal length: Source focal length can be set using the property focal-length in dewarper configuration file. It has the units of \u201cpixels per radian\u201d. It can be specified as a single focal length or two different focal lengths for X and Y directions. Center of projection/optical center/principal point: The principal point can be set using the properties src-x0 and src-y0 . Distortion coefficients: Up to 5 (k0 to k4) distortion coefficients can be configured in Dewarper plugin using the property distortion . The plugin supports two types of distortion coefficients based on the type of input/source camera: Perspective camera input : To correct the distortion caused by perspective camera, 5 distortion coefficients are supported (k0 to k4) which consist of: 3 radial distortion coefficients : k0 to k2 2 tangential distortion coefficients : k3 &amp; k4 Fisheye camera input: To correct fisheye distortion, 4 distortion coefficients (k0 to k3) need to be specified. The distortion coefficients are unused for equirectangular input sources.", "keywords": []}, {"id": 2380, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-support-triton-ensemble-model", "display_name": "How to support Triton ensemble model?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-support-triton-ensemble-model", "priority": -1, "content": "See details in Triton Ensemble Models in :doc: DS_plugin_gst_nvinferserver section.", "keywords": []}, {"id": 2381, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-tune-gpu-memory-for-tensorflow-models", "display_name": "How to tune GPU memory for Tensorflow models?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-tune-gpu-memory-for-tensorflow-models", "priority": -1, "content": "When running TensorFlow models using Triton Inference Server, the GPU device memory may fall short. The allowed GPU device memory allocation for TensorFlow models can be tuned using the tf_gpu_memory_fraction parameter in the nvdsinferserver\u2019s config files ( config_infer_* ). For more details, see samples/configs/deepstream-app-triton/README . This parameter is same as Tensorflow config\u2019s per_process_gpu_memory_fraction . For more details, see: Tensorflow 1.x gpu-guide TF-TRT user guide", "keywords": []}, {"id": 2382, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#how-to-use-the-oss-version-of-the-tensorrt-plugins-in-deepstream", "display_name": "How to use the OSS version of the TensorRT plugins in DeepStream?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "how-to-use-the-oss-version-of-the-tensorrt-plugins-in-deepstream", "priority": -1, "content": "If TensorRT OSS plugins library is not already available, please follow instructions from NVIDIA/TensorRT to build the library. To use the library in DeepStream, export LD_PRELOAD=/path/to/oss/libnvinfer_plugin.so before running any DeepStream app.", "keywords": []}, {"id": 2383, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#i-started-the-record-with-a-set-duration-can-i-stop-it-before-that-duration-ends", "display_name": "I started the record with a set duration. Can I stop it before that duration ends?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "i-started-the-record-with-a-set-duration-can-i-stop-it-before-that-duration-ends", "priority": -1, "content": "Yes, running recording instance can be stopped any time.", "keywords": []}, {"id": 2384, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#migration-to-newer-gstreamer-version", "display_name": "Migration to  newer gstreamer version", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "migration-to-newer-gstreamer-version", "priority": -1, "content": "In order to migrate to newer gstreamer version (e.g. gstreamer-1.22.6) follow below steps: Prerequisites: Install below packages: apt-get install python3-pip pip3 install meson pip3 install ninja apt-get install libmount-dev apt-get install flex apt-get install flex bison apt-get install libglib2.0-dev Compilation and installation steps #Remove older version apt-get remove *gstreamer* mkdir /tmp/gst-&lt;gst-version&gt; #e.g. mkdir /tmp/gst-1.22.6 cd /tmp/gst-&lt;gst-version&gt; #e.g. cd /tmp/gst-1.22.6 #Clone the repository git clone https://gitlab.freedesktop.org/gstreamer/gstreamer.git cd gstreamer #Switch to gst-version git checkout &lt;gst-version-branch&gt; #e.g. git checkout 1.22.6 meson build --prefix=/usr ninja -C build/ cd build/ ninja install cd rm -rf &lt;directory created in step 2&gt; #e.g. rm -rf /tmp/gst-1.22.6 Check and confirm the newly installed gstreamer version: gst-inspect-1.0 --version Run commands with sudo when prompted for permissions.", "keywords": []}, {"id": 2385, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#my-deepstream-performance-is-lower-than-expected-how-can-i-determine-the-reason", "display_name": "My DeepStream performance is lower than expected. How can I determine the reason?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "my-deepstream-performance-is-lower-than-expected-how-can-i-determine-the-reason", "priority": -1, "content": "See the Troubleshooting chapter in the NVIDIA DeepStream Development Guide .", "keywords": []}, {"id": 2386, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#on-jetson-platform-i-get-same-output-when-multiple-jpeg-images-are-fed-to-nvv4l2decoder-using-multifilesrc-plugin-why-is-that", "display_name": "On Jetson platform, I get same output when multiple Jpeg images are fed to nvv4l2decoder using multifilesrc plugin. Why is that?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "on-jetson-platform-i-get-same-output-when-multiple-jpeg-images-are-fed-to-nvv4l2decoder-using-multifilesrc-plugin-why-is-that", "priority": -1, "content": "For example multifilesrc location = frame%d.jpeg ! jpegparse ! nvv4l2decoder ! nv3dsink On Jetson platforms nvv4l2decoder needs to set property mjpeg=1 in order to work with multifilesrc .", "keywords": []}, {"id": 2387, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#on-jetson-platform-i-observe-lower-fps-output-when-screen-goes-idle", "display_name": "On Jetson platform, I observe lower FPS output when screen goes idle.", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "on-jetson-platform-i-observe-lower-fps-output-when-screen-goes-idle", "priority": -1, "content": "If you are running Ubuntu UI, then run below commands: $ export DISPLAY=:0 $ gsettings set org.gnome.desktop.session idle-delay 0 $ gsettings set org.gnome.desktop.lockdown disable-lock-screen &#x27;true&#x27; This will prevent screen lock and display going off. You should not see low fps when this is done If you are running this on a bare X server and have an ubuntu UI up then kill it with: $ sudo service gdm stop $ sudo pkill -15 Xorg Then start a bare X server with either of the 2 commands below: $ xinit &amp; $ X -noreset &amp; Wait for few seconds and then run: $ export DISPLAY=:0 $ xset s off; xset s noblank; xset -dpms", "keywords": []}, {"id": 2388, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#on-x86-why-do-i-get-below-error-during-compilation-and-running-of-application-libs-plugins-cuda-failure-the-provided-ptx-was-compiled-with-an-unsupported-toolchain-nvdsinferconvert-c3top3float-cuda-err-the-provided-ptx-was-compiled-with-an-unsupported-toolchain", "display_name": "On x86, why do I get below ERROR during compilation and running of application/libs/plugins : Cuda failure: the provided PTX was compiled with an unsupported toolchain NvDsInferConvert_C3ToP3Float: cuda err = the provided PTX was compiled with an unsupported toolchain.?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "on-x86-why-do-i-get-below-error-during-compilation-and-running-of-application-libs-plugins-cuda-failure-the-provided-ptx-was-compiled-with-an-unsupported-toolchain-nvdsinferconvert-c3top3float-cuda-err-the-provided-ptx-was-compiled-with-an-unsupported-toolchain", "priority": -1, "content": "Below steps are needed to be executed for source files which include \u201c.cu\u201d files during compilation and before running the application sudo apt-get install -y cuda-compat-12-x export LD_LIBRARY_PATH=/usr/local/cuda/compat:$LD_LIBRARY_PATH Replace x with the CUDA version mentioned in the Quickstart Guide Guide. This is applicable for data center GPUs only.", "keywords": []}, {"id": 2389, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#profiling-using-nvtx", "display_name": "Profiling using NVTX", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "profiling-using-nvtx", "priority": -1, "content": "NVIDIA \u00ae Tools Extension SDK (NVTX) provides APIs for annotating events, code ranges, and resources in an application. The core GStreamer plugins in DeepStreamSDK have integrated NVTX and the events and ranges can be captured and visualized using NVIDIA Nsight tool, Tegra System Profiler, and Visual Profiler to capture and visualize these events and ranges. For more information on NVTX, visit https://docs.nvidia.com/gameworks/content/gameworkslibrary/nvtx/nvidia_tools_extension_library_nvtx.htm . Following are the instructions on how to capture and visualize these events using deepstream-app with NVIDIA Nsight tool: Download and install Nsight tool from https://developer.nvidia.com/nsight-systems . Installation can be done using any file (.deb, .run or .rpm). Run the following command on terminal: $ nsys-ui Click on File -&gt; New Project Select target system as \u201cTarget for profiling\u201d. Now the deepstream-app process needs to be launched by Nsight tool for profiling. In order to do that, add the following command in \u201cCommand line with arguments\u201d: deepstream-app -c /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/source30_1080p_dec_infer-resnet_tiled_display_int8.txt In the tick box options, enable \u201cCollect NVTX trace\u201d. User can select other custom options as per requirement on the tool. To begin profiling, click on \u201cStart\u201d. Manually stop collection of traces once application run is completed. Once collection is stopped, in analytics view, the framewise analysis of each plugin will be shown, which gives an idea of time taken by each plugin. For more information about performance settings, refer \u201cPerformance\u201d section of troubleshooting page.", "keywords": []}, {"id": 2390, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-are-different-memory-transformations-supported-on-jetson-and-dgpu", "display_name": "What are different Memory transformations supported on Jetson and dGPU?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-are-different-memory-transformations-supported-on-jetson-and-dgpu", "priority": -1, "content": "dGPU: User can use NvBufSurfaceCopy() to copy from one memory type to another. If transformation is required, nvvideoconvert plugin support nvbuf-memory-type property to allow different type of memory. NvBufSurfTransform() can also be used to do the transformation between various CUDA types of memories. CUDA to NVBUF_MEM_SYSTEM transformation is not supported by NvBufSurfTransform directly, user can use NvBufSurfaceCopy() to copy into CUDA memory and perform transformation on that memory. Jetson: User can use NvBufSurfaceCopy() to copy from one memory type to another, although CUDA memory copies are not supported directly. User can perform NvBufSurfTransform() for transformation from NVBUF_MEM_SURFACE_ARRAY/NVBUF_MEM_DEFAULT to Cuda Memory, but user need to use GPU as compute device for doing the transformation, as VIC doesn\u2019t support transformation to CUDA memory or NVBUF_MEM_SYTEM . See NvBufSurfTransform APIs for more information.", "keywords": []}, {"id": 2391, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-are-different-memory-types-supported-on-jetson-and-dgpu", "display_name": "What are different Memory types supported on Jetson and dGPU?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-are-different-memory-types-supported-on-jetson-and-dgpu", "priority": -1, "content": "Memory Type Jetson dGPU or X86_64 NVBUF_MEM_DEFAULT Memory of type Surface Array which is 2D pitched allocated by default: Used by all hardware accelerator on the platform. Accessible by CPU using NvBufSurfaceMap and NvBufSurfaceSyncForCpu or NvBufSurfaceSyncForDevice based on read write usage. GPU Access using EGLImageCreate and Map APIs Memory of type Cuda Device is allocated by default, accessible only by GPU. User might need to have custom Cuda kernels to access or modify memory. Or NvBufSurfaceCopy to copy content into CPU accessible memory NVBUF_MEM_CUDA_PINNED Page Locked Memory allocated using cudaMallocHost () , accessible by CPU and GPU Page Locked Memory allocated using cudaMallocHost () accessible by CPU and GPU. NVBUF_MEM_CUDA_DEVICE Memory of type Cuda Device is allocated, accessible only by GPU. User might need to have custom Cuda kernels to access or modify memory. NvBufSurfaceCopy is not supported for Cuda memory on Jetson Memory of type Cuda Device is allocated, accessible only by GPU. User might need to have custom Cuda kernels to access or modify memory. Or NvBufSurfaceCopy to copy content into CPU accessible memory NVBUF_MEM_CUDA_UNIFIED Unsupported Unified Virtual Memory allocated using cudaMallocManaged () accessible by CPU and multiple GPU NVBUF_MEM_SURFACE_ARRAY Memory of type Surface Array which is 2D pitched allocated by default; used by all hardware accelerator on the platform; accessible by CPU using NvBufSurfaceMap () and NvBufSurfaceSyncForCpu () or NvBufSurfaceSyncForDevice () based on usage read write usage. GPU Access using EGLImageCreate and Map APIs Unsupported NVBUF_MEM_HANDLE Used internally for Jetson Unsupported NVBUF_MEM_SYSTEM Allocated using malloc Allocated using malloc ()", "keywords": []}, {"id": 2392, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-if-i-do-not-get-expected-30-fps-from-camera-using-v4l2src-plugin-in-pipeline-but-instead-get-15-fps-or-less-than-30-fps", "display_name": "What if I do not get expected 30 FPS from camera using v4l2src plugin in pipeline but instead get 15 FPS or less than 30 FPS?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-if-i-do-not-get-expected-30-fps-from-camera-using-v4l2src-plugin-in-pipeline-but-instead-get-15-fps-or-less-than-30-fps", "priority": -1, "content": "This could be possible due to exposure or lighting conditions around camera however this can be fixed by changing camera settings through below reference commands to change the exposure settings. v4l2-ctl -d /dev/video0 --list-ctrls v4l2-ctl --set-ctrl=exposure_auto=1 v4l2-ctl --set-ctrl=exposure_absolute=300", "keywords": []}, {"id": 2393, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-if-i-dont-set-default-duration-for-smart-record", "display_name": "What if I don\u2019t set default duration for smart record?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-if-i-dont-set-default-duration-for-smart-record", "priority": -1, "content": "Default value of record duration is 10 seconds.", "keywords": []}, {"id": 2394, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-if-i-dont-set-video-cache-size-for-smart-record", "display_name": "What if I don\u2019t set video cache size for smart record?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-if-i-dont-set-video-cache-size-for-smart-record", "priority": -1, "content": "Default value of video cache size is 30 seconds.", "keywords": []}, {"id": 2395, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-if-i-forgot-to-stop-the-recording", "display_name": "What if I forgot to stop the recording?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-if-i-forgot-to-stop-the-recording", "priority": -1, "content": "There is default duration setting and if record is not stopped by stop event it would be stopped automatically as per default duration value.", "keywords": []}, {"id": 2396, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-batch-size-differences-for-a-single-model-in-different-config-files-gie-group-in-source-config-inferserver-and-triton-models-config-pbtxt", "display_name": "What is batch-size differences for a single model in different config files (gie group in source, config_inferserver.., and Triton model\u2019s config.pbtxt)?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-batch-size-differences-for-a-single-model-in-different-config-files-gie-group-in-source-config-inferserver-and-triton-models-config-pbtxt", "priority": -1, "content": "Take TensorRT Primary_Detector for example: Gst-nvinferserver Plugin\u2019s config file configs/deepstream-app-triton/config_infer_plan_engine_primary.txt , defines infer_config { max_batch_size: 30 } This indicates the Gst plugin would pre-allocate 30 input buffers for preprocessing and pass at most 30 batched preprocessed buffers into Triton Runtime each time. This value must be &gt; 0 Deepstream-app\u2019s config file configs/deepstream-app-triton/source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt , defines [primary-gie] batch-size=4 config-file=config_infer_plan_engine_primary.txt This config-file has top-priority and would overwrite configs/deepstream-app-triton/config_infer_plan_engine_primary.txt with max_batch_size to 4 at run time. Triton Runtime has its own config file format following https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_configuration.html#model-configuration . Inside triton_model_repo/Primary_Detector/config.pbtxt , it defines name: &quot;Primary_Detector&quot; platform: &quot;tensorrt_plan&quot; max_batch_size: 30 This indicates Triton Runtime can batch at most 30 input buffers for model inference. In this example, plan engine model resnet18_trafficcamnet_pruned.onnx_b30_gpu0_int8.engine in Triton backend can support maximum batch-size: 30 . If Triton model is not non-batching configured with max_batch_size: &gt;0 , you\u2019ll need to make sure batch-size in config-file of Gst-nvinferserver and deepstream-app must less than or equal to this Triton model\u2019s max_batch_size in triton_model_repo/${model}/config.pbtxt . If Triton model is non-batching configured with max_batch_size: 0 , see the non-batching support questions above. #TODO Mention EGLSink error, suggest to use nv3dsink rather than EGL", "keywords": []}, {"id": 2397, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-maximum-duration-of-data-i-can-cache-as-history-for-smart-record", "display_name": "What is maximum duration of data I can cache as history for smart record?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-maximum-duration-of-data-i-can-cache-as-history-for-smart-record", "priority": -1, "content": "As such, there is no limit on cache size. It is limited by available system memory.", "keywords": []}, {"id": 2398, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-the-approximate-memory-utilization-for-1080p-streams-on-dgpu", "display_name": "What is the approximate memory utilization for 1080p streams on dGPU?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-the-approximate-memory-utilization-for-1080p-streams-on-dgpu", "priority": -1, "content": "Use the table below as a guide to memory utilization in this case. Width and height in Gst-nvstreammux are set to the input stream resolution specified in the configuration file. The pipeline is: decoder |rarr| nvstreammux |rarr| nvinfer |rarr| fakesink . Batch size (Number of streams) Decode memory Gst-nvinfer memory Gst-nvstreammux memory 1 32 MB 333 MB 0 MB 2 64 MB 341 MB 0 MB 4 128 MB 359 MB 0 MB 8 256 MB 391 MB 0 MB 16 512 MB 457 MB 0 MB If input stream resolution and Gst-nvstreammux resolution (set in the configuration file) are the same, no additional GPU memory is allocated in Gst-nvstreammux. If input stream resolution is not same as Gst-nvstreammux resolution, Gst-nvstreammux allocates memory of size: buffers*(1.5*width*height)*mismatches Where: buffers is the number of Gst-nvstreammux output buffers (set to 4). width and height are the mux output width and height. mismatches is the number of sources with resolution mismatch. This table shows some examples: Example Gst-nvstreammux width*height settings Gst-nvstreammux GPU memory size 16 sources at 1920*1080 resolution 1280*720 4*(1.5*1280*720)*16 = 84 MB 15 sources at 1280*720 resolution and one source at 1920*1080 resolution 1280*720 4*(1.5*1280*720)*1 = 5.2 MB", "keywords": []}, {"id": 2399, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-the-difference-between-batch-size-of-nvstreammux-and-nvinfer-what-are-the-recommended-values-for-nvstreammux-batch-size", "display_name": "What is the difference between batch-size of nvstreammux and nvinfer? What are the recommended values for nvstreammux batch-size?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-the-difference-between-batch-size-of-nvstreammux-and-nvinfer-what-are-the-recommended-values-for-nvstreammux-batch-size", "priority": -1, "content": "nvstreammux\u2019s batch-size is the number of buffers(frames) it will batch together in one muxed buffer. Nvinfer\u2019s batch-size is the number of frame(primary-mode)/objects(secondary-mode) it will infer together. We recommend that the nvstreammux\u2019s batch-size be set to either number of sources linked to it or the primary nvinfer\u2019s batch-size.", "keywords": []}, {"id": 2400, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-the-difference-between-deepstream-classification-and-triton-classification", "display_name": "What is the difference between DeepStream classification and Triton classification?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-the-difference-between-deepstream-classification-and-triton-classification", "priority": -1, "content": "Gst-nvinferserver plugin support 2 classification methods: Use DeepStream plugin to parse classification output and select labels. Configure the plugin\u2019s postprocess block with labelfile_path , and classification options. infer_config { postprocess { labelfile_path: \u201cpath/to/classification_labels.txt\u201d classification { threshold: 0.5 } } } Example: samples/ configs/deepstream-app-triton/config_infer_primary_classifier_inception_graphdef_postprocessInDS.txt Use Triton native classification method. The label file configured in Triton model\u2019s config.pbtxt (e.g. samples/triton_model_repo/inception_graphdef/config.pbtxt ) output [ { name: &quot;InceptionV3/Predictions/Softmax&quot; data_type: TYPE_FP32 dims: [ 1001 ] label_filename: &quot;inception_labels.txt&quot; } ] To enable it, need update Gst-nvinferserver\u2019s config file with: infer_config { postprocess { triton_classification { topk:1 threshold: 0.5 } } } Example: samples/configs/deepstream-app-triton/config_infer_primary_classifier_inception_graphdef_postprocessIntriton.txt", "keywords": []}, {"id": 2401, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-the-official-deepstream-docker-image-and-where-do-i-get-it", "display_name": "What is the official DeepStream Docker image and where do I get it?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-the-official-deepstream-docker-image-and-where-do-i-get-it", "priority": -1, "content": "You can download the official DeepStream Docker image from DeepStream docker image. For dGPU, see: https://ngc.nvidia.com/containers/nvidia:deepstream . For Jetson, see: https://ngc.nvidia.com/containers/nvidia:deepstream-l4t nvdrmvideosink plugin is not supported in docker. It is an unsupported use case, nvdrmvideosink only work well when there is no compositor running in background, and that is not possible inside a docker.", "keywords": []}, {"id": 2402, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-is-the-recipe-for-creating-my-own-docker-image", "display_name": "What is the recipe for creating my own Docker image?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-is-the-recipe-for-creating-my-own-docker-image", "priority": -1, "content": "One can use the DeepStream container as the base image and add custom layers on top of it using standard technique in Docker. Alternatively, follow below steps if you want to create a DeepStream triton docker on the top of a particular triton base image. 1. For example to build a custom Triton base container image, follow the instructions mentioned on https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/customization_guide/compose.html#use-the-compose-py-script Once the \u201cserver repository\u201d is cloned use below command to create the base docker. python3 compose.py --backend tensorrt --backend onnxruntime --repoagent checksum The command will create a tritonserver container locally named \u201ctritonserver:latest\u201d. 2. Go through README mentioned on NVIDIA-AI-IOT/deepstream_dockers In the required Dockerfile, edit the FROM command to use the base docker name created in step 1 e.g. FROM tritonserver:latest Once the Dockerfile is updated, follow README to create a DeepStream based docker on the top of pulled triton based docker.", "keywords": []}, {"id": 2403, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-s-the-throughput-of-h-264-and-h-265-decode-on-dgpu-tesla", "display_name": "What\u2019s the throughput of H.264 and H.265 decode on dGPU (Tesla)?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-s-the-throughput-of-h-264-and-h-265-decode-on-dgpu-tesla", "priority": -1, "content": "See https://developer.nvidia.com/nvidia-video-codec-sdk for information.", "keywords": []}, {"id": 2404, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#what-types-of-input-streams-does-deepstream-7-1-support", "display_name": "What types of input streams does DeepStream 7.1 support?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "what-types-of-input-streams-does-deepstream-7-1-support", "priority": -1, "content": "It supports H.264, H.265, JPEG, and MJPEG streams.", "keywords": []}, {"id": 2405, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#when-deepstream-app-is-run-in-loop-on-jetson-agx-orin-using-while-true-do-deepstream-app-c-config-file-done-after-a-few-iterations-i-see-low-fps-for-certain-iterations-why-is-that", "display_name": "When deepstream-app is run in loop on Jetson AGX Orin using \u201cwhile true; do deepstream-app -c <config_file>; done;\u201d, after a few iterations I see low FPS for certain iterations. Why is that?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "when-deepstream-app-is-run-in-loop-on-jetson-agx-orin-using-while-true-do-deepstream-app-c-config-file-done-after-a-few-iterations-i-see-low-fps-for-certain-iterations-why-is-that", "priority": -1, "content": "This may happen when you are running thirty 1080p streams at 30 frames/second. The issue is caused by initial load. I/O operations bog down the CPU, and with qos=1 as a default property of the [sink0] group, decodebin starts dropping frames. To avoid this, set qos=0 in the [sink0] group in the configuration file.", "keywords": []}, {"id": 2406, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#where-can-i-find-the-deepstream-sample-applications", "display_name": "Where can I find the DeepStream sample applications?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "where-can-i-find-the-deepstream-sample-applications", "priority": -1, "content": "The DeepStream sample applications are located at: &lt;DeepStream installation dir&gt;/sources/apps/sample_apps/ The configuration files for the sample applications are located at: &lt;DeepStream installation dir&gt;/samples/configs/deepstream-app For more information, see the NVIDIA DeepStream Development Guide .", "keywords": []}, {"id": 2407, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-error-could-not-get-egl-display-connection-while-running-deepstream-sample-application", "display_name": "Why am I getting error Could not get EGL display connection while running deepstream sample application?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-error-could-not-get-egl-display-connection-while-running-deepstream-sample-application", "priority": -1, "content": "Before running the application, if display device is connected, use command: $export DISPLAY=:0 If display device is not connected, use command: $unset DISPLAY", "keywords": []}, {"id": 2408, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-error-cugraphicsglregisterbuffer-failed-with-error-219-gst-eglglessink-cuda-init-texture-1-while-running-deepstream-sample-application-with-eglsink-on-sbsa-gh100", "display_name": "Why am I getting error cuGraphicsGLRegisterBuffer failed with error(219) gst_eglglessink_cuda_init texture = 1 while running deepstream sample application with EGLSink on SBSA/GH100?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-error-cugraphicsglregisterbuffer-failed-with-error-219-gst-eglglessink-cuda-init-texture-1-while-running-deepstream-sample-application-with-eglsink-on-sbsa-gh100", "priority": -1, "content": "SBSA/dGPU on ARM does not support nveglglessink. You should instead be using nv3dsink in your application.", "keywords": []}, {"id": 2409, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-error-gpuassert-invalid-argument-when-setting-outputreidtensor-1-in-gst-nvtracker-low-level-config-file", "display_name": "Why am I getting error \u201cGPUassert: invalid argument\u201d when setting outputReidTensor: 1 in Gst-nvtracker low level config file?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-error-gpuassert-invalid-argument-when-setting-outputreidtensor-1-in-gst-nvtracker-low-level-config-file", "priority": -1, "content": "The actual number of objects in all the streams exceeds the memory allocated for tracker re-identification embedding output. When outputting re-identification tensor is enabled, users are recommended to set maxTargetsPerStream to be larger than the total number of objects across all streams in the pipeline.", "keywords": []}, {"id": 2410, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-following-warning-when-running-deepstream-app-for-first-time", "display_name": "Why am I getting following warning when running deepstream app for first time?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-following-warning-when-running-deepstream-app-for-first-time", "priority": -1, "content": "&quot;GStreamer-WARNING: Failed to load plugin &#x27;...libnvdsgst_inferserver.so&#x27;: libtrtserver.so: cannot open shared object file: No such file or directory&quot; This is a harmless warning indicating that the DeepStream\u2019s nvinferserver plugin cannot be used since \u201cTriton Inference Server\u201d is not installed. If DeepStream-Triton is required, try to pull DeepStream\u2019s Triton docker image on dGPU following instructions at https://ngc.nvidia.com/catalog/containers/nvidia:deepstream and run the test apps inside container. Triton Inference Server is automatically installed on Jetson along with DeepStream package. No extra instructions are needed.", "keywords": []}, {"id": 2411, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-importerror-no-module-named-google-protobuf-internal-when-running-convert-to-uff-py-on-jetson-agx-orin", "display_name": "Why am I getting \u201cImportError: No module named google.protobuf.internal when running convert_to_uff.py on Jetson AGX Orin\u201d?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-importerror-no-module-named-google-protobuf-internal-when-running-convert-to-uff-py-on-jetson-agx-orin", "priority": -1, "content": "If you set up Tensorflow using https://elinux.org/Jetson_Zoo#TensorFlow , please use Python 3 for running convert_to_uff.py : $ python3 /usr/lib/python3.6/dist-packages/uff/bin/convert_to_uff.py", "keywords": []}, {"id": 2412, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-am-i-getting-warning-failed-to-query-video-capabilities-invalid-argument", "display_name": "Why am I getting warning \u201cFailed to query video capabilities: Invalid argument\u201d?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-am-i-getting-warning-failed-to-query-video-capabilities-invalid-argument", "priority": -1, "content": "This is a harmless warning. It is due to a bug in nvv4l2decoder and can be safely ignored.", "keywords": []}, {"id": 2413, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-are-all-deepstream-reference-apps-failing-on-dgpu-on-arm-with-ds-7-1-and-throwing-a-segfault", "display_name": "Why are all deepstream reference apps failing on dGPU on ARM with DS 7.1 and throwing a segfault?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-are-all-deepstream-reference-apps-failing-on-dgpu-on-arm-with-ds-7-1-and-throwing-a-segfault", "priority": -1, "content": "This is a known limitation with DS 7.1 arm sbsa docker. Video sink will not work by default on dGPU on ARM systems. Please see section Known Limitation with Video Subsystem and Workaround for details and workaround on how to get nv3dsink working.", "keywords": []}, {"id": 2414, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-encounter-such-error-while-running-deepstream-pipeline-memory-type-configured-and-i-p-buffer-mismatch-ip-surf-0-muxer-3", "display_name": "Why do I encounter such error while running Deepstream pipeline memory type configured and i/p buffer mismatch ip_surf 0 muxer 3?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-encounter-such-error-while-running-deepstream-pipeline-memory-type-configured-and-i-p-buffer-mismatch-ip-surf-0-muxer-3", "priority": -1, "content": "This error is observed on dGPU, when NvStreamMux is configured for memory type 3, i.e., NVBUF_MEM_CUDA_UNIFIED and the input surface to the nvstreammux has the memory type 0 i.e., NVBUF_MEM_CUDA_DEFAULT (Cuda device for dGPU). The resolution of input surface is same as nvstreammux configured resolution, in such scenario the nvstreammux ``tries to send the original buffer on its sinkpad to downstream muxed with buffers from other sources, but due to different configured memory type of ``nvstreammux it can\u2019t do the same. To get around this ensure that all the sources connected to nvstreammux are generating same type of memory and configure the nvstreammux memory to the same type. Alternatively, if there is scaling in nvstreammux this error won\u2019t be encountered.", "keywords": []}, {"id": 2415, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-error-glib-gthread-posix-c-unexpected-error-from-c-library-during-pthread-setspecific-invalid-argument-aborting", "display_name": "Why do I get error GLib (gthread-posix.c): Unexpected error from C library during 'pthread_setspecific': Invalid argument.  Aborting.", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-error-glib-gthread-posix-c-unexpected-error-from-c-library-during-pthread-setspecific-invalid-argument-aborting", "priority": -1, "content": "The issue is caused because of a bug in glib 2.0-2.72 version which comes with ubuntu22.04 by default. The issue is addressed in glib2.76 and its installation is required to fix the issue ( GNOME/glib ).", "keywords": []}, {"id": 2416, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-error-incorrect-camera-parameters-provided-please-provide-supported-resolution-and-frame-rate-when-i-compile-deepstream-sample-application-with-source1-usb-dec-infer-resnet-int8-txt-config-in-default-setting-on-jetson", "display_name": "Why do I get the error incorrect camera parameters provided, please provide supported resolution and frame rate when I compile DeepStream sample application with source1_usb_dec_infer_resnet_int8.txt config in default setting on Jetson?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-error-incorrect-camera-parameters-provided-please-provide-supported-resolution-and-frame-rate-when-i-compile-deepstream-sample-application-with-source1-usb-dec-infer-resnet-int8-txt-config-in-default-setting-on-jetson", "priority": -1, "content": "This is because nvdrmvideosink does not work along with Xorg . Refer to /opt/nvidia/deepstream/deepstream/README (Notes section, Point#3) to resolve the error.", "keywords": []}, {"id": 2417, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-error-makefile-13-cuda-ver-is-not-set-stop-when-i-compile-deepstream-sample-applications", "display_name": "Why do I get the error Makefile:13: *** \"CUDA_VER is not set\".  Stop when I compile DeepStream sample applications?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-error-makefile-13-cuda-ver-is-not-set-stop-when-i-compile-deepstream-sample-applications", "priority": -1, "content": "Export this environment variable: For both Jetson &amp; x86 : CUDA_VER=12.6 Then compile again using sudo -E make .", "keywords": []}, {"id": 2418, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-message-error-this-container-was-built-for-nvidia-driver-release-560-28-or-later-but-version-540-4-0-was-detected-and-compatibility-mode-is-unavailable", "display_name": "Why do I get the message: ERROR: This container was built for NVIDIA Driver Release 560.28 or later, but version 540.4.0 was detected and compatibility mode is UNAVAILABLE?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-message-error-this-container-was-built-for-nvidia-driver-release-560-28-or-later-but-version-540-4-0-was-detected-and-compatibility-mode-is-unavailable", "priority": -1, "content": "While running multiaarch triton docker on jetson, above prints are observed. These prints are harmless and should be ignored.", "keywords": []}, {"id": 2419, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-warning-failed-to-load-plugin-usr-lib-aarch64-linux-gnu-gstreamer-1-0-libgstlibav-so-libavfilter-so-7-cannot-open-shared-object-file-no-such-file-or-directory-when-using-deepstream-app-version-all", "display_name": "Why do I get the WARNING: Failed to load plugin '/usr/lib/aarch64-linux-gnu/gstreamer-1.0/libgstlibav.so': libavfilter.so.7: cannot open shared object file: No such file or directory when using deepstream-app \u2013version-all?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-warning-failed-to-load-plugin-usr-lib-aarch64-linux-gnu-gstreamer-1-0-libgstlibav-so-libavfilter-so-7-cannot-open-shared-object-file-no-such-file-or-directory-when-using-deepstream-app-version-all", "priority": -1, "content": "With DS 6.2+, DeepStream containers do not package gstreamer1.0-libav, library necessary for certain multimedia operations. Please run the below script inside the docker images to install additional packages that might be necessary to use all of the DeepStreamSDK features: $ /opt/nvidia/deepstream/deepstream/user_additional_install.sh", "keywords": []}, {"id": 2420, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-warning-message-libegl-warning-dri3-screen-seems-not-dri3-capable-and-libegl-warning-dri2-failed-to-authenticate-when-running-deepstream-pipeline-with-nveglglesink", "display_name": "Why do I get the warning message: libEGL warning: DRI3: Screen seems not DRI3 capable and libEGL warning: DRI2: failed to authenticate when running deepstream pipeline with nveglglesink?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-warning-message-libegl-warning-dri3-screen-seems-not-dri3-capable-and-libegl-warning-dri2-failed-to-authenticate-when-running-deepstream-pipeline-with-nveglglesink", "priority": -1, "content": "This warning is seen on T4 dGPU when the pipeline is run with nveglglessink. This warning is harmless and can be ignored.", "keywords": []}, {"id": 2421, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-get-the-warning-warning-from-src-elem-no-decoder-available-for-type-audio-mpeg-mpegversion-int-4-when-i-run-deepstream-app-sample-configuration-on-ds-docker-containers", "display_name": "Why do I get the WARNING WARNING from src_elem: No decoder available for type 'audio/mpeg, mpegversion=(int)4\u2019 when I run deepstream-app sample configuration on DS docker containers?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-get-the-warning-warning-from-src-elem-no-decoder-available-for-type-audio-mpeg-mpegversion-int-4-when-i-run-deepstream-app-sample-configuration-on-ds-docker-containers", "priority": -1, "content": "With DS 6.2+, DeepStream docker containers do not package libraries necessary for certain multimedia operations like audio data parsing, CPU decode, and CPU encode. This change could affect processing certain video streams/files like mp4 that include audio track. Please run the below script inside the docker images to install additional packages that might be necessary to use all of the DeepStreamSDK features: $ /opt/nvidia/deepstream/deepstream/user_additional_install.sh For more FAQs and troubleshooting information, see https://forums.developer.nvidia.com/t/deepstream-sdk-faq/ .", "keywords": []}, {"id": 2422, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-observe-a-lot-of-buffers-are-being-dropped-when-running-live-camera-streams-even-for-few-or-single-stream-also-output-looks-jittery", "display_name": "Why do I observe: A lot of buffers are being dropped. When running live camera streams even for few or single stream, also output looks jittery?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-observe-a-lot-of-buffers-are-being-dropped-when-running-live-camera-streams-even-for-few-or-single-stream-also-output-looks-jittery", "priority": -1, "content": "For live streams, nvstreammux element live-source property should be set as 1 . Also, sink/renderer element\u2019s sync and qos property should be set as 0 or FALSE .", "keywords": []}, {"id": 2423, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-see-confidence-value-as-0-1", "display_name": "Why do I see confidence value as -0.1.?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-see-confidence-value-as-0-1", "priority": -1, "content": "If \u201cGroup Rectangles\u201d mode of clustering is chosen then confidence value is set to -0.1 because the algorithm does not preserve confidence value. Also, for the objects being tracked by the tracker but not detected by the inference component, confidence value is set to -0.1 .", "keywords": []}, {"id": 2424, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-i-see-the-below-error-while-processing-h265-rtsp-stream", "display_name": "Why do I see the below Error while processing H265 RTSP stream?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-i-see-the-below-error-while-processing-h265-rtsp-stream", "priority": -1, "content": "Error: gstrtph265depay.c:1196:gst_rtp_h265_finish_fragmentation_unit: assertion failed:(outsize &gt;= 4) This issue is observed from h265depay gstreamer plugin component when size of rtp payload is less than 4 . The component throws assertion. This invalid packet size could be because of packet corruption. To overcome this issue, you should ignore assertion and handle such errors. Required modification in the code is present at https://forums.developer.nvidia.com/t/deepstream-sdk-faq/80236 . You\u2019ll need to compile the code and place the lib at the appropriate location.", "keywords": []}, {"id": 2425, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-on-jetson-engine-file-generation-fails-occasionally-inside-container", "display_name": "Why do on Jetson, engine file generation fails occasionally inside container?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-on-jetson-engine-file-generation-fails-occasionally-inside-container", "priority": -1, "content": "This is due to a bug in TensorRT-10.3 version. The issue is fixed in TensorRT-10.5 version. So, to overcome this issue, you should either install TensorRT-10.5 inside the docker or generate the engine file outside docker, on baremetal, and copy it inside the docker.", "keywords": []}, {"id": 2426, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-do-transformations-below-16x16-dimensions-fail-on-jetson", "display_name": "Why do transformations below 16x16 dimensions fail on Jetson?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-do-transformations-below-16x16-dimensions-fail-on-jetson", "priority": -1, "content": "Jetson (VIC) has a hardware limitation which only allows transformations with minimum 16x16 dimensions therefore NvBufSurfTransform has the same limitations on this platform.", "keywords": []}, {"id": 2427, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-does-my-image-look-distorted-if-i-wrap-my-cudamalloc-ed-memory-into-nvbufsurface-and-provide-to-nvbufsurftransform", "display_name": "Why does my image look distorted if I wrap my cudaMalloc\u2019ed memory into NvBufSurface and provide to NvBufSurfTransform?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-does-my-image-look-distorted-if-i-wrap-my-cudamalloc-ed-memory-into-nvbufsurface-and-provide-to-nvbufsurftransform", "priority": -1, "content": "If you are not using NvBufSurfaceCreate for allocation, ensure the pitch of the allocated memory is multiple of 32. Also ensure that the starting address of each plane of the input is 128-byte aligned.", "keywords": []}, {"id": 2428, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-does-the-deepstream-nvof-test-application-show-the-error-message-device-does-not-support-optical-flow-functionality", "display_name": "Why does the deepstream-nvof-test application show the error message \u201cDevice Does NOT support Optical Flow Functionality\u201d ?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-does-the-deepstream-nvof-test-application-show-the-error-message-device-does-not-support-optical-flow-functionality", "priority": -1, "content": "Optical flow functionality is supported only on NVIDIA\u00ae Jetson AGX Orin, NVIDIA\u00ae Jetson Orin NX\u2122 and on GPUs with Turing architecture (NVIDIA\u00ae T4, NVIDIA\u00ae GeForce\u00ae RTX 2080 etc.).", "keywords": []}, {"id": 2429, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-does-the-rtsp-source-used-in-gst-launch-pipeline-through-uridecodebin-show-blank-screen-followed-by-the-error-warning-from-element-gstpipeline-pipeline0-gstnvstreammux-m-no-sources-found-at-the-input-of-muxer-waiting-for-sources", "display_name": "Why does the RTSP source used in gst-launch pipeline through uridecodebin show blank screen followed by the error -  WARNING: from element /GstPipeline:pipeline0/GstNvStreamMux:m: No Sources found at the input of muxer. Waiting for sources?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-does-the-rtsp-source-used-in-gst-launch-pipeline-through-uridecodebin-show-blank-screen-followed-by-the-error-warning-from-element-gstpipeline-pipeline0-gstnvstreammux-m-no-sources-found-at-the-input-of-muxer-waiting-for-sources", "priority": -1, "content": "At times the requested muxer pad gets deleted before linking happens, as streams might contain both video and audio. If queue element is added between nvstreammux and the uridecodebin then the above pipeline will work. As uridecodebin will link to queue pad and not nvstreammux pad. This problem is not observed programmatically as the linking takes place new pad callback of decoder on video stream.", "keywords": []}, {"id": 2430, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-is-max-batch-size-0-used-in-some-triton-model-config-files-samples-triton-model-repo-config-pbtxt", "display_name": "Why is max_batch_size: 0 used in some Triton model config files (samples/triton_model_repo/*/config.pbtxt)?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-is-max-batch-size-0-used-in-some-triton-model-config-files-samples-triton-model-repo-config-pbtxt", "priority": -1, "content": "This is the parameter settings for Triton runtime. Some models do not support batching according to Triton docs ( https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_configuration.html#maximum-batch-size ). Gst-nvinferserver plugin supports these models in the non-batching mode, and tensor input/output shapes usually exist with full dimensions (1st dim is a batch-size). For example in triton_model_repo/densenet_onnx/config.pbtxt with: max_batch_size : 0 input { ... dims: [1, 3, 224, 224 ] } The 1st dim 1 is a batch-size in full-dims. In addition to some specific cases, if a model can support dynamic-shape with: max_batch_size : 0 input { ... dims: [-1, 3, 224, 224 ] } The 1st dim -1 means a dynamic batching size. In this case, to control the maximum batching size for pre-allocated buffer pool, user need to configure Gst-nvinferserver plugin configs/deepstream-app-triton/config_infer_**.txt with a valid maximum batch-size: infer_config { unique_id: 1 gpu_ids: [0] max_batch_size: 30 ... } The example above limits the final input batch-size to &lt;= 30. Gst-nvinferserver can also support Triton models reshape in config files. Read more details here: https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_configuration.html#reshape", "keywords": []}, {"id": 2431, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-is-the-gst-nvstreammux-plugin-required-in-deepstream-4-0", "display_name": "Why is the Gst-nvstreammux plugin required in DeepStream 4.0+?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-is-the-gst-nvstreammux-plugin-required-in-deepstream-4-0", "priority": -1, "content": "Multiple source components like decoder, camera, etc. are connected to the Gst-nvstreammux plugin to form a batch. This plugin is responsible for creating batch metadata, which is stored in the structure NvDsBatchMeta . This is the primary form of metadata in DeepStream 4.0.1. All plugins downstream from Gst-nvstreammux work on NvDsBatchMeta to access metadata and fill in the metadata they generate.", "keywords": []}, {"id": 2432, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-is-the-ntp-timestamp-value-0", "display_name": "Why is the NTP timestamp value 0?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-is-the-ntp-timestamp-value-0", "priority": -1, "content": "NTP timestamp 0 suggests that you are not receiving NTP timestamp from RTCP sender report. You can verify this using a tool like Wireshark.", "keywords": []}, {"id": 2433, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-is-the-script-prepare-classification-test-video-sh-failing-on-triton-docker-s", "display_name": "Why is the script prepare_classification_test_video.sh failing on Triton docker(s)?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-is-the-script-prepare-classification-test-video-sh-failing-on-triton-docker-s", "priority": -1, "content": "The script prepare_classification_test_video.sh present at /opt/nvidia/deepstream/deepstream/samples requires ffmpeg to be installed. Some of the low level codec libraries need to be re-installed along with ffmpeg. Use the following command to install/re-install ffmpeg: apt-get install --reinstall libflac8 libmp3lame0 libxvidcore4 ffmpeg", "keywords": []}, {"id": 2434, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "page", "name": "text/DS_FAQ#why-the-application-hangs-sometimes-with-rtsp-streams-on-reaching-eos", "display_name": "Why the application hangs sometimes with RTSP streams on reaching EOS?", "type": "section", "display_type": "Page section", "docname": "text/DS_FAQ", "anchor": "why-the-application-hangs-sometimes-with-rtsp-streams-on-reaching-eos", "priority": -1, "content": "This is because of an issue in rtpjitterbuffer component. To fix this issue,a script \u201cupdate_rtpmanager.sh\u201d at /opt/nvidia/deepstream/deepstream/ has been provided with required details to update gstrtpmanager library. The script should be executed once user installs packages mentioned under \u201cInstall Dependencies\u201d section of Quickstart Guide.", "keywords": []}, {"id": 2435, "doc_id": 2435, "filename": "text/DS_FAQ.html", "domain_name": "std", "name": "text/DS_FAQ", "display_name": "Frequently Asked Questions", "type": "doc", "display_type": "Page", "docname": "text/DS_FAQ", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2436, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#add-gstreamer-scheduler", "display_name": "Add GStreamer Scheduler", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "add-gstreamer-scheduler", "priority": -1, "content": "DeepStream components uses DeepStream and GStreamer plugins which requires GStreamer runtime to execute the pipeline. GStreamer scheduler component handles background GStreamer functionality to create and execute pipeline from graph.", "keywords": []}, {"id": 2437, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#configure-components", "display_name": "Configure Components", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "configure-components", "priority": -1, "content": "Component\u2019s parameters can be configured once these are added to the canvas by selecting the component on canvas. If property is not updated then it uses default value hence not all properties are required to be set. Configure components by setting properties to expected values Set input file path in source component, eg \u201c/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4\u201d Set batch size and GPU ID in mux, eg \u201c0\u201d Set inference model to use in video inference component, eg \u201cnvidia::deepstream::NvDsResnet18_4ClassDetectorModel\u201d Plugin component (INvDsElement) properties match 1:1 with GStreamer plugin properties. NvDsInferVideo and NvInferAudio components have special connector infer-model-config which allows users to connect INvDsInferModelConfigComponent components. Users can package infer config file along with other model related files in these components. Using this config is optional and users can also directly program the infer config file path in the config-file-path property.", "keywords": []}, {"id": 2438, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#connect-components", "display_name": "Connect Components", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "connect-components", "priority": -1, "content": "It is required to connect input/output ports of the components to the establish data transfer. Input/output ports of INvDsElement match 1:1 with Gstreamer plugin pads. Current Composer does not validate input/output data type in this release, it will just check if the input/output handles are compatible. Data type validation is planned for future release. Users can match port types using names e.g. video-out, video-in, audio-out, audio-in etc. Only out and in ports can be connected to each other, in to in or out to out connections are not allowed.", "keywords": []}, {"id": 2439, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#count-number-of-people", "display_name": "Count Number Of People", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "count-number-of-people", "priority": -1, "content": "How to add some more functionality to this inference pipeline such as measuring FPS or counting objects? Let\u2019s add people counting to this pipeline since we used people detection network. People counting component is added as a probe handler on output video port. Probe handler components registers callbacks which are called whenever data is available on the connected port. It allows users to process the data from the ports, these handlers can either add new data to the GstBuf or modify the existing GstBuf .", "keywords": []}, {"id": 2440, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#drag-and-drop-components", "display_name": "Drag and Drop Components", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "drag-and-drop-components", "priority": -1, "content": "DeepStream pipeline primarily depends on Gstreamer plugins which are represented by INvDsElement base type in Graph Composer. Use GroupBy button to list the components by their base type. All the components under INvDsElement represent GStreamer plugins. DeepStream test1 application detects people in the single batch video source and renders the output on display with bounding boxes. It requires the following: Source plugin component for input Mux plugin component as infer plugin component requires mux before it Video inference plugin component with peoplenet model OSD plugin component to draw bounding boxes Render plugin component to display output All these components are available in the extensions published to NVIDIA Cloud repository and can be browsed in component list window of the Composer. You can drag and drop these components from component list window to canvas. Refer to the DeepStream Components for all the components supported by DeepStream.", "keywords": []}, {"id": 2441, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#launch-composer", "display_name": "Launch Composer", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "launch-composer", "priority": -1, "content": "Launch Composer tool using following command: composer", "keywords": []}, {"id": 2442, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#runtime-add-remove-inputs", "display_name": "Runtime add/remove inputs", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "runtime-add-remove-inputs", "priority": -1, "content": "There is NvDsMultiSrcInput component which is based on a Gstream bin. It takes list of inputs as property allowing runtime changes in the list through runtime manipulator component, smart record start/stop. Runtime add/remove and smart record start/stop signals can be triggered by other components. You can implement your custom components to trigger these actions, for example, cloud message, keyboard event etc.,", "keywords": []}, {"id": 2443, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#save-graph", "display_name": "Save Graph", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "save-graph", "priority": -1, "content": "Graph can be saved by right clicking on canvas. Follow instructions from GraphComposer_Graph_Runtime to run the application using saved .yaml graph file. Refer to Container Builder config files in /opt/nvidia/deepstream/deepstream-7.1/reference_graphs/deepstream-test1 as a reference to create new config for the saved graph.", "keywords": []}, {"id": 2444, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "page", "name": "text/DS_GraphComposer_Create_Graph#use-multiple-inputs", "display_name": "Use Multiple inputs", "type": "section", "display_type": "Page section", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "use-multiple-inputs", "priority": -1, "content": "You can add multiple NvDsSingleSrcInput components and connect to MvDsStreamMux component. This does not allow runtime add/remove of inputs.", "keywords": []}, {"id": 2445, "doc_id": 2445, "filename": "text/DS_GraphComposer_Create_Graph.html", "domain_name": "std", "name": "text/DS_GraphComposer_Create_Graph", "display_name": "Creating an AI Application", "type": "doc", "display_type": "Page", "docname": "text/DS_GraphComposer_Create_Graph", "anchor": "", "priority": -1, "content": "Previous section explained how to run pre-created DeepStream test1 application. This section will explain how to create DeepStream test1 application from scratch using Composer.", "keywords": []}, {"id": 2446, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#dgpu-on-arm-setup-for-ubuntu-alpha", "display_name": "dGPU on ARM Setup for Ubuntu (Alpha)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "dgpu-on-arm-setup-for-ubuntu-alpha", "priority": -1, "content": "This section explains how to prepare an Ubuntu aarch64 system with NVIDIA dGPU devices before installing the DeepStream SDK. This document uses the term dGPU (\u201cdiscrete GPU\u201d) to refer to NVIDIA GPU expansion card products such as NVIDIA Tesla T4, NVIDIA Hopper, NVIDIA Ampere, NVIDIA\u00ae ADA, NVIDIA GeForce GTX 1080, NVIDIA GeForce RTX 2080, NVIDIA GeForce RTX 3080, NVIDIA GeForce RTX 4080 and GeForce/NVIDIA RTX/QUADRO. This version of DeepStream SDK runs on GPUs supported by NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs) and NVIDIA TensorRT\u2122 10.3.0.26. You must install the following components: NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs) Docker Nvidia Container Toolkit Please note: GH200 has been validated with Nvidia Driver 550 using Base-OS", "keywords": []}, {"id": 2447, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#dgpu-setup-for-redhat-enterprise-linux-rhel", "display_name": "dGPU Setup for RedHat Enterprise Linux (RHEL)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "dgpu-setup-for-redhat-enterprise-linux-rhel", "priority": -1, "content": "DeepStream for RHEL is not supported in this release.", "keywords": []}, {"id": 2448, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#dgpu-setup-for-ubuntu", "display_name": "dGPU Setup for Ubuntu", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "dgpu-setup-for-ubuntu", "priority": -1, "content": "This section explains how to prepare an Ubuntu x86_64 system with NVIDIA dGPU devices before installing the DeepStream SDK. Steps to install DeepStream SDK locally, assume that ~/.local/bin/ has been added to the ~/.bashrc or ~/.profile This document uses the term dGPU (\u201cdiscrete GPU\u201d) to refer to NVIDIA GPU expansion card products such as NVIDIA Tesla \u00ae T4, NVIDIA\u00ae Hopper, NVIDIA \u00ae Ampere, NVIDIA \u00ae ADA, NVIDIA GeForce \u00ae RTX 2080, NVIDIA GeForce \u00ae RTX 3080, NVIDIA GeForce \u00ae RTX 4080 and GeForce \u00ae /NVIDIA RTX/QUADRO. This version of DeepStream SDK runs on GPUs supported by NVIDIA driver 535.183.06 for Data Center GPUs and 560.35.03 for RTX GPUs and NVIDIA TensorRT\u2122 10.3.0.26 and later versions.", "keywords": []}, {"id": 2449, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#ds-installation-install-deepstream-sdk", "display_name": "Install the DeepStream SDK", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "ds-installation-install-deepstream-sdk", "priority": -1, "content": "Method 1 : Using the DeepStream Debian package Download the DeepStream 7.1 dGPU Debian package deepstream-7.1_7.1.0-1_amd64.deb : https://catalog.ngc.nvidia.com/orgs/nvidia/resources/deepstream Enter the command: $ sudo apt-get install ./deepstream-7.1_7.1.0-1_amd64.deb Method 2 : Download the DeepStream tar package: https://catalog.ngc.nvidia.com/orgs/nvidia/resources/deepstream Navigate to the location of the downloaded DeepStream package to extract and install the DeepStream SDK: $ sudo tar -xvf deepstream_sdk_v7.1.0_x86_64.tbz2 -C / $ cd /opt/nvidia/deepstream/deepstream-7.1/ $ sudo ./install.sh $ sudo ldconfig Method 3 : Use Docker containers DeepStream docker containers are available on NGC. See the Docker Containers section to learn about developing and deploying DeepStream using docker containers. Verification: Once DeepStream SDK installation is successful, refer to Expected output (deepstream-app) for the expected output.", "keywords": []}, {"id": 2450, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#ds-installation-sbsa-known-limitation", "display_name": "Known Limitation with Video Subsystem and Workaround", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "ds-installation-sbsa-known-limitation", "priority": -1, "content": "DeepStream 7.1 supports Cuda-12.6 in the compute stack and also in the docker container by default. Data Center GPUs are currently only supported by driver 535.183.06, which comes with Cuda-12.2 driver by default. Even though CUDA supports forward compatibility with newer runtime versions like Cuda-12.6, other components such as Cuda-GL Interop do not support forward compatibility which are required for display sink to work. Hence, for other components such as Cuda-GL Interop to work, Cuda-12.2 toolkit also must be installed along with the default Cuda-12.6 runtime inside the docker container. For users who need to use/enable display output, following steps can be utilized inside the docker to implement this workaround: Start the docker as shown in the step above. Install cuda-toolkit-12-2. Please follow these instructions PLEASE NOTE : From the Cuda-12 installation instructions mentioned in link above, please replace : sudo apt-get -y install cuda with sudo apt-get -y install cuda-toolkit-12-2 Change default CUDA version to point to Cuda-12.2 inside the docker using update alternatives: update-alternatives --set cuda /usr/local/cuda-12.2 To check which version of CUDA is currently in use inside the docker, run : update-alternatives --display cuda Similar limitation is also present for dGPU driver 550, which comes with Cuda-12.4 by default and Cuda-12.6 based docker containers which need to use/enable display. For users who need to use/enable display on systems using dGPU driver 550, please enable cuda-toolkit-12-4 in addition to Cuda-12.6 inside the container by following similar steps as above. Replace step no. 2 with cuda-toolkit-12-4 installation instructions found here", "keywords": []}, {"id": 2451, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#id1", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "id1", "priority": -1, "content": "You must install the following components: Ubuntu 22.04 GStreamer 1.20.3 NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs) CUDA 12.6 TensorRT 10.3.0.26", "keywords": []}, {"id": 2452, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#id2", "display_name": "Migrate glib to newer version", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "id2", "priority": -1, "content": "In order to migrate to newer glib version (e.g. 2.76.6) follow below steps: Prerequisites: Install below packages: pip3 install meson pip3 install ninja On baremetal x86, use sudo pip3 install meson and sudo pip3 install ninja for root permissions Compilation and installation steps: $ git clone https://github.com/GNOME/glib.git $ cd glib $ git checkout &lt;glib-version-branch&gt; # e.g. 2.76.6 $ meson build --prefix=/usr $ ninja -C build/ $ cd build/ $ ninja install On baremetal x86, use sudo ninja install to install with root permissions Check and confirm the newly installed glib version: pkg-config --modversion glib-2.0", "keywords": []}, {"id": 2453, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#id4", "display_name": "Install prerequisite packages", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "id4", "priority": -1, "content": "Enter the following commands to install the necessary packages before installing the DeepStream SDK: $ sudo apt install \\ libssl3 \\ libssl-dev \\ libgles2-mesa-dev \\ libgstreamer1.0-0 \\ gstreamer1.0-tools \\ gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-libav \\ libgstreamer-plugins-base1.0-dev \\ libgstrtspserver-1.0-0 \\ libjansson4 \\ libyaml-cpp-dev \\ libjsoncpp-dev \\ protobuf-compiler \\ gcc \\ make \\ git \\ python3 Sometimes with RTSP streams the application gets stuck on reaching EOS. This is because of an issue in rtpjitterbuffer component. To fix this issue,a script \u201cupdate_rtpmanager.sh\u201d at /opt/nvidia/deepstream/deepstream/ has been provided with required details to update gstrtpmanager library. The script should be executed once above mentioned packages are installed as prerequisite.", "keywords": []}, {"id": 2454, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#id5", "display_name": "Install librdkafka (to enable Kafka protocol adaptor for message broker)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "id5", "priority": -1, "content": "Clone the librdkafka repository from GitHub: $ git clone https://github.com/confluentinc/librdkafka.git Configure and build the library: $ cd librdkafka $ git checkout tags/v2.2.0 $ ./configure --enable-ssl $ make $ sudo make install Copy the generated libraries to the deepstream directory: $ sudo mkdir -p /opt/nvidia/deepstream/deepstream/lib $ sudo cp /usr/local/lib/librdkafka* /opt/nvidia/deepstream/deepstream/lib $ sudo ldconfig", "keywords": []}, {"id": 2455, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#id7", "display_name": "Install NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "id7", "priority": -1, "content": "Download and install using NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs) from NVIDIA Unix drivers page at: https://www.nvidia.com/en-us/drivers/unix/linux-aarch64-archive/ Run the following commands: For Data Center GPUs: $ chmod 755 NVIDIA-Linux-aarch64-535.183.06.run $ sudo ./NVIDIA-Linux-aarch64-535.183.06.run --no-cc-version-check For RTX GPUs: $ chmod 755 NVIDIA-Linux-aarch64-560.35.03.run $ sudo ./NVIDIA-Linux-aarch64-560.35.03.run --no-cc-version-check Ensure gdm, lightdm or Xorg service is stopped while installing Nvidia driver Use command : sudo service gdm stop  sudo service lightdm stop  sudo pkill -9 Xorg", "keywords": []}, {"id": 2456, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#igx-dgpu-on-arm-setup-for-ubuntu-alpha", "display_name": "IGX/dGPU on ARM Setup for Ubuntu (Alpha)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "igx-dgpu-on-arm-setup-for-ubuntu-alpha", "priority": -1, "content": "This section explains how to prepare a NVIDIA IGX system with NVIDIA dGPU devices before installing the DeepStream SDK. This document uses the term dGPU (\u201cdiscrete GPU\u201d) to refer to NVIDIA GPU expansion card products such as NVIDIA RTX A6000 and NVIDIA RTX 6000 Ada. This version of DeepStream SDK has been validated with NVIDIA driver 535.183.01 and NVIDIA TensorRT\u2122 10.3.0.26. You must install the following components: Please refer IGX-Software Install Guide for installing Base-OS: IGX-Software Guide Docker Nvidia Container Toolkit", "keywords": []}, {"id": 2457, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-cuda-toolkit-12-6", "display_name": "Install CUDA Toolkit 12.6", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-cuda-toolkit-12-6", "priority": -1, "content": "Run the following commands (reference, https://developer.nvidia.com/cuda-downloads ): $ sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/3bf863cc.pub $ sudo add-apt-repository &quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/ /&quot; $ sudo apt-get update $ sudo apt-get install cuda-toolkit-12-6 If you observe following errors while CUDA installation, refer to https://developer.nvidia.com/blog/updating-the-cuda-linux-gpg-repository-key/ . W: GPG error: https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64 InRelease: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY A4B469963BF863CC E: The repository &#x27;https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64 InRelease&#x27; is no longer signed.", "keywords": []}, {"id": 2458, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-jetson-sdk-components", "display_name": "Install Jetson SDK components", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-jetson-sdk-components", "priority": -1, "content": "Download NVIDIA SDK Manager from https://developer.nvidia.com/embedded/jetpack . You will use this to install JetPack 6.1 GA (corresponding to L4T 36.4 release) NVIDIA SDK Manager is a graphical application which flashes and installs the JetPack packages. The flashing procedure takes approximately 10-30 minutes, depending on the host system. If you are using Jetson Orin nano developer kit, you can download the SD card image from https://developer.nvidia.com/embedded/jetpack . This comes packaged with CUDA, TensorRT and cuDNN.", "keywords": []}, {"id": 2459, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-latest-nvidia-bsp-packages", "display_name": "Install latest NVIDIA BSP packages", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-latest-nvidia-bsp-packages", "priority": -1, "content": "Installation of JetPack 6.1 GA will ensure that latest NVIDIA BSP packages are installed.", "keywords": []}, {"id": 2460, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-librdkafka-to-enable-kafka-protocol-adaptor-for-message-broker", "display_name": "Install librdkafka (to enable Kafka protocol adaptor for message broker)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-librdkafka-to-enable-kafka-protocol-adaptor-for-message-broker", "priority": -1, "content": "Clone the librdkafka repository from GitHub: $ git clone https://github.com/confluentinc/librdkafka.git Configure and build the library: $ cd librdkafka $ git checkout tags/v2.2.0 $ ./configure --enable-ssl $ make $ sudo make install Copy the generated libraries to the deepstream directory: $ sudo mkdir -p /opt/nvidia/deepstream/deepstream/lib $ sudo cp /usr/local/lib/librdkafka* /opt/nvidia/deepstream/deepstream/lib $ sudo ldconfig", "keywords": []}, {"id": 2461, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-nvidia-driver-535-183-06-for-data-center-gpus-and-560-35-03-for-rtx-gpus", "display_name": "Install NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-nvidia-driver-535-183-06-for-data-center-gpus-and-560-35-03-for-rtx-gpus", "priority": -1, "content": "Download and install using NVIDIA driver 535.183.06 (for Data Center GPUs) and 560.35.03 (for RTX GPUs) from NVIDIA Unix drivers page at: https://www.nvidia.cn/Download/driverResults.aspx/222416/en-us/ Run the following commands: For Data Center GPUs: $ chmod 755 NVIDIA-Linux-x86_64-535.183.06.run $ sudo ./NVIDIA-Linux-x86_64-535.183.06.run --no-cc-version-check For RTX GPUs: $ chmod 755 NVIDIA-Linux-x86_64-560.35.03.run $ sudo ./NVIDIA-Linux-x86_64-560.35.03.run --no-cc-version-check Ensure gdm, lightdm or Xorg service is stopped while installing nvidia driver Use command : sudo service gdm stop  sudo service lightdm stop  sudo pkill -9 Xorg", "keywords": []}, {"id": 2462, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-prerequisite-packages", "display_name": "Install prerequisite packages", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-prerequisite-packages", "priority": -1, "content": "Enter the following commands to install the prerequisite packages: $ sudo apt install \\ libssl3 \\ libssl-dev \\ libgstreamer1.0-0 \\ gstreamer1.0-tools \\ gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-libav \\ libgstreamer-plugins-base1.0-dev \\ libgstrtspserver-1.0-0 \\ libjansson4 \\ libyaml-cpp-dev Sometimes with RTSP streams the application gets stuck on reaching EOS. This is because of an issue in rtpjitterbuffer component. To fix this issue, a script \u201cupdate_rtpmanager.sh\u201d at /opt/nvidia/deepstream/deepstream/ has been provided with required details to update gstrtpmanager library. The script should be executed once above mentioned packages are installed as prerequisite.", "keywords": []}, {"id": 2463, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-tensorrt-10-3-0-26", "display_name": "Install TensorRT 10.3.0.26", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-tensorrt-10-3-0-26", "priority": -1, "content": "Run the following command to install TensorRT 10.3.0.26: version=&quot;10.3.0.26-1+cuda12.5&quot; sudo apt-get install libnvinfer-dev=${version} libnvinfer-dispatch-dev=${version} libnvinfer-dispatch10=${version} libnvinfer-headers-dev=${version} libnvinfer-headers-plugin-dev=${version} libnvinfer-lean-dev=${version} libnvinfer-lean10=${version} libnvinfer-plugin-dev=${version} libnvinfer-plugin10=${version} libnvinfer-vc-plugin-dev=${version} libnvinfer-vc-plugin10=${version} libnvinfer10=${version} libnvonnxparsers-dev=${version} libnvonnxparsers10=${version} tensorrt-dev=${version} It is assumed, \u201cdeb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/ \u201d has been added, as mentioned in CUDA Toolkit 12.6 installation step. libnvparsers are deprecated since TRT 9.0.", "keywords": []}, {"id": 2464, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#install-the-deepstream-sdk", "display_name": "Install the DeepStream SDK", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "install-the-deepstream-sdk", "priority": -1, "content": "Method 1 : Using SDK Manager Select DeepStreamSDK from the Additional SDKs section along with JP 6.1 GA software components for installation. Method 2 : Using the DeepStream tar package: https://catalog.ngc.nvidia.com/orgs/nvidia/resources/deepstream Download the DeepStream 7.1 Jetson tar package deepstream_sdk_v7.1.0_jetson.tbz2 to the Jetson device. Enter the following commands to extract and install the DeepStream SDK: $ sudo tar -xvf deepstream_sdk_v7.1.0_jetson.tbz2 -C / $ cd /opt/nvidia/deepstream/deepstream-7.1 $ sudo ./install.sh $ sudo ldconfig Method 3 : Using the DeepStream Debian package: https://catalog.ngc.nvidia.com/orgs/nvidia/resources/deepstream Download the DeepStream 7.1 Jetson Debian package deepstream-7.1_7.1.0-1_arm64.deb to the Jetson device. Enter the following command: $ sudo apt-get install ./deepstream-7.1_7.1.0-1_arm64.deb Method 4 : Use Docker containers DeepStream docker containers are available on NGC. See the Docker Containers section to learn about developing and deploying DeepStream using docker containers. Verification: Once DeepStream SDK installation is successful, refer to Expected output (deepstream-app) for the expected output.", "keywords": []}, {"id": 2465, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#jetson-setup", "display_name": "Jetson Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "jetson-setup", "priority": -1, "content": "This section explains how to prepare a Jetson device before installing the DeepStream SDK. Steps to install DeepStream SDK locally, assume that ~/.local/bin/ has been added to the ~/.bashrc or ~/.profile", "keywords": []}, {"id": 2466, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#known-limitation-with-video-subsystem-and-workaround", "display_name": "Known Limitation with Video Subsystem and Workaround", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "known-limitation-with-video-subsystem-and-workaround", "priority": -1, "content": "DeepStream 7.1 supports Cuda-12.6 in the compute stack and also in the docker container by default. Data Center GPUs are currently only supported by driver 535.183.06, which comes with Cuda-12.2 driver by default. Even though CUDA supports forward compatibility with newer runtime versions like Cuda-12.6, other components such as Cuda-GL Interop do not support forward compatibility which are required for display sink to work. Hence, for other components such as Cuda-GL Interop to work, Cuda-12.2 toolkit also must be installed alongside Cuda-12.6 runtime inside the docker container. For users who need to use/enable display output, following steps can be utilized inside the docker to implement this workaround: Start the docker as shown in the step above. Install cuda-toolkit-12-2. Please follow these instructions PLEASE NOTE : From the Cuda-12 installation instructions mentioned in link above, please replace : sudo apt-get -y install cuda with sudo apt-get -y install cuda-toolkit-12-2 Change default CUDA version to point to Cuda-12.2 inside the docker using update alternatives: update-alternatives --set cuda /usr/local/cuda-12.2 To check which version of CUDA is currently in use inside the docker, run : update-alternatives --display cuda", "keywords": []}, {"id": 2467, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#migrate-glib-to-newer-version", "display_name": "Migrate glib to newer version", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "migrate-glib-to-newer-version", "priority": -1, "content": "In order to migrate to newer glib version (e.g. 2.76.6) follow below steps: Prerequisites: Install below packages: pip3 install meson pip3 install ninja On baremetal, use sudo pip3 install meson and sudo pip3 install ninja for root permissions Compilation and installation steps: $ git clone https://github.com/GNOME/glib.git $ cd glib $ git checkout &lt;glib-version-branch&gt; # e.g. 2.76.6 $ meson build --prefix=/usr $ ninja -C build/ $ cd build/ $ ninja install On baremetal, use sudo ninja install to install with root permissions Check and confirm the newly installed glib version: pkg-config --modversion glib-2.0", "keywords": []}, {"id": 2468, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#platform-and-os-compatibility", "display_name": "Platform and OS Compatibility", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "platform-and-os-compatibility", "priority": -1, "content": "The following table provides information about platform and operating system compatibility in the current and earlier versions of DeepStream. DS release DS 6.1 DS 6.1.1 DS 6.2 DS 6.3 DS 6.4 DS 7.0 DS 7.1 Jetson platforms AGX Xavier, Jetson NX, Jetson Orin AGX Xavier, Jetson NX, Jetson Orin Xavier AGX , Xavier NX, AGX Orin, Orin NX Xavier AGX , Xavier NX, AGX Orin, Orin NX, Orin nano AGX Orin, Orin NX, Orin nano AGX Orin, Orin NX, Orin nano AGX Orin, Orin NX, Orin nano OS L4T Ubuntu 20.04 L4T Ubuntu 20.04 L4T Ubuntu 20.04 L4T Ubuntu 20.04 L4T Ubuntu 22.04 L4T Ubuntu 22.04 L4T Ubuntu 22.04 JetPack release 5.0.1 DP 5.0.2 GA Revision 1 5.1 GA 5.1.2 GA 6.0 DP 6.0 GA 6.1 GA L4T release 34.1.1 35.1 35.2.1 35.4 36.2 36.3 36.4 CUDA release CUDA 11.4 CUDA 11.4 CUDA 11.4 CUDA 11.4 CUDA 12.2 CUDA 12.2 CUDA 12.6 cuDNN release cuDNN 8.3.2.49 cuDNN 8.4.1.50+ cuDNN 8.6.0.166+ cuDNN 8.6.0.166+ cuDNN 8.9.4.25+ cuDNN 8.9.4.25+ cuDNN 9.3.0 TensorRT release TRT 8.4.0.11 TRT 8.4.1.5 TRT 8.5.2.2 TRT 8.5.2.2 TRT 8.6.2.3 TRT 8.6.2.3 TRT 10.3.0.31 OpenCV release OpenCV 4.2.0 OpenCV 4.2.0 OpenCV 4.2.0 OpenCV 4.5.4 OpenCV 4.8.0 OpenCV 4.8.0 OpenCV 4.8.0 Vision\u00adWorks NA NA NA NA NA NA NA GStreamer GStreamer 1.16.2 GStreamer 1.16.2 GStreamer 1.16.3 GStreamer 1.16.3 GStreamer 1.20.3 GStreamer 1.20.3 GStreamer 1.20.3 Docker image deepstream-l4t:6.1 deepstream-l4t:6.1.1 deepstream-l4t:6.2 deepstream-l4t:6.3 deepstream:6.4 deepstream:7.0 deepstream:7.1 DS release DS 6.1 DS 6.1.1 DS 6.2 DS 6.3 DS 6.4 DS 7.0 DS 7.1 GPU platforms T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0) T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0) T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0), Hopper, ADA T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0), Hopper, ADA T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0), Hopper, ADA T4, V100, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0), Hopper, ADA T4, A2, A10, A30, A100, RTX Ampere (Ax000/RTX30x0), Hopper, ADA OS Ubuntu 20.04 Ubuntu 20.04 Ubuntu 20.04 Ubuntu 20.04 Ubuntu 22.04 Ubuntu 22.04 Ubuntu 22.04 GCC GCC 9.4.0 GCC 9.4.0 GCC 9.4.0 GCC 9.4.0 GCC 11.4.0 GCC 11.4.0 GCC 11.4.0 CUDA release CUDA 11.6.1 CUDA 11.7.1 CUDA 11.8 CUDA 12.1 CUDA 12.2 CUDA 12.2 CUDA 12.6 cuDNN release cuDNN 8.4.0.27 cuDNN 8.4.1.50+ cuDNN 8.7.0.84-1+ cuDNN 8.8.1.3-1+ cuDNN 8.9.4.25-1+ cuDNN 8.9.6.50-1+ cuDNN 9.3.0 TRT release TRT 8.2.5.1 TRT 8.4.1.5 TRT 8.5.2.2 TRT 8.5.3.1 TRT 8.6.1.6 TRT 8.6.1.6 TRT 10.3.0.26 Display Driver R510.47.03 R515.65.01 R525.85.12 R525.125.06 R535.104.12 R535.161.08 R535.183.06(Data Center GPUs), R560.35.03(RTX GPUs) VideoSDK release SDK 9.1 SDK 9.1 SDK 9.1 SDK 9.1 SDK 9.1 SDK 9.1 SDK 9.1 OFSDK release 2.0.23 2.0.23 2.0.23 2.0.23 2.0.23 2.0.23 2.0.23 GStreamer release GStreamer 1.16.2 GStreamer 1.16.2 GStreamer 1.16.3 GStreamer 1.16.3 GStreamer 1.20.3 GStreamer 1.20.3 GStreamer 1.20.3 OpenCV release OpenCV 4.2.0 OpenCV 4.2.0 OpenCV 4.2.0 OpenCV 4.2.0 OpenCV 4.5.4 OpenCV 4.5.4 OpenCV 4.5.4 Docker image deepstream:6.1 deepstream:6.1.1 deepstream:6.2 deepstream:6.3 deepstream:6.4 deepstream:7.0 deepstream:7.1 NVAIE release NA NA NVAIE-3.x NVAIE-3.x NVAIE-4.x NA NA By default, OpenCV has been deprecated. However, OpenCV can be enabled in plugins such as nvinfer (nvdsinfer) and dsexample (gst-dsexample) by setting WITH_OPENCV=1 in the Makefile of these components. Please refer component README for more instructions. NA: \u201cNot Applicable\u201d DeepStream 7.1 comes with Alpha support on ARM SBSA platform. This support is currently enabled by SBSA triton docker. SBSA category currently supports IGX/dGPU, GH100 and GH200.", "keywords": []}, {"id": 2469, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "prerequisites", "priority": -1, "content": "Sometimes while running gstreamer pipeline or sample apps, user can encounter error : GLib (gthread-posix.c): Unexpected error from C library during &#x27;pthread_setspecific&#x27;: Invalid argument. Aborting. The issue is caused because of a bug in glib 2.0-2.72 version which comes with ubuntu22.04 by default. The issue is addressed in glib2.76 and its installation is required to fix the issue ( GNOME/glib ).", "keywords": []}, {"id": 2470, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#remove-all-previous-deepstream-installations", "display_name": "Remove all previous DeepStream installations", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "remove-all-previous-deepstream-installations", "priority": -1, "content": "Enter the following commands to remove all previous DeepStream 3.0 or prior installations: $ sudo rm -rf /usr/local/deepstream /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstnv* /usr/bin/deepstream* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libnvdsgst* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/deepstream* /opt/nvidia/deepstream/deepstream* $ sudo rm -rf /usr/lib/x86_64-linux-gnu/libv41/plugins/libcuvidv4l2_plugin.so To remove DeepStream 4.0 or later installations: Open the uninstall.sh file in /opt/nvidia/deepstream/deepstream/ Run the following script as sudo ./uninstall.sh Sometimes while running gstreamer pipeline or sample apps, user can encounter error : GLib (gthread-posix.c): Unexpected error from C library during &#x27;pthread_setspecific&#x27;: Invalid argument. Aborting. The issue is caused because of a bug in glib 2.0-2.72 version which comes with ubuntu22.04 by default. The issue is addressed in glib2.76 and its installation is required to fix the issue ( GNOME/glib ).", "keywords": []}, {"id": 2471, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#run-arm-sbsa-docker-on-igx-dgpu", "display_name": "Run ARM SBSA docker on IGX/dGPU", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "run-arm-sbsa-docker-on-igx-dgpu", "priority": -1, "content": "Pull the DeepStream Triton Inference Server docker docker pull nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa Start the docker sudo docker run -it --rm --runtime=nvidia --network=host -e NVIDIA_DRIVER_CAPABILITIES=compute,utility,video,graphics --gpus all --privileged -e DISPLAY=:0 -v /tmp/.X11-unix:/tmp/.X11-unix -v /etc/X11:/etc/X11 nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa", "keywords": []}, {"id": 2472, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "page", "name": "text/DS_Installation#run-dgpu-on-arm-docker-sbsa", "display_name": "Run dGPU on ARM Docker (SBSA)", "type": "section", "display_type": "Page section", "docname": "text/DS_Installation", "anchor": "run-dgpu-on-arm-docker-sbsa", "priority": -1, "content": "Pull the DeepStream Triton Inference Server docker docker pull nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa Start the docker sudo docker run -it --rm --runtime=nvidia --network=host -e NVIDIA_DRIVER_CAPABILITIES=compute,utility,video,graphics --gpus all --privileged -e DISPLAY=:0 -v /tmp/.X11-unix:/tmp/.X11-unix -v /etc/X11:/etc/X11 nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa", "keywords": []}, {"id": 2473, "doc_id": 2473, "filename": "text/DS_Installation.html", "domain_name": "std", "name": "text/DS_Installation", "display_name": "Installation", "type": "doc", "display_type": "Page", "docname": "text/DS_Installation", "anchor": "", "priority": -1, "content": "NVIDIA \u00ae DeepStream Software Development Kit (SDK) is an accelerated AI framework to build intelligent video analytics (IVA) pipelines. DeepStream runs on NVIDIA \u00ae T4, NVIDIA\u00ae Hopper, NVIDIA \u00ae Ampere, NVIDIA \u00ae ADA and platforms such as NVIDIA \u00ae Jetson AGX Orin\u2122, NVIDIA \u00ae Jetson Orin\u2122 NX, NVIDIA \u00ae Jetson Orin\u2122 Nano. For dGPU platforms Enterprise GPUs are highly recommended for deployments that are expected to run 24x7. Gaming GPUs are not designed to perform in such type of environments.", "keywords": []}, {"id": 2474, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#autoreconnect-feature", "display_name": "Autoreconnect feature", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "autoreconnect-feature", "priority": -1, "content": "DeepStream (6.0 onwards) features autoreconnect capability wherein if network connection with the endpoint is down, a periodic reconnect attempt is made with the external entity while the application is still running. This feature is made available within low-level nvmsgbroker library. Configurations applicable for autoreconnect feature introduced within low-level nvmsgbroker library are listed in cfg_nvmsgbroker.txt $DEEPSTREAM_DIR/sources/libs/nvmsgbroker/cfg_nvmsgbroker.txt", "keywords": []}, {"id": 2475, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#bidirectional-messaging", "display_name": "Bidirectional Messaging", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "bidirectional-messaging", "priority": -1, "content": "DeepStream (5.0 onwards) now supports bi-directional communication to send and receive cloud-to-device messages along with publishing device-to-cloud messages. This is particularly important for various use cases, such as triggering the application to record an important event, changing operating parameters and app configurations, over-the-air (OTA) updates, or requesting system logs and other vital information. DeepStream (5.0 onwards) supports several other IoT features that can be used in conjunction with bi-directional messaging. DeepStream now offers an API to do a smart record based on an anomaly or could-to-device message. In addition, DeepStream also supports OTA updates of AI models while the application is running. The figure below shows the bi-directional messaging architecture: Message subscribers can be enabled in test5 application by adding the following group in the configuration file. [message-consumerX] enable=1 proto-lib=/opt/nvidia/deepstream/deepstream/lib/libnvds_kafka_proto.so conn-str= &lt;connection string as host;port &gt; config-file=../cfg_kafka.txt subscribe-topic-list=&lt;topic1&gt;;&lt;topic2&gt;;&lt;topicN&gt; Here X should be replaced with integer value e.g., 0,1,2 etc.", "keywords": []}, {"id": 2476, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#certificate-signing", "display_name": "Certificate Signing", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "certificate-signing", "priority": -1, "content": "While the security setup document provides instructions to create a token certificate authority (CA) to sign the client certificate, in production, the user would create certificates signed by third party CAs. These are created using a certificate signing request (CSR). See https://en.wikipedia.org/wiki/Certificate_signing_request for more information. Client requesting a certificate creates a key pair, but only includes the public key with other information, notably the \u201ccommon name\u201d, which is the fully qualified domain name (FQDN) of the machine for which the certificate is being requested. This information is signed by the user using the private key, which must be confidential.", "keywords": []}, {"id": 2477, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#choice-of-cipher", "display_name": "Choice of Cipher", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "choice-of-cipher", "priority": -1, "content": "As part of TLS configuration option while deploying the DeepStream application, the user can specify the cipher suite to be used. The cipher suite defines a collection of underlying algorithms used through the lifetime of the TLS connection. These algorithms address: Key exchange (during initial handshake) Digital signature (during initial handshake) Bulk encryption (confidentiality during data communication) Message authentication (tamper prevention during data communication). Numerous ciphers exist that are supported by OpenSSL (and in turn librdkafka and the Kafka adaptor in DeepStream). Recommendations for above algorithms as described below: ECDHE as the key exchange algorithm; it is based on Elliptic Key crypto cryptography while using ephemeral keys, thereby offering forward secrecy. ECDSA or RSA for digital signature AES for bulk encryption. AES offers both 128- and 256-bit key sizes. Tradeoff is between computational overhead and additional protection. It is also suggested to use bulk encryption algorithms that support authenticated encryption, which uses a tag in addition to the ciphertext. Use of tags enables detection of improperly constructed ciphertexts, which could for instance be specially chosen for attack. AES_GCM and AES_CBC are examples of block cipher that support authentication encryption. In summary, examples of TLSv1.2 ciphers that conform to these recommendations include: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "keywords": []}, {"id": 2478, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#choosing-between-2-way-tls-and-sasl-plain", "display_name": "Choosing Between 2-way TLS and SASL/Plain", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "choosing-between-2-way-tls-and-sasl-plain", "priority": -1, "content": "SASL/Plain offers the familiar username and password authentication metaphor to be used with Kafka. It can also be easier to setup as client-side certificates do not have to be created. But 2-way TLS offers several advantages, including enabling CA based list of allowed clients, which means new clients from a same organization using the shared CA can be automatically authenticated without reconfiguring the broker. Unlike passwords, private key used with 2-way TLS authentication can leverage key storage hardware such as HSM and TPM that perform cryptographic operations using the keys without revealing the keys themselves. Certificates can have a limited expiry time, and so credentials by design must be renewed periodically thereby protecting against duplication or theft.", "keywords": []}, {"id": 2479, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#cloud-to-edge", "display_name": "Cloud-to-Edge", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "cloud-to-edge", "priority": -1, "content": "DeepStream applications can subscribe to Apache Kafka topics or Redis streams to receive the messages from the cloud. DeepStream 5.0 introduces a new low-level nvmsgbroker library. The Cloud-to-device messaging currently happens through this library. The nvmsgbroker library calls into the lower-level adapter library with the appropriate protocol API\u2019s. You can choose between Kafka, Redis, or you can even create a custom adapter. Implementation of the receiving and processing of cloud messages can be found in the following files: $DEEPSTREAM_DIR/sources/apps/apps-common/src/deepstream_c2d_msg.c $DEEPSTREAM_DIR/sources/apps/apps-common/src/deepstream_c2d_msg_util.c", "keywords": []}, {"id": 2480, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#configure-tls-options-in-kafka-config-file-for-deepstream", "display_name": "Configure TLS options in Kafka config file for DeepStream", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "configure-tls-options-in-kafka-config-file-for-deepstream", "priority": -1, "content": "Configuration options provided by the Kafka message adaptor to the librdkafka library needs to be modified for SSL. The DeepStream documentation in the Kafka adaptor section describes various mechanisms to provide these config options, but this section addresses these steps based on using a dedicated config file. A list of parameters must be defined within the config file using the proto-cfg entry within the message-broker section as shown in the example below. [message-broker] proto-cfg = &quot;security.protocol=ssl;ssl.ca.location=&lt;path to your ca&gt;/ca-client-cert;ssl.certificate.location=&lt;path to your certificate &gt;/client1_cert.pem;ssl.key.location=&lt;path to your private key&gt;/client1_private_key.pem;ssl.key.password=test1234;ssl.key. password=abcdefgh; ssl.cipher.suites=ECDHE-RSA-AES256-GCM-SHA384; debug=broker,security&quot; The various options specified in the config file are described below: security.protocol.ssl : use SSL as the authentication protocol ssl.ca.location : path where your client CA certificate is stored ssl.certificate.location : path where your client certificate is stored ssl.key.location : path where your protected private key is stored ssl.cipher.suites=ECDHE-RSA-AES256-GCM-SHA384 ssl.key.password : password for your private key provided while extracting it from the p12 file The ssl.cipher.suites option allows the user to pick the cipher to be used for connecting to the broker. Given that the underlying librdkafka library uses OpenSSL, the list of supported ciphers can be identified from the OpenSSL documentation: https://www.openssl.org/docs/man1.0.2/man1/ciphers.html  librdkafka supports several other security related options that can be enabled as part of the Kafka adapter config file. Refer to the librdkafka configuration page for a complete list of options: edenhill/librdkafka", "keywords": []}, {"id": 2481, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#credential-storage", "display_name": "Credential Storage", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "credential-storage", "priority": -1, "content": "Standard guidelines for creating and sharing passwords applies to SASL/Plain credentials. Options to keep Kafka SASL/Plain credentials confidential include using filesystem-based access control. The Kafka configuration file which stores the credentials can be kept encrypted on disk and decrypted on the fly and stored in clear text for a limited period.", "keywords": []}, {"id": 2482, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#edge-to-cloud", "display_name": "Edge-to-Cloud", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "edge-to-cloud", "priority": -1, "content": "Device-to-cloud messaging currently happens through the Gst-nvmsgbroker (MSGBROKER) plugin. The Gstnvmsgbroker plugin by default calls the lower-level adapter library with the appropriate protocol API\u2019s. You can choose between Kafka, AMQP, Azure IoT, Redis or you can even create a custom adapter. DeepStream 5.0 introduces a new low-level nvmsgbroker library to present a unified interface for bi-directional messaging across the various protocols. The Gst-nvmsgbroker plugin has the option of interfacing with this new library instead of directly calling the protocol adaptor libraries, as controlled via a configuration option. For detailed information on Gst-nvmsgbroker plugin, please refer to the DeepStream Plugins Development Guide.", "keywords": []}, {"id": 2483, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#id1", "display_name": "Overview of Steps", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "id1", "priority": -1, "content": "This section provides high level guidance and considerations while enabling SASL/Plain authentication for Kafka. For detailed setup instructions regarding setting up SSL security, please refer to the Secure_Setup.md document in the DeepStream 5.0+ SDK in sources/libs/kafka_protocol_adaptor/ folder. Follow the steps below to enable SASL/Plain authentication for DeepStream apps with Kafka: Configure Kafka broker to use SASL/Plain authentication to use SASL authentication along with SSL for encryption Configure desired username and password with the Kafka broker Create and deploy certificates for broker Copy CA certificates to the broker and client TrustStores Configure DeepStream application with username and password within the Kafka config file (see proto-cfg parameter above)", "keywords": []}, {"id": 2484, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#impact-on-performance", "display_name": "Impact on performance", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "impact-on-performance", "priority": -1, "content": "Enabling TLS-based security will incur a computational overhead on the processor in your system. Several aspects influence the overhead, including message size, frame rate and choice of cipher suite. While the key exchange algorithms in the cipher suite incur a one-time overhead during the initial connection establishment, the bulk encryption and message authentication algorithms are run during data transfer, and hence need to be considered for performance. For instance, AES offers two variants, based on 128- and 256-bit keys. While the latter is more secure, it incurs a larger performance overhead. Ensure that your processor supports AES instructions; most modern Xeon processors do, as do Jetson\u2019s processors. See https://developer.nvidia.com/embedded/develop/hardware for more information on Jetson processors.", "keywords": []}, {"id": 2485, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#key-generation", "display_name": "Key generation", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "key-generation", "priority": -1, "content": "The security setup document describes use of the keytool utility to generate a key pair. The user has an option of specifying the algorithm used to generate the key pair. RSA is a popular algorithm, offering 2048-bit key option for increased security. Others include DSA and ECDSA with varying speeds in signing and verifying as described here: https://wiki.mozilla.org/Security/Server_Side_TLS .", "keywords": []}, {"id": 2486, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#nvmsgbroker-library", "display_name": "NvMsgbroker Library", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "nvmsgbroker-library", "priority": -1, "content": "DeepStream (5.0 onwards) features a new nvmsgbroker library which can be used to make connections with multiple external brokers. This library acts as a wrapper around the message adapter libraries and provides APIs for making and closing connections as well as publishing/subscribing to messages. The nvmsgbroker library provides thread safety, enabling any number of components in the DeepStream application to use the same connection handle to publish/subscribe messages. Gst-msgbroker plugin has an option to directly call in to the adapter library API\u2019s for connecting with external entity or use the nvmsgbroker library interface to have the ability to connect with multiple external entities at a time.", "keywords": []}, {"id": 2487, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#overview-of-steps", "display_name": "Overview of Steps", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "overview-of-steps", "priority": -1, "content": "This section provides high level guidance and considerations while enabling 2-way TLS security for Kafka. For detailed setup instructions regarding setting up SSL security, please refer to the Secure_Setup.md document in the DeepStream 5.0+ SDK in sources/libs/kafka_protocol_adaptor/ folder. Follow the steps below to enable 2-way TLS authentication for DeepStream apps with Kafka: Setup Kafka broker with TLS authentication enabled Create and deploy certificates for broker and DeepStream application Copy CA certificates to the broker and client Truststores Configure TLS options in Kafka config file (see proto-cfg param above)", "keywords": []}, {"id": 2488, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#sasl-plain", "display_name": "SASL/Plain", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "sasl-plain", "priority": -1, "content": "DeepStream (5.0 onwards) enables SASL/Plain based authentication mechanism for Kafka. SASL/Plain enables a username/password form of authentication. It is typically used with TLS to enable end to end encryption, thereby ensuring that both the username password credentials, and subsequent data transfer is confidential, which is especially important when the communication between DeepStream applications and the Kafka broker occurs over public networks.", "keywords": []}, {"id": 2489, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#secure-edge-to-cloud-messaging", "display_name": "Secure Edge-to-Cloud Messaging", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "secure-edge-to-cloud-messaging", "priority": -1, "content": "Starting with DeepStream 5.0, the Kafka adaptor supports secure communication. Security includes: Authentication : Kafka brokers can restrict clients (producers and consumers) connecting to a cluster based on credentials. DeepStream applications, starting with the 5.0 release, can authenticate themselves to brokers using TLS mutual authentication &amp; SASL/Plain mechanisms to send (and receive) messages to such clusters. This is particularly important for clusters executing outside of company networks, and thereby having data travel over public networks during communication. Encryption : Encryption ensures that confidentiality is maintained from third parties for messages sent by DeepStream applications to Kafka brokers. Tampering : The added security support prevents messages between application and broker from being tampered in flight. Authorization : Limit the operations allowed for a client connecting to the broker. Identity of the client (the DeepStream application in this case) is established during the authentication step.", "keywords": []}, {"id": 2490, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#tls-configuration", "display_name": "TLS Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "tls-configuration", "priority": -1, "content": "Note that unlike with 2-way TLS authentication, client certificates are not required for SASL/Plain. Instead, only certificates of the broker are required, and used by the DeepStream application to ensure authenticity of the broker. To that end, the various aspects of TLS described in the 2-way TLS section including TLS version to use, generation of keys and choice of cipher are applicable.", "keywords": []}, {"id": 2491, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#tls-version", "display_name": "TLS Version", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "tls-version", "priority": -1, "content": "As part of the initial TLS handshake, clients like DeepStream applications and servers agree on the TLS protocol to use. The recommendation is to use TLSv1.2 or later in production. You can verify which version of TLS your broker supports by connecting to the broker using the OpenSSL utility. The OpenSSL utility can be deployed by installing the openssl package, available for Ubuntu and other Linux distributions. Run the following command: openssl s_client -connect &lt;broker address&gt;:&lt;broker port&gt; -tls1_2 This operation connects to the broker using the openssl_s client while using TLSv1.2 . In case of error, review logs for issues during handshake indicating that TLSv1.2 is not supported.", "keywords": []}, {"id": 2492, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "page", "name": "text/DS_IoT#way-tls-authentication", "display_name": "2-way TLS Authentication", "type": "section", "display_type": "Page section", "docname": "text/DS_IoT", "anchor": "way-tls-authentication", "priority": -1, "content": "DeepStream (5.0 onwards) supports Kafka security based on the 2-way TLS (Transport Layer Security) Authentication mechanism. TLS is a successor to SSL, but the two terms are still used interchangeably in literature. TLS/SSL is used commonly for secure communication while connecting to servers (e.g. HTTPS) is used for secure communication on the web. 2-way communication ensures that both clients and servers can authenticate each other, while also supporting other aspects of security like encryption, enabling tamper proof communication, and supporting client authorization.", "keywords": []}, {"id": 2493, "doc_id": 2493, "filename": "text/DS_IoT.html", "domain_name": "std", "name": "text/DS_IoT", "display_name": "IoT", "type": "doc", "display_type": "Page", "docname": "text/DS_IoT", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2494, "doc_id": 2494, "filename": "text/DS_Legal.html", "domain_name": "std", "name": "text/DS_Legal", "display_name": "DeepStream End User License Agreement", "type": "doc", "display_type": "Page", "docname": "text/DS_Legal", "anchor": "", "priority": -1, "content": "Read about the licenses in DeepStream End User License Agreement .", "keywords": []}, {"id": 2495, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "page", "name": "text/DS_Libraries#additional-references-and-applications", "display_name": "Additional References and Applications", "type": "section", "display_type": "Page section", "docname": "text/DS_Libraries", "anchor": "additional-references-and-applications", "priority": -1, "content": "For more references and application please refer to the below link: CVCUDA NvImageCodec PyNvVideoCodec PyNvVIdeoCodec Online Documents", "keywords": []}, {"id": 2496, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "page", "name": "text/DS_Libraries#deepstream-libraries-installation", "display_name": "DeepStream Libraries Installation", "type": "section", "display_type": "Page section", "docname": "text/DS_Libraries", "anchor": "deepstream-libraries-installation", "priority": -1, "content": "Download DeepStream Libraries wheel file from NGC. Download wheel file from this NGC link Install DeepStream Libraries package. $ pip3 install deepstream_libraries-1.1-cp310-cp310-linux_x86_64.whl", "keywords": []}, {"id": 2497, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "page", "name": "text/DS_Libraries#deepstream-libraries-repository-setup", "display_name": "DeepStream Libraries Repository Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_Libraries", "anchor": "deepstream-libraries-repository-setup", "priority": -1, "content": "To run sample apps , follow below steps: Clone DeepStream Libraries repo. $ git clone https://github.com/NVIDIA-AI-IOT/deepstream_libraries.git $ cd deepstream_libraries Install dependencies. Install all the dependent packages required by sample apps: $ sudo sh scripts/install_dependencies.sh Download test files Download images/videos to run sample apps: $ sh scripts/download_data.sh", "keywords": []}, {"id": 2498, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "page", "name": "text/DS_Libraries#getting-started-with-deepstream-libraries-apis", "display_name": "Getting Started with DeepStream Libraries APIs", "type": "section", "display_type": "Page section", "docname": "text/DS_Libraries", "anchor": "getting-started-with-deepstream-libraries-apis", "priority": -1, "content": "We can use DeepStream Libraries API\u2019s to create an application. Consider the below reference example: Read an image from the given file path using NvImageCodec Resize the image with specified dimensions and Cubic interpolation method using CVCUDA Save the resized image using NvImageCodec # Import necessary libraries import cvcuda from nvidia import nvimgcodec # Create Decoder decoder = nvimgcodec.Decoder() # Read image with nvImageCodec inputImage = decoder.read(&quot;path/to/image.jpg&quot;) # Pass it to cvcuda using as_tensor nvcvInputTensor = cvcuda.as_tensor(inputImage, &quot;HWC&quot;) # Resize with cvcuda to 320x240 cvcuda_stream = cvcuda.Stream() with cvcuda_stream: nvcvResizeTensor = cvcuda.resize(nvcvInputTensor, (320, 240, 3), cvcuda.Interp.CUBIC) nvcvResizeTensor.cuda().__cuda_array_interface__ # Write with nvImageCodec encoder = nvimgcodec.Encoder() output_image_path = &quot;output.jpg&quot; encoder.write(output_image_path, nvimgcodec.as_image(nvcvResizeTensor.cuda(), cuda_stream = cvcuda_stream.handle))", "keywords": []}, {"id": 2499, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "page", "name": "text/DS_Libraries#sample-applications", "display_name": "Sample Applications", "type": "section", "display_type": "Page section", "docname": "text/DS_Libraries", "anchor": "sample-applications", "priority": -1, "content": "Application Description Classification A CUDA-accelerated image and video classification pipeline integrating PyTorch or TensorRT for efficient processing on NVIDIA GPUs Object-Detection GPU accelerated Object detection using CV-CUDA library with TensorFlow or TensorRT Segmentation GPU accelerated Semantic segmentation by utilizing the CV-CUDA library with PyTorch or TensorRT Resize-Image A sample app that decodes, resizes, and encodes images using the CVCUDA and NvImageCodec Python API\u2019s Decode-Video Decodes encoded bitstreams using PyNvVideoCodec decode APIs Encode-Video Encodes a raw YUV file using PyNvVideoCodec encode APIs Transcode-Video Transcodes the video files using PyNvVideoCodec API\u2019s", "keywords": []}, {"id": 2500, "doc_id": 2500, "filename": "text/DS_Libraries.html", "domain_name": "std", "name": "text/DS_Libraries", "display_name": "DeepStream Libraries (Developer Preview)", "type": "doc", "display_type": "Page", "docname": "text/DS_Libraries", "anchor": "", "priority": -1, "content": "DeepStream Libraries provide CVCUDA , NvImageCodec , and PyNvVideoCodec modules as Python APIs to easily integrate into custom frameworks. Developers can build complete Python applications with fully accelerated components leveraging intuitive Python APIs. Most of the DeepStream Libraries building blocks and their Python APIs are available today as standalone packages. DeepStream Libraries provide a way for Python developers to install these packages with a single installer. All these packages are built against the same CUDA version and validated with the specified driver version. Reference applications are provided to demonstrate the usage of Python APIs.", "keywords": []}, {"id": 2501, "doc_id": 2504, "filename": "text/DS_Migration_guide.html", "domain_name": "page", "name": "text/DS_Migration_guide#additional-resources", "display_name": "Additional Resources", "type": "section", "display_type": "Page section", "docname": "text/DS_Migration_guide", "anchor": "additional-resources", "priority": -1, "content": "For additional details, make sure you are familiar with the documentation available along with checking our developer forums.", "keywords": []}, {"id": 2502, "doc_id": 2504, "filename": "text/DS_Migration_guide.html", "domain_name": "page", "name": "text/DS_Migration_guide#documentation", "display_name": "Documentation", "type": "section", "display_type": "Page section", "docname": "text/DS_Migration_guide", "anchor": "documentation", "priority": -1, "content": "TensorRT Documentation TAO Toolkit Documentation", "keywords": []}, {"id": 2503, "doc_id": 2504, "filename": "text/DS_Migration_guide.html", "domain_name": "page", "name": "text/DS_Migration_guide#forums", "display_name": "Forums", "type": "section", "display_type": "Page section", "docname": "text/DS_Migration_guide", "anchor": "forums", "priority": -1, "content": "DeepStream SDK Forum TensorRT Forum TAO Toolkit Forum", "keywords": []}, {"id": 2504, "doc_id": 2504, "filename": "text/DS_Migration_guide.html", "domain_name": "std", "name": "text/DS_Migration_guide", "display_name": "Migration Guide", "type": "doc", "display_type": "Page", "docname": "text/DS_Migration_guide", "anchor": "", "priority": -1, "content": "The NVIDIA team is very excited with all the new features and capabilities that DeepStream 7.1 brings to the table. However, there are a few important items that need to be understood before you start developing with DeepStream 7.1. This is especially true if you are an existing developer and plan to bring existing models to the latest release of DeepStream. Make sure you understand how to migrate your older DeepStream custom models to DeepStream 7.1 before you start. DeepStream 7.1 now supports TensorRT 10.3.0.26 for x86 and Jetson. TensorRT 10.3.0.26 does not maintain compatibility with previous versions of TensorRT 8.x and models created with older versions of TenorRT require updated calibration files. Depending on where you are in your development journey there are a few steps that need to take before you get started. If you are new to DeepStream OR you do not need to reuse any old models, You are good to go! Make sure you download the latest models from NGC . If you want to bring models that were developed for previous versions of DeepStream or TensorRT, you\u2019ll need to create a new calibration cache files . This can be easily done using native TAO Toolkit tools. An example on how to perform this task is available in the Exporting a Model section of the TAO Toolkit documentation.", "keywords": []}, {"id": 2505, "doc_id": 2505, "filename": "text/DS_NTP_Timestamp.html", "domain_name": "std", "name": "text/DS_NTP_Timestamp", "display_name": "NTP Timestamp in DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_NTP_Timestamp", "anchor": "", "priority": -1, "content": "DeepStream 5.0+ supports the setting of NTP timestamps per frame. Calculated NTP timestamp is available in ntp_timestamp field of NvDsFrameMeta . DeepStream calculates NTP timestamps in 2 ways: Host system time as NTP timestamp - when the frame is received by the NvStreamMux plugin in the DeepStream pipeline. This method requires you to synchronize host system to NTP clock. To attach host system time as NTP timestamp, you\u2019ll need to set attach-sys-ts to TRUE on nvstreammux . Set the attach-sys-ts-as-ntp config parameter to 1 in [streammux] group of the application configuration file in the DeepStream reference app. NTP timestamp when attached at RTSP source - supported only if RTSP sources send RTCP Sender Reports (SR). To configure the pipeline to attach these timestamps: Set attach-sys-ts to FALSE on nvstreammux . Set the attach-sys-ts-as-ntp config parameter to 0 in [streammux] group of the application configuration file in the DeepStream reference app. After creating an \u201crtspsrc\u201d element or an \u201curidecodebin\u201d element, application must call configure_source_for_ntp_sync() function and pass the GstElement pointer to this API. (Refer to create_rtsp_src_bin() in deepstream_source_bin.c file.) The API internally configures the pipeline to parse sender report and calculate NTP timestamps for each frame. Make sure RTSP source can send RTCP Sender Reports. Verify this by starting streaming from the source on a host and viewing the packets in a tool like wireshark or tshark on the same host to confirm the presence of Sender Reports (SR). Example method to check if RTSP source sends RTCP sender reports using a tool like tshark : We assume RTSP source has IP address 192.168.1.100 Install tshark on a host: sudo apt-get install tshark Find the host network interface that would be receiving the RTP/RTCP packets: $ sudo tshark -D ... eno1 ... Start the monitoring using tshark tool. Replace the network interface and source IP as applicable: $ sudo tshark -i eno1 -f &quot;src host 192.168.1.100&quot; -Y &quot;rtcp&quot; On the same host, start streaming from the RTSP source only after starting the monitoring tool. Any client may be used: $ gst-launch-1.0 rtspsrc location= &lt;RTSP URL e.g. rtsp://192.168.1.100/stream1&gt; ! fakesink The output of the tshark monitoring tool should have lines containing &quot;Sender Report Source description&quot; . Here is a sample output: 6041 10.500649319 192.168.1.100 \u2192 192.168.1.101 RTCP 94 Sender Report Source description", "keywords": []}, {"id": 2506, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "page", "name": "text/DS_Overview#deepstream-graph-architecture", "display_name": "DeepStream Graph Architecture", "type": "section", "display_type": "Page section", "docname": "text/DS_Overview", "anchor": "deepstream-graph-architecture", "priority": -1, "content": "DeepStream is an optimized graph architecture built using the open source GStreamer framework. . The graph below shows a typical video analytic application starting from input video to outputting insights. All the individual blocks are various plugins that are used. At the bottom are the different hardware engines that are utilized throughout the application. Optimum memory management with zero-memory copy between plugins and the use of various accelerators ensure the highest performance. DeepStream provides building blocks in the form of GStreamer plugins that can be used to construct an efficient video analytic pipeline. There are more than 20 plugins that are hardware accelerated for various tasks. Streaming data can come over the network through RTSP or from a local file system or from a camera directly. The streams are captured using the CPU. Once the frames are in the memory, they are sent for decoding using the NVDEC accelerator. The plugin for decode is called Gst-nvvideo4linux2 . After decoding, there is an optional image pre-processing step where the input image can be pre-processed before inference. The pre-processing can be image dewarping or color space conversion. Gst-nvdewarper plugin can dewarp the image from a fisheye or 360 degree camera. Gst-nvvideoconvert plugin can perform color format conversion on the frame. These plugins use GPU or VIC (vision image compositor). The next step is to batch the frames for optimal inference performance. Batching is done using the Gst-nvstreammux plugin. Once frames are batched, it is sent for inference. The inference can be done using TensorRT, NVIDIA\u2019s inference accelerator runtime or can be done in the native framework such as TensorFlow or PyTorch using Triton inference server. Native TensorRT inference is performed using Gst-nvinfer plugin and inference using Triton is done using Gst-nvinferserver plugin. The inference can use the GPU or DLA (Deep Learning accelerator) for Jetson AGX Orin and Orin NX. After inference, the next step could involve tracking the object. There are several built-in reference trackers in the SDK, ranging from high performance to high accuracy. Object tracking is performed using the Gst-nvtracker plugin. For creating visualization artifacts such as bounding boxes, segmentation masks, labels there is a visualization plugin called Gst-nvdsosd . Finally to output the results, DeepStream presents various options: render the output with the bounding boxes on the screen, save the output to the local disk, stream out over RTSP or just send the metadata to the cloud. For sending metadata to the cloud, DeepStream uses Gst-nvmsgconv and Gst-nvmsgbroker plugin. Gst-nvmsgconv converts the metadata into schema payload and Gst-nvmsgbroker establishes the connection to the cloud and sends the telemetry data. There are several built-in broker protocols such as Kafka, MQTT, AMQP and Azure IoT. Custom broker adapters can be created.", "keywords": []}, {"id": 2507, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "page", "name": "text/DS_Overview#deepstream-in-python", "display_name": "DeepStream in Python", "type": "section", "display_type": "Page section", "docname": "text/DS_Overview", "anchor": "deepstream-in-python", "priority": -1, "content": "Python is easy to use and widely adopted by data scientists and deep learning experts when creating AI models. NVIDIA introduced Python bindings to help you build high-performance AI applications using Python. DeepStream pipelines can be constructed using Gst-Python , the GStreamer framework\u2019s Python bindings. The DeepStream Python application uses the Gst-Python API action to construct the pipeline and use probe functions to access data at various points in the pipeline. The data types are all in native C and require a shim layer through PyBindings or NumPy to access them from the Python app. Tensor data is the raw tensor output that comes out after inference. If you are trying to detect an object, this tensor data needs to be post-processed by a parsing and clustering algorithm to create bounding boxes around the detected object. To get started with Python, see the Python Sample Apps and Bindings Source Details in this guide and \u201cDeepStream Python\u201d in the DeepStream Python API Guide .", "keywords": []}, {"id": 2508, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "page", "name": "text/DS_Overview#deepstream-reference-app", "display_name": "DeepStream reference app", "type": "section", "display_type": "Page section", "docname": "text/DS_Overview", "anchor": "deepstream-reference-app", "priority": -1, "content": "To get started, developers can use the provided reference applications. Also included are the source code for these applications. The end-to-end application is called deepstream-app . This app is fully configurable - it allows users to configure any type and number of sources. Users can also select the type of networks to run inference. It comes pre-built with an inference plugin to do object detection cascaded by inference plugins to do image classification. There is an option to configure a tracker. For the output, users can select between rendering on screen, saving the output file, or streaming the video out over RTSP. This is a good reference application to start learning the capabilities of DeepStream. This application is covered in greater detail in the DeepStream Reference Application - deepstream-app chapter. The source code for this application is available in /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-app . This application will work for all AI models with detailed instructions provided in individual READMEs. The performance benchmark is also run using this application.", "keywords": []}, {"id": 2509, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "page", "name": "text/DS_Overview#getting-started-with-building-apps", "display_name": "Getting started with building apps", "type": "section", "display_type": "Page section", "docname": "text/DS_Overview", "anchor": "getting-started-with-building-apps", "priority": -1, "content": "For developers looking to build their custom application, the deepstream-app can be a bit overwhelming to start development. The SDK ships with several simple applications, where developers can learn about basic concepts of DeepStream, constructing a simple pipeline and then progressing to build more complex applications. Developers can start with deepstream-test1 which is almost like a DeepStream hello world. In this app, developers will learn how to build a GStreamer pipeline using various DeepStream plugins. They will take video from a file, decode, batch and then do object detection and then finally render the boxes on the screen. The deepstream-test2 progresses from test1 and cascades secondary network to the primary network. The deepstream-test3 shows how to add multiple video sources and then finally test4 will show how to IoT services using the message broker plugin. These 4 starter applications are available in both native C/C++ as well as in Python. To read more about these apps and other sample apps in DeepStream, see the C/C++ Sample Apps Source Details and Python Sample Apps and Bindings Source Details . DeepStream applications can be created without coding using the Graph Composer. Please see the Graph Composer Introduction for details.", "keywords": []}, {"id": 2510, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "page", "name": "text/DS_Overview#nvidia-deepstream-overview", "display_name": "NVIDIA DeepStream Overview", "type": "section", "display_type": "Page section", "docname": "text/DS_Overview", "anchor": "nvidia-deepstream-overview", "priority": -1, "content": "DeepStream is a streaming analytic toolkit to build AI-powered applications. It takes the streaming data as input - from USB/CSI camera, video from file or streams over RTSP, and uses AI and computer vision to generate insights from pixels for better understanding of the environment. DeepStream SDK can be the foundation layer for a number of video analytic solutions like understanding traffic and pedestrians in smart city, health and safety monitoring in hospitals, self-checkout and analytics in retail, detecting component defects at a manufacturing facility and others. Read more about DeepStream here . DeepStream supports application development in C/C++ and in Python through the Python bindings. To make it easier to get started, DeepStream ships with several reference applications in both in C/C++ and in Python. See the C/C++ Sample Apps Source Details and Python Sample Apps and Bindings Source Details sections to learn more about the available apps. See NVIDIA-AI-IOT GitHub page for some sample DeepStream reference apps. The core SDK consists of several hardware accelerator plugins that use accelerators such as VIC, GPU, DLA, NVDEC and NVENC. By performing all the compute heavy operations in a dedicated accelerator, DeepStream can achieve highest performance for video analytic applications. One of the key capabilities of DeepStream is secure bi-directional communication between edge and cloud. DeepStream ships with several out of the box security protocols such as SASL/Plain authentication using username/password and 2-way TLS authentication. To learn more about these security features, read the IoT chapter. To learn more about bi-directional capabilities, see the Bidirectional Messaging section in this guide. DeepStream builds on top of several NVIDIA libraries from the CUDA-X stack such as CUDA, TensorRT, NVIDIA \u00ae  Triton \u2122 Inference server and multimedia libraries. TensorRT accelerates the AI inference on NVIDIA GPU. DeepStream abstracts these libraries in DeepStream plugins, making it easy for developers to build video analytic pipelines without having to learn all the individual libraries. DeepStream is optimized for NVIDIA GPUs; the application can be deployed on an embedded edge device running Jetson platform or can be deployed on larger edge or datacenter GPUs like T4. DeepStream applications can be deployed in containers using NVIDIA container Runtime. The containers are available on NGC, NVIDIA GPU cloud registry. To learn more about deployment with dockers, see the Docker container chapter. DeepStream applications can be orchestrated on the edge using Kubernetes on GPU. Sample Helm chart to deploy DeepStream application is available on NGC.", "keywords": []}, {"id": 2511, "doc_id": 2511, "filename": "text/DS_Overview.html", "domain_name": "std", "name": "text/DS_Overview", "display_name": "Welcome to the DeepStream Documentation", "type": "doc", "display_type": "Page", "docname": "text/DS_Overview", "anchor": "", "priority": -1, "content": "Ensure you understand how to migrate your DeepStream 7.0 custom models to DeepStream 7.1 before you start. DeepStream 7.1 is the release that supports new features for NVIDIA \u00ae T4, NVIDIA \u00ae Hopper, NVIDIA \u00ae Ampere, NVIDIA \u00ae ADA, NVIDIA \u00ae Jetson\u2122 Orin NX, NVIDIA \u00ae Jetson\u2122 AGX Orin and NVIDIA \u00ae Jetson\u2122 Orin Nano. It is the release with support for Ubuntu 22.04 LTS. For NVAIE customers, only x86 platform is supported.", "keywords": []}, {"id": 2512, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#application-configuration", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "application-configuration", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=180 sample_1080p_h264.mp4 (provided with the SDK) N=93 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 180 11% 74.17% H.264 93 2.57% 41.63%", "keywords": []}, {"id": 2513, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#configuration-file-settings-for-performance-measurement", "display_name": "Configuration File Settings for Performance Measurement", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "configuration-file-settings-for-performance-measurement", "priority": -1, "content": "To achieve peak performance, make sure the devices are properly cooled. For Turing and Ampere GPUs, make sure you use a server that meets the thermal and airflow requirements. Along with the hardware setup, a few other options in the config file need to be set to achieve the published performance. Make the required changes to one of the config files from DeepStream SDK to replicate the peak performance. Turn off output rendering, OSD, and tiler OSD (on-screen display) is used to display bounding box, masks, and labels on the screen. If output rendering is disabled, creating bounding boxes is not required unless the output needs to be streamed over RTSP or saved to disk. Tiler is used to display the output in NxM tiled grid. It is not needed if rendering is disabled. Output rendering, OSD and tiler use some percentage of compute resources, so it can reduce the inference performance. To disable OSD, tiled display and output sink, make the following changes in the DeepStream config file. To disable OSD, change enable to 0 [osd] enable=0 To disable tiling, change enable to 0 [tiled-display] enable=0 To turn-off output rendering, change the sink to fakesink. [sink0] enable=1 #Type - 1=FakeSink 2=EglSink 3=File type=1 sync=0 Use the max_perf setting for tracker DeepStream SDK 6.2 introduces a new reference low-level tracker library, NvMultiObjectTracker , along with a set of configuration files: config_tracker_IOU.yml config_tracker_NvDCF_max_perf.yml config_tracker_NvDCF_perf.yml config_tracker_NvDCF_accuracy.yml To achieve the peak performance shown in the table above when using the NvDCF tracker, make sure the max_perf configuration is used with video frame resolution matched to that of the inference module. If the inference module uses 480x272 resolution, for example, it would be recommended to use a reduced resolution (e.g., 480x288) for the tracker module like the following: [tracker] enable=1 tracker-width=480 tracker-height=288 ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so #ll-config-file=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_tracker_IOU.yml ll-config-file=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_tracker_NvDCF_max_perf.yml gpu-id=0 enable-batch-process=1 display-tracking-id=1 When the IOU tracker is used, the video frame resolution doesn\u2019t matter, and the default config_tracker_IOU.yml can be used. To use DLA on Jetson AGX Orin and Orin NX for performance measurement, refer to the Using DLA for inference section in the Quickstart Guide. CudaDeviceScheduleBlockingSync flag is set by default on dGPU On dGPU only, cudaDeviceScheduleBlockingSync flag is set by default on the GPU where the Deepstream pipeline runs. In general, for pipelines with multiple streams, this helps in reducing the CPU utilization without affecting the performance much. Setting cudaDeviceScheduleBlockingSync flag when sub batches are enabled in the tracker, results in significant reduction in CPU utilization with similar or negligible dip in performance. When the environment variable NVDS_DISABLE_CUDADEV_BLOCKINGSYNC is set to 1, cudaDeviceScheduleBlockingSync flag is not set by default. There is a remote possibility that setting cudaDeviceScheduleBlockingSync flag might affect the pipeline performance negatively when the pipeline already runs with GPU utilization close to 100%. Hence, when the user encounters a situation where a Deepstream pipeline is GPU bound and the GPU utilization does not reach close to 100%, then the user may experiment with setting NVDS_DISABLE_CUDADEV_BLOCKINGSYNC to 1 and check if it helps in improving the performance of the pipeline.", "keywords": []}, {"id": 2514, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-a10", "display_name": "Data center GPU - A10", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-a10", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - A10.", "keywords": []}, {"id": 2515, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-a2", "display_name": "Data center GPU - A2", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-a2", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - A2.", "keywords": []}, {"id": 2516, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-a30", "display_name": "Data center GPU - A30", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-a30", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - A30.", "keywords": []}, {"id": 2517, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-a4000", "display_name": "Data center GPU - A4000", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-a4000", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - A4000.", "keywords": []}, {"id": 2518, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-ga100", "display_name": "Data center GPU - GA100", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-ga100", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - GA100.", "keywords": []}, {"id": 2519, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-h100", "display_name": "Data center GPU - H100", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-h100", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - H100.", "keywords": []}, {"id": 2520, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-l4", "display_name": "Data center GPU - L4", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-l4", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - L4.", "keywords": []}, {"id": 2521, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-l40", "display_name": "Data center GPU - L40", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-l40", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - L40.", "keywords": []}, {"id": 2522, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-l4000", "display_name": "Data center GPU - L4000", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-l4000", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - L4000.", "keywords": []}, {"id": 2523, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-quadro-a6000", "display_name": "Data center GPU - Quadro (A6000)", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-quadro-a6000", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - Quadro (A6000).", "keywords": []}, {"id": 2524, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#data-center-gpu-t4", "display_name": "Data center GPU - T4", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "data-center-gpu-t4", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Data center GPU - T4.", "keywords": []}, {"id": 2525, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#deepstream-reference-model-and-tracker", "display_name": "DeepStream reference model and tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "deepstream-reference-model-and-tracker", "priority": -1, "content": "DeepStream SDK ships with a reference DetectNet_v2-ResNet10 model and three ResNet18 classifier models. The detailed instructions to run these models with DeepStream are provided in the next section. DeepStream provides four reference trackers: IOU , NvSORT , NvDeepSORT and NvDCF . For more information about trackers, See the Gst-nvtracker section.", "keywords": []}, {"id": 2526, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id11", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id11", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU Dual Intel\u00ae Xeon\u00ae CPU E5-2650 v4 @ 2.20GHz (48 threads total) GPU Tesla T4* System Memory 360448Mb (22x16384) DDR42666, 2400MHz Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6 GPU clock frequency 1513 MHz", "keywords": []}, {"id": 2527, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id12", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id12", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=45 sample_1080p_h264.mp4 (provided with the SDK) N=31 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 45 51.81% 100% H.264 31 2.72% 61.23%", "keywords": []}, {"id": 2528, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id13", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id13", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU A30 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6 GPU clock frequency 1440 MHz", "keywords": []}, {"id": 2529, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id14", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id14", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=150 sample_1080p_h264.mp4 (provided with the SDK) N=98 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 150 41.87% 96.9% H.264 98 5.62% 61.33%", "keywords": []}, {"id": 2530, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id15", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id15", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU A2 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6 GPU clock frequency 1770 MHz", "keywords": []}, {"id": 2531, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id16", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id16", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=31 sample_1080p_h264.mp4 (provided with the SDK) N=31 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 31 21.91% 100% H.264 31 21.99% 100%", "keywords": []}, {"id": 2532, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id17", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id17", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU A10 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6 GPU clock frequency 1695 MHz", "keywords": []}, {"id": 2533, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id18", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id18", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=79 sample_1080p_h264.mp4 (provided with the SDK) N=43 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 79 3.26% 65.59% H.264 43 1.4% 31.18%", "keywords": []}, {"id": 2534, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id19", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id19", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU H100 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2535, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id20", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id20", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=229 sample_1080p_h264.mp4 (provided with the SDK) N=148 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 229 2.76% 90.1% H.264 148 2.6% 42.32%", "keywords": []}, {"id": 2536, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id21", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id21", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU L40 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2537, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id22", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id22", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=166 sample_1080p_h264.mp4 (provided with the SDK) N=75 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 166 12.65% 71.63% H.264 75 1.89% 34.57%", "keywords": []}, {"id": 2538, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id23", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id23", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU L4 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2539, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id24", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id24", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=81 sample_1080p_h264.mp4 (provided with the SDK) N=68 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 81 46.1% 100% H.264 68 8.06% 75.74%", "keywords": []}, {"id": 2540, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id25", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id25", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU Quadro (A6000) Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2541, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id26", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id26", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=101 sample_1080p_h264.mp4 (provided with the SDK) N=49 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 101 7.05% 60.17% H.264 49 2.68% 28.57%", "keywords": []}, {"id": 2542, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id27", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id27", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU L4 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2543, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id28", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id28", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=49 sample_1080p_h264.mp4 (provided with the SDK) N=24 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 49 0.97% 49.87% H.264 24 0.48% 24.56%", "keywords": []}, {"id": 2544, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id29", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id29", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7763 @2430 MHz GPU L4 Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6", "keywords": []}, {"id": 2545, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id30", "display_name": "Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id30", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IoU tracker. The application configuration for the DeepStream SDK is listed below: Application Configuration Specification N\u00d71080p 30 fps stream sample_1080p_h265.mp4 (provided with the SDK) N=76 sample_1080p_h264.mp4 (provided with the SDK) N=45 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval=0 Tracker Enabled. Processing at 960x544 resolution, IOU tracker enabled. 2 \u00d7 Secondary GIEs All batches size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) Tiled Display Disabled Rendering Disabled Achieved Performance The table below shows the achieved performance of the DeepStream SDK under the specified system and application configuration: Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 76 20% 99.25% H.264 45 0.96% 53.02%", "keywords": []}, {"id": 2546, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#id31", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "id31", "priority": -1, "content": "For the performance test: Max power mode is enabled: $ sudo nvpmodel -m 0 . The GPU clocks are stepped to maximum: $ sudo jetson_clocks For information about supported power modes, see the \u201cSupported Modes and Power Efficiency\u201d section in the power management topics of NVIDIA Tegra Linux Driver Package Development Guide , e.g., \u201cPower Management for Jetson AGX Orin Devices.\u201d", "keywords": []}, {"id": 2547, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#jetson", "display_name": "Jetson", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "jetson", "priority": -1, "content": "This section describes configuration and settings for the DeepStream SDK on NVIDIA Jetson\u2122 platforms. JetPack 6.0 GA is used for software installation.", "keywords": []}, {"id": 2548, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#jetson-agx-orin", "display_name": "Jetson AGX Orin", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "jetson-agx-orin", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IOU tracker. The following tables describe performance results for the NVIDIA Jetson Orin\u2122. Application Configuration Specification N\u00d71080p 30 fps streams sample_1080p_h265.mp4 (provided with the SDK) N=37 sample_1080p_h264.mp4 (provided with the SDK) N=15 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval = 0 Tracker Enabled; processing at 960x544 resolution, IOU tracker enabled. 2\u00d7 secondary GIEs All batches are size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) OSD/tiled display Disabled Renderer Disabled Achieved Performance Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 37 21.25% 82.30% H.264 15 9.49% 36.42%", "keywords": []}, {"id": 2549, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#jetson-orin-nano", "display_name": "Jetson Orin Nano", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "jetson-orin-nano", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IOU tracker. The following tables describe performance results for the NVIDIA Jetson Orin Nano\u2122. Application Configuration Specification N\u00d71080p 30 fps streams sample_1080p_h265.mp4 (provided with the SDK) N=13 sample_1080p_h264.mp4 (provided with the SDK) N=8 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval = 0 Tracker Enabled; processing at 960x544 resolution, IOU tracker enabled. 2\u00d7 secondary GIEs All batches are size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) OSD/tiled display Disabled Renderer Disabled Achieved Performance Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 13 20.65% 99% H.264 8 12.49% 60.15%", "keywords": []}, {"id": 2550, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#jetson-orin-nx", "display_name": "Jetson Orin NX", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "jetson-orin-nx", "priority": -1, "content": "Config file : source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt Change the following items in the config file: Change batch size under streammux and primary-gie to match the number of streams. Disable tiled display and rendering using instructions above. Enable IOU tracker. The following tables describe performance results for the NVIDIA Jetson Orin NX\u2122. Application Configuration Specification N\u00d71080p 30 fps streams sample_1080p_h265.mp4 (provided with the SDK) N=16 sample_1080p_h264.mp4 (provided with the SDK) N=13 Primary GIE resnet18_trafficcamnet_pruned.onnx Batch Size = N Interval = 0 Tracker Enabled; processing at 960x544 resolution, IOU tracker enabled. 2\u00d7 secondary GIEs All batches are size 32. Asynchronous mode enabled. Secondary_VehicleTypes (224\u00d7224\u2014Resnet18) Secondary_VehicleMake (224\u00d7224\u2014Resnet18) OSD/tiled display Disabled Renderer Disabled Achieved Performance Stream type No. of Stream @ 30 FPS CPU Utilization GPU Utilization H.265 16 19.26% 99% H.264 13 15.22% 78.52%", "keywords": []}, {"id": 2551, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#system-configuration", "display_name": "System Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "system-configuration", "priority": -1, "content": "The system configuration for the DeepStream SDK is listed below: System Configuration Specification CPU AMD EPYC 7742 @ 2.25GHz 3.4GHz Turbo (Rome) HT Off GPU A100-PCIE-40GB(GA100) 1*40537 MiB 1*108 SM Ubuntu Ubuntu 22.04 GPU Driver 535.161.08 CUDA 12.2 TensorRT 8.6.1.6 GPU clock frequency 1410 MHz", "keywords": []}, {"id": 2552, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "page", "name": "text/DS_Performance#tao-pre-trained-models", "display_name": "TAO Pre-trained models", "type": "section", "display_type": "Page section", "docname": "text/DS_Performance", "anchor": "tao-pre-trained-models", "priority": -1, "content": "TAO toolkit has a set of pretrained models listed in the table below. If the models below satisfy your requirement, you should start with one of them. These could be used for various applications in smart city or smart places. If your application is beyond the scope of these models, you may re-train one of the popular model architecture using TAO toolkit. The table below shows the end-to-end performance on highly accurate pre-trained models from TAO toolkit. All models are available on NGC. These models are natively integrated with DeepStream and the instructions to run these models are in /opt/nvidia/deepstream/deepstream/samples/configs/tao_pretrained_models/ . The following numbers are obtained with sample_1080p_h265.mp4 . Jetson AGX Orin Jetson Orin NX Jetson Orin Nano Model Arch Inference resolution Precision Tracker GPU (FPS) DLA1 /DLA2 (FPS) GPU (FPS) DLA1/ DLA2 (FPS) GPU (FPS) PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 No Tracker 976 330 336 166 250 PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 NvDCF Tracker 626 312 286 153 217 PeopleNet- ViT (deployable_v1.1) 960x544 INT8 No Tracker 48 NA 17 NA 13 PeopleNet- ViT (deployable_v1.1) 960x544 INT8 NvDCF Tracker 43 NA 17 NA 13 YOLOv8 640x640 INT8 No Tracker 750 NA 236 NA 182 YOLOv8 640x640 INT8 NvDCF Tracker 579 NA 211 NA 155 YOLOv9 640x640 FP16 No Tracker 474 NA 164 NA 122 YOLOv9 640x640 FP16 NvDCF Tracker 396 NA 140 NA 104 All the models in the table above can run solely on DLA. This saves valuable GPU resources to run more complex models. Running inference simultaneously on multiple models is not supported on the DLA. You can only run one model at a time on the DLA. NA : Not available for Jetson NA* : For these models DLA falls back to GPU A100 PCIe A30 A2 A10 Model Arch Inference resolution Precision Inference Engine Tracker GPU (FPS) GPU (FPS) GPU (FPS) GPU (FPS) PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 TRT No Tracker 4955 3127 551 2056 PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 TRT NvDCF Tracker 4272 2672 515 1901 PeopleNet- ViT (deployable_v1.1) 960x544 INT8 TRT No Tracker 347 167 18 148 PeopleNet- ViT (deployable_v1.1 ) 960x544 INT8 TRT NvDCF Tracker 308 165 18 180 YOLOv8s 640x640 INT8 TRT No Tracker 2593 1879 486 1465 YOLOv8s 640x640 INT8 TRT NvDCF Tracker 2455 1803 418 1334 YOLOv9t 640x640 FP16 TRT No Tracker 2396 1638 339 1262 YOLOv9t 640x640 FP16 TRT NvDCF Tracker 2215 1476 326 1121 H100 L40 L4 Quadro (A6000) A4000 L4000 Model Arch Inference resolution Precision Inference Engine Tracker GPU (FPS) GPU (FPS) GPU (FPS) GPU (FPS) GPU (FPS) GPU (FPS) PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 TRT No Tracker 6831 4571 1580 2834 1308 1361 PeopleNet- ResNet34 (v2.3.4) 960x544 INT8 TRT NvDCF Tracker 5842 3818 1370 1459 1268 1183 PeopleNet- ViT (deployable_v1.1) 960x544 INT8 TRT No Tracker 495 362 119 227 106 102 PeopleNet- ViT (deployable_v1.1) 960x544 INT8 TRT NvDCF Tracker 461 349 116 209 107 73 YOLOv8s 640x640 INT8 TRT No Tracker 2993 2213 1123 1845 1175 957 YOLOv8s 640x640 INT8 TRT NvDCF Tracker 2826 2248 984 607 1027 844 YOLOv9t 640x640 FP16 TRT No Tracker 2688 2260 1019 1660 939 865 YOLOv9t 640x640 FP16 TRT NvDCF Tracker 2541 1931 893 1587 852 764 NA : Not available TBU : To Be Updated", "keywords": []}, {"id": 2553, "doc_id": 2553, "filename": "text/DS_Performance.html", "domain_name": "std", "name": "text/DS_Performance", "display_name": "Performance", "type": "doc", "display_type": "Page", "docname": "text/DS_Performance", "anchor": "", "priority": -1, "content": "DeepStream application is benchmarked across various NVIDIA TAO Toolkit and open source models. The measured performance represents end-to-end performance of the entire video analytic application considering video capture and decode, pre-processing, batching, inference, and post-processing to generate metadata. The output rendering is turned off to achieve peak inference performance. For information on disabling the output rendering, see DeepStream Reference Application - deepstream-app chapter.", "keywords": []}, {"id": 2554, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#allocations", "display_name": "Allocations", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "allocations", "priority": -1, "content": "When MetaData objects are allocated in Python, an allocation function is provided by the bindings to ensure proper memory ownership of the object. If the constructor is used, the the object will be claimed by the garbage collector when its Python references terminate. However, the object will still need to be accessed by C/C++ code downstream, and therefore must persist beyond those Python references. Example: To allocate an NvDsEventMsgMeta instance, use this: msg_meta = pyds.alloc_nvds_event_msg_meta() *# get reference to allocated instance without claiming memory ownership* NOT this: msg_meta = NvDsEventMsgMeta() *# memory will be freed by the garbage collector when msg_meta goes out of scope in Python* Allocators are available for the following structs: NvDsVehicleObject: alloc_nvds_vehicle_object() NvDsPersonObject: alloc_nvds_person_object() NvDsFaceObject: alloc_nvds_face_object() NvDsEventMsgMeta: alloc_nvds_event_msg_meta() NvDsEvent: alloc_nvds_event() NvDsPayload: alloc_nvds_payload() Generic buffer: alloc_buffer(size)", "keywords": []}, {"id": 2555, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#callback-function-registration", "display_name": "Callback Function Registration", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "callback-function-registration", "priority": -1, "content": "Custom MetaData added to NvDsUserMeta require custom copy and release functions. The MetaData library relies on these custom functions to perform deep-copy of the custom structure, and free allocated resources. These functions are registered as callback function pointers in the NvDsUserMeta structure. Callback functions are registered using these functions: pyds.set_user_copyfunc(NvDsUserMeta_instance, copy_function) pyds.set_user_releasefunc(NvDsUserMeta_instance, free_func) Callbacks need to be unregistered with the bindings library before the application exits. The bindings library currently keeps global references to the registered functions, and these cannot last beyond bindings library unload which happens at application exit. Use the following function to unregister all callbacks: pyds.unset_callback_funcs() See the deepstream-test4 sample application for an example of callback registration and deregistration. Limitation : The bindings library currently only supports a single set of callback functions for each application. The last registered function will be used.", "keywords": []}, {"id": 2556, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#casting", "display_name": "Casting", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "casting", "priority": -1, "content": "Some MetaData instances are stored in GList form. To access the data in a GList node, the data field needs to be cast to the appropriate structure. This casting is done via cast() member function for the target type: NvDsBatchMeta.cast NvDsFrameMeta.cast NvDsObjectMeta.cast NvDsUserMeta.cast NvDsClassifierMeta.cast NvDsDisplayMeta.cast NvDsLabelInfo.cast NvDsEventMsgMeta.cast NvDsVehicleObject.cast NvDsPersonObject.cast In version v0.5, standalone cast functions were provided. Those are now deprecated and superseded by the cast() functions above: glist_get_nvds_batch_meta glist_get_nvds_frame_meta glist_get_nvds_object_meta glist_get_nvds_user_meta glist_get_nvds_classifier_meta glist_get_nvds_display_meta glist_get_nvds_label_info glist_get_nvds_event_msg_meta glist_get_nvds_vehicle_object glist_get_nvds_person_object Example: l_frame = batch_meta.frame_meta_list frame_meta = pyds.NvDsFrameMeta.cast(l_frame.data)", "keywords": []}, {"id": 2557, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#image-data-access", "display_name": "Image Data Access", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "image-data-access", "priority": -1, "content": "Decoded images are accessible as NumPy arrays via the get_nvds_buf_surface function. This function is documented in the API Guide. See the deepstream-imagedata-multistream sample application for an example of image data usage.", "keywords": []}, {"id": 2558, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#memory-management", "display_name": "Memory Management", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "memory-management", "priority": -1, "content": "Memory for MetaData is shared by the Python and C/C++ code paths. For example, a MetaData item may be added by a probe function written in Python and needs to be accessed by a downstream plugin written in C/C++. The deepstream-test4 app contains such usage. The Python garbage collector does not have visibility into memory references in C/C++, and therefore cannot safely manage the lifetime of such shared memory. Because of this complication, Python access to MetaData memory is typically achieved via references without claiming ownership.", "keywords": []}, {"id": 2559, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#metadata-access", "display_name": "MetaData Access", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "metadata-access", "priority": -1, "content": "DeepStream MetaData contains inference results and other information used in analytics. The MetaData is attached to the Gst Buffer received by each pipeline component. The metadata format is described in detail in the SDK MetaData documentation and API Guide. The SDK MetaData library is developed in C/C++. Python bindings provide access to the MetaData from Python applications. Please find Python bindings source and packages at NVIDIA-AI-IOT/deepstream_python_apps .", "keywords": []}, {"id": 2560, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#optimizations-and-utilities", "display_name": "Optimizations and Utilities", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "optimizations-and-utilities", "priority": -1, "content": "Python interpretation is generally slower than running compiled C/C++ code. To provide better performance, some operations are implemented in C and exposed via the bindings interface. This is currently experimental and will expand over time. The following optimized functions are available: pyds.NvOSD_ColorParams.set(double red, double green, double blue, double alpha) This is a simple function that performs the same operations as the following: txt_params.text_bg_clr.red = red txt_params.text_bg_clr.green = green txt_params.text_bg_clr.blue = blue txt_params.text_bg_clr.alpha = alpha These are performed on each object in deepstream_test_4.py, causing the aggregate processing time to slow down the pipeline. Pushing this function into the C layer helps to increase performance. generate_ts_rfc3339 (buffer, buffer_size) This function populates the input buffer with a timestamp generated according to RFC3339: %Y-%m-%dT%H:%M:%S.nnnZ\\0", "keywords": []}, {"id": 2561, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#pipeline-construction", "display_name": "Pipeline Construction", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "pipeline-construction", "priority": -1, "content": "DeepStream pipelines can be constructed using Gst Python, the GStreamer framework\u2019s Python bindings. See sample applications main functions for pipeline construction examples.", "keywords": []}, {"id": 2562, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "prerequisites", "priority": -1, "content": "Ubuntu 22.04 DeepStream SDK 7.0 or later Python 3.10 Gst Python v1.20.3 If Gst python installation is missing on Jetson, follow the instructions in bindings readme .", "keywords": []}, {"id": 2563, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#python-bindings-and-application-development", "display_name": "Python Bindings and Application Development", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "python-bindings-and-application-development", "priority": -1, "content": "This section provides details about DeepStream application development in Python. Python bindings are available here: NVIDIA-AI-IOT/deepstream_python_apps . Read more about Pyds API here .", "keywords": []}, {"id": 2564, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#reading-string-fields", "display_name": "Reading String Fields", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "reading-string-fields", "priority": -1, "content": "Directly reading a string field returns C address of the field in the form of an int, for example: obj = pyds.NvDsVehicleObject.cast(data); print(obj.type) This will print an int representing the address of obj.type in C (which is a char*). To retrieve the string value of this field, use pyds.get_string() , for example: print(pyds.get_string(obj.type))", "keywords": []}, {"id": 2565, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#running-sample-applications", "display_name": "Running Sample Applications", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "running-sample-applications", "priority": -1, "content": "Clone the deepstream_python_apps repo under &lt;DeepStream ROOT&gt;/sources : git clone https://github.com/NVIDIA-AI-IOT/deepstream_python_apps This will create the following directory: &lt;DeepStream ROOT&gt;/sources/deepstream_python_apps The Python apps are under the apps directory. Go into each app directory and follow instructions in the README. The app configuration files contain relative paths for models.", "keywords": []}, {"id": 2566, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#sample-application-source-details", "display_name": "Sample Application Source Details", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "sample-application-source-details", "priority": -1, "content": "The following table shows the location of the Python sample applications under NVIDIA-AI-IOT/deepstream_python_apps . Reference test application Path inside the GitHub repo Description Simple test application 1 apps/\u00addeepstream-test1 Simple example of how to use DeepStream elements for a single H.264 stream: filesrc \u2192 decode \u2192 nvstreammux \u2192 nvinfer (primary detector) \u2192 nvdsosd \u2192 renderer. Simple test application 2 apps/\u00addeepstream-test2 Simple example of how to use DeepStream elements for a single H.264 stream: filesrc \u2192 decode \u2192 nvstreammux \u2192 nvinfer (primary detector) \u2192 nvtracker \u2192 nvinfer (secondary classifier) \u2192 nvdsosd \u2192 renderer. Simple test application 3 apps/\u00addeepstream-test3 Builds on deepstream-test1 (simple test application 1) to demonstrate how to: Use multiple sources in the pipeline Use a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codec Configure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilization Extract the stream metadata, which contains useful information about the frames in the batched buffer Simple test application 4 apps/\u00addeepstream-test4 Builds on deepstream-test1 for a single H.264 stream: filesrc, decode, nvstreammux, nvinfer, nvdsosd, renderer to demonstrate how to: Use the Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline Create NVDS_META_EVENT_MSG type metadata and attach it to the buffer Use NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and person Implement \u201ccopy\u201d and \u201cfree\u201d functions for use if metadata is extended through the extMsg field USB camera source application apps/\u00addeepstream-test1-usbcam Simple test application 1 modified to process a single stream from a USB camera. RTSP output application apps/\u00addeepstream-test1-rtsp-out Simple test application 1 modified to output visualization stream over RTSP. Image data access application apps/\u00addeepstream-imagedata-multistream Builds on simple test application 3 to demonstrate how to: Access decoded frames as NumPy arrays in the pipeline Check detection confidence of detected objects (DBSCAN or NMS clustering required) Modify frames and see the changes reflected downstream in the pipeline Use OpenCV to annotate the frames and save them to file SSD detector output parser application apps/\u00addeepstream-ssd-parser Demonstrates how to perform custom post-processing for inference output from Triton Inference Server: Use SSD model on Triton Inference Server for object detection Enable custom post-processing and raw tensor export for Triton Inference Server via configuration file settings Access inference output tensors in the pipeline for post-processing in Python Add detected objects to the metadata Output the OSD visualization to MP4 file Optical flow application apps/deepstream-opticalflow Demonstrates how to obtain opticalflow meta data and also demonstrates how to: Access optical flow vectors as numpy array Visualize optical flow using obtained flow vectors and OpenCV Segmentation application apps/deepstream-segmentation Demonstrates how to obtain segmentation meta data and also demonstrates how to: Acess segmentation masks as numpy array Visualize segmentation using obtained masks and OpenCV Analytics application apps/deepstream-nvdsanalytics Demonstrates how to use the nvdsanalytics plugin and obtain analytics metadata Runtime source add/delete application apps/runtime_source_add_delete Demonstrates how to add and delete input sources at runtime Face redaction application apps/deepstream-imagedata-multistream-redaction Demonstrates how to access image data and perform face redaction RTSP input/output application apps/deepstream-rtsp-in-rtsp-out Multi-stream pipeline with RTSP input and output Preprocess application apps/deepstream-preprocess-test Demonstrates how to use nvdspreprocess plugin and perform custom preprocessing on provided ROIs Demuxer application apps/deepstream-demux-multi-in-multi-out Builds on deepstream-test3 to demonstrate how to use nvstreamdemux plugin to split batches and output separate buffer/streams. CuPy application apps/deepstream-imagedata-multistream-cupy Demonstrates how to access GPU buffer in a multistream source as a CuPy array and modify images in place. Segmask application apps/deepstream-segmask Demonstrates how to extract NvOSD_MaskParams from stream metadata and resize and binarize mask array for interpretable segmentation mask. Custom binding application apps/deepstream-custom-binding-test Demonstrates how to use NvDsUserMeta to attach and extract custom data structure written in Python bindings to/from the buffer.", "keywords": []}, {"id": 2567, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#setting-string-fields", "display_name": "Setting String Fields", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "setting-string-fields", "priority": -1, "content": "Setting a string field results in the allocation of a string buffer in the underlying C++ code. obj.type = &quot;Type&quot; This will cause a memory buffer to be allocated, and the string \u201cTYPE\u201d will be copied into it. This memory is owned by the C code and will be freed later. To free the buffer in Python code, use: pyds.free_buffer(obj.type) NvOSD_TextParams.display_text string now gets freed automatically when a new string is assigned.", "keywords": []}, {"id": 2568, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "page", "name": "text/DS_Python_Sample_Apps#string-access", "display_name": "String Access", "type": "section", "display_type": "Page section", "docname": "text/DS_Python_Sample_Apps", "anchor": "string-access", "priority": -1, "content": "Some MetaData structures contain string fields. Sections below provide details on accessing them.", "keywords": []}, {"id": 2569, "doc_id": 2569, "filename": "text/DS_Python_Sample_Apps.html", "domain_name": "std", "name": "text/DS_Python_Sample_Apps", "display_name": "Python Sample Apps and Bindings Source Details", "type": "doc", "display_type": "Page", "docname": "text/DS_Python_Sample_Apps", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2570, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#boost-the-clocks", "display_name": "Boost the clocks", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "boost-the-clocks", "priority": -1, "content": "After you have installed DeepStream SDK, run these commands on the Jetson device to boost the clocks: $ sudo nvpmodel -m 0 $ sudo jetson_clocks You should run these commands before running DeepStream application.", "keywords": []}, {"id": 2571, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#deepstream-triton-inference-server-usage-guidelines", "display_name": "DeepStream Triton Inference Server Usage Guidelines", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "deepstream-triton-inference-server-usage-guidelines", "priority": -1, "content": "To migrate the Triton version in a DeepStream 7.1 deployment (Triton 24.08) to a newer version (say Triton 24.09 or newer), follow the instructions at DeepStream Triton Migration Guide . Before running prepare_classification_test_video.sh , refer note in section Docker Containers .", "keywords": []}, {"id": 2572, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#dgpu", "display_name": "dGPU", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "dgpu", "priority": -1, "content": "Pull the DeepStream Triton Inference Server docker docker pull nvcr.io/nvidia/deepstream:7.1-triton-multiarch Start the docker docker run --gpus &quot;device=0&quot; -it --rm -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY -e CUDA_CACHE_DISABLE=0 nvcr.io/nvidia/deepstream:7.1-triton-multiarch The triton docker for x86 &amp; jetson is based on Tritonserver 24.08 docker and has Ubuntu 22.04. When the triton docker is launched for the first time, it might take a few minutes to start since it has to generate compute cache.", "keywords": []}, {"id": 2573, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#dgpu-for-ubuntu", "display_name": "dGPU for Ubuntu", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "dgpu-for-ubuntu", "priority": -1, "content": "This section explains how to use DeepStream SDK on a x86 machine.", "keywords": []}, {"id": 2574, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#dgpu-on-arm-igx-dgpu-gh100-gh200-sbsa", "display_name": "dGPU on ARM (IGX/dGPU, GH100, GH200, SBSA)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "dgpu-on-arm-igx-dgpu-gh100-gh200-sbsa", "priority": -1, "content": "Pull the DeepStream Triton Inference Server docker docker pull nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa Start the docker sudo docker run -it --rm --runtime=nvidia --network=host -e NVIDIA_DRIVER_CAPABILITIES=compute,utility,video,graphics --gpus all --privileged -e DISPLAY=:0 -v /tmp/.X11-unix:/tmp/.X11-unix -v /etc/X11:/etc/X11 nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa The triton docker for dGPU on ARM is based on Tritonserver 24.08 docker and has Ubuntu 22.04. When the triton docker is launched for the first time, it might take a few minutes to start since it has to generate compute cache. dGPU on ARM/SBSA docker currently supports only nv3dsink for video display via workaround mentioned in section Known Limitation with Video Subsystem and Workaround .", "keywords": []}, {"id": 2575, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#ds-quickstart-ds-app-x86", "display_name": "Expected output (deepstream-app)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "ds-quickstart-ds-app-x86", "priority": -1, "content": "The image below shows the expected output of deepstream-app with source30_1080p_dec_infer-resnet_tiled_display_int8.txt config:", "keywords": []}, {"id": 2576, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#expected-output-deepstream-app", "display_name": "Expected output (deepstream-app)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "expected-output-deepstream-app", "priority": -1, "content": "The image below shows the expected output of deepstream-app with source30_1080p_dec_infer-resnet_tiled_display_int8.txt config:", "keywords": []}, {"id": 2577, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#id2", "display_name": "Run precompiled sample applications", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "id2", "priority": -1, "content": "Navigate to the chosen application directory inside sources/apps/sample_apps . Follow that directory\u2019s README file to run the application. If the application encounters errors and cannot create Gst elements, remove the GStreamer cache, then try again. To remove the GStreamer cache, enter this command: $ rm ${HOME}/.cache/gstreamer-1.0/registry.x86_64.bin When the application is run for a model which does not have an existing engine file, it may take up to a few minutes (depending on the platform and the model) for the file generation and application launch. For later runs, these generated engine files can be reused for faster loading.", "keywords": []}, {"id": 2578, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#jetson", "display_name": "Jetson", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "jetson", "priority": -1, "content": "DeepStream Triton container image (nvcr.io/nvidia/deepstream:7.1-triton-multiarch) has Triton Inference Server and supported backend libraries pre-installed. In order to run the Triton Inference Server directly on device, i.e., without docker, Triton Server setup will be required. Go to samples directory and run the following commands to set up the Triton Server and backends. $ cd /opt/nvidia/deepstream/deepstream/samples/ $ sudo ./triton_backend_setup.sh By default script will download the Triton Server version 2.49. For setting up any other version change the package path accordingly. Triton backends are installed into /opt/nvidia/deepstream/deepstream/lib/triton_backends by default by the script. User can update infer_config settings for specific folders as follows: model_repo { backend_dir: /opt/nvidia/tritonserver/backends/ }", "keywords": []}, {"id": 2579, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#jetson-not-applicable-for-nvaie-customers", "display_name": "Jetson [Not applicable for NVAIE customers]", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "jetson-not-applicable-for-nvaie-customers", "priority": -1, "content": "This section explains how to use DeepStream SDK on a Jetson device.", "keywords": []}, {"id": 2580, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#run-deepstream-app-the-reference-application", "display_name": "Run deepstream-app (the reference application)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "run-deepstream-app-the-reference-application", "priority": -1, "content": "Navigate to the configs/deepstream-app directory on the development kit. $ cd /opt/nvidia/deepstream/deepstream-7.1/samples/configs/deepstream-app Enter the following command to run the reference application: # deepstream-app -c &lt;path_to_config_file&gt; e.g. $deepstream-app -c source30_1080p_dec_infer-resnet_tiled_display_int8.txt Where &lt;path_to_config_file&gt; is the pathname of one of the reference application\u2019s configuration files, found in configs/deepstream-app/ . See Package Contents in configs/deepstream-app/ for a list of the available files. Config files that can be run with deepstream-app: source30_1080p_dec_infer-resnet_tiled_display_int8.txt source30_1080p_dec_preprocess_infer-resnet_tiled_display_int8.txt source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt source1_usb_dec_infer_resnet_int8.txt source1_csi_dec_infer_resnet_int8.txt source2_csi_usb_dec_infer_resnet_int8.txt source6_csi_dec_infer_resnet_int8.txt source2_1080p_dec_infer-resnet_demux_int8.txt source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yml source30_1080p_dec_infer-resnet_tiled_display_int8.yml source4_1080p_dec_preprocess_infer-resnet_preprocess_sgie_tiled_display_int8.txt source2_dewarper_test.txt Refer to Sample Configurations and Streams for detailed explanation of each configuration file. You can find sample configuration files under /opt/nvidia/deepstream/deepstream-7.1/samples directory. Enter this command to see application usage: $ deepstream-app --help To save TensorRT Engine/Plan file, run the following command: $ sudo deepstream-app -c &lt;path_to_config_file&gt; To show labels in 2D Tiled display view, expand the source of interest with mouse left-click on the source. To return to the tiled display, right-click anywhere in the window. Keyboard selection of source is also supported. On the console where application is running, press the z key followed by the desired row index (0 to 9), then the column index (0 to 9) to expand the source. To restore 2D Tiled display view, press z again.", "keywords": []}, {"id": 2581, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#run-precompiled-sample-applications", "display_name": "Run precompiled sample applications", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "run-precompiled-sample-applications", "priority": -1, "content": "Navigate to the chosen application directory inside sources/apps/sample_apps . Follow the directory\u2019s README file to run the application. If the application encounters errors and cannot create Gst elements, remove the GStreamer cache, then try again. To remove the GStreamer cache, enter this command: $ rm ${HOME}/.cache/gstreamer-1.0/registry.aarch64.bin When the application is run for a model which does not have an existing engine file, it may take up to a few minutes (depending on the platform and the model) for the file generation and the application launch. For later runs, these generated engine files can be reused for faster loading.", "keywords": []}, {"id": 2582, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#run-the-deepstream-app-the-reference-application", "display_name": "Run the deepstream-app (the reference application)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "run-the-deepstream-app-the-reference-application", "priority": -1, "content": "Navigate to the configs/deepstream-app directory on the development kit. $ cd /opt/nvidia/deepstream/deepstream-7.1/samples/configs/deepstream-app Enter the following command to run the reference application: # deepstream-app -c &lt;path_to_config_file&gt; e.g. $deepstream-app -c source30_1080p_dec_infer-resnet_tiled_display_int8.txt Where &lt;path_to_config_file&gt; is the pathname of one of the reference application\u2019s configuration files, found in configs/deepstream-app . See Package Contents in configs/deepstream-app/ for a list of the available files. Config files that can be run with deepstream-app: source30_1080p_dec_infer-resnet_tiled_display_int8.txt source30_1080p_dec_preprocess_infer-resnet_tiled_display_int8.txt source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8_gpu1.txt source1_usb_dec_infer_resnet_int8.txt source2_1080p_dec_infer-resnet_demux_int8.txt source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yml source30_1080p_dec_infer-resnet_tiled_display_int8.yml source4_1080p_dec_preprocess_infer-resnet_preprocess_sgie_tiled_display_int8.txt source2_dewarper_test.txt Refer to Sample Configurations and Streams for detailed explanation of each configuration file. To dump engine file, run the following command: $ sudo deepstream-app -c &lt;path_to_config_file&gt; You can find sample configuration files under /opt/nvidia/deepstream/deepstream-7.1/samples directory. Enter this command to see application usage: $ deepstream-app --help To show labels in 2D tiled display view, expand the source of interest with a mouse left-click on the source. To return to the tiled display, right-click anywhere in the window. Keyboard selection of source is also supported. On the console where application is running, press the z key followed by the desired row index (0 to 9), then the column index (0 to 9) to expand the source. To restore the 2D Tiled display view, press z again.", "keywords": []}, {"id": 2583, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#running-with-an-x-server-by-creating-virtual-display", "display_name": "1 . Running with an X server by creating virtual display", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "running-with-an-x-server-by-creating-virtual-display", "priority": -1, "content": "Refer https://docs.nvidia.com/grid/latest/grid-vgpu-user-guide/index.html#configuring-xorg-server-on-linux-server for details.", "keywords": []}, {"id": 2584, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#running-without-an-x-server-applicable-for-applications-supporting-rtsp-streaming-output", "display_name": "2 . Running without an X server (applicable for applications supporting RTSP streaming output)", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "running-without-an-x-server-applicable-for-applications-supporting-rtsp-streaming-output", "priority": -1, "content": "The default configuration files provided with the SDK have the EGL based nveglglessink as the default renderer (indicated by type=2 in the [sink] groups). The renderer requires a running X server and fails without one. In case of absence of an X server, DeepStream reference applications provide an alternate functionality of streaming the output over RTSP. This can be enabled by adding an RTSP out sink group in the configuration file. Refer to [sink2] group in source30_1080p_dec_infer-resnet_tiled_display_int8.txt file for an example. Don\u2019t forget to disable the nveglglessink renderer by setting enable=0 for the corresponding sink group.", "keywords": []}, {"id": 2585, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#separate-processes", "display_name": "Separate processes", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "separate-processes", "priority": -1, "content": "When GPU and DLA are run in separate processes, set the environment variable CUDA_DEVICE_MAX_CONNECTIONS as 1 from the terminal where DLA config is running.", "keywords": []}, {"id": 2586, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#single-process", "display_name": "Single process", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "single-process", "priority": -1, "content": "DeepStream reference application supports multiple configs in the same process. To run DLA and GPU in same process, set environment variable CUDA_DEVICE_MAX_CONNECTIONS as 32 : $ deepstream-app -c &lt;gpuconfig&gt; -c &lt;dla0config&gt; -c &lt;dla1config&gt;", "keywords": []}, {"id": 2587, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "page", "name": "text/DS_Quickstart#using-dla-for-inference", "display_name": "Using DLA for inference", "type": "section", "display_type": "Page section", "docname": "text/DS_Quickstart", "anchor": "using-dla-for-inference", "priority": -1, "content": "DLA is Deep Learning Accelerator present on the Jetson AGX Orin and Jetson Orin NX. These platforms have two DLA engines. DeepStream can be configured to run inference on either of the DLA engines through the Gst-nvinfer plugin. One instance of Gst-nvinfer plugin and thus a single instance of a model can be configured to be executed on a single DLA engine or the GPU. However, multiple Gst-nvinfer plugin instances can be configured to use the same DLA. To configure Gst-nvinfer to use the DLA engine for inference, modify the corresponding property in nvinfer component configuration file (example: samples/configs/deepstream-app/config_infer_primary.txt): Set enable-dla=1 in [property] group. Set use-dla-core=0 or use-dla-core=1 depending on the DLA engine to use. DeepStream does support inferencing using GPU and DLAs in parallel. You can run this in separate processes or single process. You will need three separate sets of configs configured to run on GPU, DLA0 and DLA1:", "keywords": []}, {"id": 2588, "doc_id": 2588, "filename": "text/DS_Quickstart.html", "domain_name": "std", "name": "text/DS_Quickstart", "display_name": "Quickstart Guide", "type": "doc", "display_type": "Page", "docname": "text/DS_Quickstart", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2589, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#application-instance", "display_name": "Application Instance", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "application-instance", "priority": -1, "content": "Application quit Endpoint: /app/quit Configuration value for \u201capp_quit\u201d field of the schema: (1): - Application quit (boolean) Curl command to quit the sample application: curl -XPOST &#x27;http://localhost:9000/api/v1/app/quit&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;app_quit&quot;:1 } }&#x27; Expected output: The application should quit.", "keywords": []}, {"id": 2590, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#callback-implementation-for-rest-api-endpoints", "display_name": "Callback implementation for REST API endpoints", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "callback-implementation-for-rest-api-endpoints", "priority": -1, "content": "Implement the callback function (as registered with the struct NvDsServerCallbacks) defined for the new custom REST API. If REST server is used with nvmultiurisrcbin, refer to the below source code snippet of /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvmultiurisrcbin/gstdsnvmultiurisrcbin.cpp static void s_roi_api_impl (NvDsServerRoiInfo * roi_info, void *ctx) If REST server is used with the application, refer to the below source code snippet of /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-server/rest_server_callbacks.cpp void s_roi_callback_impl (NvDsServerRoiInfo * roi_info, void *ctx) This callback function injects the new custom gst-event into the pipeline to be handled by corresponding gstreamer element or group of elements. Applicable gstreamer element or group of elements need to intercept this new custom gst-event at sink pad event handler and apply received configurations to the applicable element at runtime. Refer to the below source code snippet of /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvmultiurisrcbin/gstdsnvmultiurisrcbin.cpp GstEvent *nvevent = gst_nvevent_new_roi_update((char*)roi_info-&gt;stream_id.c_str(), roi_info-&gt;roi_count, roi_dim); if (!nvevent) { roi_info-&gt;roi_log = &quot;ROI_UPDATE_FAIL, nv-roi-update event creation failed&quot;; roi_info-&gt;status = ROI_UPDATE_FAIL; roi_info-&gt;err_info.code = StatusInternalServerError; } if (!gst_pad_push_event ((GstPad *) (nvmultiurisrcbin-&gt;bin_src_pad), nvevent)) { switch (roi_info-&gt;roi_flag) { case ROI_UPDATE: g_print (&quot;[WARN] nv-roi-update event not pushed downstream.. !! \\n&quot;); roi_info-&gt;roi_log = &quot;ROI_UPDATE_FAIL, nv-roi-update event not pushed&quot;; roi_info-&gt;status = ROI_UPDATE_FAIL; roi_info-&gt;err_info.code = StatusInternalServerError; break; default: break; } } else { switch (roi_info-&gt;roi_flag) { case ROI_UPDATE: roi_info-&gt;status = ROI_UPDATE_SUCCESS; roi_info-&gt;roi_log = &quot;ROI_UPDATE_SUCCESS&quot;; roi_info-&gt;err_info.code = StatusOk; break; default: break; } } In case the applicable element is already a part of the gstdsnvmultiurisrbin (e.g. decoder) then no such custom gst-events are required to be injected into the pipeline as all runtime configuration for the applicable gst-element can be handled from inside the gstdsnvmultiurisrcbin. Refer to the below source code snippet of /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvmultiurisrcbin/gstdsnvmultiurisrcbin.cpp if (!set_nvuribin_dec_prop (nvmultiurisrcbin-&gt;nvmultiurisrcbinCreator, sourceId, dec_info)) { switch (dec_info-&gt;dec_flag) { case DROP_FRAME_INTERVAL: g_print (&quot;[WARN] drop-frame-interval not set on decoder .. !! \\n&quot;); dec_info-&gt;status = DROP_FRAME_INTERVAL_UPDATE_FAIL; dec_info-&gt;dec_log = &quot;DROP_FRAME_INTERVAL_UPDATE_FAIL, drop-frame-interval not set on decoder&quot;; dec_info-&gt;err_info.code = StatusInternalServerError; break; case SKIP_FRAMES: g_print (&quot;[WARN] skip-frame not set on decoder .. !! \\n&quot;); dec_info-&gt;status = SKIP_FRAMES_UPDATE_FAIL; dec_info-&gt;dec_log = &quot;SKIP_FRAMES_UPDATE_FAIL, skip-frame not set on decoder&quot;; dec_info-&gt;err_info.code = StatusInternalServerError; break; case LOW_LATENCY_MODE: g_print (&quot;[WARN] low-latency-mode not set on decoder .. !! \\n&quot;); dec_info-&gt;status = LOW_LATENCY_MODE_UPDATE_FAIL; dec_info-&gt;dec_log = &quot;LOW_LATENCY_MODE_UPDATE_FAIL, low-latency-mode not set on decoder&quot;; dec_info-&gt;err_info.code = StatusInternalServerError; break; default: break; } } else { switch (dec_info-&gt;dec_flag) { case DROP_FRAME_INTERVAL: dec_info-&gt;status = dec_info-&gt;status != DROP_FRAME_INTERVAL_UPDATE_FAIL ? DROP_FRAME_INTERVAL_UPDATE_SUCCESS : DROP_FRAME_INTERVAL_UPDATE_FAIL; if ( dec_info-&gt;status == DROP_FRAME_INTERVAL_UPDATE_SUCCESS ){ dec_info-&gt;err_info.code = StatusOk; dec_info-&gt;dec_log = &quot;DROP_FRAME_INTERVAL_UPDATE_SUCCESS&quot;; } else{ dec_info-&gt;err_info.code = StatusInternalServerError; dec_info-&gt;dec_log = &quot;DROP_FRAME_INTERVAL_UPDATE_FAIL, Error while setting drop-frame-interval property&quot;; } break; case SKIP_FRAMES: dec_info-&gt;status = dec_info-&gt;status != SKIP_FRAMES_UPDATE_FAIL ? SKIP_FRAMES_UPDATE_SUCCESS : SKIP_FRAMES_UPDATE_FAIL; if ( dec_info-&gt;status == SKIP_FRAMES_UPDATE_SUCCESS ){ dec_info-&gt;err_info.code = StatusOk; dec_info-&gt;dec_log = &quot;SKIP_FRAMES_UPDATE_SUCCESS&quot;; } else{ dec_info-&gt;err_info.code = StatusInternalServerError; dec_info-&gt;dec_log = &quot;SKIP_FRAMES_UPDATE_FAIL, Error while setting skip-frame property&quot;; } break; case LOW_LATENCY_MODE: dec_info-&gt;status = dec_info-&gt;status != LOW_LATENCY_MODE_UPDATE_FAIL ? LOW_LATENCY_MODE_UPDATE_SUCCESS : LOW_LATENCY_MODE_UPDATE_FAIL; if ( dec_info-&gt;status == LOW_LATENCY_MODE_UPDATE_SUCCESS ){ dec_info-&gt;err_info.code = StatusOk; dec_info-&gt;dec_log = &quot;LOW_LATENCY_MODE_UPDATE_SUCCESS&quot;; } else{ dec_info-&gt;err_info.code = StatusInternalServerError; dec_info-&gt;dec_log = &quot;LOW_LATENCY_MODE_UPDATE_FAIL, Error while setting skip-frame property&quot;; } break; default: break; } }", "keywords": []}, {"id": 2591, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#custom-event-generation", "display_name": "Custom event generation", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "custom-event-generation", "priority": -1, "content": "Define and implement new custom gst-event applicable for specific \u201celement or group of elements\u201d corresponding to handling of the new custom REST API. Refer to the below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/gstnvdscustomhelper/gst-nvdscustomevent.c GstEvent * gst_nvevent_new_roi_update (gchar* stream_id, guint roi_count, RoiDimension *roi_dim) This custom gst-event to be injected into the native gstreamer pipeline by the gstnvdsmulturisrcbin.", "keywords": []}, {"id": 2592, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#decoder", "display_name": "Decoder", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "decoder", "priority": -1, "content": "Drop frame interval Endpoint: /dec/drop-frame-interval Configuration values for \u201cdrop_frame_interval\u201d field of the schema: Range [0 - 30] Curl command to configure decoder drop-frame-interval property: curl -XPOST &#x27;http://localhost:9000/api/v1/dec/drop-frame-interval&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;drop_frame_interval&quot;:2 } }&#x27; Expected output: The drop-frame-interval value will be set on the decoder. Decoder drop frame interval should reflect with every interval &lt;value&gt; frame given by decoder, rest all dropped for selected stream. Skip frame Endpoint: /dec/skip-frames Configuration values for \u201cskip_frames\u201d field of the schema: (0): - Decode all frames (1): - Decode non-ref frames (2): - Decode key frames Curl command to configure decoder skip-frames property curl -XPOST &#x27;http://localhost:9000/api/v1/dec/skip-frames&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;skip_frames&quot;:2 } }&#x27; Expected output: The skip-frames property value will be set on the decoder. (0): - Decoder will decode all frames of the encoded bitstream (1): - Decoder will decode only non-reference frames of the encoded bitstream (2): - Decoder will decode only key frames of the encoded bitstream", "keywords": []}, {"id": 2593, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#deepstream-server-app", "display_name": "deepstream-server-app", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "deepstream-server-app", "priority": -1, "content": "The deepstream-server-app sample application is provided at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-server . The reference application demonstrates REST API usage to configure DeepStream plugin parameters at runtime using nvmultiurisrcbin or using low level nvds_rest_server library APIs directly. Refer to the README at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-server/README for application usage, payload schema and REST API endpoints details. deepstream-server-app operates in two modes: REST server within nvmultiurisrcbin (default): To use nvmultiurisrcbin, set within_multiurisrcbin: 1 in the rest-server group defined in dsserver_config.yml file. Paramters defined in multiurisrcbin group of dsserver_config.yml would be used by the application if simulation is done using nvmultiurisrcbin. All the REST API callbacks are implemented with nvmultiurisrcbin. REST server with the application: To use REST server with the application, set within_multiurisrcbin: 0 in the dsserver_config.yml config file. Parameters defined inside group server-app-ctx of dsserver_config.yml would be used. All the REST API callbacks are implemented with the application. This application package contains dsserver_pgie_config.yml and dsserver_config.yml files. The dsserver_config.yml is used while launching the application. dsserver_pgie_config.yml is used to configure pgie in the sample application. Expected behavior: The sample server app would run continuously even after EOS is received from the pipeline, as drop-pipeline-eos is set to TRUE (default ) in the config file dsserver_config.yml . However, if user needs to change this behavior, set \u2018drop-pipeline-eos: 0\u2019 of group \u2018multiurisrcbin\u2019 or \u2018drop_pipeline_eos: 0\u2019 of group \u2018server-app-ctx\u2019 defined in dsserver_config.yml file to exit app at EOS.", "keywords": []}, {"id": 2594, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#encoder", "display_name": "Encoder", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "encoder", "priority": -1, "content": "By default encoder is disabled. To enable, set enable: 1 in the \u201cencoder\u201d group of dsserver_config.yml. Currently stream_id (specified in the schema) do not have any impact on specified stream_id, rather configuration is applied on muxed encoded bitstream. Force-idr Endpoint: /enc/force-idr Configuration value for \u201cforce_idr\u201d field of the schema: (1): - Force IDR frame Curl command to configure encoder force idr frame property: curl -XPOST &#x27;http://localhost:9000/api/v1/enc/force-idr&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;force_idr&quot;:1 } }&#x27; Expected output: The force-idr property value will be set on the encoder. Encoder force-idr property should reflect with insertion of the IDR frame with the encoded bitstream by the encoder. Force-intra Endpoint: /enc/force-intra Configuration value for \u201cforce_intra\u201d field of the schema: (1): - Force Intra frame Curl command to configure encoder force intra frame property curl -XPOST &#x27;http://localhost:9000/api/v1/enc/force-intra&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;force_intra&quot;:1 } }&#x27; Expected output: The force-intra property value will be set on the encoder. Encoder force-intra property should reflect with insertion of the intra frame with the encoded bitstream by the encoder. Bitrate Endpoint: /enc/bitrate Curl command to configure encoder bitrate property curl -XPOST &#x27;http://localhost:9000/api/v1/enc/bitrate&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;bitrate&quot;:2000000 } }&#x27; Convert generated .h264 elementary bitstream to mp4 file using below commands: $ ffmpeg -i out.h264 -vcodec copy out.mp4 $ mediainfo out.mp4 Expected output: Encoder should be reconfigured to use updated bitrate &lt;value&gt; and provide corresponding encoded bitstream. Mediainfo should show Encoder bitrate corresponding to updated value. iframeinterval Endpoint: /api/v1/enc/iframe-interval Curl command to configure encoder iframeinterval property: curl -XPOST &#x27;http://localhost:9000/api/v1/enc/iframe-interval&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;iframeinterval&quot;:50 } }&#x27; Expected output: The iframeinterval property value will be set on the encoder. Encoder iframeinterval property should reflect with insertion of the I-frame at specified interval with the encoded bitstream by the encoder.", "keywords": []}, {"id": 2595, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "features", "priority": -1, "content": "The sample deepstream-server application can be used to demonstrate usage of REST APIs to configure DeepStream component parameters at runtime. Currently supported REST APIs to configure the DeepStream pipeline as mentioned below: DS-6.4 onwards version support has been introduced with REST API. Currently supported version with DS-7.1 is /api/v1 . DS-7.0 onwards supports REST API error handling, as per OpenAPI Specification ( https://spec.openapis.org/oas/v3.0.3 ). The following table summarizes the supported REST APIs: Group/Component name Parameter update Stream specific Stream addition and removal nvdspreprocess Update ROI for preprocess nvv4l2decoder \u201cdrop-frame-interval\u201d and \u201cskip-frame\u201d property update nvdsinfer \u201cinterval\u201d property update nvdsinferserver \u201cinterval\u201d property update nvv4l2encoder \u201cforce-idr\u201d, \u201cforce-intra\u201d, \u201ciframeinterval\u201d and \u201cbitrate\u201d property update nvstreammux \u201cbatched-push-timeout\u201d property update nvvideoconvert \u201csrc-crop\u201d, \u201cdest-crop\u201d, \u201cflip-method\u201d and \u201cinterpolation-method\u201d property update nvdsosd \u201cprocess-mode\u201d property update Application specific Application quit GET requests Get the stream-info", "keywords": []}, {"id": 2596, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#get-requests", "display_name": "GET requests", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "get-requests", "priority": -1, "content": "GET stream info Endpoint: /api/v1/stream/get-stream-info Curl command to get the stream info: curl -XGET &#x27;http://localhost:9000/api/v1/stream/get-stream-info&#x27; OR curl -XGET &#x27;http://localhost:9000/api/v1/stream/get-stream-info&#x27; -d &#x27;{}&#x27; Expected output: The sample stream-info response returned to the client: { &quot;reason&quot; : &quot;GET_LIVE_STREAM_INFO_SUCCESS&quot;, &quot;status&quot; : &quot;HTTP/1.1 200 OK&quot;, &quot;stream-info&quot; : { &quot;stream-count&quot; : 1, &quot;stream-info&quot; : [ { &quot;camera_id&quot; : &quot;UniqueSensorId1&quot;, &quot;camera_name&quot; : &quot;UniqueSensorName1&quot; } ] } }", "keywords": []}, {"id": 2597, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#handler-function-implementation-details", "display_name": "Handler Function Implementation Details", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "handler-function-implementation-details", "priority": -1, "content": "Define and implement a parser function to parse payload data received with the HTTP request for the new custom REST API. User may define new custom data structure (with nvds_rest_server.h) to hold the parsed payload data. Refer to the source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_roi_parse.cpp bool nvds_rest_roi_parse (const Json::Value &amp; in, NvDsServerRoiInfo * roi_info) Call the defined callback providing input the payload parsed data and custom context pointer (if any). Based on the callback function return status received, create a JSON response to be sent for the received HTTP request. Refer to the below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_rest_server.cpp : if (nvds_rest_roi_parse (in, &amp;roi_info) &amp;&amp; (roi_cb)) { roi_cb (&amp;roi_info, &amp;custom_ctx); switch (roi_info.roi_flag) { case ROI_UPDATE: http_err_code = NvDsServerStatusCodeToHttpStatusCode(roi_info.err_info.code); break; default: break; } } else { http_err_code = NvDsServerStatusCodeToHttpStatusCode(roi_info.err_info.code); } res_info.status = std::string (&quot;HTTP/1.1 &quot;) + std::to_string (http_err_code.first) + &quot; &quot; + http_err_code.second; res_info.reason = roi_info.roi_log; response[&quot;status&quot;] = res_info.status; response[&quot;reason&quot;] = res_info.reason;", "keywords": []}, {"id": 2598, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#how-to-add-custom-rest-api-support", "display_name": "How to add custom REST API support", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "how-to-add-custom-rest-api-support", "priority": -1, "content": "Users should follow the below sections. Each section explains detailed steps to implement new custom REST API support. REST API endpoints implementation Custom event generation Callback implementation for REST API endpoints", "keywords": []}, {"id": 2599, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#limitations", "display_name": "Limitations", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "limitations", "priority": -1, "content": "REST API feature is validated with HTTP. HTTPS support is not yet enabled, however users can add HTTPS support by enhancing corresponding sources in DeepStream SDK. Usage of new nvstreammux for video and audio use cases are not supported at this time and might not work. REST API support for nvvidconvert and nvstreammux is currently only supported in mode where nvmultiurisrcbin is used in the pipeline. Refer dsserver_config.yml file present at deepstream-server-app source directory. MJPEG input stream source is not supported. Decoder REST API for skip-frame is not supported on Jetson. Currently on x86, skip-frame for value \u201c(1): decode_non_ref\u201d is not supported.", "keywords": []}, {"id": 2600, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#nvds-rest-server", "display_name": "nvds_rest_server", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "nvds-rest-server", "priority": -1, "content": "nvds_rest_server is a custom DeepStream library open sourced with DeepStreamSDK package at /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/ . Users are encouraged to use this library as-is or make modifications to support custom use cases. This library could be integrated into a Gstreamer plugin, GStreamer bin, or a DeepStream application. With DS 6.2 release onwards, nvds_rest_server library is integrated with Gst-nvmultiurisrcbin to support runtime sensor addition and removal over REST API.", "keywords": []}, {"id": 2601, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#nvdsosd", "display_name": "Nvdsosd", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "nvdsosd", "priority": -1, "content": "Endpoint: /osd/process-mode Configuration value for \u201cprocess_mode\u201d field of the schema: 0 and 1, 0=CPU mode, 1=GPU mode Curl command to configure nvdsosd process_mode property: curl -XPOST &#x27;http://localhost:9000/api/v1/osd/process-mode&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;process_mode&quot;:0 } }&#x27; Expected output: There would not be any visual change, but applied process-mode should be used for drawing bounding boxes.", "keywords": []}, {"id": 2602, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#nvinfer", "display_name": "Nvinfer", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "nvinfer", "priority": -1, "content": "Endpoint: /infer/set-interval Curl command to configure nvinfer interval property curl -XPOST &#x27;http://localhost:9000/api/v1/infer/set-interval&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;interval&quot;:2 } }&#x27; Expected output: The interval value will be set on the nvinfer. Interval value specify consecutive batches will be skipped for inference for the video stream. Disable/comment \u201cinput-tensor-meta\u201d property in dsserver_pgie_config.yml to see \u201cinterval\u201d property functionality of nvinfer/nvinferserver. Currently stream_id (specified in the schema) do not have any impact on specified stream_id, rather configuration is getting applied to all active streams.", "keywords": []}, {"id": 2603, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#nvinferserver", "display_name": "Nvinferserver", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "nvinferserver", "priority": -1, "content": "Endpoint:/inferserver/set-interval Curl command to configure nvinferserver interval property: curl -XPOST &#x27;http://localhost:9000/api/v1/inferserver/set-interval&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;interval&quot;:2 } }&#x27; Expected output: The interval value will be set on nvinferserver. Interval value specify consecutive batches will be skipped for inference for the video stream. Currently stream_id (specified in the schema) do not have any impact on specified stream_id, rather configuration is getting applied to all active streams.", "keywords": []}, {"id": 2604, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#nvvideoconvert", "display_name": "Nvvideoconvert", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "nvvideoconvert", "priority": -1, "content": "To simulate video convert specific REST API features, deepstream-server application explicitly disables passthrough mode using the \u201cdisbale-passthrough\u201d property of nvvideoconvert within the nvmultiurisrcbin. Set disable-passthrough: 1 in dsserver_config.yml file. src-crop Endpoint: /conv/srccrop Configuration value for \u201csrc_crop\u201d field of the schema: (String) Pixel location left:top:width:height Curl command to configure nvvideoconvert src-crop property: curl -XPOST &#x27;http://localhost:9000/api/v1/conv/srccrop&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;src_crop&quot;:&quot;200:200:400:500&quot; } }&#x27; Expected output: left:top:width:height of the input image which will be cropped and transformed into the output buffer. If the crop location is out of bound the values will be clamped to image boundaries of the input image. dest-crop Endpoint: /conv/destcrop Configuration value for \u201cdest_crop\u201d field of the schema: (String) Pixel location left:top:width:height Curl command to configure nvvideoconvert dest-crop property: curl -XPOST &#x27;http://localhost:9000/api/v1/conv/destcrop&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;dest_crop&quot;:&quot;100:200:400:500&quot; } }&#x27; Expected output: left:top:width:height is the location in the output image where the input image will be transformed. If the crop location is out of bound the values will be clamped to image boundaries of the output image. The region apart from the cropped location in the destination frame will retain the last pixel values. flip-method Endpoint: /conv/flip-method Configuration value for \u201cflip_method\u201d field of the schema: (0): none - Identity (no rotation) (1): counterclockwise - Rotate counter-clockwise 90 degrees (2): rotate-180 - Rotate 180 degrees (3): clockwise - Rotate clockwise 90 degrees (4): horizontal-flip - Flip horizontally (5): upper-right-diagonal - Flip across upper right/lower left diagonal (6): vertical-flip - Flip vertically (7): upper-left-diagonal - Flip across upper left/lower right diagonal Curl command to configure nvvideoconvert flip-method property: curl -XPOST &#x27;http://localhost:9000/api/v1/conv/flip-method&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;flip_method&quot;:2 } }&#x27; Expected output: Based on flip-method property type value, output image should be flipped. For ex- For value 2, image will be rotated by 180 degree. interpolation-method Endpoint: /conv/interpolation-method Configuration value for \u201cinterpolation_method\u201d field of the schema: (0): Nearest - Nearest (1): Bilinear - Bilinear (2): Algo-1 - GPU - Cubic, VIC - 5 Tap (3): Algo-2 - GPU - Super, VIC - 10 Tap (4): Algo-3 - GPU - LanzoS, VIC - Smart (5): Algo-4 - GPU - Ignored, VIC - Nicest (6): Default - GPU - Nearest, VIC - Nearest Curl command to configure nvvideoconvert interpolation-method property: curl -XPOST &#x27;http://localhost:9000/api/v1/conv/interpolation-method&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;:&quot;0&quot;, &quot;interpolation_method&quot;:2 } }&#x27; Expected output: There would not be any visual change, but applied interpolation-method should be used for transformation.", "keywords": []}, {"id": 2605, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#rest-api-endpoints-implementation", "display_name": "REST API endpoints implementation", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "rest-api-endpoints-implementation", "priority": -1, "content": "Define any component/group specific custom REST API endpoints. Register custom REST API endpoints. For 1 &amp; 2, refer below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_rest_server.cpp : if (uri.find (&quot;/roi/update&quot;) != std::string::npos) { /* Pre-Process Specific */ m_func[uri] = [roi_cb, uri] (const Json::Value &amp; req_info, const Json::Value &amp; in, Json::Value &amp; out, struct mg_connection * conn) { return handleUpdateROI (req_info, in, out, conn, roi_cb, uri); }; } Define and implement the Handler function corresponding to the new custom REST API. Refer to the below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_rest_server.cpp : NvDsServerStatusCode handleUpdateROI (const Json::Value &amp; req_info, const Json::Value &amp; in, Json::Value &amp; response, struct mg_connection *conn, std::function &lt; void (NvDsServerRoiInfo * roi_ctx, void *ctx) &gt; roi_cb, std::string uri); Refer to the Handler Function Implementation Details section for more details. Register the Handler function for the new custom REST API with Civerweb\u2019s \u201chttpServerHandler-&gt;addHandler\u201d interface. Refer to the below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_rest_server.cpp : httpServerHandler-&gt;addHandler (it.first, new RequestHandler (it.first, it.second)); Define callback function to be used by REST server for the corresponding new custom REST API. The user needs to add callback function pointer as member of the struct NvDsServerCallbacks. Refer to the below source code snippet in /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/nvds_rest_server.h : typedef struct NvDsServerCallbacks { std::function &lt; void (NvDsServerRoiInfo * roi_info, void *ctx) &gt; roi_cb; std::function &lt; void (NvDsServerDecInfo * dec_info, void *ctx) &gt; dec_cb; std::function &lt; void (NvDsServerEncInfo * enc_info, void *ctx) &gt; enc_cb; std::function &lt; void (NvDsServerStreamInfo * stream_info, void *ctx) &gt; stream_cb; std::function &lt; void (NvDsServerInferInfo * infer_info, void *ctx) &gt; infer_cb; std::function &lt; void (NvDsServerConvInfo * conv_info, void *ctx) &gt; conv_cb; std::function &lt; void (NvDsServerMuxInfo * mux_info, void *ctx) &gt; mux_cb; std::function &lt; void (NvDsServerInferServerInfo * inferserver_info, void *ctx) &gt; inferserver_cb; std::function &lt; void (NvDsServerOsdInfo * osd_info, void *ctx) &gt; osd_cb; std::function &lt; void (NvDsServerAppInstanceInfo * appinstance_info, void *ctx) &gt; appinstance_cb; std::unordered_map &lt;std::string, cb_func&gt; custom_cb_endpt; } NvDsServerCallbacks;", "keywords": []}, {"id": 2606, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#roi", "display_name": "ROI", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "roi", "priority": -1, "content": "Endpoint: /roi/update Curl command to update ROI: curl -XPOST &#x27;http://localhost:9000/api/v1/roi/update&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;stream_id&quot;: &quot;0&quot;, &quot;roi_count&quot;: 2, &quot;roi&quot;: [{ &quot;roi_id&quot;: &quot;0&quot;, &quot;left&quot;: 100, &quot;top&quot;: 300, &quot;width&quot;: 400, &quot;height&quot;: 400 }, { &quot;roi_id&quot;: &quot;1&quot;, &quot;left&quot;: 550, &quot;top&quot;: 300, &quot;width&quot;: 500, &quot;height&quot;: 500 } ] } }&#x27; Expected output: The updated roi dimension should be observed at display.", "keywords": []}, {"id": 2607, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#schema-and-endpoints", "display_name": "Schema and endpoints", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "schema-and-endpoints", "priority": -1, "content": "DS-7.1 supports REST API version /api/v1 . Refer below schema details.", "keywords": []}, {"id": 2608, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#sensor-provisioning-with-deepstream-test5-app", "display_name": "Sensor provisioning with deepstream-test5-app", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "sensor-provisioning-with-deepstream-test5-app", "priority": -1, "content": "The DeepStream config file parsing reference apps like deepstream-test5-app support Sensor provisioning (runtime stream add/remove). For more details and sample config file to refer, please follow documentation here .", "keywords": []}, {"id": 2609, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#stream-add-remove", "display_name": "Stream add/remove", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "stream-add-remove", "priority": -1, "content": "Stream add Endpoint: /stream/add Curl command to add stream: 1.curl -XPOST &#x27;http://localhost:9000/api/v1/stream/add&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;value&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;, &quot;change&quot;: &quot;camera_add&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27; 2.curl -XPOST &#x27;http://localhost:9000/api/v1/stream/add&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;event&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;rtsp://xyz.mp4&quot;, &quot;change&quot;: &quot;camera_streaming&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27; Expected output: The uri specified should be added to the display. The camera_id should be unique for each newly added streams. The curl command mentioned above at (2), is only supported when the sample application uses nvmultiurisrcbin. Stream remove Endpoint: /stream/remove Curl command to remove stream curl -XPOST &#x27;http://localhost:9000/api/v1/stream/remove&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;value&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;, &quot;change&quot;: &quot;camera_remove&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27; Expected output: The uri specified should be removed from the display. The camera_id used to remove stream should be same as being used while adding stream using REST API.", "keywords": []}, {"id": 2610, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "page", "name": "text/DS_RestServer#streammux", "display_name": "Streammux", "type": "section", "display_type": "Page section", "docname": "text/DS_RestServer", "anchor": "streammux", "priority": -1, "content": "Endpoint: /mux/batched-push-timeout Configuration value for \u201cbatched_push_timeout\u201d field of the schema: (microseconds): - Timeout value Curl command to configure streammux batched pushed timeout property: curl -XPOST &#x27;http://localhost:9000/api/v1/mux/batched-push-timeout&#x27; -d &#x27;{ &quot;stream&quot;: { &quot;batched_push_timeout&quot;:100000 } }&#x27; Applicable for old nvstreammux. Expected output: The batched push timeout property value will be set on the nvstreammux. nvstreammux property should reflect with the timeout in microseconds to wait after the first buffer is available to push the batch even if the complete batch is not formed.", "keywords": []}, {"id": 2611, "doc_id": 2611, "filename": "text/DS_RestServer.html", "domain_name": "std", "name": "text/DS_RestServer", "display_name": "DeepStream With REST API Sever", "type": "doc", "display_type": "Page", "docname": "text/DS_RestServer", "anchor": "", "priority": -1, "content": "DeepStream application supports runtime parameter configuration for certain components with the help of REST APIs. DeepStream application should run as a server for this feature. Rest Server support is enabled for both x86 (DeepStream-6.2 release onwards) and Jetson (DeepStream-6.3 release onwards). REST Server library integrates the HTTP server using the \u201cCivetweb\u201d OSS library to process the REST API endpoints. REST Server library implements various component specific endpoints handling. Also, REST API Payload Parser is integrated using the \u201cjsoncpp\u201d OSS library to parse JSON format payload. New nvmultiurisrcbin implements callback APIs for runtime parameter configuration of the supported components in the native DeepStream gstreamer pipeline. Upon receiving the HTTP POST request for the REST API, relevant callbacks implemented with the nvmultiurisrcbin creates new custom gstreamer events which gets injected into the native gstreamer pipeline. Applicable gstreamer component intercepts the custom event to runtime configure the relevant component in the native gstreamer pipeline. A sample app deepstream-server-app is also provided at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-server for reference. These interfaces sources are available in the DeepStream SDK package. This should provide users with readily available infrastructure to define and implement their own custom REST APIs support for various DeepStream components (Please refer \u201cHow to add custom REST API support\u201d section below). REST server is instantiated by default inside nvmultiurisrcbin plugin. Refer to Gst-nvmultiurisrcbin for \u201cnvmultiurisrcbin\u201d details.", "keywords": []}, {"id": 2612, "doc_id": 2614, "filename": "text/DS_Smart_video.html", "domain_name": "page", "name": "text/DS_Smart_video#smart-video-record-configurations", "display_name": "Smart Video Record Configurations", "type": "section", "display_type": "Page section", "docname": "text/DS_Smart_video", "anchor": "smart-video-record-configurations", "priority": -1, "content": "In existing deepstream-test5-app only RTSP sources are enabled for smart record. There are two ways in which smart record events can be generated \u2013 either through local events or through cloud messages. To enable smart record in deepstream-test5-app set the following under [sourceX] group: smart-record=&lt;1/2&gt; To enable smart record through only cloud messages, set smart-record=1 and configure [message-consumerX] group accordingly. The following minimum json message from the server is expected to trigger the Start/Stop of smart record. { command: string // &lt;start-recording / stop-recording&gt; start: string // &quot;2020-05-18T20:02:00.051Z&quot; end: string // &quot;2020-05-18T20:02:02.851Z&quot;, sensor: { id: string } } If you set smart-record=2 , this will enable smart record through cloud messages as well as local events with default configurations. That means smart record Start/Stop events are generated every 10 seconds through local events. Following are the default values of configuration parameters: cache size = 30 seconds, container = MP4, default duration = 10 seconds, interval = 10 seconds, file prefix = Smart_Record etc. Following fields can be used under [sourceX] groups to configure these parameters. smart-rec-cache=&lt;val in seconds&gt; Size of cache in seconds. This parameter will increase the overall memory usages of the application. smart-rec-duration=&lt;val in seconds&gt; Duration of recording. smart-rec-start-time=&lt;val in seconds&gt; Here, start time of recording is the number of seconds earlier to the current time to start the recording. For example, if t0 is the current time and N is the start time in seconds that means recording will start from t0 \u2013 N. For it to work, the cache size must be greater than the N. smart-rec-default-duration=&lt;val in seconds&gt; In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Smart-rec-container=&lt;0/1&gt; MP4 and MKV containers are supported. smart-rec-interval=&lt;val in seconds&gt; This is the time interval in seconds for SR start / stop events generation. In the deepstream-test5-app, to demonstrate the use case smart record Start / Stop events are generated every interval second. smart-rec-file-prefix=&lt;file name prefix&gt; Prefix of file name for generated stream. By default, \u201cSmart_Record\u201d is the prefix in case this field is not set. For unique names every source must be provided with a unique prefix. smart-rec-dir-path=&lt;path of directory to save the file&gt; Path of directory to save the recorded file. By default, the current directory is used. Recording also can be triggered by JSON messages received from the cloud. The message format is as follows: { command: string // &lt;start-recording / stop-recording&gt; start: string // &quot;2020-05-18T20:02:00.051Z&quot; end: string // &quot;2020-05-18T20:02:02.851Z&quot;, sensor: { id: string } } Receiving and processing such messages from the cloud is demonstrated in the deepstream-test5 sample application. This is currently supported for Kafka. To activate this functionality, populate and enable the following block in the application configuration file: # Configure this group to enable cloud message consumer. [message-consumer0] enable=1 proto-lib=/opt/nvidia/deepstream/deepstream/lib/libnvds_kafka_proto.so conn-str=&lt;host&gt;;&lt;port&gt; config-file=&lt;broker config file e.g. cfg_kafka.txt&gt; subscribe-topic-list=&lt;topic1&gt;;&lt;topic2&gt;;&lt;topicN&gt; # Use this option if message has sensor name as id instead of index (0,1,2 etc.). #sensor-list-file=dstest5_msgconv_sample_config.txt While the application is running, use a Kafka broker to publish the above JSON messages on topics in the subscribe-topic-list to start and stop recording. Currently, there is no support for overlapping smart record.", "keywords": []}, {"id": 2613, "doc_id": 2614, "filename": "text/DS_Smart_video.html", "domain_name": "page", "name": "text/DS_Smart_video#smart-video-record-module-apis", "display_name": "Smart Video Record Module APIs", "type": "section", "display_type": "Page section", "docname": "text/DS_Smart_video", "anchor": "smart-video-record-module-apis", "priority": -1, "content": "This module provides the following APIs. See the gst-nvdssr.h header file for more details. NvDsSRStatus NvDsSRCreate (NvDsSRContext **ctx, NvDsSRInitParams *params); This function creates the instance of smart record and returns the pointer to an allocated NvDsSRContext . The params structure must be filled with initialization parameters required to create the instance. A callback function can be setup to get the information of recorded audio/video once recording stops. userData received in that callback is the one which is passed during NvDsSRStart() . GstBin which is the recordbin of NvDsSRContext must be added to the pipeline. It expects encoded frames which will be muxed and saved to the file. Add this bin after the audio/video parser element in the pipeline. Call NvDsSRDestroy() to free resources allocated by this function. NvDsSRStatus NvDsSRStart (NvDsSRContext *ctx, NvDsSRSessionId *sessionId, guint startTime, guint duration, gpointer userData); This function starts writing the cached audio/video data to a file. It returns the session id which later can be used in NvDsSRStop() to stop the corresponding recording. Here startTime specifies the seconds before the current time and duration specifies the seconds after the start of recording. If current time is t1 , content from t1 - startTime to t1 + duration will be saved to file. Therefore, a total of startTime + duration seconds of data will be recorded. In case duration is set to zero, recording will be stopped after defaultDuration seconds set in NvDsSRCreate() . Any data that is needed during callback function can be passed as userData . NvDsSRStatus NvDsSRStop (NvDsSRContext *ctx, NvDsSRSessionId sessionId); This function stops the previously started recording. NvDsSRStatus NvDsSRDestroy (NvDsSRContext *ctx); This function releases the resources previously allocated by NvDsSRCreate() See the deepstream_source_bin.c for more details on using this module.", "keywords": []}, {"id": 2614, "doc_id": 2614, "filename": "text/DS_Smart_video.html", "domain_name": "std", "name": "text/DS_Smart_video", "display_name": "Smart Video Record", "type": "doc", "display_type": "Page", "docname": "text/DS_Smart_video", "anchor": "", "priority": -1, "content": "Smart video record is used for event (local or cloud) based recording of original data feed. Only the data feed with events of importance is recorded instead of always saving the whole feed. This recording happens in parallel to the inference pipeline running over the feed. A video cache is maintained so that recorded video has frames both before and after the event is generated. The size of the video cache can be configured per use case. In smart record, encoded frames are cached to save on CPU memory. Based on the event, these cached frames are encapsulated under the chosen container to generate the recorded video. This means, the recording cannot be started until we have an Iframe. The first frame in the cache may not be an Iframe, so, some frames from the cache are dropped to fulfil this condition. This causes the duration of the generated video to be less than the value specified. Below diagram shows the smart record architecture: From DeepStream 6.0, Smart Record also supports audio. It uses same caching parameters and implementation as video. To enable audio, a GStreamer element producing encoded audio bitstream must be linked to the asink pad of the smart record bin. Both audio and video will be recorded to the same containerized file. Refer to the deepstream-testsr sample application for more details on usage.", "keywords": []}, {"id": 2615, "doc_id": 2616, "filename": "text/DS_TAO_integration.html", "domain_name": "page", "name": "text/DS_TAO_integration#pre-trained-models", "display_name": "Pre-trained models", "type": "section", "display_type": "Page section", "docname": "text/DS_TAO_integration", "anchor": "pre-trained-models", "priority": -1, "content": "There are 2 types of pre-trained models that users can start with - purpose-built pre-trained models and meta-architecture vision models. Purpose-built pre-trained models are highly accurate models that are trained on millions of objects for a specific task. The pre-trained weights for meta-architecture vision models merely act as a starting point to build more complex models. These pre-trained weights are trained on Open image dataset and they provide a much better starting point for training versus starting from scratch or starting from random weights. With the latter choice, users can choose from 100+ permutations of model architecture and backbone. See the illustration below. The purpose-built models are highly accurate models that are trained on thousands of data inputs for a specific task. These domain-focused models can either be used directly for inference or can be used with TAO for transfer learning on your own dataset. More information about each of these models is available in Computer Vision Model Zoo chapter of TAO toolkit documentation \u2013 Computer Vision Model Zoo or in the individual model cards. Model Name Description NGC Instance TAO Finetuning TrafficCamNet 4 class object detection network to detect cars in an image. nvidia/tao/trafficcamnet Yes PeopleNet 3 class object detection network to detect people in an image. nvidia/tao/peoplenet Yes DashCamNet 4 class object detection network to detect cars in an image. nvidia/tao/dashcamnet Yes VehicleMakeNet Resnet18 model to classify a car crop into 1 out 20 car brands. nvidia/tao/vehiclemakenet Yes VehicleTypeNet Resnet18 model to classify a car crop into 1 out 6 car types. nvidia/tao/vehicletypenet Yes License Plate Detection Object Detection network to detect license plates in an image of a car. nvidia/tao/lpdnet Yes License Plate Recognition Model to recognize characters from the image crop of a License Plate. nvidia/tao/lprnet Yes PeopleSemSegNet Semantic segmentation of persons in an image. nvidia/tao/peoplesemsegnet Yes CitySemSegFormer Semantic segmentation of persons in an image. nvidia/tao/citysemsegformer Yes Optical Character Detection Network to detect characters in an image. nvidia/tao/ocdnet Yes Optical Character Recognition Model to recognise characters from a preceding OCDNet model. nvidia/tao/ocrnet Yes Retail Object Detection DINO (DETR with Improved DeNoising Anchor Boxes) based object detection network to detect retail objects on a checkout counter. nvidia/tao/retail_object_detection Yes Retail Object Recognition Embedding generator model to recognize objects on a checkout counter. nvidia/tao/retail_object_recognition Yes ReIdentificationNet Re-Identification network to generate embeddings for identifying persons in different scenes. nvidia/tao/reidentificationnet Yes Pose Classification Pose classification network to classify poses of people from their skeletons. nvidia/tao/poseclassificationnet Yes PeopleNet Transformer 3 class object detection network to detect people in an image. nvidia/tao/peoplenet_transformer Yes BodyPose3DNet 3D human pose estimation network to predict 34 keypoints in 3D of a person in an image. nvidia/tao/bodypose3dnet Yes Most models trained with TAO toolkit are natively integrated for inference with DeepStream. If the model is integrated, it is supported by the reference deepstream-app . If the model is not natively integrated in the SDK, you can find a reference application on the GitHub repo. See the table below for information on the models supported. For models integrated into deepstream-app , we have provided sample config files for each of the networks. The sample config files are available in the https://github.com/NVIDIA-AI-IOT/deepstream_tao_apps/blob/master/deepstream_app_tao_configs/ folder. The table below also lists config files for each model. Refer README in package /opt/nvidia/deepstream/deepstream/samples/configs/tao_pretrained_models/README.md to obtain TAO toolkit config files and models mentioned in following table. The TAO toolkit pre-trained models table shows the deployment information of purpose-built pre-trained models. Pre-Trained model DeepStream reference app Config files DLA supported TrafficCamNet deepstream-app deepstream_app_source1_trafficcamnet.txt , config_infer_primary_trafficcamnet.txt , labels_trafficnet.txt Yes PeopleNet deepstream-app deepstream_app_source1_peoplenet.txt , config_infer_primary_peoplenet.txt , labels_peoplenet.txt Yes DashCamNet deepstream-app deepstream_app_source1_dashcamnet_vehiclemakenet_vehicletypenet.txt , config_infer_primary_dashcamnet.txt , labels_dashcamnet.txt Yes VehicleMakeNet deepstream-app deepstream_app_source1_dashcamnet_vehiclemakenet_vehicletypenet.txt , config_infer_secondary_vehiclemakenet.txt , labels_vehiclemakenet.txt Yes VehicleTypeNet deepstream-app deepstream_app_source1_dashcamnet_vehiclemakenet_vehicletypenet.txt , config_infer_secondary_vehicletypenet.txt , labels_vehicletypenet.txt Yes CitySemSegFormer deepstream_tao_apps seg_app_unet.yml , pgie_citysemsegformer_tao_config.txt Yes License Plate Detection deepstream_tao_apps No License Plate Recognition deepstream_tao_apps No PoseClassificationNet deepstream_tao_apps No BodyPose3DNet deepstream_tao_apps No Retail Object Recognition deepstream_tao_apps No Retail Object Detection deepstream_tao_apps No PeopleNet Transformer Model deepstream_tao_apps No ReIdentificationNet deepstream_tao_apps No Optical Character Detection deepstream_tao_apps No Optical Character Recognition deepstream_tao_apps No PeopleNet Transformer deepstream_tao_apps det_app_frcnn.yml , pgie_peoplenet_transformer_tao_config.yml No The TAO toolkit models can be deployed with DeepStream sample applications. Learn more about running the TAO models here: NVIDIA-AI-IOT/deepstream_tao_apps For more information about TAO and how to deploy TAO models, refer to Integrating TAO Models into DeepStream chapter of TAO toolkit user guide . For more information about deployment of architecture specific models with DeepStream, refer to NVIDIA-AI-IOT/deepstream_tao_apps GitHub repo.", "keywords": []}, {"id": 2616, "doc_id": 2616, "filename": "text/DS_TAO_integration.html", "domain_name": "std", "name": "text/DS_TAO_integration", "display_name": "TAO Toolkit Integration with DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_TAO_integration", "anchor": "", "priority": -1, "content": "NVIDIA TAO toolkit is a simple, easy-to-use training toolkit that requires minimal coding to create vision AI models using the user\u2019s own data. Using TAO toolkit, users can transfer learn from NVIDIA pre-trained models to create their own model. Users can add new classes to an existing pre-trained model, or they can re-train the model to adapt to their use case. Users can use model pruning capability to reduce the overall size of the model.", "keywords": []}, {"id": 2617, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#do-we-need-to-install-nvidia-driver-inside-ubuntu-image-with-wsl", "display_name": "1. Do we need to install nvidia driver inside Ubuntu Image with WSL?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "do-we-need-to-install-nvidia-driver-inside-ubuntu-image-with-wsl", "priority": -1, "content": "No. You only need to install the driver in Windows Host Machine for the specific GPU you are using. In fact you should not install nvidia drivers inside ubuntu machine to avoid any potential clashes.", "keywords": []}, {"id": 2618, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#there-is-no-video-on-the-screen-while-running-gstreamer-or-deepstream-video-pipelines-but-pipeline-seems-to-be-running-in-terminal-without-any-error-what-is-the-reason", "display_name": "7. There is no video on the screen while running gstreamer or deepstream video pipelines. But pipeline seems to be running in terminal without any error. What is the reason?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "there-is-no-video-on-the-screen-while-running-gstreamer-or-deepstream-video-pipelines-but-pipeline-seems-to-be-running-in-terminal-without-any-error-what-is-the-reason", "priority": -1, "content": "Make sure you have not launched WSL instance through ssh sessions (for eg. using Mobaxterm). Use VNC to start and use WSL. In case you have already launched the WSL through ssh, make sure you shutdown the WSL instance (you can use command \u201cwsl \u2013shutdown\u201d for this) before opening it again from VNC.", "keywords": []}, {"id": 2619, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#warning-prints-are-coming-while-running-deepstream-app-for-first-time-after-starting-docker-for-e-g-deepstream-app-version-shows-below-warnings-is-that-an-issue", "display_name": "8. Warning prints are coming while running deepstream-app for first time after starting docker. For e.g: \u201cdeepstream-app \u2013version\u201d shows below warnings. Is that an issue?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "warning-prints-are-coming-while-running-deepstream-app-for-first-time-after-starting-docker-for-e-g-deepstream-app-version-shows-below-warnings-is-that-an-issue", "priority": -1, "content": "These prints are harmless. They come because we don\u2019t have the corresponding OSS plugin libs packaged inside the container. They can be safely ignored.", "keywords": []}, {"id": 2620, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#while-installing-driver-should-you-choose-clean-installation", "display_name": "2. While installing driver, should you choose \u2018Clean Installation\u2019?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "while-installing-driver-should-you-choose-clean-installation", "priority": -1, "content": "Although it is not insisted, it is better to choose \u2018clean installation\u2019 with all the available packages in driver by choosing \u2018Advanced\u2019 option during installation to avoid potential issues with different libraries.", "keywords": []}, {"id": 2621, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#while-installing-ubuntu-image-for-wsl2-i-get-error-the-service-cannot-be-started-either-because-it-is-disabled-or-because-it-has-no-enabled-devices-associated-with-it-what-should-i-do", "display_name": "5. While installing Ubuntu image for WSL2, I get error: \u201cThe service cannot be started, either because it is disabled or because it has no enabled devices associated with it\u201d. What should I do?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "while-installing-ubuntu-image-for-wsl2-i-get-error-the-service-cannot-be-started-either-because-it-is-disabled-or-because-it-has-no-enabled-devices-associated-with-it-what-should-i-do", "priority": -1, "content": "Open the Services application (services.msc) by searching for it in the Start menu. (Run as administrator) Look for the service named \u201cWindows Update\u201d and make sure its startup type is set to \u201cManual\u201d or \u201cAutomatic.\u201d (Automatic is preferred) If it\u2019s not running, start the service. (Right click -&gt; start)", "keywords": []}, {"id": 2622, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#while-running-deepstream-app-for-the-first-time-i-get-an-error-glib-gthread-posix-c-unexpected-error-from-c-library-during-pthread-setspecific-invalid-argument-aborting-what-should-i-do", "display_name": "6. While running deepstream-app for the first time, I get an error: \u201cGLib (gthread-posix.c): Unexpected error from C library during \u2018pthread_setspecific\u2019: Invalid argument.  Aborting.\u201d. What should I do?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "while-running-deepstream-app-for-the-first-time-i-get-an-error-glib-gthread-posix-c-unexpected-error-from-c-library-during-pthread-setspecific-invalid-argument-aborting-what-should-i-do", "priority": -1, "content": "This is a harmless error and is associated with the glib package in your system. It may not be observed in every system. You can ignore this message.", "keywords": []}, {"id": 2623, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#while-starting-docker-i-face-error-docker-error-response-from-daemon-could-not-select-device-driver-with-capabilities-gpu-what-should-i-do", "display_name": "3. While starting docker, I face error:\u201cdocker: Error response from daemon: could not select device driver \u201c\u201d with capabilities: [[gpu]]. What should I do?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "while-starting-docker-i-face-error-docker-error-response-from-daemon-could-not-select-device-driver-with-capabilities-gpu-what-should-i-do", "priority": -1, "content": "Try below steps: (Make sure your logged in windows account does not have any limited access before trying this.) $ sudo apt install --reinstall nvidia-container-toolkit $ sudo service docker restart After the above steps, shutdown WSL and open it again. $ wsl --shutdown $ wsl -d Ubuntu-22.04", "keywords": []}, {"id": 2624, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "page", "name": "text/DS_WSL2_FAQ#while-starting-docker-i-get-error-gpu-access-blocked-by-operating-system-what-should-i-do", "display_name": "4. While starting docker, I get error \u201cGPU access blocked by operating system\u201d. What should I do?", "type": "section", "display_type": "Page section", "docname": "text/DS_WSL2_FAQ", "anchor": "while-starting-docker-i-get-error-gpu-access-blocked-by-operating-system-what-should-i-do", "priority": -1, "content": "Not all GPUs are supported by WSL. Check the below document to see constraints associated with WSL2. https://docs.nvidia.com/cuda/wsl-user-guide/index.html#wsl-2-support-constraints", "keywords": []}, {"id": 2625, "doc_id": 2625, "filename": "text/DS_WSL2_FAQ.html", "domain_name": "std", "name": "text/DS_WSL2_FAQ", "display_name": "FAQ for Deepstream On WSL", "type": "doc", "display_type": "Page", "docname": "text/DS_WSL2_FAQ", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 2626, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#action-invdsaction", "display_name": "Action - INvDsAction", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "action-invdsaction", "priority": -1, "content": "The INvDsAction interface is used to represent a GstElement action. An action is a trigger that signals an INvDsElement based component to perform some action corresponding to that trigger. Every concrete INvDsElement based component that supports actions will have a corresponding concrete type derived from INvDsAction . This concrete type will expose a method to trigger the action. The INvDsAction based components act only as helper components for providing a prototype for the trigger and connecting a component that triggers an action to a component that reacts to the trigger. The custom component that triggers the action must be implemented separately. It must register a handle parameter of the type of concrete INvDsAction based component. The component that reacts to the trigger would also do the same. The concrete INvDsAction based component must be attached to the parameters of the other two components. When required, the custom component can trigger the action by calling the action trigger method on the handle of the INvDsAction based component, for example, NvDsRecordAction component. This action is used to toggle recording on/off recording of a camera source. Thus this component has methods start_record() , stop_record() and take_snapshot() . This action is supported by NvDsMultiSrcInputWithRecord component, thus it has a handle parameter \u201crecord-action\u201d of type NvDsRecordAction . To trigger the action, a custom component must have a Parameter of type Handle&lt;NvDsRecordAction&gt; . The component NvDsRecordAction must be added to the graph and attached to the parameters of both, the NvDsMultiSrcInputWithRecord component and the custom component. The custom component can then call start_record() , stop_record() and take_snapshot() methods as required.", "keywords": []}, {"id": 2627, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#basic-components", "display_name": "Basic Components", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "basic-components", "priority": -1, "content": "This section explains the basic concrete components that are required to create any type of DeepStream based graph. All these basic components are part of the NvDsBaseExt extension.", "keywords": []}, {"id": 2628, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#configurations-invdsconfigcomponent-template-and-specializations", "display_name": "Configurations  \u2013 INvDsConfigComponent template and specializations", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "configurations-invdsconfigcomponent-template-and-specializations", "priority": -1, "content": "The INvDsConfigComponent interface is used as a base class for components acting as configuration providers (collection of settings, associated files, binaries etc.) for other components. The aim of this interface and the components that would derive from it is to: Simplify specification of group of parameters and their values that are fixed for a use case. Package together all related assets (e.g. model files, custom implementation libraries) Remove the need of knowing beforehand the paths to files during deployment and thus hardcoding these paths to related asset files in the yaml files. Since the files are packaged with the extension library, the component can internally determine the correct absolute path to the files. The INvDsConfigComponent interface is a templated type. It provides a standard virtual method fill_config(Config *config) for any type of configuration, Config being the template type. It also provides a helper function get_absolute_path(std::string path) which can convert a path relative to the extension\u2019s binary to an absolute path at runtime. Components wanting to use this template interface for reading configurations must declare a structure with supported configuration parameters and specialize the template by using the struct as a template argument. These components must have a parameter with handle type of the specialized template. The configuration can then be read by calling the fill_config() method of the handle. Components wanting to act as configuration providers must inherit from the specialized template and implement the fill_config() method. The configuration provider component is responsible for populating the config structure appropriately. These components can use the get_absolute_path() method to convert paths relative to extension binary to absolute paths. The DeepStream extensions currently have the following configuration provider interfaces:", "keywords": []}, {"id": 2629, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#connections", "display_name": "Connections", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "connections", "priority": -1, "content": "The connection components are responsible for connecting two elements. Connecting two elements means linking an output of one of the elements (called upstream element) to an input of the other element (called downstream element) which enables flow of data between the two elements through the linked I/Os. Two types of connection components are provided:", "keywords": []}, {"id": 2630, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#connections-invdsconnection", "display_name": "Connections - INvDsConnection", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "connections-invdsconnection", "priority": -1, "content": "The INvDsConnection interface is used by components representing a link between an output component and an input component i.e., a link between two INvDsElement based components. Concrete implementations do the actual work of connecting the components. The main virtual methods provided by this interface are: Methods Details gxf_result_t connect() Concrete implementations must link the source and target I/Os and return the status void disconnect() Concrete implementations must unlink the source and target I/Os bool is_io_compatible(INvDsIO *io, GstPadSPtr gstpad) Method to check if an I/O is compatible with the I/O on the other side of the connection. void on_pad_added(INvDsIO *io, GstPadSPtr gstpad) Notification from dynamic I/Os that a new underlying GstPad object has been added. void on_pad_removed(INvDsIO *io, GstPadSPtr gstpad) Notification from dynamic I/Os that an existing underlying GstPad object has been removed. void on_no_more_pads(INvDsIO *io) Notification from dynamic I/Os that no more new underlying GstPad objects would be added. The interface APIs are primarily used by the NvDsScheduler component during pipeline construction to link elements. Ideally, custom components and extensions will never need to implement a component based on this interface or use the APIs provided by this interface. The \u201coutput\u201d component of the upstream element component must be attached to the \u201csource\u201d parameter of the INvDsConnection based component and the \u201cinput\u201d component of the downstream element component must be attached to the \u201ctarget\u201d parameter.", "keywords": []}, {"id": 2631, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#data-components", "display_name": "Data Components", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "data-components", "priority": -1, "content": "DeepStream extensions provide some Data components which can be passed around as part of entities. This removes the need of having fixed structures / function prototypes to pass data, thus removing the problem of API breakage with changing versions. Entity provides a key-value mechanism for adding and retrieving data components. The key is of string type. Both the component producing these entities and consuming the entities must know the mapping between a key and the type of the associated value. Components consuming such entities must also check the existence of the key value pair by having a Boolean check on the return value of the get() method of the entity. The rest of the section provides details on the data components provided by DeepStream extensions. These data components are part of the NvDsInterfaceExt extension and are defined in the interfaces.hpp header file of the extension.", "keywords": []}, {"id": 2632, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#deepstream-domain-component-invdscomponent", "display_name": "DeepStream Domain Component - INvDsComponent", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "deepstream-domain-component-invdscomponent", "priority": -1, "content": "The INvDsComponent interface should be used by custom components working with DeepStream components in the graph. The main feature of this interface is that it adds start() and stop() virtual methods on top of the Component interface. The component gets a notification with start() method that all other components in the graph have been initialized, underlying pipeline constructed and ready to start. In this method it is safe to call APIs of other components through their handles. This is not guaranteed to be safe in initialize() method provided by Component because the other component may not be initialized by then. stop() method is called when the underlying pipeline has been stopped and before components are de-initialized.", "keywords": []}, {"id": 2633, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#element-invdselement", "display_name": "Element - INvDsElement", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "element-invdselement", "priority": -1, "content": "This interface is used by components representing a GStreamer element in the graph. An element is the basic building block of a GStreamer based pipeline. It represents a unit of processing. These elements can perform very specific tasks like video decoding or encoding or they might perform a set of related tasks together e.g. Object detection - pre-processing, inference and post-processing to get bounding box co-ordinates of detected objects. This interface is primarily used by the NvDsScheduler component to manage the lifecycle of the elements and construct a GStreamer pipeline from the elements represented by the components. It should only be used as a base class and derived from to create a component representing a GStreamer element. Ideally, no other component should ever use this interface for interacting with the elements. Other mechanisms are provided which are described later. This interface provides following main virtual methods. gxf_result_t create_element() Concrete types must use this to create the GStreamer element and return the error/success status gxf_result_t bin_add(GstElement *pipeline) Concrete types must use this to add the created element to the provided GStreamer pipeline and return the error/success status GstElement *get_element_ptr() Concrete types must return the raw pointer to the GStreamer element Most components implementing this interface are thin wrappers created over corresponding GStreamer element. In such cases, there would be a 1-to-1 mapping between the Component parameter and the GStreamer element property. Special cases like NvDsMultiSrcInput exist which are not wrappers over a single element but elaborate implementations using GStreamer API to combine multiple elements together.", "keywords": []}, {"id": 2634, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#element-property-controller-invdspropertycontroller", "display_name": "Element Property Controller \u2013 INvDsPropertyController", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "element-property-controller-invdspropertycontroller", "priority": -1, "content": "The INvDsPropertyController interface is used by components acting as runtime property(parameter) controllers for INvDsElement based components. Every concrete INvDsElement based component that supports runtime property control will have a corresponding concrete type derived from INvDsPropertyController . This concrete type will expose methods to get/set the properties(parameters) of the element component. A method for each property that can be controlled will be exposed. The INvDsPropertyController based components act only as helper components for providing prototypes for the get/set methods and connecting a component that can control the property to the element component that the property belongs to. The custom component that controls the properties must be implemented separately. It must register a handle parameter of the type of concrete INvDsPropertyController based component. The component the properties belong to would also do the same. The concrete INvDsPropertyController based component must be attached to the parameters of the other two components. When required, the custom component can call the get/set methods of the properties on the handle of the INvDsAction based component for exmaple, NvDsOSDPropertyController component. This component can be used to get/set properties of NvDsOSD component, thus it has a handle parameter property-controller of type NvDsOSDPropertyController . To controls properties of the NvDsOSD component, a custom component must have a Parameter of type Handle&lt;NvDsOSDPropertyController&gt; . The component NvDsOSDPropertyController must be added to the graph and attached to the paramers of both, the NvDsOSD component and the custom component. The custom component can then call set/get methods exposed by NvDsOSDPropertyController .", "keywords": []}, {"id": 2635, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#gstbufferhandle", "display_name": "GstBufferHandle", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "gstbufferhandle", "priority": -1, "content": "Wraps the pointer to GstBuffer which is the GStreamer data structure for buffers - https://gstreamer.freedesktop.org/documentation/gstreamer/gstbuffer.html . The key usually associated with this data component is defined by BUF_DATA_KEY_GST_BUFFER.", "keywords": []}, {"id": 2636, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#i-os", "display_name": "I/Os", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "i-os", "priority": -1, "content": "As explained in the previous section of the INvDsIO interface, I/Os are the input/output ports of an INvDsElement based component. An I/O is defined by a template which consists of: the direction (input or output) it\u2019s availability the format of the data that flows through it. An I/O is identified by the template\u2019s name. An element component will have one or more I/Os depending on it\u2019s functionality and input/output requirements. The following types of I/O availabilities are defined along with the behavior of the GstPadSPtr get_pad(char *requested_name) method of INvDsIO interface for each of the type. Static \u2013 The I/O is always available on the element: get_pad() always returns the underlying GstPad object (single). requested_name argument is ignored OnRequest \u2013 The underlying I/O objects must be requested from the element by the application: e.g. NvDsStreamMux component which aggregates frames from multiple upstream components. Underlying GstPad objects for pushing data to the component must be requested from it, one for each upstream component. e.g. NvDsTee component which broadcasts input data to multiple outputs. Underlying GstPad objects for pushing data to multiple downstream components must be requested from it, one for each downstream component. If a non-NULL requested_name is provided to get_pad() , the method will try to create an underlying GstPad with the supplied name if it does not already exist and return it. If a pad with the provided requested_name cannot be created, NULL will be returned. If requested_name is not supplied, it creates a underlying GstPad with an internally generated name from the I/O\u2019s template name and return it. Dynamic \u2013 The underlying I/O object is made available by the element at runtime when some conditions are satisfied: e.g. NvDsSingleSrcInput component which reads from an input like FILE or RTSP and can decide whether it can output audio or video or both only after parsing the file headers/initial communication with the RTSP server. get_pad() tries to get an existing underlying GstPad object having name requested_name, returns NULL if no such pad is found. requested_name is mandatory. Multi \u2013 A special I/O availability created for components which output data from multiple sources. This availability exposes itself as a single I/O but internally groups together multiple outputs, one for each of the sources. Due to the group representation, it makes the graph and components that would use the I/O independent of the number of sources. This makes it easy to have a variable number of sources, and to dynamically add/remove sources at runtime without any changes to the graph. e.g. NvDsMultiSrcInput component which outputs data from multiple sources. get_pad() tries to get an existing underlying GstPad object having name requested_name , returns NULL if no such pad is found. requested_name is mandatory. Based on these concepts, the following concrete I/O types are provided: NvDsStaticOutput NvDsOnRequestOutput NvDsDynamicOutput NvDsMultiOutput NvDsStaticInput NvDsOnRequestInput An element component exposes a handle parameter of a concrete I/O type for each of the I/O template it supports. For any kind of interaction with an I/O, like connecting two elements, in-place manipulation of data flowing through the I/O, a concrete type of I/P component must be attached to the parameter. Depending on the function of the element component, a variety of I/O templates and thus handle parameters will be present on the component.", "keywords": []}, {"id": 2637, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#i-os-invdsio-invdsinput-invdsoutput", "display_name": "I/Os - INvDsIO/INvDsInput/INvDsOutput", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "i-os-invdsio-invdsinput-invdsoutput", "priority": -1, "content": "The INvDsIO interface is used to represent to represent an input/output of an INvDsElement based component. It is used to represent a GStreamer Pad which is the input / output port of a GStreamer element through which it receives/transmits data. The direction input or output is from the perspective of the component and not the application. An element receives data from an input and transmits data on an output. The base type for an input component is INvDsInput and that for an output is INvDsOutput . Both of these inherit from INvDsIO . Depending on the I/O (data) availability type, multiple concrete types are derived from INvDsInput and INvDsOutput , which are described in detail later. The complete hierarchy looks like Any concrete pad type can interact with via INvDsIO interface or INvDsInput/INvDsOutput interface or the concrete pad classes themselves. INvDsElement based components have parameters with the handle type of the concrete pad types (depending on the direction \u2013 input/output and availability \u2013 static/on-request/dynamic/multi). In the graph, for such a component to send/receive data, an I/O component of the corresponding type must be attached to the parameter. For e.g., the NvDsStreamMux component has a \u201con-request\u201d input and a \u201cstatic\u201d output. Thus, for it to receive data a NvDsOnRequestInput component must be attached to its video-in-%u parameter and for it to send data a NvDsStaticOutput component must be attached to its \u201cvideo-out\u201d parameter. An I/O is identified by its template name in the element. GStreamer APIs can be used to find more details about the underlying pad details using this template name. These interfaces expose the following main virtual methods: Interfaces Details void set_template_name(const char *templ) Called by INvDsElement based element to set the template name of the i/o. INvDsElement *get_element() Get the owning INvDsElement based element of the i/o. const char *get_template_name() Get the template name for the i/o. GstPadSPtr get_pad(const char *requested_name) Get the underlying GstPad pointer as a shared_ptr. Detailed behavior of this API for each type of I/O has been documented in the \u201cPads\u201d subsection of \u201cBasic Components\u201d section const std::vector&lt;GstPadSPtr&gt; get_all_pads() Get a list of all the underlying GstPad objects as vector of shared_ptrs. In case of multi/on-request/dynamic type of I/Os, element might have multiple underlying pads associated with the I/O. This API can be used to get the raw pointers to all such pads. Custom extensions will almost never need to implement a I/O based component from these interfaces. All the concrete types that would be required are already provided as a part of the NvDsBaseExt extension. Custom components wanting to interact with pads directly can use APIs from this interface. However, if only access to the data being received/transmitted is required \u201cProbe\u201d based mechanism is recommended.", "keywords": []}, {"id": 2638, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#interfaces", "display_name": "Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "interfaces", "priority": -1, "content": "DeepStream extensions provide interfaces (abstract base types) for some commonly used types of components and functionality. These interfaces provide a way for other components to interact with a variety of components implementing or inheriting from the interface without depending on the actual type/implementation. For e.g. NvDsInfer component has a parameter infer-model-config with handle type INvDsInferModelConfigComponent . The INvDsInferModelConfigComponent base type is for components representing a NN model (the model files, associated configuration, post-processing algorithm). Thus, NvDsInfer component can load any type of model without actual depending on the concrete type of the model component by calling APIs of INvDsInferModelConfigComponent . The interfaces also act as base types which can be used by tools like registry and composer to filter and group together components inheriting from the interface. Thus in the above example, registry command registry comp list -b nvidia::deepstream::INvDsInferModelConfigComponent can be used to find all the components that can be connected to the parameter \u201cinfer-model-config\u201d of NvDsInfer . Composer also uses this base type to provide quick access context-menu to on a handle type parameter create a component inheriting from the base type and attaching the newly created component to the parameter. However interfaces themselves are abstract and won\u2019t be listed in the component list from the Composer for users to create the instances through drag&amp;drop. The rest of the section provides a high-level overview of the interfaces provided by the DeepStream extensions. These interfaces are part of the NvDsInterfaceExt extension. The detailed API and parameter description is part of the document Graph Composer Extensions Manual.", "keywords": []}, {"id": 2639, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#invdsinfermodelconfigcomponent", "display_name": "INvDsInferModelConfigComponent", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "invdsinfermodelconfigcomponent", "priority": -1, "content": "This interface acts as a configuration provider for the NvDsInferVideo and NvDsInferAudio components. Components implementing this interface must populate the following parameters of the configuration structure in the fill_config() method. Method Details std::string config_file_path Absolute path to the nvinfer configuration file for the model std::string model_engine_path Absolute path to the pre-generated TensorRT engine file for the model (OPTIONAL) NvDsInferVideo and NvDsInferAudio components expose a handle parameter infer-model-config of type INvDsInferModelConfigComponent to which components implementing this interface can be attached. Components implementing this interface are model configuration providers. Thus they will package the DeepStreamSDK Gst-nvinfer/ Gst-nvinferaudio configuration file along with the model files. The specification of the Gst-nvinfer configuration file can be found at https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvinfer.html#gst-nvinfer-file-configuration-specifications .", "keywords": []}, {"id": 2640, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#invdsvideotemplatepluginconfigcomponent-invdsaudiotemplatepluginconfigcomponent", "display_name": "INvDsVideoTemplatePluginConfigComponent / INvDsAudioTemplatePluginConfigComponent", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "invdsvideotemplatepluginconfigcomponent-invdsaudiotemplatepluginconfigcomponent", "priority": -1, "content": "These interfaces act as configuration providers for the NvDsVideoTemplate and the NvDsAudioTemplate components respectively. Components implementing these interfaces must populate the following parameters of the configuration structure in the fill_config() method. Method Details std::string customlib_name Absolute path to the custom library that the audio/video template component should load std::unordered_map&lt;std::string, std::string&gt; customlib_props name-value pairs of properties to be passed to the custom library. NvDsVideoTemplate and NvDsAudioTemplate components expose handle parameters video-template-config and audio-template-config respectively to which components implementing the interfaces INvDsVideoTemplatePluginConfigComponent or INvDsAudioTemplatePluginConfigComponent can be attached. Components implementing these interfaces will package the custom library that must be provided to the template components. NvDsVideoTemplate and NvDsAudioTemplate components are wrappers for the DeepStreamSDK Gst-nvdsvideotemplate and Gst-nvdsaudiotemplate plugins respectively. For information on these plugins, refer to https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvdsvideotemplate.html and https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvdsaudiotemplate.html .", "keywords": []}, {"id": 2641, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvbufaudiohandle", "display_name": "NvBufAudioHandle", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvbufaudiohandle", "priority": -1, "content": "Wraps the pointer to NvBufAudio which is the DeepStream data structure for batched audio data \u2013 LINK TBD. The key usually associated with this data component is defined by BUF_DATA_KEY_NVBUFAUDIO .", "keywords": []}, {"id": 2642, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvbufsurfacehandle", "display_name": "NvBufSurfaceHandle", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvbufsurfacehandle", "priority": -1, "content": "Wraps the pointer to NvBufSurface which is the DeepStream data structure for batched video frames - https://docs.nvidia.com/metropolis/deepstream/dev-guide/sdk-api/structNvBufSurface.html . The key usually associated with this data component is defined by BUF_DATA_KEY_NVBUFSURFACE .", "keywords": []}, {"id": 2643, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsbatchmetahandle", "display_name": "NvDsBatchMetaHandle", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsbatchmetahandle", "priority": -1, "content": "Wraps the pointer to NvDsBatchMeta which is the DeepStream data structure for metadata associated with batched video frames or batched audio data \u2013 https://docs.nvidia.com/metropolis/deepstream/dev-guide/sdk-api/struct__NvDsBatchMeta.html . The key usually associated with this data component is defined by BUF_DATA_KEY_VIDEO_BATCH_META or BUF_DATA_KEY_AUDIO_BATCH_META depending on whether the NvDsBatchMeta structure contains information for video or audio.", "keywords": []}, {"id": 2644, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsconnection", "display_name": "NvDsConnection", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsconnection", "priority": -1, "content": "This connection component can be used to link any type of output component to any type of input component with the exception of NvDsMultiOutput . It provides two handle parameters \u201csource\u201d and \u201ctarget\u201d. To connect, an output I/O component attached to an upstream element must be attached to the \u201csource\u201d parameter of an NvDsConnection component and an input I/O component attached to a downstream element must be attached to the \u201ctarget\u201d parameter of the NvDsConnection component.", "keywords": []}, {"id": 2645, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsmultisrcconnection", "display_name": "NvDsMultiSrcConnection", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsmultisrcconnection", "priority": -1, "content": "As with NvDsMultiOutput , this connection type has been specially created for handling the use case of variable number of sources and dynamic addition/removal of sources at runtime. It can only be used to link a NvDsMultiOutput component to a NvDsOnRequestInput component, i.e. link an element which outputs data from multiple sources to aggregation type of elements. It has two parameters, \u201csource\u201d to attach the NvDsMultiOutput component to and \u201ctarget\u201d to attach the NvDsOnRequestInput component.", "keywords": []}, {"id": 2646, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsprobe", "display_name": "NvDsProbe", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsprobe", "priority": -1, "content": "This component is responsible for intercepting data (buffers/events/queries) flowing through an I/O and calling the callback functions of the target handler component whenever data arrives at the I/O. It has two handle type properties. \u201cio\u201d to which an I/O component must be attached which needs to be probed and \u201cprobe-handler\u201d to which a NvDsProbeConnector component must be attached.", "keywords": []}, {"id": 2647, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsprobeconnector", "display_name": "NvDsProbeConnector", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsprobeconnector", "priority": -1, "content": "This component is used to link a NvDsProbe component to a target component derived from INvDsInPlaceDataHandler which makes it capable of handling callbacks from the probe. This component provides the following public methods, defined in nvds_probe_connector.hpp header file as part of NvDsBaseExt : Method Details void set_handler(INvDsInPlaceDataHandler *handler) Set the component that will be handling the probe callbacks. Must be called by INvDsInPlaceDataHandler based components. INvDsInPlaceDataHandler *get_handler() Get the component that will be handling the probe callbacks. void set_flags(NvDsProbeFlags flags) Set the types of information to receive probe callbacks for. Must be called by INvDsInPlaceDataHandler based components. NvDsProbeFlags get_flags() Get the types of information to receive probe callbacks for. void set_io(INvDsIO *io) Set the IO this component is connected to. This method is called by NvDsProbe. INvDsIO *get_io() Get the IO this component is connected to. The flags must be a bitwise OR combination of the following: Method Details NvDsProbeFlags::NONE The target does not wish to handle any data NvDsProbeFlags::BUFFER The target component wants to handle buffers NvDsProbeFlags::EVENT The target component wants to handle events NvDsProbeFlags::QUERY The target component wants to handle queries The target component must register a handle parameter of type NvDsProbeConnector . The target component in it\u2019s initialize() method must call set_handler() and set_flags() method of the NvDsProbeConnector to receive callbacks.", "keywords": []}, {"id": 2648, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#nvdsscheduler", "display_name": "NvDsScheduler", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "nvdsscheduler", "priority": -1, "content": "The NvDsScheduler component is responsible for setting up the underlying pipeline and managing its state, connecting and scheduling components in the graph and managing their lifecycle. It is also responsible for setting up the probe handlers. There must be a NvDsScheduler in a graph. Without the presence of a NvDsScheduler in the graph, the DeepStream based components would never get scheduled. Additionally, there must be only one NvDsScheduler in a graph. In case multiple NvDsSchedulers are added to a graph, only one gets actually executed others become redundant and get skipped.", "keywords": []}, {"id": 2649, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#probe-callback-implementation-invdsinplacedatahandler", "display_name": "Probe Callback Implementation - INvDsInPlaceDataHandler", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "probe-callback-implementation-invdsinplacedatahandler", "priority": -1, "content": "Custom components wanting to monitor data flow or to do in place data modifications at a particular I/O of a component must inherit from this interface. The methods of this interface are called by the INvDsProbe based component when a buffer/event/query arrives at the I/O. The interface provides the following virtual methods. Concrete implementations can implement any of the methods as required. Methods Details bool handle_buffer(GstPad *pad, nvidia::gxf::Entity buffer_data) Notification to the component to handle buffer data bool handle_event(GstPad *pad, GstEvent *event) Notification to the component to handle the passed event bool handle_query(GstPad *pad, GstQuery *query) Notification to the component to handle passed query Returning true from these methods tells the probe component to let them pass through. Returning false implies that the objects should be dropped at that point. The buffer_data argument of the handle_buffer method is an Entity that contains the following data: Key Value Type BUF_DATA_KEY_GST_BUFFER GstBufferHandle BUF_DATA_KEY_NVBUFSURFACE NvBufSurfaceHandle BUF_DATA_KEY_NVBUFAUDIO NvBufAudioHandle BUF_DATA_KEY_GST_VIDEO_BATCH_META NvDsBatchMetaHandle BUF_DATA_KEY_GST_AUDIO_BATCH_META NvDsBatchMetaHandle The value types are explained in the Data components section. Depending upon the type of data flowing through the I/O, not all values might be present in the buffer_data entity. For e.g for a I/O handling video frames, buffer_data can contain NvBufSurfaceHandle and NvDsBatchMetaHandle for video but not NvBufAudioHandle and NvDsBatchMetaHandle for audio. The handle_buffer implementations must check for existence of the values before directly using the values. INvDsInPlaceDataHandler based components must register a handle parameter of type NvDsProbeConnector and in the initialize() method must call set_handler() and set_flags() method of the NvDsProbeConnector to receive callbacks. For more information on GStreamer queries and events and the APIs, refer to the following links: https://gstreamer.freedesktop.org/documentation/additional/design/query.html https://gstreamer.freedesktop.org/documentation/gstreamer/gstquery.html https://gstreamer.freedesktop.org/documentation/additional/design/events.html https://gstreamer.freedesktop.org/documentation/gstreamer/gstevent.html", "keywords": []}, {"id": 2650, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#probe-invdsprobe", "display_name": "Probe - INvDsProbe", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "probe-invdsprobe", "priority": -1, "content": "The INvDsProbe interface is used by components representing a probe. A probe is used for monitoring dataflow and in-place buffer modifications by adding callbacks on the I/O components of and INvDsElement based component. Depending on the flags used, these callbacks are called for every buffer/query/event that flows through the I/O. INvDsProbe based components are used to only install a probe. The components that want to implement these callbacks need to implemented the INvDsInPlaceDataHandler interface described later. Ideally, custom components and extensions will never need to implement this interface or use APIs of this interface, it is required by the NvDsScheduler for setting up the probes.", "keywords": []}, {"id": 2651, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#probes", "display_name": "Probes", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "probes", "priority": -1, "content": "As mentioned earlier probes are used for in-place manipulation and monitoring of data flowing through the I/Os of an element component. Two components are provided to achieve this.", "keywords": []}, {"id": 2652, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "page", "name": "text/DS_Zero_Coding_DS_Components#signal-invdssignal", "display_name": "Signal  - INvDsSignal", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "signal-invdssignal", "priority": -1, "content": "The INvDsSignal interface is used to represent a GstElement signal. A signal is a callback from an INvDsElement based component on the occurrence of some event. Every concrete component that supports signals will have a corresponding concrete type derived from INvDsSignal . This concrete type will expose the prototype of the callback function and a method to set the callback function. The INvDsSignal based components act only as helper components for providing a prototype for the callback and connecting a component that emits the signal to a component that implements the callback handling the signal. The custom component that handles the signal must be implemented separately. It must register a handle parameter of the type of concrete INvDsSignal based component. It must implement the Handler interface exposed by the signal component and call set_handler() method on the handle of the signal component. The component that emits the signal would similarly register a handle parameter of type of the concrete signal component. The concrete INvDsSignal based component must be attached to the parameters of the other two components. When the INvDsElement based element emits the corresponding signal, the methods of the Handler interface will get called via the signal component for example, NvDsModelUpdateSignal component. This signal is used to notify the status of on the fly model update. Thus the Handler interface for this signal has the method on_model_updated(int errorCode, char *configFilePath) . This signal is emitted by NvDsInfer component, thus it has a handle parameter model-updated-signal of type NvDsModelUpdateSignal . To receive the signal callback, a custom component must implement NvDsModelUpdateSignal::Handler interface. It must register a parameter of type Handle&lt;NvDsModelUpdateSignal&gt; and call set_handler() on the handle. The component NvDsModelUpdateSignal must be added to the graph and attached to the parameters of both NvDsInfer and the custom component.", "keywords": []}, {"id": 2653, "doc_id": 2653, "filename": "text/DS_Zero_Coding_DS_Components.html", "domain_name": "std", "name": "text/DS_Zero_Coding_DS_Components", "display_name": "DeepStream Components", "type": "doc", "display_type": "Page", "docname": "text/DS_Zero_Coding_DS_Components", "anchor": "", "priority": -1, "content": "DeepStream/Gstreamer pipeline is implemented using the Graph Specification by wrapping GStreamer element in Graph Component and adding supportive Components to enable communication with GStreamer pipeline from Graph components. This section explains components types used in DeepStream graphs.", "keywords": []}, {"id": 2654, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#a-simple-deepstream-component", "display_name": "A simple DeepStream component", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "a-simple-deepstream-component", "priority": -1, "content": "#include &quot;extensions/nvdsinterface/interfaces.hpp&quot; namespace nvidia { namespace deepstream { class NvDsSimpleComponent : INvDsComponent { public: // Public methods using which other components can interact with this // component via its handle. void simpleComponentMethod() { // } private: gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override { nvidia::gxf::Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter( simple_param_, // Parameter member variable &quot;simple-param-key&quot;, // Parameter name(key). This is used to set // parameter value in a graph &quot;Simple Parameter&quot;, // Parameter head line &quot;Description of the simple parameter&quot;, // A description of the // parameter 100UL, // A default value for the parameter GXF_PARAMETER_FLAGS_OPTIONAL // Parameter flags marking it ); result &amp;= registrar-&gt;parameter(handle_param_, &quot;handle-parameter&quot;, &quot;Handle Parameter&quot;, &quot;Description of the handle parameter&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); return nvidia::gxf::ToResultCode(result); } gxf_result_t initialize() override { // This method can be used to initialize the component. ... // Check if parameter is set if (simple_param_.try_get() != std::nullopt) { uint64_t simple_param_value = simple_param_.try_get().value(); ... } return GXF_SUCCESS; // return GXF_FAILURE in case of any fatal error } gxf_result_t deinitialize() override { // This method can be used to deinitialize the component. ... return GXF_SUCCESS; // return GXF_FAILURE in case of any fatal error } gxf_result_t start() override { // Start the component. The underlying DeepStream pipeline and other // components are already initialized. It is safe to call methods of other components // via their handles. ... // Check if any component is attached to the parameter if (handle_param.try_get() != std::nullopt) { SampleOtherComponent *other_comp = handle_param.try_get().value(); other_comp-&gt;otherComponentMethod(); ... } return GXF_SUCCESS; // return GXF_FAILURE in case of any fatal error } gxf_result_t stop() override { // Pipeline has been stopped. All the components would be deinitialized // after this. Add any logic for stopping the component. return GXF_SUCCESS; // return GXF_FAILURE in case of any fatal error } nvidia::gxf::Parameter&lt;uint64_t&gt; simple_param_; nvidia::gxf::Parameter&lt;nvidia::gxf::Handle&lt;SampleOtherComponent&gt;&gt; handle_param_; }; } // namespace deepstream", "keywords": []}, {"id": 2655, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#controlling-properties", "display_name": "Controlling Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "controlling-properties", "priority": -1, "content": "This sample code demonstrates the usage of an INvDsPropertyController ( NvDsOSDPropertyController in this case) component by a custom component to control properties of an INvDsElement based component ( NvDsOSD in this case). // Provided as part of the NvDsVisualizationExt extension which contains the // NvDsOSD component. This header contains the definition of // NvDsOSDPropertyController component which provides methods to control // properties of NvDsOSD component. #include &quot;nvdsvisualization_prop_controllers.hpp&quot; namespace nvidia { namespace deepstream { class NvDsSamplePropertyControl : public INvDsComponent { nvidia::gxf::Parameter&lt;nvidia::gxf::Handle&lt;NvDsOSDPropertyController&gt;&gt; osd_property_controller_; NvDsOSDPropertyController *osd_property_controller = nullptr; gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override { ... // Must register a handle parameter of type NvDsOSDPropertyController result &amp;= registrar-&gt;parameter( osd_property_controller_, &quot;nvdsosd-prop-controller&quot;, &quot;NvDsOSD Property Controller&quot;, &quot;Handle to a nvidia::deepstream::NvDsOSDPropertyController &quot; &quot;component.&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); ... }; void sample_thread_func() { while (1) { bool display_text; // Get the current property value osd_property_controller-&gt;get_display_text(&amp;display_text); // Toggle the property value osd_property_controller-&gt;set_display_text(!display_text); sleep(1); // Break when signalled to stop } } gxf_result_t start() override { ... // Check if the property controller component is attached if (osd_property_controller_.try_get() != std::nullopt) { osd_property_controller = osd_property_controller_.try_get().value(); osd_property_controller-&gt;set_display_text(true); // Start a thread which periodically toggles the display-text property } ... } gxf_result_t stop() override { // Signal samplethread to stop } }; } // namespace deepstream } // namespace nvidia", "keywords": []}, {"id": 2656, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#extension-and-component-factory-registration-boilerplate", "display_name": "Extension and component factory registration boilerplate", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "extension-and-component-factory-registration-boilerplate", "priority": -1, "content": "The following provides a boilerplate on registering extensions and components #include &quot;gxf/std/extension_factory_helper.hpp&quot; #include &quot;sample_runtime_source_manipulator.hpp&quot; ... GXF_EXT_FACTORY_BEGIN() GXF_EXT_FACTORY_SET_INFO(0x44a711e485194a68, 0x81e8be7ee4af3ff0, &quot;NvDsSampleExt&quot;, &quot;Sample components for demonstrating usage of various &quot; &quot;DeepStream interfaces and components&quot;, &quot;NVIDIA&quot;, &quot;0.0.1&quot;, &quot;Proprietary&quot;); ... GXF_EXT_FACTORY_ADD( 0x717b2c432f104fe8, 0xb96165e408ece299, nvidia::deepstream::NvDsSimpleComponent, nvidia::deepstream::INvDsComponent, &quot;Description of a simple component&quot;); ... GXF_EXT_FACTORY_END() Include the header file gxf/std/extension_factory_helper.hpp containing the helper macros. Include any other header file containing the definitions of components to be registered. GXF_EXT_FACTORY_BEGIN() and GXF_EXT_FACTORY_END() mark the beginning and end of the block of code containing registration code. Within the factory block, call GXF_EXT_FACTORY_SET_INFO() to set the extension information including the UUID for the extension, the extension name, description, author, version and license. For each of the component to be registered as part of the extension, call GXF_EXT_FACTORY_ADD() to add the component along with the component information including the UUID for the component, the component type, the component\u2019s base type and a description of the component. The UUIDs are unique 128-bit identifiers. This must be unique across all extensions and component registered. In the code, two 64-bit unsigned integers represent the upper 64 bits and lower 64bits of the 128-bit UUID.", "keywords": []}, {"id": 2657, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#handling-signal-callbacks", "display_name": "Handling signal callbacks", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "handling-signal-callbacks", "priority": -1, "content": "This sample code demonstrates the usage of an INvDsSignal ( NvDsModelUpdatedSignal in this case) component by a custom component to handle signals emitted by an INvDsElement based component ( NvDsInferVideo in this case). // Provided as part of the NvDsInferenceExt extension which contains the // NvDsInferVideo component. This header contains the definition of // NvDsModelUpdatedSignal component which provides the Handler interface and // callback method prototype and a way to set the Handler instance. #include &quot;nvdsinference_signals.hpp&quot; namespace nvidia { namespace deepstream { class NvDsSampleSignalHandler : public INvDsComponent, public NvDsModelUpdatedSignal::Handler { nvidia::gxf::Parameter&lt;nvidia::gxf::Handle&lt;NvDsModelUpdatedSignal&gt;&gt; model_update_signal_; gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override { ... // Must register a handle parameter of type NvDsModelUpdatedSignal result &amp;= registrar-&gt;parameter( model_update_signal_, &quot;model-update-signal&quot;, &quot;Model Updated Signal&quot;, &quot;Handle to a nvidia::deepstream::NvDsModelUpdatedSignal &quot; &quot;component.&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); ... }; // Implement the methods of the NvDsModelUpdatedSignal::Handler interface void on_model_updated(int errorCode, gchar *configFilePath) override { // Handle the on-the-fly model update status. } gxf_result_t start() override { // Start the component ... // Check if the signal component is attached, set the signal handler to self if (model_update_signal_.try_get() != std::nullopt) { // The pointer to self (this) can be passed since the component // implements the NvDsModelUpdatedSignal::Handler interface model_update_signal_.try_get().value()-&gt;set_handler(this); } ... } gxf_result_t stop() override { // Stop the component } }; } // namespace deepstream } // namespace nvidia", "keywords": []}, {"id": 2658, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#implementation-of-an-configuration-provider-component", "display_name": "Implementation of an Configuration Provider component", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "implementation-of-an-configuration-provider-component", "priority": -1, "content": "This sample code demonstrates the implementation of a configuration provider interface ( INvDsInferModelConfigComponent in this case) component by a custom component to provide a configuration (to NvDsInferVideo in this case). // Provided as part of the NvDsInferenceExt extension which contains the // NvDsInferVideo component. This header contains the definition of // INvDsInferModelConfigComponent interface which acts as a model configuration // provider to the NvDsInferVideo component. #include &quot;nvdsinference_config.hpp&quot; namespace nvidia { namespace deepstream { class SampleModel : public INvDsInferModelConfigComponent { gxf_result_t fill_config(NvDsInferModelConfig *config) override { // config_infer_primary.txt is packaged alongside the extension binary, // along with caffemodel, prototxt and labels file. Use get_absolute_path() // method to convert a path relative to the extension binary to an absolute // path at runtime. config-&gt;config_file_path = get_absolute_path(&quot;config_infer_primary.txt&quot;); if (engine_file_.try_get() != std::nullopt) { // The configuration provider component itself can have parameters which // can be used to populate the configuration. config-&gt;model_engine_path = get_absolute_path(engine_file_.try_get().value()); } return GXF_SUCCESS; } gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override { nvidia::gxf::Expected&lt;void&gt; result; result &amp;= registrar-&gt;parameter(engine_file_, &quot;model-engine-file&quot;, &quot;Model Engine File&quot;, &quot;Path to the model engine file. Absolute or &quot; &quot;relative to the extension directoy.&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); return nvidia::gxf::ToResultCode(result); } nvidia::gxf::Parameter&lt;std::string&gt; engine_file_; }; } // namespace deepstream } // namespace nvidia NvDsSampleAudioTemplateLib and NvDsSampleVideoTemplateLib are other examples of components acting as configuration providers. These components are part of the sample extension.", "keywords": []}, {"id": 2659, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#implementation-of-invdsinplacedatahandler", "display_name": "Implementation of INvDsInPlaceDataHandler", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "implementation-of-invdsinplacedatahandler", "priority": -1, "content": "#include &quot;extensions/nvdsbase/nvds_probe_connector.hpp&quot; #include &quot;extensions/nvdsinterface/interfaces.hpp&quot; namespace nvidia { namespace deepstream { class NvDsSampleInPlaceDataHandler : public INvDsInPlaceDataHandler { nvidia::gxf::Parameter&lt;nvidia::gxf::Handle&lt;NvDsProbeConnector&gt;&gt; probe_connector_; gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) { ... // Must register a handle parameter of type NvDsProbeConnector result &amp;= registrar-&gt;parameter( probe_connector_, &quot;probe-connector&quot;, &quot;Probe Connector&quot;, &quot;Handle to a nvidia::deepstream::NvDsProbeConnector component&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); ... } gxf_result_t initialize() override { ... // Need to set the handler and flags which tells NvDsProbe component // what type of data this component wants to handle. This must be done // in the initialize method. if (probe_connector_.try_get() != std::nullopt) { // The pointer to self (this) can be passed since the component // implements the INvDsInPlaceDataHandler interface. probe_connector_.try_get().value()-&gt;set_handler(this); probe_connector_.try_get().value()-&gt;set_flags(static_cast&lt;NvDsProbeFlags&gt;( NvDsProbeFlags::BUFFER | NvDsProbeFlags::EVENT)); } ... return GXF_SUCCESS; } bool handle_buffer(GstPad *pad, nvidia::gxf::Entity buffer_data) override { // Check for presence of NvDsBatchMeta and NvBufSurface in the buffer_data // entity since this implementation requires it. Other implementations may // want to check for presence of other data components. if (!buffer_data.get&lt;NvDsBatchMetaHandle&gt;(BUF_DATA_KEY_VIDEO_BATCH_META)) { return true; } if (!buffer_data.get&lt;NvBufSurfaceHandle&gt;(BUF_DATA_KEY_NVBUFSURFACE)) { return true; } NvDsBatchMeta *batch_meta = *(buffer_data.get&lt;NvDsBatchMetaHandle&gt;(BUF_DATA_KEY_VIDEO_BATCH_META) .value()); NvBufSurface *surf = *(buffer_data.get&lt;NvBufSurfaceHandle&gt;(BUF_DATA_KEY_VIDEO_BATCH_META) .value()); // Use batch_meta and surf ... return true; // allows buffer to pass through. return false to drop the buffer } bool handle_event(GstPad *pad, GstEvent *event) override { // Use the event ... return true; // allows buffer to pass through. return false to drop the event } }; } // namespace deepstream } // namespace nvidia The component NvDsSampleProbeMessageMetaCreation provided as part of the sample extension is a complete sample implementation of INvDsInPlaceDataHandler interface.", "keywords": []}, {"id": 2660, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Developing_Extension#triggering-actions", "display_name": "Triggering Actions", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "triggering-actions", "priority": -1, "content": "This sample code demonstrates the usage of an INvDsAction ( NvDsSourceManipulationAction in this case) component by a custom component to trigger actions of an INvDsElement based component ( NvDsMultiSrcInput in this case). // Provided as part of the NvDsSourceExt extension which contains the // NvDsMultiSrcInput component. This header contains the definition of // NvDsSourceManipulationAction component which provides methods to trigger // add/remove source actions of NvDsMultiSrcInput component. #include &quot;nvdsinputsrc_signals.hpp&quot; namespace nvidia { namespace deepstream { class NvDsSampleSourceManipulator : public INvDsComponent { nvidia::gxf::Parameter&lt;nvidia::gxf::Handle&lt;NvDsSourceManipulationAction&gt;&gt; source_manip_action_; NvDsSourceManipulationAction *source_manip_action = nullptr; bool add = true; gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override { ... // Must register a handle parameter of type NvDsSourceManipulationAction result &amp;= registrar-&gt;parameter( source_manip_action_, &quot;source-manip-action&quot;, &quot;Source Manipulation Action&quot;, &quot;Handle to a nvidia::deepstream::NvDsSourceManipulationAction &quot; &quot;component&quot;, std::nullopt, GXF_PARAMETER_FLAGS_OPTIONAL); ... } void sample_thread_func() { while (1) { // Call methods of the action component via it&#x27;s handle to trigger the add/remove actions. if (add) { if (!source_manip_action-&gt;add_source(&quot;file:///some/file/path.mp4&quot;, 2)) { GXF_LOG_WARNING(&quot;Failed to add source&quot;); } } else { if (!source_manip_action-&gt;remove_source(&quot;file:///some/file/path.mp4&quot;, 2)) { GXF_LOG_WARNING(&quot;Failed to remove source&quot;); } } add = !add; sleep(10); // Break when signalled to stop } } gxf_result_t start() override { ... // Check if the action component is attached if (source_manip_action_.try_get() != std::nullopt) { source_manip_action = source_manip_action_.try_get().value(); // Start a thread to periodically add / remove a source } ... } gxf_result_t stop() override { // Stop the thread } }; } // namespace deepstream } // namespace nvidia The component NvDsSampleSourceManipulator provided as part of the sample extension is a complete sample implementation demonstrating this.", "keywords": []}, {"id": 2661, "doc_id": 2661, "filename": "text/DS_Zero_Coding_Developing_Extension.html", "domain_name": "std", "name": "text/DS_Zero_Coding_Developing_Extension", "display_name": "Developing Extensions for DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_Zero_Coding_Developing_Extension", "anchor": "", "priority": -1, "content": "This section provides an overview of developing extensions with a focus on developing DeepStream based components. The usage of various interfaces and components is explained through sample code snippets. For the sake of simplicity, the component definition and implementation of its methods are shown together in the sample code. However, this can be split between a header file and .cpp source file as required. The interfaces.hpp header provided as part of NvDsInterfaceExt contains the basic DeepStream interface definitions. The definition of some concrete component types like the I/Os, NvDsProbeConnector are included in header files provided as part of NvDsBaseExt . The definitions of component specific Action, Signal, PropertyController, and Configuration types are included in header files provided as part of the extension the component belongs to. All DeepStream types are defined under the namespace nvidia::deepstream . Implementations should take care of this if not using the same namespace.", "keywords": []}, {"id": 2662, "doc_id": 2662, "filename": "text/DS_Zero_Coding_Introduction.html", "domain_name": "std", "name": "text/DS_Zero_Coding_Introduction", "display_name": "Introduction", "type": "doc", "display_type": "Page", "docname": "text/DS_Zero_Coding_Introduction", "anchor": "", "priority": -1, "content": "Graph Composer tools reduces the burden of writing code for AI applications. It does this by using Graph Specification for representing a graph and wide array of NVIDIA published extensions. DeepStream provided extensions do all the heavy lifting, requiring developers to only implement the core business logic by implementing a few methods of the interfaces/base classes, thus removing the need to learn the underlying framework concepts and its APIs. This document starts by describing the basic concepts behind the Graph Specification. The rest of the document is very much oriented towards using DeepStream with Graph Composer, how to create and execute DeepStream based AI Applications using Graph Composer and a guide on developing custom extensions. A section for troubleshooting and frequently asked questions has been added that may help answer queries and issues. Finally, a list of reference DeepStream AI Application graphs released by NVIDIA has been added. DeepStream and GStreamer DeepStream set of extensions have been created for developing DeepStream based applications. These extensions depends on DeepStream SDK and hence some knowledge of the DeepStream SDK will be helpful. For more information on DeepStreamSDK refer to https://developer.nvidia.com/deepstream-getting-started . DeepStreamSDK is based on the GStreamer multimedia framework. DeepStream extensions abstracts away all the complexities of using the GStreamer framework. In most cases, developers will never need to directly refer to GStreamer or call a GStreamer API. However, in a few advanced use cases, access to GStreamer objects being used underneath might be required.", "keywords": []}, {"id": 2663, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-3d-camera", "display_name": "deepstream-3d-camera", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-3d-camera", "priority": -1, "content": "Demonstrates capture, processing and rendering of 3D data from a 3D camera.", "keywords": []}, {"id": 2664, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-action-recognition", "display_name": "deepstream-action-recognition", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-action-recognition", "priority": -1, "content": "Demonstrates usage of NvDsPreProcess component to do pre-processing outside the NvDsInferVideo component. In this sample, it is used to demonstrate temporal batching and pre-processing required by the NVIDIA TAO Action Recognition models.", "keywords": []}, {"id": 2665, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-app", "display_name": "deepstream-app", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-app", "priority": -1, "content": "DeepStream reference application, showing a wide variety of features such as kitti dump, performance measurement, handling tiler events. Two graphs corresponding to the two sample configurations in the DeepStreamSDK are provided.", "keywords": []}, {"id": 2666, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-camera", "display_name": "deepstream-camera", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-camera", "priority": -1, "content": "Demonstrates usage of a camera source in a simple DeepStream pipeline", "keywords": []}, {"id": 2667, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-runtime-src-add-del", "display_name": "deepstream-runtime-src-add-del", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-runtime-src-add-del", "priority": -1, "content": "Demonstrates how sources can be dynamically added/removed at runtime. Also, demonstrates the use of action/signal components. The \u201cNvDsSourceManipulationAction\u201d of \u201cNvDsMultiSrcInput\u201d component is used to add/remove the sources. This action is triggered by another sample component \u201cNvDsSampleSourceManipulator\u201d every fixed interval which can be configured. Or this action can also be triggered by an Http service \u201cNvDsStreamManager\u201d upon add source or remove source Http request.", "keywords": []}, {"id": 2668, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-subgraph", "display_name": "deepstream-subgraph", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-subgraph", "priority": -1, "content": "Demonstrates usage of subgraphs with DS components.", "keywords": []}, {"id": 2669, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-template-plugin", "display_name": "deepstream-template-plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-template-plugin", "priority": -1, "content": "Demonstrates the usage of configuration components used as configuration providers for other components. These graphs are meant to run only on DGPU platforms since the DeepStream template plugins are available only on DGPU platforms.", "keywords": []}, {"id": 2670, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-test1", "display_name": "deepstream-test1", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-test1", "priority": -1, "content": "Simplest example of using DeepStream for object detection. Demonstrates decoding video from a file, performing object detection and overlaying bounding boxes on the frames.", "keywords": []}, {"id": 2671, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-test2", "display_name": "deepstream-test2", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-test2", "priority": -1, "content": "Builds on top of deepstream-test1 and demonstrates object tracking and cascaded inferencing.", "keywords": []}, {"id": 2672, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-test3", "display_name": "deepstream-test3", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-test3", "priority": -1, "content": "Builds on top of deepstream-test1 to demonstrate use of multiple sources in the pipeline.", "keywords": []}, {"id": 2673, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-test4", "display_name": "deepstream-test4", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-test4", "priority": -1, "content": "Builds on top of deepstream-test1 to demonstrate how to send the metadata generated by the DeepStream components to the cloud using messaging components.", "keywords": []}, {"id": 2674, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-test5", "display_name": "deepstream-test5", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-test5", "priority": -1, "content": "DeepStream reference application which demonstrates device-to-cloud and cloud-to-device messaging, Smart Record and model on-the-fly update.", "keywords": []}, {"id": 2675, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-triton", "display_name": "deepstream-triton", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-triton", "priority": -1, "content": "Demonstrates usage of triton server in a simple DeepStream pipeline along with the use of NVIDIA Graph Container Builder for creating use case based containers. The graph shows object detection using SSD Inception V2 Tensorflow model via the Triton server. For DGPU, the graph must be executed inside the container built using the container builder, since Triton is available only in docker format. For Jetson, the graph can be run directly on the device.", "keywords": []}, {"id": 2676, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-ucx-test1", "display_name": "deepstream-ucx-test1", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-ucx-test1", "priority": -1, "content": "Demonstrates how to use DeepStream UCX communication components for data transfer:", "keywords": []}, {"id": 2677, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#deepstream-ucx-test2", "display_name": "deepstream-ucx-test2", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "deepstream-ucx-test2", "priority": -1, "content": "Demonstrates how to use DeepStream UCX communication components for data transfer including DS metadata.", "keywords": []}, {"id": 2678, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#graph-and-related-files", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "graph-and-related-files", "priority": -1, "content": "deepstream-test5.yaml \u2013 The main graph file parameters.yaml \u2013 File containing parameters for the various components in the graph test_sr_message_generator.yaml \u2013 Test graph for generating Smart record start/stop messages dstest5_msgconv_sample_config.txt \u2013 Configuration files for the components used in the graph ds_test5_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_test5_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform resources.yaml - List of resources required to execute the graph. This is required when using remote graph execution README - Contains detailed graph description and execution instructions Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test5 Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test5.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test5.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml NOTE: When executing on a remote target, additional argument &quot;--resources resources.yaml&quot; must be provided to execute_graph.sh script. By default the sample is configured to send messages over Kafka and thus needs a Kafka broker running. The graph files assume that the server is running on \u201clocalhost:9092\u201d. The server to send messages to along with the topic can be changed by modifying msg-broker-conn-str , conn-str and topic parameters in the parameters.yaml and test_sr_message_generator.yaml file.", "keywords": []}, {"id": 2679, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#graph-files", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "graph-files", "priority": -1, "content": "deepstream-test1.yaml \u2013 The main graph file parameters.yaml \u2013 File containing parameters for the various components in the graph README - Contains detailed graph description and execution instructions ds_test1_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_test1_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test1 Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test1.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test1.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2680, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id1", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id1", "priority": -1, "content": "deepstream-test2.yaml \u2013 The main graph file parameters.yaml \u2013 File containing parameters for the various components in the graph README - Contains detailed graph description and execution instructions ds_test2_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_test2_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test2 Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test2.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test2.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2681, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id12", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id12", "priority": -1, "content": "deepstream-runtime-src-add-del.yaml \u2013 The main graph file deepstream-runtime-src-add-del-as-a-service.yaml \u2013 The main graph file with stream manager service parameters.yaml \u2013 File containing parameters for the various components in the graph README - Contains detailed graph description and execution instructions ds_runtime_src_add_del_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_runtime_src_add_del_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-runtime-src-add-del Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-runtime-src-add-del.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-runtime-src-add-del-as-a-service.yaml \\ -d ../common/target_x86_64.yaml * To add / remove a stream using a client on the same host Add stream with id 1: $ curl -X POST &quot;http://localhost:8082/AddStream/stream&quot; -d &quot;{\\&quot;sensor\\&quot;:{\\&quot;id\\&quot;: \\&quot;1\\&quot;, \\&quot;uri\\&quot;: \\&quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4\\&quot;}}&quot; Add stream with id 2: $ curl -X POST &quot;http://localhost:8082/AddStream/stream&quot; -d &quot;{\\&quot;sensor\\&quot;:{\\&quot;id\\&quot;: \\&quot;2\\&quot;, \\&quot;uri\\&quot;: \\&quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4\\&quot;}}&quot; ...... Until the max number of streams configured in NvDsStreamManager is reached Remove stream with id 2: $ curl -X POST &quot;http://localhost:8082/RemoveStream/stream&quot; -d &quot;{\\&quot;sensor\\&quot;:{\\&quot;id\\&quot;: \\&quot;2\\&quot;}}&quot; Remove stream with id 1: $ curl -X POST &quot;http://localhost:8082/RemoveStream/stream&quot; -d &quot;{\\&quot;sensor\\&quot;:{\\&quot;id\\&quot;: \\&quot;1\\&quot;}}&quot; ...... Until all streams are removed On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-runtime-src-add-del.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2682, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id15", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id15", "priority": -1, "content": "deepstream-videotemplate.yaml \u2013 Graph demonstrating usage of DS video template plugin and a configuration provider for the plugin README - Contains detailed graph description and execution instructions Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-template-plugin Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-videotemplate.yaml \\ -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-videotemplate.yaml \\ -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2683, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id17", "display_name": "Sample Output", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id17", "priority": -1, "content": "The sample output consists of the input video scaled by \u201cscale-factor\u201d mentioned in parameters of NvDsSampleVideoTemplateLib component in the graph.", "keywords": []}, {"id": 2684, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id18", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id18", "priority": -1, "content": "source30_1080p_dec_infer-resnet_tiled_display_int8.yaml \u2013 Graph file for 30 file inputs + Primary Detector + Tiled Output source30_1080p_dec_infer-resnet_tiled_display_int8.parameters.yaml \u2013 File with parameters for various components in the above graph source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yaml \u2013 Graph file for 4 file inputs + Primary Detector + Tracker + 3 x Secondary Classifiers + Tiled Output source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.parameters.yaml \u2013 File with parameters for various components in the above graph README - Contains detailed graph description and execution instructions ds_app_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_app_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-app Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh \\ source30_1080p_dec_infer-resnet_tiled_display_int8.yaml \\ source30_1080p_dec_infer-resnet_tiled_display_int8.parameters.yaml \\ -d ../common/target_x86_64.yaml $ /opt/nvidia/graph-composer/execute_graph.sh \\ source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yaml \\ source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.parameters.yaml \\ -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh \\ source30_1080p_dec_infer-resnet_tiled_display_int8.yaml \\ source30_1080p_dec_infer-resnet_tiled_display_int8.parameters.yaml \\ -d ../common/target_aarch64.yaml $ /opt/nvidia/graph-composer/execute_graph.sh \\ source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yaml \\ source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.parameters.yaml \\ -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2685, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id19", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id19", "priority": -1, "content": "deepstream-triton.yaml \u2013 The main graph file deepstream-triton.parameters.dgpu_container.yaml \u2013 File containing parameters for executing the graph on DGPU deepstream-triton.parameters.jetson.yaml \u2013 File containing parameters for executing the graph on Jetson ds_triton_container_builder_cfg_dgpu.yaml \u2013 Container Builder configuration file for building a container for the graph README - Contains detailed graph description and execution instructions ds_triton_container_builder_cfg_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_triton_container_builder_cfg_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-triton Sample Commands: On x86: Triton samples for DGPU need to be run in containers based on Triton. This sample uses the NVIDIA Container Builder to build a container for the sample. Steps: * Build the container $ container_builder build -c ds_triton_container_builder_cfg_dgpu.yaml \\ -d target_triton_x86_64.yaml -wd $(pwd) * Start the container $ docker run -it --rm -e DISPLAY=:0 -v /tmp/.X11-unix/:/tmp/.X11-unix \\ --gpus all deepstream_triton_dgpu On Jetson: Triton samples for Jetson can be run natively or in a container. Steps for running natively: * Setup the Triton Server. - $ cd /opt/nvidia/deepstream/deepstream/samples - $ sudo ./triton_backend_setup.sh * Prepare the triton model repo. Downloads the model files. - $ cd /opt/nvidia/deepstream/deepstream/samples/ - $ ./prepare_ds_triton_model_repo.sh # prepare the triton model repo * Launch the graph - $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-triton.yaml \\ deepstream-triton.parameters.jetson.yaml -d target_triton_aarch64.yaml Sometime there can be following error while running the graph. &quot;unable to load backend library: /usr/lib/aarch64-linux-gnu/libgomp.so.1: cannot allocate memory in static TLS block&quot; To solve the issue the libgomp.so.1 needs to be preloaded which can be done as follows before running the sample: $ export LD_PRELOAD=/usr/lib/aarch64-linux-gnu/libgomp.so.1:$LD_PRELOAD", "keywords": []}, {"id": 2686, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id22", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id22", "priority": -1, "content": "deepstream-camera.yaml \u2013 The main graph file v4l2-usb-camera.parameters.yaml - Parameters file for using V4L2 USB camera. Works on both x86 and jetson argus-csi-camera.parameters.yaml - Parameters file for using CSI camera using NVIDIA Argus API. Works on jetson only README - Contains detailed graph description and execution instructions ds_camera_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_camera_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-camera Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-camera.yaml \\ v4l2-usb-camera.parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-camera.yaml \\ v4l2-usb-camera.parameters.yaml -d ../common/target_aarch64.yaml OR $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-camera.yaml \\ argus-csi-camera.parameters.yaml -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2687, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id25", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id25", "priority": -1, "content": "deepstream-action-recognition.yaml \u2013 The main graph file parameters.yaml - File containing parameters for the various components in the graph resources.yaml - List of resources required to execute the graph. This is required when using remote graph execution README - Contains detailed graph description and execution instructions ds_action_recognition_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_action_recognition_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform config_preprocess_3d_custom.txt - NvDsPreProcess component configuration file for the 3D Action Recogntion model config_preprocess_2d_custom.txt - NvDsPreProcess component configuration file for the 2D Action Recogntion model Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-action-recognition Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-action-recognition.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-action-recognition.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml When executing on a remote target, additional argument \u201c\u2013resources resources.yaml\u201d must be provided to execute_graph.sh script.", "keywords": []}, {"id": 2688, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id28", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id28", "priority": -1, "content": "main_graph.yaml \u2013 The main graph file inference_subgraph.yaml - Inference subgraph used by thr main graph resources.yaml - List of resources required to execute the graph. This is required when using remote graph execution README - Contains detailed graph description and execution instructions ds_subgraph_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_subgraph_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-subgraph Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh main_graph.yaml \\ -s inference_subgraph.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh main_graph.yaml \\ -s inference_subgraph.yaml -d ../common/target_aarch64.yaml When executing on a remote target, additional argument \u201c\u2013resources resources.yaml\u201d must be provided to execute_graph.sh script.", "keywords": []}, {"id": 2689, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id29", "display_name": "Graph", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id29", "priority": -1, "content": "Main graph: Inference Subgraph", "keywords": []}, {"id": 2690, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id31", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id31", "priority": -1, "content": "deepstream-3d-camera.yaml \u2013 The main graph file parameters-2drender.yaml - Parameters to render as 2D instead of 3D ds_3d_loader_realsense.yaml - Configuration file for Data loader component (source) ds_3d_filter_depth2cloud.yaml - Configuration file for Data filtering component (nvds3dfilter) ds_3d_render_depth2d.yaml - Configuration file for Data render component (sink) - 2D rendering ds_3d_render_pointcloud3d.yaml - Configuration file for Data render component (sink) - 3D rendering resources.yaml - List of resources required to execute the graph. This is required when using remote graph execution README - Contains detailed graph description and execution instructions ds_3d_depth_camera_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-3d-camera Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-3d-camera.yaml \\ -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-3d-camera.yaml \\ -d ../common/target_aarch64.yaml NOTE: \u201cparameters-2drender.yaml\u201d can be added to the commandline to render 2D depth/color images instead of the default 3D point cloud rendering. Mouse interactions are possible with default 3D point render.", "keywords": []}, {"id": 2691, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id34", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id34", "priority": -1, "content": "deepstream-ucx-test1-server.yaml \u2013 Server application graph file (sender) deepstream-ucx-test1-client.yaml \u2013 Client application graph file (receiver) server-parameters.yaml - Configurable parameters for various components in the server application. client-parameters.yaml - Configurable parameters for various components in the client application. README - Contains detailed graph description and execution instructions Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-ucx-test1 Sample Commands: Run the server first: Update `addr` parameter in `server-parameters.yaml` to mellanox NIC address on which the server listens. On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-ucx-test1-server.yaml \\ server-parameters.yaml -d ../common/target_x86_64.yaml Run the client next: Update addr` parameters in `client-parameters.yaml` to address on which the server is listening. This may be executed on the same device in another terminal or on another device with a mellanox NIC connected to the server side mellanox NIC. On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-ucx-test1-client.yaml \\ client-parameters.yaml -d ../common/target_x86_64.yaml This sample is supported only for x86.", "keywords": []}, {"id": 2692, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id35", "display_name": "Graph", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id35", "priority": -1, "content": "Server Graph Client Graph", "keywords": []}, {"id": 2693, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id37", "display_name": "Graph and related files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id37", "priority": -1, "content": "deepstream-ucx-test2-server.yaml \u2013 Server application graph file (sender) deepstream-ucx-test2-client.yaml \u2013 Client application graph file (receiver) server-parameters.yaml - Configurable parameters for various components in the server application. client-parameters.yaml - Configurable parameters for various components in the client application. README - Contains detailed graph description and execution instructions Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-ucx-test2 Sample Commands: Run the server first: Update `addr` parameter in `server-parameters.yaml` to mellanox NIC address on which the server listens. On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-ucx-test2-server.yaml \\ server-parameters.yaml -d ../common/target_x86_64.yaml Run the client next: Update addr` parameters in `client-parameters.yaml` to address on which the server is listening. This may be executed on the same device in another terminal or on another device with a Mellanox NIC connected to the server side Mellanox NIC. On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-ucx-test2-client.yaml \\ client-parameters.yaml -d ../common/target_x86_64.yaml This sample is supported only for x86.", "keywords": []}, {"id": 2694, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id38", "display_name": "Graph", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id38", "priority": -1, "content": "Server Graph Client Graph", "keywords": []}, {"id": 2695, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id4", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id4", "priority": -1, "content": "deepstream-test3.yaml \u2013 The main graph file parameters.yaml \u2013 File containing parameters for the various components in the graph README - Contains detailed graph description and execution instructions ds_test3_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_test3_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test3 Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test3.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test3.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml", "keywords": []}, {"id": 2696, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id7", "display_name": "Graph Files", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id7", "priority": -1, "content": "deepstream-test4.yaml \u2013 The main graph file parameters.yaml \u2013 File containing parameters for the various components in the graph README - Contains detailed graph description and execution instructions ds_test4_container_builder_dgpu.yaml - Configuration file for building application specific container for dGPU platform ds_test4_container_builder_jetson.yaml - Configuration file for building application specific container for Jetson platform Path - /opt/nvidia/deepstream/deepstream/reference_graphs/deepstream-test4 Sample Commands: On x86: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test4.yaml \\ parameters.yaml -d ../common/target_x86_64.yaml On Jetson: $ /opt/nvidia/graph-composer/execute_graph.sh deepstream-test4.yaml \\ parameters.yaml -d ../common/target_aarch64.yaml A small note on what minimum parameter changes are needed to run the graph on any system By default the sample is configured to send messages over Kafka and thus needs a Kafka broker running. The graph files assume that the server is running on \u201clocalhost:9092\u201d. The server to send messages to along with the topic can be changed by modifying msg-broker-conn-str and topic parameters in the parameters.yaml file.", "keywords": []}, {"id": 2697, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#id9", "display_name": "Sample Output", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "id9", "priority": -1, "content": "Following is the snapshot from output video. However, the app also sends messages over Kafka which can be viewed using the console consumer utility in the Kafka package or a similar alternative.", "keywords": []}, {"id": 2698, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "page", "name": "text/DS_Zero_Coding_Sample_Graphs#installing-the-reference-graphs", "display_name": "Installing the reference graphs", "type": "section", "display_type": "Page section", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "installing-the-reference-graphs", "priority": -1, "content": "Download reference graphs: https://catalog.ngc.nvidia.com/orgs/nvidia/resources/gxf_and_gc Install reference graphs: sudo dpkg -i deepstream-reference-graphs-7.1.deb Graphs are installed to: /opt/nvidia/deepstream/deepstream/reference_graphs", "keywords": []}, {"id": 2699, "doc_id": 2699, "filename": "text/DS_Zero_Coding_Sample_Graphs.html", "domain_name": "std", "name": "text/DS_Zero_Coding_Sample_Graphs", "display_name": "Reference graphs", "type": "doc", "display_type": "Page", "docname": "text/DS_Zero_Coding_Sample_Graphs", "anchor": "", "priority": -1, "content": "This section provides details about the sample graphs for the DeepStream extensions. Most of these sample graphs are equivalents of the sample apps released as part of the DeepStreamSDK and demonstrate how to port/convert various portions of the \u201cC/C++\u201d based DeepStream applications into graphs and custom components/extensions.", "keywords": []}, {"id": 2700, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#a-docker-container-for-dgpu", "display_name": "A Docker Container for dGPU", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "a-docker-container-for-dgpu", "priority": -1, "content": "The Containers page in the NGC web portal gives instructions for pulling and running the container, along with a description of its contents. The dGPU container is called deepstream and the Jetson container is called deepstream-l4t . Unlike the container in DeepStream 3.0, the dGPU DeepStream 7.1 container supports DeepStream application development within the container. It contains the same build tools and development libraries as the DeepStream 7.1 SDK. In a typical scenario, you build, execute and debug a DeepStream application within the DeepStream container. Once your application is ready, you can use the DeepStream 7.1 container as a base image to create your own Docker container holding your application files (binaries, libraries, models, configuration file, etc.,). Here is an example snippet of Dockerfile for creating your own Docker container: FROM nvcr.io/nvidia/deepstream:7.1-&lt;container type&gt; COPY myapp /root/apps/myapp # To get video driver libraries at runtime (libnvidia-encode.so/libnvcuvid.so) ENV NVIDIA_DRIVER_CAPABILITIES $NVIDIA_DRIVER_CAPABILITIES,video This Dockerfile copies your application (from directory mydsapp ) into the container ( pathname /root/apps ). Note that you must ensure the DeepStream 7.1 image location from NGC is accurate. Table below lists the docker containers for dGPU released with DeepStream 7.1: Container Container pull commands Triton devel docker (contains the entire SDK along with a development environment for building DeepStream applications and graph composer) docker pull nvcr.io/nvidia/deepstream:7.1-gc-triton-devel Triton Inference Server docker with Triton Inference Server and dependencies installed along with a development environment for building DeepStream applications docker pull nvcr.io/nvidia/deepstream:7.1-triton-multiarch DeepStream samples docker (contains the runtime libraries, GStreamer plugins, reference applications and sample streams, models and configs) docker pull nvcr.io/nvidia/deepstream:7.1-samples-multiarch See the DeepStream 7.1 Release Notes for information regarding nvcr.io authentication and more. See the dGPU container on NGC for more details and instructions to run the dGPU containers.", "keywords": []}, {"id": 2701, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#a-docker-container-for-dgpu-on-arm-igx-dgpu-gh100-gh200-sbsa", "display_name": "A Docker Container for dGPU on ARM (IGX/dGPU, GH100, GH200, SBSA)", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "a-docker-container-for-dgpu-on-arm-igx-dgpu-gh100-gh200-sbsa", "priority": -1, "content": "The Containers page in the NGC web portal gives instructions for pulling and running the container, along with a description of its contents. The dGPU on ARM container is called deepstream:&lt;version&gt;-triton-arm-sbsa and the Jetson container is called deepstream-l4t . Unlike the container in DeepStream 3.0, the dGPU DeepStream 7.1 container supports DeepStream application development within the container. It contains the same build tools and development libraries as the DeepStream 7.1 SDK. In a typical scenario, you build, execute and debug a DeepStream application within the DeepStream container. Once your application is ready, you can use the DeepStream 7.1 container as a base image to create your own Docker container holding your application files (binaries, libraries, models, configuration file, etc.,). Here is an example snippet of Dockerfile for creating your own Docker container: FROM nvcr.io/nvidia/deepstream:7.1-&lt;container type&gt; COPY myapp /root/apps/myapp # To get video driver libraries at runtime (libnvidia-encode.so/libnvcuvid.so) ENV NVIDIA_DRIVER_CAPABILITIES $NVIDIA_DRIVER_CAPABILITIES,video This Dockerfile copies your application (from directory mydsapp ) into the container ( pathname /root/apps ). Note that you must ensure the DeepStream 7.1 image location from NGC is accurate. Table below lists the docker containers for dGPU on ARM released with DeepStream 7.1: Container Container pull commands Triton Inference Server docker with Triton Inference Server and dependencies installed along with a development environment for building DeepStream applications docker pull nvcr.io/nvidia/deepstream:7.1-triton-arm-sbsa See the DeepStream 7.1 Release Notes for information regarding nvcr.io authentication and more. See the dGPU on ARM container on NGC for more details and instructions to run the dGPU on ARM (SBSA) containers.", "keywords": []}, {"id": 2702, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#a-docker-container-for-jetson", "display_name": "A Docker Container for Jetson", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "a-docker-container-for-jetson", "priority": -1, "content": "As of JetPack release 4.2.1, NVIDIA Container Runtime for Jetson has been added, enabling you to run GPU-enabled containers on Jetson devices. Using this capability, DeepStream 7.1 can be run inside containers on Jetson devices using Docker images on NGC. Pull the container and execute it according to the instructions on the NGC Containers page. The DeepStream container no longer expects CUDA, TensorRT to be installed on the Jetson device, because it is included within the container image. Make sure that the BSP is installed using JetPack and nvidia-container tools installed from Jetpack or apt server (See instructions below) on your Jetson prior to launching the DeepStream container. The Jetson Docker containers are for deployment only. They do not support DeepStream software development within a container. You can build applications natively on the Jetson target and create containers for them by adding binaries to your docker images. Alternatively, you can generate Jetson containers from your workstation using instructions in the Building Jetson Containers on an x86 Workstation section in the NVIDIA Container Runtime for Jetson documentation. The table below lists the docker containers for Jetson released with DeepStream 7.1: Container Container pull commands DeepStream samples docker (contains the runtime libraries, GStreamer plugins, reference applications and sample streams, models and configs) docker pull nvcr.io/nvidia/deepstream:7.1-samples-multiarch DeepStream Triton docker (contains contents of the samples docker plus devel libraries and Triton Inference Server backends) docker pull nvcr.io/nvidia/deepstream:7.1-triton-multiarch For the Jetson Triton Container an error message is printed \u201cFailed to detect NVIDIA driver version\u201d when running the docker. No impact on functionality is observed currently. See the DeepStream 7.1 Release Notes for information regarding nvcr.io authentication and more. See the Jetson container on NGC for more details and instructions to run the Jetson containers.", "keywords": []}, {"id": 2703, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#creating-custom-deepstream-dockers-for-dgpu-or-jetson-using-deepstreamsdk-package", "display_name": "Creating custom DeepStream dockers for dGPU or Jetson using DeepStreamSDK package", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "creating-custom-deepstream-dockers-for-dgpu-or-jetson-using-deepstreamsdk-package", "priority": -1, "content": "See the DeepStream Dockerfile Guide on GitHub for more details.", "keywords": []}, {"id": 2704, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#known-limitation-with-video-subsystem-and-workaround", "display_name": "Known Limitation with Video Subsystem and Workaround", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "known-limitation-with-video-subsystem-and-workaround", "priority": -1, "content": "With DS 7.1 arm sbsa docker, video display will not work by default on dGPU on ARM systems. Please see section Known Limitation with Video Subsystem and Workaround for details and workaround.", "keywords": []}, {"id": 2705, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "prerequisites", "priority": -1, "content": "Install docker-ce by following the official instructions . Once you have installed docker-ce , follow the post-installation steps to ensure that the docker can be run without sudo . Install nvidia-container-toolkit by following the install-guide . Get an NGC account and API key: Go to NGC and search the DeepStream in the Container tab. This message is displayed: \u201cSign in to access the PULL feature of this repository\u201d. Enter your Email address and click Next , or click Create an Account . Choose your organization when prompted for Organization/Team . Click Sign In . Log in to the NGC docker registry ( nvcr.io ) using the command docker login nvcr.io and enter the following credentials: a. Username: &quot;$oauthtoken&quot; b. Password: &quot;YOUR_NGC_API_KEY&quot; where YOUR_NGC_API_KEY corresponds to the key you generated from step 3. Sample commands to run a docker container: # Pull the required docker. Refer Docker Containers table to get docker container name. $ docker pull &lt;required docker container name&gt; # Step to run the docker $ export DISPLAY=:0 $ xhost + $ docker run -it --rm --net=host --gpus all -e DISPLAY=$DISPLAY --device /dev/snd -v /tmp/.X11-unix/:/tmp/.X11-unix &lt;required docker container name&gt;", "keywords": []}, {"id": 2706, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#recommended-minimal-l4t-setup-necessary-to-run-the-new-docker-images-on-jetson", "display_name": "Recommended Minimal L4T Setup necessary to run the new docker images on Jetson", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "recommended-minimal-l4t-setup-necessary-to-run-the-new-docker-images-on-jetson", "priority": -1, "content": "Users are encouraged to install the L4T BSP alone from Jetpack and later use command line to install NVIDIA Container runtime from Debian repo to save space on the Jetson device. 1. In Step 02 of sdkmanager Jetpack setup, select \u201cJetson OS\u201d and de-select \u201cJetson SDK Components\u201d to flash just the BSP. Refer to the screenshot below for reference. Instructions for installing nvidia-container from command line: Flash BSP from Jetpack and boot Run &quot;sudo apt update&quot; Run &quot;sudo apt install docker.io&quot; Run &quot;sudo apt install nvidia-container&quot; Run &quot;sudo apt install nvidia-l4t-gstreamer&quot; Run &quot;sudo apt install nvidia-l4t-dla-compiler&quot; Run &quot;sudo service docker restart&quot;", "keywords": []}, {"id": 2707, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "page", "name": "text/DS_docker_containers#suggested-setup-for-video-subsystem-on-x86-dgpu-docker", "display_name": "Suggested Setup for Video Subsystem on x86 dGPU docker", "type": "section", "display_type": "Page section", "docname": "text/DS_docker_containers", "anchor": "suggested-setup-for-video-subsystem-on-x86-dgpu-docker", "priority": -1, "content": "This does not affect dGPUs which utilize Nvidia Driver 560 series on RTX series. DeepStream 7.1 supports Cuda-12.6 in the compute stack and also in the docker container by default. Data Center GPUs are currently only supported by driver 535.183.06, which comes with Cuda-12.2 driver by default. Even though CUDA supports forward compatibility with newer runtime versions like Cuda-12.6, other components such as Cuda-GL Interop do not support forward compatibility and might not work as expected which are required for display sink to work. Hence, for other components such as Cuda-GL Interop to work, Cuda-12.2 toolkit also must be installed along with the default Cuda-12.6 runtime inside the docker container. For users who need to use/enable display output, following steps are suggested inside the docker to implement this workaround: Start the docker as shown in the step above. Install cuda-toolkit-12-2. Please follow these instructions PLEASE NOTE : From the Cuda-12 installation instructions mentioned in link above, please replace : sudo apt-get -y install cuda with sudo apt-get -y install cuda-toolkit-12-2 Change default CUDA version to point to Cuda-12.2 inside the docker using update alternatives: update-alternatives --set cuda /usr/local/cuda-12.2 To check which version of CUDA is currently in use inside the docker, run : update-alternatives --display cuda Similar limitation is also present for dGPU driver 550, which comes with Cuda-12.4 by default and Cuda-12.6 based docker containers which need to use/enable display. For users who need to use/enable display on systems using dGPU driver 550, please enable cuda-toolkit-12-4 in addition to Cuda-12.6 inside the container by following similar steps as above. Replace step no. 2 with cuda-toolkit-12-4 installation instructions found here", "keywords": []}, {"id": 2708, "doc_id": 2708, "filename": "text/DS_docker_containers.html", "domain_name": "std", "name": "text/DS_docker_containers", "display_name": "Docker Containers", "type": "doc", "display_type": "Page", "docname": "text/DS_docker_containers", "anchor": "", "priority": -1, "content": "DeepStream 7.1 provides Docker containers for dGPU on both x86 and ARM platforms (like SBSA, GH100, etc.,) and Jetson platforms. These containers provide a convenient, out-of-the-box way to deploy DeepStream applications by packaging all associated dependencies within the container. The associated Docker images are hosted on the NVIDIA container registry in the NGC web portal at https://ngc.nvidia.com . They use the nvidia-docker package, which enables access to the required GPU resources from containers. This section describes the features supported by the DeepStream Docker container for dGPU on both x86 and ARM and Jetson platforms. The DeepStream 7.1 containers for dGPU on x86 and ARM (SBSA) and Jetson are distinct, so you must get the right image for your platform. With DS 7.1, DeepStream docker containers do not package libraries necessary for certain multimedia operations like audio data parsing, CPU decode, and CPU encode. This change could affect processing certain video streams/files like mp4 that include audio track. Run the below script inside the docker images to install additional packages (e.g. gstreamer1.0-libav , gstreamer1.0-plugins-good , gstreamer1.0-plugins-bad , gstreamer1.0-plugins-ugly as required) that might be necessary to use all of the DeepStreamSDK features: /opt/nvidia/deepstream/deepstream/user_additional_install.sh The script prepare_classification_test_video.sh present at /opt/nvidia/deepstream/deepstream/samples requires ffmpeg to be installed. Some of the low level codec libraries need to be re-installed along with ffmpeg. Use the following command to install/re-install ffmpeg: apt-get install --reinstall libflac8 libmp3lame0 libxvidcore4 ffmpeg", "keywords": []}, {"id": 2709, "doc_id": 2713, "filename": "text/DS_library_nvdsnmos.html", "domain_name": "page", "name": "text/DS_library_nvdsnmos#nvdsnmos-api", "display_name": "NvDsNmos API", "type": "section", "display_type": "Page section", "docname": "text/DS_library_nvdsnmos", "anchor": "nvdsnmos-api", "priority": -1, "content": "Refer to the nvdsnmos.h header file.", "keywords": []}, {"id": 2710, "doc_id": 2713, "filename": "text/DS_library_nvdsnmos.html", "domain_name": "page", "name": "text/DS_library_nvdsnmos#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/DS_library_nvdsnmos", "anchor": "prerequisites", "priority": -1, "content": "The Avahi Apple Bonjour compatibility library must be installed. For example, run: sudo apt-get install libavahi-compat-libdnssd-dev The Avahi mDNS/DNS-SD daemon must also be running. The Avahi browsing, publishing and discovery utilities (avahi-utils) can be used to confirm that DNS Service Discovery (DNS-SD) records for an NMOS Registry are discoverable. For example, run: avahi-browse -r _nmos-register._tcp", "keywords": []}, {"id": 2711, "doc_id": 2713, "filename": "text/DS_library_nvdsnmos.html", "domain_name": "page", "name": "text/DS_library_nvdsnmos#sample-application", "display_name": "Sample Application", "type": "section", "display_type": "Page section", "docname": "text/DS_library_nvdsnmos", "anchor": "sample-application", "priority": -1, "content": "Refer to the DeepStream Reference Application - deepstream-nmos app , which demonstrates how to use the NvDsNmos library.", "keywords": []}, {"id": 2712, "doc_id": 2713, "filename": "text/DS_library_nvdsnmos.html", "domain_name": "page", "name": "text/DS_library_nvdsnmos#supported-specifications", "display_name": "Supported Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_library_nvdsnmos", "anchor": "supported-specifications", "priority": -1, "content": "The NvDsNmos library supports the following specifications, using the Sony nmos-cpp implementation: AMWA IS-04 NMOS Discovery and Registration Specification v1.3 AMWA IS-05 NMOS Device Connection Management Specification v1.1 AMWA IS-09 NMOS System Parameters Specification v1.0 AMWA BCP-002-01 Natural Grouping of NMOS Resources v1.0 AMWA BCP-002-02 NMOS Asset Distinguishing Information v1.0 AMWA BCP-004-01 NMOS Receiver Capabilities v1.0 Session Description Protocol conforming to SMPTE ST 2110-20 and -30", "keywords": []}, {"id": 2713, "doc_id": 2713, "filename": "text/DS_library_nvdsnmos.html", "domain_name": "std", "name": "text/DS_library_nvdsnmos", "display_name": "Networked Media Open Specifications (NMOS) in DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_library_nvdsnmos", "anchor": "", "priority": -1, "content": "The NvDsNmos utility library provides the APIs to create, destroy and internally manage an NMOS Node for a DeepStream application. The library can automatically discover and register with an NMOS Registry on the network using the AMWA IS-04 Registration API. The library provides callbacks for NMOS events such as AMWA IS-05 Connection API requests from an NMOS Controller. These callbacks can be used to update running DeepStream pipelines with new transport parameters, for example. NvDsNmos currently supports Senders and Receivers for uncompressed Video and Audio, i.e., SMPTE ST 2110-20 and SMPTE ST 2110-30 streams.", "keywords": []}, {"id": 2714, "doc_id": 2718, "filename": "text/DS_on_WSL2.html", "domain_name": "page", "name": "text/DS_on_WSL2#install-docker-engine-and-dependencies-inside-ubuntu", "display_name": "Install Docker Engine And Dependencies Inside Ubuntu:", "type": "section", "display_type": "Page section", "docname": "text/DS_on_WSL2", "anchor": "install-docker-engine-and-dependencies-inside-ubuntu", "priority": -1, "content": "Start Ubuntu Inside WSL: Open windows terminal with admin privilege (Right click and run as administrator). Start Ubuntu using WSL. (This step is required only if you are not already logged into Ubuntu) $ wsl -d Ubuntu-22.04 Verify Driver Installation from within WSL environment: $ nvidia-smi NOTE: If \u2018nvidia-smi\u2019 is not working as expected, then there is some issue with the driver installation in windows and we can\u2019t go further without fixing this. Install Docker Engine and Dependencies: $ sudo apt-get update $ sudo apt-get install -y apt-transport-https ca-certificates curl gnupg-agent software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo apt-key fingerprint 0EBFCD88 $ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; $ sudo apt-get update $ sudo apt-get install -y docker-ce docker-ce-cli containerd.io --fix-missing Verify docker installation: This should print a \u201cHello from Docker!\u201d $ sudo docker run hello-world NOTE: If you are not able to run the above command because of docker service not running, start the docker service before that. $ sudo dockerd &amp; Enabling the Docker Repository and Installing the NVIDIA Container Toolkit: $ distribution=$(. /etc/os-release;echo $ID$VERSION_ID) $ curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg $ curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list $ sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit $ sudo systemctl restart docker", "keywords": []}, {"id": 2715, "doc_id": 2718, "filename": "text/DS_on_WSL2.html", "domain_name": "page", "name": "text/DS_on_WSL2#install-ubuntu-os-for-wsl", "display_name": "Install Ubuntu OS for WSL :", "type": "section", "display_type": "Page section", "docname": "text/DS_on_WSL2", "anchor": "install-ubuntu-os-for-wsl", "priority": -1, "content": "Open terminal and install Ubuntu 22: Open windows terminal with admin privilege. (Right click and run as administrator) Check what all OS images are available for wsl to install. $ wsl --list --online Install Ubuntu version required for Deepstream 7.1. $ wsl --install Ubuntu-22.04 The above step may first install dependencies for running WSL, prior to install Ubuntu and can ask for restart of Windows machine. In that case, restart the machine, open windows terminal with admin privilege and check if Ubuntu is installed properly using below command. $ wsl --list If you can\u2019t find an installed Ubuntu version, again install it using \u2018wsl \u2013install Ubuntu-22.04\u2019 command. Set the username and password for Ubuntu when prompted.", "keywords": []}, {"id": 2716, "doc_id": 2718, "filename": "text/DS_on_WSL2.html", "domain_name": "page", "name": "text/DS_on_WSL2#pre-requisites", "display_name": "Pre-Requisites:", "type": "section", "display_type": "Page section", "docname": "text/DS_on_WSL2", "anchor": "pre-requisites", "priority": -1, "content": "1. Windows 11 system with NVIDIA GPU: NOTE: Tesla/Datacenter GPUs are not supported for WSL. Only GeForce and Quadro GPUs in WDDM mode are supported. Please check the link for more info: https://docs.nvidia.com/cuda/wsl-user-guide/index.html#wsl-2-support-constraints 2. NVIDIA driver (windows version) compatible for your GPU: You can download the compatible driver based on your windows OS and GPU type from here: https://www.nvidia.com/Download/index.aspx Currently validated Driver Version and GPU info: GameReady Driver version 546.65 with RTX-3080, RTX-3090 and RTX-A6000 NOTE: This is the only driver you need to install on Windows. Do not install any Linux display driver inside WSL. 3. WSL (Windows Store Version): Download and install the latest stable version of WSL2 from microsoft/WSL . NOTE: In some build versions of Windows, \u2018wsl \u2013install\u2019 command will install the WSL which comes as a part of windows image, which has limited functionality. DO NOT install that.", "keywords": []}, {"id": 2717, "doc_id": 2718, "filename": "text/DS_on_WSL2.html", "domain_name": "page", "name": "text/DS_on_WSL2#run-deepstream-container", "display_name": "Run Deepstream Container:", "type": "section", "display_type": "Page section", "docname": "text/DS_on_WSL2", "anchor": "run-deepstream-container", "priority": -1, "content": "Pull the required deepstream docker container: $ sudo docker pull nvcr.io/nvidia/deepstream:7.1-triton-multiarch Start the docker container: $ sudo apt install x11-xserver-utils $ xhost + $ sudo docker run -it --privileged --rm --name=docker --net=host --gpus all -e DISPLAY=$DISPLAY -e CUDA_CACHE_DISABLE=0 --device /dev/snd -v /tmp/.X11-unix/:/tmp/.X11-unix nvcr.io/nvidia/deepstream:7.1-triton-multiarch Verify deepstream functionality: $ deepstream-app --version Expected Output: It should print the deepstream version currently installed on docker. $ cd /opt/nvidia/deepstream/deepstream/samples/streams $ gst-launch-1.0 filesrc location= sample_720p.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! nveglglessink -v Expected Output: Playback of the sample_720p.mp4 should happen fine. Sample screenshot attached below: NOTE: The display window size may differ in different systems based on the screen resolution supported. You can drag and adjust the display window to fit your screen. $ cd /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app $ deepstream-app -c source30_1080p_dec_infer-resnet_tiled_display_int8.txt Expected Output: deepstream-app should run fine. Sample screenshot attached below: The display window size may differ in different systems based on the screen resolution supported. You can drag and adjust the display window to fit your screen.", "keywords": []}, {"id": 2718, "doc_id": 2718, "filename": "text/DS_on_WSL2.html", "domain_name": "std", "name": "text/DS_on_WSL2", "display_name": "DeepStream On WSL", "type": "doc", "display_type": "Page", "docname": "text/DS_on_WSL2", "anchor": "", "priority": -1, "content": "Windows Subsystem for Linux (WSL) is a feature of Windows that allows you to run a Linux environment on your Windows machine, without the need for a separate virtual machine or dual booting. WSL 2 is the latest version of it. This page describes the steps to run a Deepstream docker container inside WSL2.", "keywords": []}, {"id": 2719, "doc_id": 2720, "filename": "text/DS_on_the_fly_model.html", "domain_name": "page", "name": "text/DS_on_the_fly_model#assumptions", "display_name": "Assumptions", "type": "section", "display_type": "Page section", "docname": "text/DS_on_the_fly_model", "anchor": "assumptions", "priority": -1, "content": "The future releases aim to address these listed assumption for on the fly model update: New model must have same network parameter configuration as of previous model (e.g. network resolution, network architecture, number of classes). Engine file or cache file of new model to be provided by developer. Other primary gie configuration parameters like group-threshold , bbox color , gpu-id , nvbuf-memory-type etc., will not have any effect after model switch even if updated parameters are provided in the override file.", "keywords": []}, {"id": 2720, "doc_id": 2720, "filename": "text/DS_on_the_fly_model.html", "domain_name": "std", "name": "text/DS_on_the_fly_model", "display_name": "On the Fly Model Update", "type": "doc", "display_type": "Page", "docname": "text/DS_on_the_fly_model", "anchor": "", "priority": -1, "content": "The current DeepStream release supports changing Model on the Fly. This feature assumes that the model being updated has the same network parameters. This is an alpha feature and only supported in deepstream-test5-app . Currently, on the fly model update helps to deploy more accurate, newly trained models without the necessity to stop and re-launch the DeepStream application or container. That means, models can be updated with zero DeepStream application downtime. The image below shows how on the fly models works currently: Refer to \u201csection 7\u201d in the deepstream-test5-app/README for instructions on how to test model update feature.", "keywords": []}, {"id": 2721, "doc_id": 2721, "filename": "text/DS_plugin_Intro.html", "domain_name": "std", "name": "text/DS_plugin_Intro", "display_name": "GStreamer Plugin Overview", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_Intro", "anchor": "", "priority": -1, "content": "DeepStream SDK is based on the GStreamer framework. This section describes the DeepStream GStreamer plugins and the DeepStream input, outputs, and control parameters. DeepStream SDK is supported on systems that contain an NVIDIA \u00ae Jetson\u2122 module or an NVIDIA dGPU adapter 1 . The manual is intended for engineers who want to develop DeepStream applications or additional plugins using the DeepStream SDK. It also contains information about metadata used in the SDK. Developers can add custom metadata as well. The manual describes the methods defined in the SDK for implementing custom inferencing layers using the IPlugin interface of NVIDIA \u00ae TensorRT\u2122. You can refer the sample examples shipped with the SDK as you use this manual to familiarize yourself with DeepStream application and plugin development. MetaData in the DeepStream SDK NvDsBatchMeta: Basic Metadata Structure User/Custom Metadata Addition inside NvDsBatchMeta Adding Custom Meta in Gst Plugins Upstream from Gst-nvstreammux Adding metadata to the plugin before Gst-nvstreammux New metadata fields Gst-nvdspreprocess (Alpha) Inputs and Outputs Features Custom library Interfaces Gst-nvdspreprocess File Configuration Specifications Gst Properties Sample pipelines Gst-nvinfer Inputs and Outputs Features Gst-nvinfer File Configuration Specifications Gst Properties Clustering algorithms supported by nvinfer cluster-mode = 0 | GroupRectangles cluster-mode = 1 | DBSCAN cluster-mode = 2 | NMS cluster-mode = 3 | Hybrid cluster-mode=4 | No clustering Tensor Metadata To read or parse inference raw tensor data of output layers Segmentation Metadata Gst-nvinferserver Inputs and Outputs Gst-nvinferserver Configuration File Specifications Features Low Level libnvds_infer_server.so Configuration File Specifications Gst Properties DeepStream Triton samples DeepStream Triton gRPC support Triton Ensemble Models Custom Process interface IInferCustomProcessor for Extra Input, LSTM Loop, Output Tensor Postprocess Tensor Metadata Output for Downstream Plugins To read or parse inference raw tensor data of output layers Segmentation Metadata Gst-nvtracker Sub-batching (Alpha) Inputs and Outputs Gst Properties NvDsTracker API for Low-Level Tracker Library NvMultiObjectTracker : A Reference Low-Level Tracker Library Unified Tracker Architecture for Composable Multi-Object Tracker Workflow and Core Modules in The NvMultiObjectTracker Library Data Association Target Management and Error Handling State Estimation Object Re-Identification Target Re-Association Bounding-box Unclipping Single-View 3D Tracking (Alpha) Configuration Parameters Low-Level Tracker Comparisons and Tradeoffs IOU Tracker NvSORT Tracker NvDeepSORT Tracker Data Association Configuration Parameters Implementation Details and Reference NvDCF Tracker Visual Tracking Data Association Configuration Parameters Miscellaneous Data Output Terminated Track List Shadow Tracking Target Data Past-frame Target Data Setup and Usage of Re-ID Model Setup Sample Re-ID Models Customize Re-ID Model Re-ID Feature Output Setup and Usage of Sub-batching (Alpha) Use-case 1 Use-case 2 Setup and Visualization of Tracker Sample Pipelines People Tracking Vehicle Tracking Tracker Accuracy Tuning How to Implement a Custom Low-Level Tracker Library Gst-nvstreammux Inputs and Outputs Features Gst Properties Known Issues with Solutions and FAQ 1. gst-inspect is not updated properly when switching between legacy and new streammux Gst-nvstreammux New Inputs and Outputs Features Gst Properties Mux Config Properties NvStreamMux Tuning Solutions for specific use cases Aim Important Tuning parameters Video and Audio muxing Use cases Troubleshooting Metadata propagation through nvstreammux and nvstreamdemux Cascaded Muxing Known Issues with Solutions and FAQ Observing video and/or audio stutter (low framerate) Sink plugin shall not move asynchronously to PAUSED Heterogeneous batching Adaptive Batching Optimizing nvstreammux config for low-latency vs Compute Latency Measurement API Usage guide for audio gst-inspect is not updated properly when switching between legacy and new streammux Gst-nvstreamdemux Inputs and Outputs Use case 1 Use case 2 Use case 3 Gst-nvmultistreamtiler Inputs and Outputs Features Gst Properties Gst-nvdsosd Inputs and Outputs Features Gst Properties Gst-nvdsmetautils Gst-nvdsmetainsert Inputs and Outputs Features customlib_impl Interfaces Gst Properties Use Cases &amp; Sample Pipelines Gst-nvdsmetaextract Inputs and Outputs Features customlib_impl Interfaces Gst Properties Use Cases &amp; Sample Pipelines Gst-nvdsvideotemplate Inputs and Outputs Features customlib_impl Interfaces Gst Properties Sample pipelines Gst-nvdsaudiotemplate Inputs and Outputs Features customlib_impl Interfaces Gst Properties Sample pipelines Gst-nvvideoconvert Inputs and Outputs Features Gst Properties Gst-nvdewarper Inputs and Outputs Features Configuration File Parameters Gst Properties Gst-nvof Inputs and Outputs Features Gst Properties Gst-nvofvisual Inputs and Outputs Features Gst Properties Gst-nvsegvisual Inputs and Outputs Features Gst Properties Gst-nvvideo4linux2 Decoder Inputs and Outputs Features Gst Properties Encoder Inputs and Outputs Features Gst Properties Gst-nvjpegdec Inputs and Outputs Features Gst Properties Gst-nvimagedec Inputs and Outputs Features Gst Properties Gst-nvjpegenc Inputs and Outputs Features Gst Properties Gst-nvimageenc Inputs and Outputs Features Gst Properties Gst-nvmsgconv Inputs and Outputs Features Gst Properties NvMsgConv low level library API\u2019s Schema Customization Payload with Custom Objects Gst-nvmsgbroker Inputs and Outputs Features Gst Properties nvds_msgapi: Protocol Adapter Interface nvds_msgapi_connect(): Create a Connection nvds_msgapi_send() and nvds_msgapi_send_async(): Send an event nvds_msgapi_subscribe(): Consume data by subscribing to topics nvds_msgapi_do_work(): Incremental Execution of Adapter Logic nvds_msgapi_disconnect(): Terminate a Connection nvds_msgapi_getversion(): Get Version Number nvds_msgapi_get_protocol_name(): Get name of the protocol nvds_msgapi_connection_signature(): Get Connection signature nvds_kafka_proto: Kafka Protocol Adapter Installing Dependencies Using the Adapter Configuring Protocol Settings Programmatic Integration Security for Kafka Azure MQTT Protocol Adapter Libraries Installing Dependencies Setting Up Azure IoT Configuring Adapter Settings Using the Adapter Monitor Adapter Execution Message Topics and Routes AMQP Protocol Adapter Installing Dependencies AMQP broker Configure Adapter Settings Using the Adapter User authentication Programmatic Integration Monitor Adapter Execution REDIS Protocol Adapter Installing Dependencies REDIS server Configure Adapter Settings User Authentication Using the Adapter Programmatic Integration Monitor Adapter Execution MQTT Protocol Adapter Installing Dependencies Eclipse Mosquitto Configure Adapter Settings Using the Adapter Programmatic Integration Monitor Adapter Execution nv_msgbroker: Message Broker interface nv_msgbroker_connect(): Create a Connection nv_msgbroker_send_async(): Send an event asynchronously nv_msgbroker_subscribe(): Consume data by subscribing to topics nv_msgbroker_disconnect(): Terminate a Connection nv_msgbroker_version(): Get Version Number Autoreconnect feature Work-interval configuration nvds_logger: Logging Framework Gst-nvdsanalytics Inputs and Outputs Features Gst Properties Configuration File Parameters Gst-nvdsudpsrc Inputs and Outputs Features Gst Properties Example pipelines Gst-nvdsudpsink Inputs and Outputs Features Gst Properties Example pipelines Gst-nvdspostprocess (Alpha) Inputs and Outputs Features Gst-nvdspostprocess File Configuration Specifications Gst Properties Sample pipelines Gst-nvds3dfilter Custom library Interfaces Inputs and Outputs Configuration file Gst-nvds3dfilter properties Specifications Supported DS3D filter custom libs Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so Inputs and Outputs Configuration file Configuration options Custom ds3d::datafilter library: libnvds_3d_depth2point_datafilter.so Gst-nvds3dbridge Gst-nvds3dbridge properties Specifications Custom library Interfaces Supported DS3D Data bridges Custom low level library: libnvds_3d_video_databridge.so Inputs and Outputs Configuration file Video bridge configuration options Gst-nvds3dmixer Gst-nvds3dmixer properties Specifications Custom library Interfaces Supported DS3D Data mixers Custom low level library: libnvds_3d_multisensor_mixer.so Inputs and Outputs Configuration file Video mixer configuration options Gst-NvDsUcx Description Requirements Inputs and Outputs Gst Properties Examples Gst-nvdsxfer Inputs and Outputs Gst Properties How to test Use cases Single Stream + Multi-dGPUs Setup Multiple Streams + Multi-dGPU Setup Gst-nvvideotestsrc Outputs Gst Properties How to test Gst-nvmultiurisrcbin 1. Introduction 2. Features 3. How to use nvmultiurisrcbin in a pipeline REST API payload definitions and sample curl commands for reference 4. Gst Properties Gst Properties directly configuring nvmultiurisrcbin Gst Properties to configure each instance of nvurisrcbin created inside this bin Gst Properties to configure the instance of nvstreammux created inside this bin 5. Important Notes nvmultiurisrcbin config recommendations and notes on expected behavior 6. Limitations Gst-nvurisrcbin 1. Introduction 2. How to use nvurisrcbin in a pipeline 3. Gst Properties 3.1 Gst Properties to configure nvurisrcbin Footnotes 1 This manual uses the term dGPU (\u201cdiscrete GPU\u201d) to refer to NVIDIA GPU expansion card products such as NVIDIA\u00ae Tesla\u00ae T4, NVIDIA\u00ae Ampere and NVIDIA\u00ae GeForce\u00ae RTX 2080. This version of DeepStream SDK runs on specific dGPU products on x86_64 platforms supported by NVIDIA driver 535+ and NVIDIA\u00ae TensorRT\u2122 10.3.0.26 and later versions.", "keywords": []}, {"id": 2722, "doc_id": 2726, "filename": "text/DS_plugin_gst-nvdewarper.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdewarper#configuration-file-parameters", "display_name": "Configuration File Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdewarper", "anchor": "configuration-file-parameters", "priority": -1, "content": "The configuration file located at configs/deepstream-app/config_dewarper.txt . The configuration file specifies per-surface configuration parameters in [surface&lt;n&gt;] groups, where &lt;n&gt; is an integer from 0 to 3 , representing dewarped surfaces 0 to 3 . Property Property Type Meaning Type and Range Example Notes output-width Global Scale dewarped surfaces to specified output width Integer, &gt;0 output-width=960 output-height Global Scale dewarped surfaces to specified output height Integer, &gt;0 output-height=752 dewarp-dump-frames Global Number of dewarped frames to dump. Integer, &gt;0 dewarp-dump-frames=10 num-batch-buffers Global Number of dewarped output surfaces per buffer, i.e batch-size of the buffer. Integer, 0 to 4 num-batch-buffers=4 projection-type Surface Selects projection type. Supported types are: 1: Fisheye to PushBroom 2: Fisheye to Vertical Radial Cylindrical 3: Perspective to Perspective 4: Fisheye to Perspective 5: Fisheye to Fisheye 6: Fisheye to Cylindrical 7: Fisheye to Equirectangular 8: Fisheye to Panini 9: Perspective to Equirectangular 10: Perspective to Panini 11: Equirectangular to Cylindrical 12: Equirectangular to Equirectangular 13: Equirectangular to Fisheye 14: Equirectangular to Panini 15: Equirectangular to Perspective 16: Equirectangular to PushBroom 17: Equirectangular to Stereographic 18: Equirectangular to Vertical Radial Cylindrical Integer, 1 to 18 projection-type=1 surface-index Surface An index that distinguishes surfaces of the same projection type. Integer, \u22650 surface-index=0 width Surface Dewarped surface width. Integer, &gt;0 width=3886 height Surface Dewarped surface height. Integer, &gt;0 height=666 top-angle Surface Top field of view angle, in degrees. Float, \u2212180.0 to 180.0 top-angle=0 bottom-angle Surface Bottom field of view angle, in degrees. Float, \u2212180.0 to 180.0 bottom-angle=0 pitch Surface Viewing parameter pitch in degrees. Float, 0.0 to 360.0 pitch=90 yaw Surface Viewing parameter yaw in degrees. Float, 0.0 to 360.0 yaw=0 roll Surface Viewing parameter roll in degrees. Float, 0.0 to 360.0 roll=0 focal-length Surface Focal length of camera lens, in pixels per radian. Can be specified as : fxy : single float value &lt;fx, fy&gt; : array of two float values corresponding to focal lengths in x and y direction respectively Floats, &gt;0.0 focal-length=437 OR focal-length=442.63;395.106339 src-fov Surface Source vertical field of view in degrees. Used to compute the source focal-length if the latter is not provided. Float, &gt;0.0 src-fov=180 distortion Surface Distortion coefficients in the distortion polynomial for a fisheye/perspective source. For perspective source : Three radial coefficients: (k_0,k_1,k_2): r^&#x27;=r(1+k_0 r^2+k_1 r^4+k_2 r^6 ) Two tangential coefficients: (k_3,k_4):x&#x27;=x+[1+2k_3 xy+k_4 (r^2 + 2x^2)] y^&#x27;=y+[ k_3 (r^2+2y^2+2k_4 xy)] For fisheye source : Four radial coefficients (k_0,k_1,k_2, k_3): r^&#x27;=r(1+k_0 r^2+k_1 r^4+k_2 r^6+k_3 r^8 ) Array of 4/5 floats distortion= -0.3721;0.1023;-0.00203;0;0 distortion=k_0,;k_1,;k_2;k_3;k_4 If not provided, all coefficients are set to 0 (no distortion) src-x0 Surface The X coordinate of the center of projection of the source image, in pixel coordinates. Typically, it is (srcWidth-1)/2, but may be different if the image is calibrated or wraps around. Float, \u22650 src-x0=479.5 If not provided, will take its default value = (srcWidth-1)/2 src-y0 Surface The Y coordinate of the center of projection of the source image, in pixel coordinates. Typically, it is (srcHeight-1)/2, but may be different if the image is calibrated or wraps around. Float, \u22650 src-y0=375.5 If not provided, will take its default value = (srcHeight-1)/2 cuda-address-mode Surface Cuda Texture addressing mode. Currently supports: 0: cudaAddressModeClamp (Default) - sets points outside of border to nearest pixel value 1: cudaAddressModeBorder - sets points outside of border to transparent black Integer, 0 or 1 cuda-address-mode= \u00ad1 aisle-calibration-file Global Pathname of the configuration file for aisle view. Set for the 360 D application only for PushBroom and/or VertRadCyl projection types. If set, properties in the [surface&lt;n&gt;] group are ignored. The configuration file is a CSV file with columns like sensorId and cameraId, and dewarping parameters like top-angle, bottom-angle, yaw, roll, pitch, focal-length, width, and height. String aisle-calibration-file= \u00adcsv_files/\u00adnvaisle_2M.csv spot-calibration-file Global Pathname of the configuration file for spot view. Set for the 360 D application only for PushBroom and/or VertRadCyl projection types. If set, properties in the [surface&lt;n&gt;] group are ignored. The configuration file is a CSV file with columns like sensorId and cameraId, and dewarping parameters like top-angle, bottom-angle, yaw, roll, pitch, focal-length, width, and height. String spot-calibration-file= \u00adcsv_files/-nvspot_2M.csv For an example of a spot view configuration file, see the file in the example above. rot-axes Surface A three-character string that specifies the sequence of application of rotation angles. Possible values are : XYZ, XZY, YXZ, YZX, ZXY, ZYX where : X corresponds to pitch, Y corresponds to yaw and Z corresponds to roll. Default sequence of rotation is YXZ String of three characters \u201crot-axes=ZXY\u201d control Surface A control parameter to vary the amount of warp. Applicable for Panini, Stereographic and Pushbroom projections. Float control=1.0. control=0 is identical to perspective output. rot-matrix Surface Configures the rotation as a 3X3 rotation matrix. The matrix is specified in a right-handed screen space, with X to the right, Y downwards and Z outwards. If specified, this setting will override yaw, pitch, roll settings. Array of 9 floats rot-matrix=0.5;-0.86;0;0.86;0.5;0;0;0.0;1.0 dst-focal-length Surface Sets destination image focal length. Can be specified as : fxy : single float value &lt;fx, fy&gt; : array of two float values If specified, this setting will override top-angle, bottom-angle settings. Floats, &gt;0.0 dst-focal-length=350;316 dst-principal-point Surface Set the X coordinate and Y coordinate in pixels of the principal point in destination image If specified, this setting will override top-angle, bottom-angle settings. Float, &gt;0.0 dst-principal-point=521.02;257.37 In case viewing angles (top &amp; bottom)/dst-focal-length/dst-principal-point are not provided, the destination center of projection (Principal Point) and Focal Length are kept the same as the source. To increase the flexibility, num-batch-buffers is also a GstProperty . The plugin properties are parsed in order, so if num-batch-buffers is passed both attached to the GstElement in the gstreamer pipeline (eg. with gst-launch-1.0 command), and in the configuration file, the latest configuration applied will be used (see example below). Example: Config file ( config_dewarper.txt ) with num-batch-buffers=2 . Command Line argument with property num-batch-buffers=1 . Pipelines: gst-launch-1.0 \u2026 ! nvdewarper config-file=config_dewarper.txt num-batch-buffers=1 ! \u2026 gst-launch-1.0 \u2026 ! nvdewarper num-batch-buffers=1 config-file=config_dewarper.txt ! \u2026 Pipeline 1 will result in 1 surface per buffer whereas pipeline 2 will result in 2 surfaces per buffer. This plugin can be tested with the one of the following pipelines. For dGPU: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_cam6.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper.txt source-id=6 ! m.sink_0 nvstreammux name=m width=960 height=752 \\ batch-size=4 num-surfaces-per-frame=4 ! nvmultistreamtiler ! nveglglessink Perspective Projection use-case: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/yoga.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper_perspective.txt ! m.sink_0 nvstreammux name=m width=3680 height=2428 \\ batch-size=1 num-surfaces-per-frame=1 ! nvmultistreamtiler ! nveglglessink For Jetson: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_cam6.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper.txt source-id=6 ! m.sink_0 nvstreammux name=m width=960 height=752 batch-size=4 \\ num-surfaces-per-frame=4 ! nvmultistreamtiler ! nv3dsink Perspective Projection use-case: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/yoga.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper_perspective.txt ! m.sink_0 nvstreammux name=m width=3680 height=2428 \\ batch-size=1 num-surfaces-per-frame=1 ! nvmultistreamtiler ! nv3dsink Image File example dGPU: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/yoga.jpg ! nvjpegdec ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper_perspective.txt ! nvvideoconvert ! jpegenc ! filesink location=output.jpg Image File example Jetson: gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/yoga.jpg ! nvjpegdec ! nvvideoconvert ! nvdewarper config-file=/opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-dewarper-test/config_dewarper_perspective.txt ! nvvideoconvert ! jpegenc ! filesink location=output.jpg To better see the effect of cuda-address-mode you can change the dewarping size. For example, in config_dewarper_perspective.txt change [surface0] parameters to: width=7360 height=4856 cuda-address-mode=1 The Gst-nvdewarper plugin always outputs a GStreamer buffer which contains the number of dewarped surfaces defined by num-batch-buffers (currently maximum of four surfaces are supported). These dewarped surfaces are scaled to the output resolution ( output-width \u00d7 output-height ) set in the configuration file. Also, the num-surfaces-per-frame and batch-size of Gst-nvstreammux must be set accordingly. Batch-size must be a multiple of the number of dewarped surfaces, which should be set in num-surfaces-per-frame .", "keywords": []}, {"id": 2723, "doc_id": 2726, "filename": "text/DS_plugin_gst-nvdewarper.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdewarper#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdewarper", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Configure number of dewarped surfaces Supports a maximum of four dewarper surfaces. DS 3.0 Configure per-surface projection type Currently supports FishPushBroom and FishVertRadCyd projections. DS 3.0 Configure per-surface projection type PerspectivePerspective projections DS 5.0 Configure per-surface projection type 18 projections DS 6.2 Configure per-surface index Surface index to be set in case of multiple surfaces having same projection type. DS 3.0 Configure per-surface width and height DS 3.0 Configure per-surface dewarping parameters Per surface configurable yaw, roll, pitch, top angle, bottom angle, and focal length and CUDA address mode dewarping parameters. For PerspectivePerspective projection type, field of view, distortion and principal point can additionally be configured. DS 3.0 Configurable dewarper output resolution Creates a batch of up to four surfaces of a specified output resolution; internally scales all dewarper surfaces to output resolution. DS 3.0 Configurable NVDS CUDA memory type \u2014 DS 3.0 Multi-GPU support \u2014 DS 3.0 Aisle view CSV calibration file support If set, properties in the [surface&lt;n&gt;] group are ignored. Only supported for FishPushBroom and FishVertRadCyd. DS 3.0 Spot view CSV calibration file support If set, properties in the [surface&lt;n&gt;] group are ignored. Only supported for FishPushBroom and FishVertRadCyd. DS 3.0 Configure source id Sets the source ID information in the NvDewarperSurfaceMeta. DS 4.0 Configurable number of output buffers Number of allocated output dewarper buffers. Each buffer contains four dewarped output surfaces. DS 4.0 Configurable number of surfaces per output buffer Number of dewarped output surfaces per buffer. Maximum allowed value is 4. DS 5.0 Support for advanced configuration parameters Fisheye distortion coefficients, destination focal length, destination principal point, rotation axes sequence, rotation matrix DS 6.2", "keywords": []}, {"id": 2724, "doc_id": 2726, "filename": "text/DS_plugin_gst-nvdewarper.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdewarper#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdewarper", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvdewarper plugin\u2019s Gst properties. Property Meaning Type and Range Example and Notes config-file Absolute pathname of configuration file for the Gst-nvdewarper element String config-file= configs/ deepstream-app/ config_dewarper.txt gpu-id Device ID of the GPU to be used (dGPU only) Integer, 0 to 4,294,967,295 source-id=6 source-id Source ID, e.g. camera ID Integer, 0 to 4,294,967,295 num-output-buffers=4 num-batch-buffers Number of dewarped output surfaces per buffer, i.e., batch-size of the buffer Integer, 0 to 4 num-batch-buffers=4 nvbuf-memory-type Type of memory to be allocated. For dGPU: 0 (nvbuf-mem-default): Default memory, cuda-device 1 (nvbuf-mem-cuda-pinned): Pinned/Host CUDA memory 2 (nvbuf-mem-cuda-device) Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For Jetson: 0 (nvbuf-mem-default): Default memory, surface array 4 (nvbuf-mem-surface-array): Surface array memory Integer, 0 to 4 nvbuf-memory-type=3", "keywords": []}, {"id": 2725, "doc_id": 2726, "filename": "text/DS_plugin_gst-nvdewarper.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdewarper#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdewarper", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs A buffer containing a frame in RGBA format Control parameters gpu-id; selects the GPU ID (dGPU only) config-file, containing the pathname of the dewarper configuration file Output Dewarped RGBA surfaces NvDewarperSurfaceMeta with information associated with each surface ( projection_type , surface_index , and source_id ), and the number of valid dewarped surfaces in the buffer ( num_filled_surfaces )", "keywords": []}, {"id": 2726, "doc_id": 2726, "filename": "text/DS_plugin_gst-nvdewarper.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdewarper", "display_name": "Gst-nvdewarper", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdewarper", "anchor": "", "priority": -1, "content": "This plugin dewarps camera input. It accepts gpu-id and config-file as properties. Based on the selected configuration of surfaces, it can generate a maximum of four dewarped surfaces. It currently supports 18 dewarping projection types. Out of these, NVDS_META_SURFACE_FISH_PUSHBROOM and NVDS_META_SURFACE_FISH_VERTCYL are used in 360-D use case for dewarping 360\u00b0 camera input. The plugin performs its function in these steps: Reads the configuration file and creates a vector of surface configurations. It supports a maximum of four dewarp surface configurations. Receives the frame from the decoder. Based on the configuration, generates up to four dewarped surfaces. Scales these surfaces down to network/selected dewarper output resolution using NPP APIs. Pushes a buffer containing the dewarped surfaces to the downstream component.", "keywords": []}, {"id": 2727, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#configuration-file", "display_name": "Configuration file", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "configuration-file", "priority": -1, "content": "Example: name: videobridge_2d_to_3d type: ds3d::databridge in_caps: video/x-raw(memory:NVMM) out_caps: ds3d/datamap custom_lib_path: libnvds_3d_video_databridge.so custom_create_function: createVideoBridge2d3d config_body: surface_to_image: True # wrap nvbufsurface into color frame of ds3d::Frame2DGuard output_image_key: DS3D::ColorFrame # convert NvDsObjectMeta into array of ds3d::Object2DBbox with ds3d::FrameGuard output_object2d_key: DS3D::Object2DBboxKey", "keywords": []}, {"id": 2728, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#custom-library-interfaces", "display_name": "Custom library Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "custom-library-interfaces", "priority": -1, "content": "The plugin parse the config file or content and set SinkCaps and SrcCaps. load a custom ds3d::databridge from custom_lib_path . Create this databridge by custom_create_function .", "keywords": []}, {"id": 2729, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#gst-nvds3dbridge-properties-specifications", "display_name": "Gst-nvds3dbridge properties Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "gst-nvds3dbridge-properties-specifications", "priority": -1, "content": "Properties Description Release config-content yaml config content DS 7.0 config-file yaml config file path DS 7.0", "keywords": []}, {"id": 2730, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs video/x-raw(memory:NVMM) data format: NvBufSurface with/without GStreamer metadata (including NvDsBatchMeta) Control parameters config-file config-content Output ds3d/datamap sink_caps parsed from config-file: in_caps: video/x-raw(memory:NVMM) . src_caps parsed from config-file: out_caps:  ds3d/datamap .", "keywords": []}, {"id": 2731, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#supported-ds3d-data-bridges", "display_name": "Supported DS3D Data bridges", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "supported-ds3d-data-bridges", "priority": -1, "content": "SL Data bridge Data bridge custom library 1 Video data bridge; wraps NVMM video memory to ds3d/datamap libnvds_3d_video_databridge.so", "keywords": []}, {"id": 2732, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dbridge#video-bridge-configuration-options", "display_name": "Video bridge configuration options", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "video-bridge-configuration-options", "priority": -1, "content": "config-key Description Example value surface_to_image If True, Output_image_key will be used to add following entries to datamap. output_image_key: ds3d::Frame2DGuard (with frame_0 in NvBufSurface-&gt;surfaceList[0]) output_image_key_%d: ds3d::Frame2DGuard (with frame_i in NvBufSurface-&gt;surfaceList[i]) True / False output_image_key The key name to use when generating datamap output. This name will be used to configure the input of downstream ds3d component. DS3D::ColorFrame output_object2d_key The key name to use when generating datamap output. This key name will be used to save NvDsObjectMeta from NvDsBatchMeta as an array of ds3d::Object2DBbox. DS3D::Object2DBboxKey", "keywords": []}, {"id": 2733, "doc_id": 2733, "filename": "text/DS_plugin_gst-nvds3dbridge.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvds3dbridge", "display_name": "Gst-nvds3dbridge", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvds3dbridge", "anchor": "", "priority": -1, "content": "The Gst-nvds3dbridge plugin is a customizable plugin which provides a custom library interface to load component ds3d::databridge . The Plugin is fully configured through YAML format content or file. sink_caps and src_caps is also configurable. Support for 3D (DS3D data format) to 2D (video/x-raw NVMM) is not provided.", "keywords": []}, {"id": 2734, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#configuration-file", "display_name": "Configuration file", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "configuration-file", "priority": -1, "content": "Example: name: multimodal_triton_infer type: ds3d::datafilter in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_tritoninferfilter.so custom_create_function: createLidarInferenceFilter config_body: in_streams: [color, depth]", "keywords": []}, {"id": 2735, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#configuration-options", "display_name": "Configuration options", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "configuration-options", "priority": -1, "content": "config-key Description Example value cam_width The width of camera image used for video input. 1242 cam_height The height of camera image used for video input. 375 cam_intrinsic Is a 3X4 matrix in column major. Projective transformation from rectified reference camera frame to cam in use for video input. More info here (see documentation for P_rect[i]; Note: we use P_rect[2] for the default config in ds3d_lidar_video_alignment_render.yaml). [3X4] matrix in column major. lidar_to_cam_extrisic is a 3X4 matrix = matrix_multiply(R0_rect, Tr_velo_to_cam); lidar_to_cam_extrisic is in column major order For more details on R0_rect and Tr_velo_to_cam, please check: lkk688/3DDepth [3X4] matrix in column major. lidar_input_key The keyname to use for lidar input from the input datamap buffer. DS3D::LidarXYZI+0 lidar_aligned_key The keyname to use for lidar output newly added by alignment filter into the output datamap buffer. DS3D::LidarAlignedXYZIKey max_points Maximum number of Lidar points in the input datamap at: {lidar_input_key: points}. 2048000 mem_pool_size Alignment filter maintains an internal pool. This is the pool size the user want to allocate. 4 align_to_intrinsic If true: AL_TR_3 is done. If false: AL_TR_2 is done. True lidar_element_size The size of output aligned lidar data points. = 3 means XYZ = 4 means XYZI (I is the intensity) More details here . 4", "keywords": []}, {"id": 2736, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#custom-ds3d-datafilter-library-libnvds-3d-alignment-datafilter-so", "display_name": "Custom ds3d::datafilter library: libnvds_3d_alignment_datafilter.so", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "custom-ds3d-datafilter-library-libnvds-3d-alignment-datafilter-so", "priority": -1, "content": "The input kLidarXYZI from ds3d/datamap buffer is converted into kLidarXYZIAligned . This is done by a series of transformations. Transformations done inside the alignment filter are described below with the help of KITTI Data format and calibration data references. Transform ID Details AL_TR_1 Euclidean transformation from lidar to reference camera. Velodyne points convert to reference camera (cam0) coordinate. Output = matrixmultiply( Tr_velo_to_cam , input_lidar_point) AL_TR_2 Note: AL_TR_2 is done on top of AL_TR_1. Alignment filter expect users to set lidar_to_cam_extrisic with both Tr_velo_to_cam and R0_rect . Rotation to account for rectification for points in the reference camera . Output = matrixmultiply(matmul(R0_rect, Tr_velo_to_cam), input_lidar_point) AL_TR_3 [Optional and is configured to ON/OFF with config: align_to_intrinsic ] Projective transformation from rectified reference camera frame (AL_TR2) to cam[2]. Note: Alignment filter expect users to set cam_intrinsic with P_rect[2] . Output = matrixmultiply(matmul(P_rect[2], R0_rect, Tr_velo_to_cam), input_lidar_point). Note: P_rect[2], R0_rect, Tr_velo_to_cam are all converted to 4X4 matrices. In DeepStream world: cam_intrinsic P0 OR P_rect[0] lidar_to_cam_extrisic is a 3X4 matrix = matrix_multiply(R0_rect, Tr_velo_to_cam) More info here: Alignment configuration Options .", "keywords": []}, {"id": 2737, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#custom-library-interfaces", "display_name": "Custom library Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "custom-library-interfaces", "priority": -1, "content": "The plugin parse the config file or content and set SinkCaps and SrcCaps. load a custom ds3d::datafilter from custom_lib_path . Create this datafilter by custom_create_function . See more details of ds3d::datafilter in DS3D Manual ds3d::datafilter- DS3D Custom DataFilter .", "keywords": []}, {"id": 2738, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#gst-nvds3dfilter-properties-specifications", "display_name": "Gst-nvds3dfilter properties Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "gst-nvds3dfilter-properties-specifications", "priority": -1, "content": "Properties Description Release config-content yaml config content DS 6.1 config-file yaml config file path DS 6.1", "keywords": []}, {"id": 2739, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#id2", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "id2", "priority": -1, "content": "Inputs ds3d/datamap Control parameters config-file config-content Output ds3d/datamap", "keywords": []}, {"id": 2740, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#id3", "display_name": "Configuration file", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "id3", "priority": -1, "content": "Example: name: lidar_alignment_filter type: ds3d::datafilter link_to: ds3d_aligned_render in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_3d_alignment_datafilter.so custom_create_function: createLidarAlignmentFilter config_body: cam_width: 1242 cam_height: 375 cam_intrinsic: [7.215377000000e+02, 0.000000000000e+00, 0.000000000000e+00, 0.000000000000e+00, 7.215377000000e+02, 0.000000000000e+00, 6.095593000000e+02, 1.728540000000e+02, 1.000000000000e+00, 4.485728000000e+01, 2.163791000000e-01, 2.745884000000e-03] #lidar_to_cam_extrisic is a 3X4 matrix = matrix_multiply(R0_rect, Tr_velo_to_cam); #lidar_to_cam_extrisic is in column major order #For more details on R0_rect and Tr_velo_to_cam, please check: https://github.com/lkk688/3DDepth/blob/main/README.md lidar_to_cam_extrisic: [2.34773698e-04, 1.04494074e-02, 9.99945389e-01, -9.99944155e-01, 1.05653536e-02, 1.24365378e-04, -1.05634778e-02, -9.99889574e-01, 1.04513030e-02, -2.79681694e-03, -7.51087914e-02, -2.72132796e-01] #cam input keys to ratain in the output datamap cam_input_keys: [DS3D::ColorFrame+1] #lidar input and output/aligned keys to retain in the output datamap #note: lidar_input_keys and lidar_aligned_keys map the same sensor data lidar_input_keys: [DS3D::LidarXYZI+0] lidar_aligned_keys: [DS3D::LidarAlignedXYZIKey] max_points: 2073600 mem_pool_size: 32 align_to_intrinsic: false lidar_element_size: 4", "keywords": []}, {"id": 2741, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NvDs3DBuffer or Metadata (NvDsBatchMeta) which has user meta NVDS_3D_DATAMAP_META_TYPE Control parameters config-file config-content Output NvDs3DBuffer or Metadata (NvDsBatchMeta) which has user meta NVDS_3D_DATAMAP_META_TYPE sink_caps parsed from filed of in_caps: ds3d/datamap or any user specified in_caps: . src_caps parsed from filed of out_caps: ds3d/datamap or any user specified out_caps: .", "keywords": []}, {"id": 2742, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dfilter#supported-ds3d-filter-custom-libs", "display_name": "Supported DS3D filter custom libs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "supported-ds3d-filter-custom-libs", "priority": -1, "content": "These custom libs are part of DeepStream release package. DS3D Data filter Data filter custom library Creating Instance Function Description Multi-Modal-triton-infer libnvds_tritoninferfilter.so createLidarInferenceFilter Multi-modal sensor data inference library, see details in libnvds_tritoninferfilter Configuration Specifications Data-alignment libnvds_3d_alignment_datafilter.so createLidarAlignmentFilter lidar/camera Sensor Intrinsic and Extrinsic parameters and alignment Depth-2-point-cloud libnvds_3d_depth2point_datafilter.so createDepth2PointFilter Convert Image Depth data into 3D Point Cloud data, see details in Custom datafilter libnvds_3d_depth2point_datafilter Configuration Specifications", "keywords": []}, {"id": 2743, "doc_id": 2743, "filename": "text/DS_plugin_gst-nvds3dfilter.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvds3dfilter", "display_name": "Gst-nvds3dfilter", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvds3dfilter", "anchor": "", "priority": -1, "content": "The Gst-nvds3dfilter plugin is a customizable plugin which provides a custom library interface to load component ds3d::datafilter . The Plugin is fully configured through YAML format content or file. sink_caps and src_caps is also configurable.", "keywords": []}, {"id": 2744, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#configuration-file", "display_name": "Configuration file", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "configuration-file", "priority": -1, "content": "Example: name: multisensor_mixer type: ds3d::datamixer in_caps: ds3d/datamap out_caps: ds3d/datamap custom_lib_path: libnvds_3d_multisensor_mixer.so custom_create_function: createMultiSensorMixer config_body: #timeout in milliseconds; timeout: 50 #force_sync == true will force mixer to wait for buffers from ALL inputs force_sync: true", "keywords": []}, {"id": 2745, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#custom-library-interfaces", "display_name": "Custom library Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "custom-library-interfaces", "priority": -1, "content": "The plugin parse the config file or content and set SinkCaps and SrcCaps. load a custom ds3d::datamixer from custom_lib_path . Create this datamixer by custom_create_function .", "keywords": []}, {"id": 2746, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#custom-low-level-library-libnvds-3d-multisensor-mixer-so", "display_name": "Custom low level library: libnvds_3d_multisensor_mixer.so", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "custom-low-level-library-libnvds-3d-multisensor-mixer-so", "priority": -1, "content": "Mix buffers from N input pads into one output pad.", "keywords": []}, {"id": 2747, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#gst-nvds3dmixer-properties-specifications", "display_name": "Gst-nvds3dmixer properties Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "gst-nvds3dmixer-properties-specifications", "priority": -1, "content": "Properties Description Release config-content yaml config content DS 7.0 config-file yaml config file path DS 7.0", "keywords": []}, {"id": 2748, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs (support N input pads) ds3d/datamap Control parameters config-file config-content Output ds3d/datamap sink_caps parsed from config-file: in_caps:  ds3d/datamap . src_caps parsed from config-file: out_caps:  ds3d/datamap . Example Inputs X 2 and Output Input at sink_0 Input at sink_1 Output GstBuffer with ds3d/datamap GstBuffer with ds3d/datamap GstBuffer with ds3d/datamap {kVideoBridge2dData:value1}, {kVideoBridge2dData:value2}, \u2026 {kLidarXYZI:value1}, {kLidarXYZI:value2}, \u2026 {kVideoBridge2dData+0:value1}, {kVideoBridge2dData+0:value2}, {kLidarXYZI+1:value1}, {kLidarXYZI+1:value2}, \u2026", "keywords": []}, {"id": 2749, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#supported-ds3d-data-mixers", "display_name": "Supported DS3D Data mixers", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "supported-ds3d-data-mixers", "priority": -1, "content": "SL Data mixer Data mixer custom library 1 DS3D Data mixer. Mix buffers from N input pads into one output pad. libnvds_3d_multisensor_mixer.so", "keywords": []}, {"id": 2750, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds3dmixer#video-mixer-configuration-options", "display_name": "Video mixer configuration options", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "video-mixer-configuration-options", "priority": -1, "content": "config-key Description Example value timeout Timeout dictates the regular time interval in which mixer algorithm will run. This configuration is in ms. This configuration can dictate the frame-rate at which mixer will produce mixed output datamap buffers. Default: 33 ms force_sync Mixer will wait for ALL inputs to produce output. If true, the output framerate of mixer will be = slower of all the inputs. One may use this if all inputs are of equal frame-rate. Default: false output_object2d_key The key name to use when generating datamap output. This key name will be used to save NvDsObjectMeta from NvDsBatchMeta as an array of ds3d::Object2DBbox. DS3D::Object2DBboxKey", "keywords": []}, {"id": 2751, "doc_id": 2751, "filename": "text/DS_plugin_gst-nvds3dmixer.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvds3dmixer", "display_name": "Gst-nvds3dmixer", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvds3dmixer", "anchor": "", "priority": -1, "content": "The Gst-nvds3dmixer plugin is a customizable plugin which provides a custom library interface to load component ds3d::datamixer . nvds3dmixer mix buffers from N input pads into one output pad. The Plugin is fully configured through YAML format content or file.", "keywords": []}, {"id": 2752, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#ds-riva-tts-yaml-file-configuration-specifications", "display_name": "DS-Riva TTS Yaml File Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "ds-riva-tts-yaml-file-configuration-specifications", "priority": -1, "content": "DS-Riva TTS configuration file uses YAML 1.2 file format: https://yaml.org/spec/1.2/spec.html . There are multiple parts in the configuration file. An example is located at /opt/nvidia/deepstream/deepstream/sources/apps/audio_apps/deepstream_asr_tts_app/riva_tts_conf.yml . Each part has a name indicating a unique part name and a detail indicating the setting details. name: riva_server part configures the Riva server URI in its corresponding node detail: . name: riva_tts_stream part configures Riva TTS service supported features in its corresponding node detail: . name: ds_riva_tts_plugin part configures DS-Riva TTS settings in its corresponding node detail: . A separator line with --- is inserted between the 2 neighbor parts according to YAML specification.", "keywords": []}, {"id": 2753, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release TTS template The plugin provides a Text To Speech base which can support runtime loading of custom TTS library DS 6.0 DS-Riva TTS library and Context Default TTS library based on Riva TTS gRPC service DS 6.0 Live speech synthesis Supports speech synthesis in real time using the streaming mode of the Riva TTS service DS 6.0 Languages support English is supported at present DS 6.0 Audio format Outputs F32LE Linear PCM mono audio at 22050 Hz DS 6.0 Frame size Supports configurable output frame size DS 6.0 x86 platform support \u2013 DS 6.0 Jetson platform support \u2013 DS 6.2", "keywords": []}, {"id": 2754, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#grpc-c-installation", "display_name": "gRPC C++ Installation", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "grpc-c-installation", "priority": -1, "content": "gRPC C++ shared libraries v1.38 installation is needed for using the DS-Riva TTS library to access the Riva TTS gRPC service. To install the libraries, please follow steps given at https://grpc.io/docs/languages/cpp/quickstart/ , and add -DBUILD_SHARED_LIBS=ON to the cmake build options. (Recommended to use make -j4 instead of make -j ) Or Use the included script to install gRPC C++ libraries, this scripts performs same steps: $ cd /opt/nvidia/deepstream/deepstream/sources/apps/audio_apps/deepstream_asr_app $ sudo chmod +x gRPC_installation.sh $ ./gRPC_installation.sh Please run below command to add the installation path to the LD_LIBRARY_PATH environment variable: $ export LD_LIBRARY_PATH=$HOME/.local/lib:$LD_LIBRARY_PATH The gRPC C++ libraries are pre-installed on the DeepStream dGPU docker images. In the dGPU docker container, please run below command to add the installation path to the LD_LIBRARY_PATH environment variable: $ export LD_LIBRARY_PATH=$HOME/.local/lib:$LD_LIBRARY_PATH", "keywords": []}, {"id": 2755, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "gst-properties", "priority": -1, "content": "The following tables describes the Gst properties of the Gst-nvds_text_to_speech plugin. Property Meaning Type and Range Example Notes name Unique name String name: riva_server detail Node for Riva Server Setting details Node detail: server_uri: \u201clocalhost:50051\u201d server_uri Part of detail node. Specify address of the Riva TTS service String server_uri: \u201clocalhost:50051\u201d Property Meaning Type and Range Example Notes name Unique name String Must be name: riva_tts_stream detail Node for Riva TTS Steam setting details Node detail: encoding: LINEAR_PCM encoding Part of detail node. Specify output audio encoding format. Only LINEAR_PCM is supported String encoding: LINEAR_PCM language_code Part of detail node. Specify which language is used for speech synthesis. Currently only en-US is supported String language_code: en-US voice_name Part of detail node. Specify the voice name parameter used for speech synthesis String voice_name: ljspeech Property Meaning Type and Range Example Notes name Unique name String Must be name: ds_riva_tts_plugin detail Node DS-Riva TTS library details Node detail: output_mode: 0 output_mode Part of detail node. Specify output mode. Output mode 0: Default. Outputs audio as received from Riva server. Suitable for non real-time sinks like filesink. Output mode 1: Inserts silence in output when audio from server is not available. Suitable for real-time/live sinks like autoaudiosink. Integer: 0 or 1 output_mode: 1 framing_mode Part of detail node. Specify framing mode. Framing mode 0: Default. Use output chunk size as received from Riva server. Framing mode 1: Splits the audio received from server into chunks of size specified by the frame_size. Last chunk if not padded if less than frame_size samples. Framing mode 1: Splits the audio into chunks of frame_size samples with last chunk padded to frame_size. Integer: 0 1 2 framing_mode: 2 frame_size Part of detail node. Specify output frame size in number of samples. Used with framing mode 1 or 2 or output mode 1. Integer: 1 to 65535 frame_size: 2205", "keywords": []}, {"id": 2756, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvds_text_to_speech plugin with DS-Riva TTS implementation. Input Text GStreamer buffers Control parameters customlib-name : Set a custom TTS library that the plugin loads to perform speech synthesis. By default, DS-Riva TTS library ( libnvds_riva_tts.so ) is set create-speech-ctx-func : Symbol name to create TTS speech context. Default: create_text_to_speech_ctx config-file : A text file to configure the plugin, DS-Riva TTS service requests. Output Raw audio GStreamer buffers containing the synthesized speech", "keywords": []}, {"id": 2757, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#riva-tts-service-initiation", "display_name": "Riva TTS Service Initiation", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "riva-tts-service-initiation", "priority": -1, "content": "Refer to https://docs.nvidia.com/deeplearning/riva/user-guide/docs/quick-start-guide.html#local-deployment-using-quick-start-scripts for the procedure to start Riva TTS service.", "keywords": []}, {"id": 2758, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvds_text_to_speech#sample-application", "display_name": "Sample Application", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "sample-application", "priority": -1, "content": "A sample application using the plugin is available here: sources/apps/audio_apps/deepstream_asr_tts_app . Please follow the README to run the tests.", "keywords": []}, {"id": 2759, "doc_id": 2759, "filename": "text/DS_plugin_gst-nvds_text_to_speech.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvds_text_to_speech", "display_name": "Gst-nvds_text_to_speech (Alpha)", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvds_text_to_speech", "anchor": "", "priority": -1, "content": "The Gst-nvds_text_to_speech plugin performs speech synthesis on the input text. It is supported on both x86 and Jetson platforms. The plugin provides a mechanism to load custom Text To Speech (TTS) low level library at runtime. By default, the plugin loads DS-Riva TTS library ( libnvds_riva_tts.so ) to perform speech synthesis. The library communicates with the TTS service of the NVIDIA Riva SDK for speech synthesis using optimized Riva TTS models. The Gst-nvds_text_to_speech plugin is being released as an alpha feature. The DS-Riva Text To Speech library uses gRPC API to access the Riva TTS service. The Riva TTS service should be started before using this plugin. Installation of the gRPC C++ libraries (v1.38) is required on the client side. The DS-Riva TTS library ( libnvds_riva_tts.so ) works with NVIDIA Riva Release 2.0.0 or later. The plugin accepts text (UTF8) GStreamer buffers ( GstBuffers ) from upstream component. It transforms the text into audio GStreamer buffer output. The DS-Riva TTS library ( libnvds_riva_tts.so ) generates raw audio data with S16LE format (Signed 16 bit Little Endian) at 22050 Hz sample rate. Library settings can be configured via YAML format file (by setting a property on nvds_text_to_speech gst plugin) which has multi-part settings for plugin control, and Riva TTS service configurations. As shown in the diagram below, input text is send to Riva TTS service for speech synthesis. The final output is available as S16LE PCM audio at 22050 Hz.", "keywords": []}, {"id": 2760, "doc_id": 2764, "filename": "text/DS_plugin_gst-nvdsanalytics.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsanalytics#configuration-file-parameters", "display_name": "Configuration File Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsanalytics", "anchor": "configuration-file-parameters", "priority": -1, "content": "The configuration file is located at sources/apps/sample_apps/deepstream-nvdsanalytics-test/config_nvdsanalytics.txt . The Gst-nvdsanalytics configuration file uses a \u201cKey File\u201d format described in: https://specifications.freedesktop.org/desktop-entry-spec/latest The [property] group configures the general behavior of the plugin. It is the only mandatory group. The [roi-filtering-stream-&lt;n&gt;] group configures ROI filtering rules parameters for stream specified by &lt;n&gt; . For example, classes.[roi-filtering-stream-0] configures ROI filtering rules for stream ID 0 . The [overcrowding-&lt;n&gt;] group configures Overcrowding parameters for a stream specified by` &lt;n&gt;`. The [direction-detection-&lt;n&gt;] group configures Direction Detection parameters for a stream specified by &lt;n&gt; . The [line-crossing-&lt;n&gt;] group configures Line Crossing parameters for a stream specified by &lt;n&gt; . The following table respectively describe the keys supported for [property] groups and [&lt;feature&gt;-stream-&lt;n&gt;] groups. Property Applicable Groups Meaning Type and Range Example Notes enable [property] | [&lt;feature&gt;-stream-&lt;n&gt;] Common property to enable or disable the plugin or feature Boolean enable=1 config-width [property] Width for which the analytics rules are configured Integer, &gt;0 config-width=1280 config-height [property] Height for which the analytics rules are configured Integer, &gt;0 config-height=720 osd-mode [property] 0: Disables display of any lines, ROIS and text 1: Display only lines, rois and static text i.e. labels 2: Display all info from 1 in addition, information for all the events Integer0,1,2 osd-mode=2 display-font-size [property] Set OSD font size for the analytics data Integer &gt; 0 display-font-size=12 roi-&lt;label&gt; [roi-filtering-stream-&lt;n&gt;] | [overcrowding-stream-&lt;n&gt;] The ROI can be specified using roi key followed by its corresponding label (roi-&lt;label&gt;) the value consist of semi-colon delimited coordinates of the polygon (roi-&lt;label&gt;=x1;y1;x2;y2;x3;y3;x4;y4;x5;y5) . The user can specify a simple polygon with &gt; 3 points. The points should be sequentially specified, as the relative position of points is required to check object in polygon. String roi-RF= 295;643;579;634;642;913;56;828 roi-OC= 295;643;579;634;642;913;56;828 inverse-roi [roi-filtering-stream-&lt;n&gt;] If the flag set true, it indicates the object outside the configured ROI be attached with the ROI label, and count the objects outside the ROI and send as frame level output Boolean inverse-roi=0 class-id [&lt;feature&gt;-stream-&lt;n&gt;] The class ID separated by semi-colon for which analytic rules should be applied. | -1 indicate that the rules are to be applied to all the classes String class-id=0;1;2 or class-id=-1 object-threshold [overcrowding-stream-&lt;n&gt;] The total count after which overcrowding flag should be indicated in the frame metadata. Integer, &gt;=0 object-threshold=10 direction-&lt;label&gt; [direction-detection-stream-&lt;n&gt;] The value indicates the direction (x1;y1;x2;y2) which corresponds to the configured &lt;label&gt;. When object is moving in configured direction, the label of the particular rule is attached to the object as user metadata String direction-South=284;840;360;662 line-crossing-&lt;label&gt; [line-crossing-stream-&lt;n&gt;] The value indicates 2 coordinates of direction followed by 2 coordinates of virtual line. These coordinates are delimited using semi-colon (line-crossing-&lt;label&gt;=x1d;y1d;x2d;y2d;x1c;y1c;x2c;y2c). The direction indicates the direction of object in which it should be moving that can be considered for counting, so the object should be in direction x1d,y1d to x2d,y2d, which indicates a direction vector. The line crossing coordinates x1c,y1c and x2c,y2c indicate a virtual line which when an object following a configured direction crosses is then accounted for line crossing. &lt;label&gt; is string identification of the rule. Multiple line-crossings can be defined for a single stream String line-crossing-Exit=789;672;1084;900;851;773;1203;732 extended [line-crossing-stream-&lt;n&gt;] Boolean parameter to check crossings only on the configured line or for the extended line covering the video frame. If extended is 0, the line crossing only the configured line would be counted Boolean extended=0 mode [line-crossing-stream-&lt;n&gt;] Parameter to allow user configuration of adherence of object direction with configured direction for crossing. Possible options strict, balanced, loose. Operate as per name suggestion, where loose will just check if the object has crossed the line and would need the object just to be in same direction with very high tolerance String mode=loose mode=strict mode=balanced The config-width, config-height, indicate the resolution at which analytics rules have been configured. If the runtime stream resolution is different than the configuration resolution. The plugin handles the resolution change and scales the rules for the runtime resolution. The configuration rules are not present in absolute pixel values. The following pipelines demonstrate plugin\u2019s usage. For dGPU: gst-launch-1.0 filesrc location=streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m width=1920 height=1080 batch-size=1 live-source=1 ! nvinfer config-file-path= sources/apps/sample_apps/ deepstream-nvdsanalytics-test/nvdsanalytics_pgie_config.txt ! nvtracker ll-lib-file = /opt/nvidia/deepstream/deepstream/lib/libnvds_nvdcf.so ll-config-file= tracker_config.yml tracker-width=640 tracker-height=384 ! nvdsanalytics config-file= sources/apps/sample_apps/deepstream-nvdsanalytics-test/config_nvdsanalytics.txt ! nvmultistreamtiler ! nvvideoconvert ! nvdsosd ! nveglglessink For Jetson: gst-launch-1.0 filesrc location=streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m width=1920 height=1080 batch-size=1 live-source=1 ! nvinfer config-file-path= sources/apps/sample_apps/ deepstream-nvdsanalytics-test/nvdsanalytics_pgie_config.txt ! nvtracker ll-lib-file = /opt/nvidia/deepstream/deepstream/lib/libnvds_nvdcf.so ll-config-file= tracker_config.yml tracker-width=640 tracker-height=384 ! nvdsanalytics config-file= sources/apps/sample_apps/deepstream-nvdsanalytics-test/config_nvdsanalytics.txt ! nvmultistreamtiler ! nvvideoconvert ! nvdsosd ! nv3dsink", "keywords": []}, {"id": 2761, "doc_id": 2764, "filename": "text/DS_plugin_gst-nvdsanalytics.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsanalytics#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsanalytics", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release ROI Filtering This feature detects presence of objects in the ROI, the result is attached as metadata for every object, as well as total count of objects in ROI per frame. DS 5.0 Overcrowding Detection This feature detects presence of objects in the ROI, the result is attached as metadata for every object, as well as total count of objects in ROI per frame along with overcrowding status, i.e. no of objects in ROI exceed a pre-configured threshold. DS 5.0 Direction Detection Checks using history of position of object and the current frame information if it is following a preconfigured direction. The result is attached as metadata for every object. DS 5.0 Line Crossing This feature checks if object is following a preconfigured direction for the virtual line and if it has crossed the virtual line. The result is attached to object when Line crossing also frame meta where cumulative count along with per frame count of line crossing is attached. DS 5.0", "keywords": []}, {"id": 2762, "doc_id": 2764, "filename": "text/DS_plugin_gst-nvdsanalytics.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsanalytics#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsanalytics", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsanalytics plugin. Property Meaning Type and Range Example Notes unique-id Unique identification unsigned integer value for element to identify the output attached by the element Integer, 0 to 4,294,967,295 unique-id=17 enable True Enables the plugin, False sets it in pass-through mode Boolean enable=1 config-file Configuration file which consist of the analytics rules String config-file=config_nvdsanalytics.txt", "keywords": []}, {"id": 2763, "doc_id": 2764, "filename": "text/DS_plugin_gst-nvdsanalytics.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsanalytics#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsanalytics", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs GStreamer buffer containing NV12/RGBA frame(s) with attached metadata Control Parameters enable: True Enables the plugin, False sets it in pass-through mode config-file: Configuration file which consist of the analytics rules Output Original NV12/RGBA batched buffer NvDsAnalyticsFrameMeta (meta containing information about individual frames in the batched buffer) NvDsAnalyticsObjInfo (meta containing information about individual objects in the individual frames of batched buffer)", "keywords": []}, {"id": 2764, "doc_id": 2764, "filename": "text/DS_plugin_gst-nvdsanalytics.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsanalytics", "display_name": "Gst-nvdsanalytics", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsanalytics", "anchor": "", "priority": -1, "content": "This plugin performs analytics on metadata attached by nvinfer (primary detector) and nvtracker . Analytics refer to Region of Interest (ROI) Filtering, Overcrowding Detection, Direction Detection and Line Crossing. The plugin operates in batch mode, it handles the context for each stream independently. ROI based analytics work on primary detector output, but Direction Detection and Line Crossing requires a tracker-id as previous history/state is required to do both the analytics. The configuration for the rules for analytics is achieved using a configuration file. For all the analytics calculations bottom center coordinate of bounding box of an object is being used. If bounding box is defined as ( x_left, y_top, width, height ) then the bottom center coordinate would be ( x_left + width/2, y_top + height ) The gst-nvdsanalytics plugin extracts the metadata from the batched buffer sent by the upstream ( nvtracker/nvinfer ) element and passes it to the low-level nvdsanalytics library. The low-level library performs analytics based on the configured rules for each feature for each of the streams, the library returns the analytics output, which is for each tracked object as well for the complete frame. The analytics output (Frame level) is encapsulated in the NvDsAnalyticsFrameMeta structure and is added as user meta with meta_type set to NVDS_USER_FRAME_META_NVDSANALYTICS .The user meta is added to the frame_user_meta_list member of NvDsFrameMeta . The analytics output (per detected Object) is encapsulated in the NvDsAnalyticsObjInfo structure and is added as user meta with meta_type set to NVDS_USER_OBJ_META_NVDSANALYTICS . The user meta is added to the obj_user_meta_list member of NvDsObjectMeta . The definition of NvDsAnalyticsObjInfo  NvDsAnalyticsFrameMeta is available in sources/includes/nvds_analytics_meta.h header file. For guidance on how to access user metadata, see the User/Custom Metadata addition in the NvDsBatchMeta and Tensor Metadata .", "keywords": []}, {"id": 2765, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#ds-riva-asr-library-yaml-file-configuration-specifications", "display_name": "DS-Riva ASR Library YAML File Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "ds-riva-asr-library-yaml-file-configuration-specifications", "priority": -1, "content": "DS-Riva ASR configuration file uses YAML 1.2 file format: https://yaml.org/spec/1.2/spec.html . There are multiple parts in the config file. An example for the gRPC riva_asr_grpc_conf.yml yml file is located at /opt/nvidia/deepstream/deepstream/sources/apps/audio_apps/deepstream_asr_tts_app/ . Each part has a name indicating a unique part name and a detail indicating the setting details. name: riva_server part configures Riva ASR server settings in its corresponding node detail: . name: riva_model part configures Riva ASR model entry in its corresponding node detail: . name: riva_asr_stream part configures Riva low level library supported features in its corresponding node detail: . Each ASR plugin instance will launch a standalone Riva stream. The settings between different plugin instances could be different. name: ds_riva_asr_plugin part configures DS-Riva ASR settings in its corresponding node detail: . A separator line with --- is inserted between the 2 neighbor parts according to YAML specification.", "keywords": []}, {"id": 2766, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Speech ASR template The plugin is a ASR speech base which can support custom ASR library loading in runtime DS 6.0 Live stream transcription Support partial transcript output in realtime DS 6.0 Final transcription Support final transcription only useful for local audio streams DS 6.0 Languages support The plugin is currently only tested for English (en-US) DS 6.0 Words punctuation Support words punctuation and capitalization DS 6.0 Custom library with gRPC API implementation Supports custom library implementation that uses gRPC APIs for accessing Riva ASR gRPC service. Set libnvds_riva_asr_grpc.so as customlib-name and create_riva_asr_grpc_ctx as create-speech-ctx-func DS 6.0 x86 platform support \u2013 DS 6.0 Jetson platform support \u2013 DS 6.2", "keywords": []}, {"id": 2767, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#grpc-c-library-installation", "display_name": "gRPC C++ Library Installation", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "grpc-c-library-installation", "priority": -1, "content": "gRPC C++ shared libraries v1.38 installation is needed for the DS-Riva ASR library to access the Riva ASR gRPC service. To install the libraries, please follow steps given at https://grpc.io/docs/languages/cpp/quickstart/ , and add -DBUILD_SHARED_LIBS=ON to the cmake build options. (Recommended to use make -j4 instead of make -j ) Or Use the included script to install gRPC C++ libraries, this scripts performs same steps: $ cd /opt/nvidia/deepstream/deepstream/sources/apps/audio_apps/deepstream_asr_app $ sudo chmod +x gRPC_installation.sh $ ./gRPC_installation.sh Please run below command to add the installation path to the LD_LIBRARY_PATH environment variable: $ export LD_LIBRARY_PATH=$HOME/.local/lib:$LD_LIBRARY_PATH The gRPC C++ libraries are pre-installed on the DeepStream dGPU docker images. In the dGPU docker container, please run below command to add the installation path to the LD_LIBRARY_PATH environment variable: $ export LD_LIBRARY_PATH=$HOME/.local/lib:$LD_LIBRARY_PATH", "keywords": []}, {"id": 2768, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "gst-properties", "priority": -1, "content": "The following tables describes the Gst properties of the Gst-nvdsasr plugin. Property Meaning Type and Range Example Notes name Unique name String name: riva_server detail Node for Riva Server Setting details Node detail: server_uri: \u201clocalhost:50051\u201d server_uri Part of detail node. Specify Riva ASR service address. Used in case of gRPC APIs. String server_uri: \u201clocalhost:50051\u201d Property Meaning Type and Range Example Notes name Unique name String Must be name: riva_model detail Node for Riva model setting details Node detail: model_name: citrinet-1024-asr-trt-ensemble-vad-streaming model_name Part of detail node. Specify which model entry is used String model_name: citrinet-1024-asr-trt-ensemble-vad-streaming Property Meaning Type and Range Example Notes name Unique name String Must be name: riva_asr_stream detail Node for Riva ASR Steam setting details Node detail: encoding: LINEAR_PCM \u2026 encoding Part of detail node. Specify Input data format Only Value LINEAR_PCM is supported String encoding: LINEAR_PCM sample_rate_hertz Part of detail node. Input audio sample rate Only Value 16000 is supported Integer &amp; &gt;0 sample_rate_hertz: 16000 language_code Part of detail node. Specify which language is used for recognition Only Value en-US is supported String language_code: en-US max_alternatives Part of detail node. Max alternatives selected by top confidence Only 1 is supported at present Integer &amp; &gt;0 max_alternatives: 1 enable_automatic_punctuation Part of detail node. Enable automatic punctuation or not Boolean enable_automatic_punctuation: false Property Meaning Type and Range Example Notes name Unique name String Must be name: ds_riva_asr_plugin detail Node DS-Riva ASR library details Node detail: final_only: false final_only Part of detail node. Specify whether final transcriptions only or with partial transcription output together Boolean final_only: false enable_text_pts Part of detail node. Specify whether text buffer timestamp is enabled or not. Boolean enable_text_pts: false use_riva_pts Part of detail node. Specify whether time informatation provided by Riva service is used to calculate the timestamp and duration of output buffer. Note: At present this option is supported for non-live sources only Boolean use_riva_pts: false force_final_trailing Part of detail node. Enable insertion of new line character after the final transcription Boolean force_final_trailing: false", "keywords": []}, {"id": 2769, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvdsasr plugin with the gRPC based ASR library. Input Raw Audio GStreamer buffers Control parameters customlib-name : Set a custom ASR library that the plugin loads to perform inference. Use : libnvds_riva_asr_grpc.so create-speech-ctx-func : Symbol name to create ASR speech context. Use : create_riva_asr_grpc_ctx config-file : A text file to configure the plugin. Use riva_asr_grpc_conf.yml Outputs Text GStreamer buffer containing ASR output", "keywords": []}, {"id": 2770, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#riva-asr-service-deployment", "display_name": "Riva ASR Service Deployment", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "riva-asr-service-deployment", "priority": -1, "content": "Please check https://docs.nvidia.com/deeplearning/riva/user-guide/docs/quick-start-guide.html for the steps to deploy the models using Riva Quick start scripts: Example steps to deploy Riva server with desired ASR model: Download Riva Quick Start package: $ ngc registry resource download-version nvidia/riva/riva_quickstart:1.5.0-beta $ cd riva_quickstart_v1.5.0-beta Update config.sh file for required ASR model e.g CitriNet-1024: service_enabled_asr=true service_enabled_nlp=false service_enabled_tts=false riva_model_loc=&quot;riva-asr-model-repo&quot; models_asr=( &quot;${riva_ngc_org}/${riva_ngc_team}/rmir_asr_citrinet_1024_asrset1p7_streaming:${riva_ngc_model_version}&quot; &quot;${riva_ngc_org}/${riva_ngc_team}/rmir_nlp_punctuation_bert_base:${riva_ngc_model_version}&quot; ) Run the Riva initialization script: $ bash riva_init.sh Deploy the Riva ASR service: $ bash riva_start.sh To stop ASR services after the application has run successfully, run the following command: $ bash riva_stop.sh", "keywords": []}, {"id": 2771, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsasr#sample-test-application", "display_name": "Sample Test Application", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "sample-test-application", "priority": -1, "content": "For information about Gst-nvdsasr sample tests, please see source code under directory sources/apps/audio_apps/deepstream_asr_app. Follow README to run the sample tests.", "keywords": []}, {"id": 2772, "doc_id": 2772, "filename": "text/DS_plugin_gst-nvdsasr.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsasr", "display_name": "Gst-nvdsasr", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsasr", "anchor": "", "priority": -1, "content": "The Gst-nvdsasr plugin performs automatic speech recognition (ASR) on the input audio data. The plugin provides a mechanism to load custom ASR low level library at runtime. It is supported on both x86 and Jetson platforms and can be used on x86, Jetson devices or from inside DeepStream dockers. A custom library libnvds_riva_asr_grpc.so is provided which uses gRPC APIs to access the Riva ASR service. The library communicates with the ASR service of the NVIDIA Riva SDK for speech recognition and punctuation-capitalization using optimized Riva models. The DS-Riva ASR library, libnvds_riva_asr_grpc.so , uses gRPC APIs to access the Riva ASR service. The Riva ASR service should be started before using this library. Required steps are outlined below in section \u2018Riva ASR Service Deployment\u2019. Installation of the gRPC C++ libraries (v1.38) is required on the client side. Required steps are outlined below in section \u2018gRPC C++ Library Installation\u2019. The libnvds_riva_asr_grpc.so library works with NVIDIA Riva Release 1.5.0 Beta or later. The plugin accepts raw PCM audio GStreamer buffers ( GstBuffer ) from upstream component. It transforms audio into generic text GstBuffer output. Model needs raw audio data input with S16LE (Signed 16bit Little Endian). Library settings can be configured via YAML format file (by setting a property on Gst-nvdsasr plugin) which has multi-part settings for plugin. As shown in the diagram below input S16LE raw audio data is preprocessed and inferred by the Riva ASR service . The final output is available in UTF8 text.", "keywords": []}, {"id": 2773, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsaudiotemplate#customlib-impl-interfaces", "display_name": "customlib_impl Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "customlib-impl-interfaces", "priority": -1, "content": "SetInitParams - Based on the negotiated caps, this API creates output buffer pool of the negotiated resolution HandleEvent - This API handles standard Gstreamer events as well as custom events such as PAD_ADDED PAD_DELETED etc. GetCompatibleCaps - This API returns the fixated caps to be set on either SINK / SRC pad of the plugin ProcessBuffer - This API passes the GstBuffer to customlib for further processing SetProperty - This API sets the customlib properties that are used by the underlying library for processing", "keywords": []}, {"id": 2774, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsaudiotemplate#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Simplified APIs Simplified interface to implement custom library to add any algorithm without implementing new plugin DS 5.1 Easy Data Accessing Easy access to GstBuffer and it\u2019s metadata inside custom library DS 5.1 Synchronous and Asynchronous Buffer Processing Buffer_Ok is the responsibility of the plugin to push the buffer downstream. Buffer_Async is the responsibility of the custom library to push the buffer downstream. Buffer_Error and Buffer_Drop are currently not implemented DS 5.1 Reference Impl. Reference implementation of custom library provides transform, transform-ip, metadata handling etc. which can be modified as per the use case. DS 5.1 Abstraction APIs Bufferpool creation, caps handling provided as an abstraction API inside customlib base class DS 5.1", "keywords": []}, {"id": 2775, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsaudiotemplate#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsaudiotemplate plugin. Property Meaning Type and Range Example/Notes Platforms gpu-id Device ID of GPU to use for decoding. Integer, 0 to 4,294,967,295 gpu-id=0 dGPU customlib-name custom library Name to be used String Default: null dGPU customlib-props Custom Library Properties (key:value) string, can be set multiple times,vector is maintained internally String Default: null dGPU", "keywords": []}, {"id": 2776, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsaudiotemplate#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NVMM or RAW Gst Buffers. Supported formats are S16LE and F32LE Control parameters customlib-name gpu-id customlib-props Output Transformed Gst Buffer", "keywords": []}, {"id": 2777, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsaudiotemplate#sample-pipelines", "display_name": "Sample pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "sample-pipelines", "priority": -1, "content": "For single stream: gst-launch-1.0 audiotestsrc wave=0 num-buffers=1000 ! audioconvert ! nvdsaudiotemplate \\ customlib-name=&quot;libcustom_impl.so&quot; customlib-props=&quot;noise-factor:100&quot; ! \\ wavenc ! filesink location=audio.wav buffer-mode=2 For Multi-stream (Ensure that new nvstreammux is enabled): export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 audiotestsrc wave=0 ! audioconvert ! m.sink_0 nvstreammux name=m \\ ! nvdsaudiotemplate customlib-name=&quot;libcustom_impl.so&quot; customlib-props=&quot;noise-factor:10&quot; ! nvstreamdemux name=d d.src_0 \\ ! wavenc ! filesink location=audio.wav buffer-mode=2 audiotestsrc wave=1 ! audioconvert ! m.sink_1", "keywords": []}, {"id": 2778, "doc_id": 2778, "filename": "text/DS_plugin_gst-nvdsaudiotemplate.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsaudiotemplate", "display_name": "Gst-nvdsaudiotemplate", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsaudiotemplate", "anchor": "", "priority": -1, "content": "The OSS Gst-nvdsaudiotemplate plugin is a template plugin which provides a custom library hooking interface for single/batched audio frame(s) processing. Custom lib implementation may have algorithms to transform or process input buffers depending upon the use case. It can support S16LE and F32LE inputs. The plugin accepts batched NVMM HW and RAW SW buffers, and outputs batched HW and SW buffers.", "keywords": []}, {"id": 2779, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#customlib-impl-interfaces", "display_name": "customlib_impl Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "customlib-impl-interfaces", "priority": -1, "content": "serialize_data =&gt; Accepts a GstBuffer, serializes input meta and attaches it as NvDsUserMeta / gst meta on the same GstBuffer.", "keywords": []}, {"id": 2780, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Simplified API Simplified interface to implement custom library to add any algorithm without implementing new plugin DS 6.1 Easy Data Accessing Easy access to GstBuffer and it\u2019s metadata inside custom library DS 6.1 Reference Impl. Reference implementation of custom library provides implementation for serialized data to be used with decoder, serializing and de-serializing of NvDsBatchmeta. DS 6.1", "keywords": []}, {"id": 2781, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#gst-nvdsmetaextract", "display_name": "Gst-nvdsmetaextract", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "gst-nvdsmetaextract", "priority": -1, "content": "The Gst-nvdsmetaextract plugin is a NvDsMeta utils plugin which provides a custom library hooking interface for single/batched audio/video frame(s) processing. Custom lib implementation can have algorithms to de-serialize NvDsBatchmeta or custom gst user meta received on the input buffer depending upon the use case. The plugin accepts batched/non-batched audio/video NVMM HW buffers, and outputs batched/non-batched audio/video NVMM HW buffers with de-serialized metadata on the buffer as per the use case.", "keywords": []}, {"id": 2782, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#gst-nvdsmetainsert", "display_name": "Gst-nvdsmetainsert", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "gst-nvdsmetainsert", "priority": -1, "content": "The Gst-nvdsmetainsert plugin is a NvDsMeta utils plugin which provides a custom library hooking interface for single/batched audio/video frame(s) processing. Custom lib implementation can have algorithms to serialize NvDsBatchmeta or custom gst user meta received on the input buffers depending upon the use case. The plugin accepts batched audio/video NVMM HW buffers, and outputs batched audio/video NVMM HW buffers with serialized metadata on the buffer as per the use case.", "keywords": []}, {"id": 2783, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsmetainsert plugin. Property Meaning Type and Range Example/Notes Platforms serialize-lib Set serialization library Name to be used. String Default: null dGPU", "keywords": []}, {"id": 2784, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#id1", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "id1", "priority": -1, "content": "Inputs NVMM Gst Buffer. Control parameters deserialize-lib Output NVMM Gst Buffer in place.", "keywords": []}, {"id": 2785, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#id2", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "id2", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Simplified API Simplified interface to implement custom library to add any algorithm without implementing new plugin DS 6.1 Easy Data Accessing Easy access to GstBuffer and it\u2019s metadata inside custom library DS 6.1 Reference Impl. Reference implementation of custom library provides implementation for serialized data to be used with decoder, serializing and de-serializing of NvDsBatchmeta. DS 6.1", "keywords": []}, {"id": 2786, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#id3", "display_name": "customlib_impl Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "id3", "priority": -1, "content": "deserialize_data =&gt; Accepts a GstBuffer, de-serializes input meta and attaches as gst meta / update existing NvDsBatchMeta on the same GstBuffer.", "keywords": []}, {"id": 2787, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#id4", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "id4", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsmetaextract plugin. Property Meaning Type and Range Example/Notes Platforms deserialize-lib Set de-serialization library Name to be used. String Default: null dGPU", "keywords": []}, {"id": 2788, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#id5", "display_name": "Use Cases & Sample Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "id5", "priority": -1, "content": "Below are two reference implementations, these can be extended to suit any particular use case. Use Case 1 : CustomMeta De-Serialization SEI in H264 : Nv decoder sends parsed SEI data of unregistered type which is serialized metadata inside bitstream, nvdsmetaextract plugin with sei_serialization library released as part of DS SDK 6.1 onwards, de-serializes this metadata and add it on the outgoing buffer as gst metadata, this data can be consumed by downstream plugin as per the use-case. Below pipeline demonstrates parsing serialized SEI data in the bitstream, attaching it as Gst meta on the outgoing buffer and de-serializing it in nvdsmetaexract plugin: gst-launch-1.0 filesrc location=~/ds_maxine_sei.h264 ! h264parse ! nvv4l2decoder extract-sei-type5-data=1 \\ ! nvdsmetaextract deserialize-lib=libnvds_sei_serialization.so ! nveglglessink Use Case 2 : Video NvDsBatchMeta De-Serialization : Upstream component sends GstBuffer with serialized NvDsFrameMeta &amp; NvDsObjectMeta attached as NvDsUserMeta inside NvDsFrameMeta, nvdsmetaextract plugin with nvds_video_meta_serialization library released as part of DS SDK 6.1 onwards, de-serializes this NvDsUserMeta and re-constructs NvDsFrameMeta and NvDsObjectMeta as part of NvDsBatchMeta. Below pipeline demonstrates serialization of NvDsFrameMeta and NvDsObjectMeta by nvdsmetainsert plugin with serialization lib. Serialized metadata is used by nvdsmetaextract plugin to de-serialize and re-construct NvDsFrameMeta and NvDsObjectMeta. Setting CLEAR_NVDS_BATCH_META=yes is needed only for the demonstration of below pipeline, in actual use-case scenario like RDMA transfer this flag is not needed. export CLEAR_NVDS_BATCH_META=yes export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 filesrc location=~/sample_720p.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m ! nvvideoconvert ! nvinfer config-file-path= config_infer_primary.txt \\ ! nvdsmetainsert serialize-lib = &quot;libnvds_video_metadata_serialization.so&quot; \\ ! nvdsmetaextract deserialize-lib = &quot;libnvds_video_metadata_serialization.so&quot; \\ ! nvmultistreamtiler width=1280 height=720 ! nvdsosd ! nveglglessink filesrc location=~/sample_720p.mp4 \\ ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 Use Case 3 - Audio NvDsBatchMeta Serialization : Upstream component sends GstBuffer with serialized NvDsAudioFrameMeta attached as NvDsUserMeta inside NvDsAudioFrameMeta, nvdsmetaextract plugin with nvds_audio_meta_serialization library released as part of DS SDK 6.1 onwards, de-serializes this NvDsUserMeta and re-constructs NvDsAudioFrameMeta as part of NvDsBatchMeta Below pipeline demonstrates serialization of NvDsAudioFrameMeta by nvdsmetainsert plugin with serialization lib. Serialized metadata is used by nvdsmetaextract plugin to de-serialize and re-construct NvDsAudioFrameMeta. Setting CLEAR_NVDS_BATCH_META=yes is needed only for the demonstration of below pipeline, in actual use-case scenario like RDMA transfer this flag is not needed. export CLEAR_NVDS_BATCH_META=yes export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 \\ filesrc location= ~/noise_44_1k_16bits.wav ! wavparse \\ ! audioconvert ! audioresample ! &quot;audio/x-raw, rate=(int)44100&quot; ! queue \\ ! m.sink_0 nvstreammux name=m batch-size=2 ! queue \\ ! nvinferaudio audio-framesize=44100 audio-hopsize=11025 batch-size=2 \\ config-file-path= config_infer_audio_sonyc.txt \\ audio-transform=&quot;melsdb,fft_length=2560,hop_size=692,dsp_window=hann,num_mels=128,sample_rate=44100,p2db_ref=(float)1.0,p2db_min_power=(float)0.0,p2db_top_db=(float)80.0&quot; \\ ! nvdsmetainsert serialize-lib = &quot;libnvds_audio_metadata_serialization.so&quot; \\ ! nvdsmetaextract deserialize-lib = &quot;libnvds_audio_metadata_serialization.so&quot; \\ ! fakesink \\ filesrc location= ~/noise_44_1k_16bits.wav ! wavparse \\ ! audioconvert ! audioresample ! &quot;audio/x-raw, rate=(int)44100&quot; ! m.sink_1", "keywords": []}, {"id": 2789, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NVMM Gst Buffer. Control parameters serialize-lib Output NVMM Gst Buffer in place.", "keywords": []}, {"id": 2790, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsmetautils#use-cases-sample-pipelines", "display_name": "Use Cases & Sample Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "use-cases-sample-pipelines", "priority": -1, "content": "Below are two reference implementations, these can be extended to suit any particular use case. Use Case 1 - Attaching CustomMeta as SEI data in H264 : nvdsmetainsert plugin with sei_serialization library released as part of DS SDK 6.1 onwards, serializes input metadata and attaches it on the same buffer as gst meta, nv encoder embeds this metadata in the bitstream with type as SEI unregistered data. Below pipeline demonstrates generation of dummy bounding boxes by nvdsvideotemplate plugin and this metadata is serialized by nvdsmetainsert plugin with serialization lib. Serialized metadata is used by nv encoder to insert it as SEI unregistered data in H264 bitstream. export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 filesrc location=~/sample_720p.mp4 ! qtdemux ! h264parse \\ ! nvv4l2decoder ! m.sink_0 nvstreammux name=m ! nvdsvideotemplate dummy-meta-insert=1 \\ customlib-name=libcustom_videoimpl.so customlib-props=&quot;scale-factor:0.5&quot; \\ ! nvmultistreamtiler width=640 height=480 ! nvdsmetainsert serialize-lib = &quot;libnvds_sei_serialization.so&quot; \\ ! nvv4l2h264enc bitrate=1000000 ! filesink location=~/ds_maxine_sei.h264 \\ filesrc location=~/sample_720p.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 Use Case 2 - Video NvDsBatchMeta Serialization : nvdsmetainsert plugin with nvds_video_meta_serialization library released as part of DS SDK 6.1 onwards, serializes NvDsFrameMeta and NvDsObjectMeta and attaches as NvDsUserMeta inside NvDsFrameMeta on the same buffer. Below pipeline demonstrates serialization of NvDsFrameMeta and NvDsObjectMeta by nvdsmetainsert plugin with serialization lib. Serialized metadata is used by nvdsmetaextract plugin to de-serialize and re-construct NvDsFrameMeta and NvDsObjectMeta. Setting CLEAR_NVDS_BATCH_META=yes is needed only for the demonstration of below pipeline, in actual use-case scenario like RDMA transfer this flag is not needed. export CLEAR_NVDS_BATCH_META=yes export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 filesrc location=~/sample_720p.mp4 ! qtdemux ! h264parse ! nvv4l2decoder \\ ! m.sink_0 nvstreammux name=m ! nvvideoconvert ! nvinfer config-file-path= config_infer_primary.txt \\ ! nvdsmetainsert serialize-lib = &quot;libnvds_video_metadata_serialization.so&quot; \\ ! nvdsmetaextract deserialize-lib = &quot;libnvds_video_metadata_serialization.so&quot; \\ ! nvmultistreamtiler width=1280 height=720 ! nvdsosd ! nveglglessink filesrc location=~/sample_720p.mp4 \\ ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 Use Case 3 - Audio NvDsBatchMeta Serialization : nvdsmetainsert plugin with nvds_audio_meta_serialization library released as part of DS SDK 6.1 onwards, serializes NvDsAudioFrameMeta and attaches as NvDsUserMeta inside NvDsAudioFrameMeta on the same buffer. Below pipeline demonstrates serialization of NvDsAudioFrameMeta by nvdsmetainsert plugin with serialization lib. Serialized metadata is used by nvdsmetaextract plugin to de-serialize and re-construct NvDsAudioFrameMeta. Setting CLEAR_NVDS_BATCH_META=yes is needed only for the demonstration of below pipeline, in actual use-case scenario like RDMA transfer this flag is not needed. export CLEAR_NVDS_BATCH_META=yes export USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 \\ filesrc location= ~/noise_44_1k_16bits.wav ! wavparse \\ ! audioconvert ! audioresample ! &quot;audio/x-raw, rate=(int)44100&quot; ! queue \\ ! m.sink_0 nvstreammux name=m batch-size=2 ! queue \\ ! nvinferaudio audio-framesize=44100 audio-hopsize=11025 batch-size=2 \\ config-file-path= config_infer_audio_sonyc.txt \\ audio-transform=&quot;melsdb,fft_length=2560,hop_size=692,dsp_window=hann,num_mels=128,sample_rate=44100,p2db_ref=(float)1.0,p2db_min_power=(float)0.0,p2db_top_db=(float)80.0&quot; \\ ! nvdsmetainsert serialize-lib = &quot;libnvds_audio_metadata_serialization.so&quot; \\ ! nvdsmetaextract deserialize-lib = &quot;libnvds_audio_metadata_serialization.so&quot; \\ ! fakesink \\ filesrc location= ~/noise_44_1k_16bits.wav ! wavparse \\ ! audioconvert ! audioresample ! &quot;audio/x-raw, rate=(int)44100&quot; ! m.sink_1", "keywords": []}, {"id": 2791, "doc_id": 2791, "filename": "text/DS_plugin_gst-nvdsmetautils.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsmetautils", "display_name": "Gst-nvdsmetautils", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsmetautils", "anchor": "", "priority": -1, "content": "gst-nvdsmetautils contain nvdsmetainsert and nvdsmetaextract plugins. Below is the detailed explanation of each plugin, purpose and use-cases.", "keywords": []}, {"id": 2792, "doc_id": 2795, "filename": "text/DS_plugin_gst-nvdsosd.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsosd#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsosd", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Supports blurring detected objects The object can be blurred according to the parameters configured. DS 8.0 Supports drawring arrows, lines, circles, text in GPU mode Fill metadata as described in below rows to draw different shapes. (Alpha) DS 6.2 Supports drawing arrows Arrows can be drawn by specifying values in NvOSD_ArrowParams in metadata. DS 5.0 Supports drawing circles Circles can be drawn by specifying values in NvOSD_CircleParams in metadata. DS 5.0 Support for blending bounding boxes Blending boxes can be drawn by specifying bg_color values in NvOSD_RectParams in metadata. DS 4.0 Supports drawing polygon lines Lines can be drawn by specifying values in NvOSD_LineParams in metadata. DS 3.0 Supports drawing text using Pango and Cairo libraries Text can be drawn by specifying values in NvOSD_TextParams in metadata. DS 2.0 CPU mode and GPU support for drawing bounding boxes. Setting opacity for bounding box borders is not supported in gpu mode. Bounding boxes can be drawn by specifying values in NvOSD_RectParams in metadata. DS 2.0", "keywords": []}, {"id": 2793, "doc_id": 2795, "filename": "text/DS_plugin_gst-nvdsosd.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsosd#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsosd", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsosd plugin. Property Meaning Type and Range Example Notes gpu-id Device ID of the GPU to be used for operation (dGPU only) Integer, 0 to 4,294,967,295 gpu-id=0 display-clock Indicates whether to display system clock Boolean display-clock=0 display-text Indicates whether to display text Boolean display-text=0 clock-font Name of Pango font to use for the clock for CPU process mode, name of TrueType font to use for the clock and other text for GPU process mode String clock-font=Arial clock-font-size Font size to use for the clock Integer, 0-60 clock-font-size=2 x-clock-offset X offset of the clock Integer, 0 to 4,294,967,295 x-clock-offset=100 y-clock-offset Y offset of the clock Integer, 0 to 4,294,967,295 y-clock-offset=50 clock-color Color of the clock to be set while display, in the order 0xRGBA Integer, 0 to 4,294,967,295 clock-color=0xff0000ff (Clock is red with alpha=1) process-mode Indicates the mode used to draw the objects Default mode: CPU mode 0: CPU mode 1: GPU mode Integer, 0 to 2 process-mode=0 display-bbox Control bounding box drawing Boolean display-bbox=1 display-mask Controls instance mask drawing Boolean display-mask=1 blur-bbox Control object blurring(GPU mode only) Boolean blur-bbox=1 blur-on-gie-class-ids Select the object to blur(GPU mode only and the blur-bbox must be 1) Semicolons and commas delimited values blur-on-gie-class-ids=0,1;1,0;2,1 format:&lt;gie_id,class_id;gie_id,class_id\u2026&gt;", "keywords": []}, {"id": 2794, "doc_id": 2795, "filename": "text/DS_plugin_gst-nvdsosd.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsosd#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsosd", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs RGBA buffer for CPU process mode. RGBA/NV12 PL/NV12 BL buffer for GPU process mode. NvDsBatchMeta (holds NvDsFrameMeta consisting of bounding boxes, text parameters, and lines parameters) NvDsLineMeta (RoI polygon) Control parameters gpu-id (dGPU only) display-clock display-text clock-font clock-font-size x-clock-offset y-clock-offset clock-color process-mode display-bbox display-mask blur-bbox blur-on-gie-class-ids Output RGBA/NV12 PL/NV12 BL buffer modified in place to overlay bounding boxes, texts, and polygons represented in the metadata", "keywords": []}, {"id": 2795, "doc_id": 2795, "filename": "text/DS_plugin_gst-nvdsosd.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsosd", "display_name": "Gst-nvdsosd", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsosd", "anchor": "", "priority": -1, "content": "This plugin draws bounding boxes, text, arrows, lines, circles and region of interest (RoI) polygons. (Polygons are presented as a set of lines.) The plugin accepts an RGBA buffer with attached metadata from the upstream component when CPU process mode. It can accepts RGBA/NV12 PL/NV12 BL buffer when GPU process mode. It draws bounding boxes, which may be shaded depending on the configuration (e.g. width, color, and opacity) of a given bounding box. It also draws text and RoI polygons at specified locations in the frame. Text and polygon parameters are configurable through metadata.", "keywords": []}, {"id": 2796, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspostprocess#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Detection output parsing Parses detector tensor data and attaches the results as object metadata DS 6.1 Classification output parsing Parses Classification tensor data and attaches the result as classifier attributes in metadata DS 6.1 Yolo detector (YoloV3/V3-tiny/V2/V2-tiny) parsing Support for parsing of Yolo detector output DS 6.1 FasterRCNN output parsing \u2014 DS 6.1 Single Shot Detector (SSD) output parsing \u2014 DS 6.1", "keywords": []}, {"id": 2797, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspostprocess#gst-nvdspostprocess-file-configuration-specifications", "display_name": "Gst-nvdspostprocess File Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "gst-nvdspostprocess-file-configuration-specifications", "priority": -1, "content": "The Gst-nvdspreprocess configuration file uses a \u201cYAML\u201d format Refer to examples like config_detector.yml, config_classifier_car_color.yml located at /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspostprocess/ . The property group configures the general behavior of the plugin. The class-attrs-all group configures parameters for all classes for detector post processor. The class-attrs-&lt;id&gt; group configures parameters &lt;id&gt; specific class for detector post processor. The following two tables describes the keys supported for property groups and class-attrs-&lt;id&gt; groups respectively. Property Meaning Type and Range Example gpu-id GPU to be used for processing Integer gpu-id: 0 process-mode Mode of operation Full Frame (Primary 1) or on Object (Secondary 2) Integer 1=Primary(On Full Frame) ,2=Secondary (On Object) process-mode: 1 gie-unique-id Perform tensor meta parsing on output of gie-unique-id Integer &gt;0 gie-unique-id: 1 num-detected-classes Number of classes detected by Detector network Integer &gt;0 num-detected-classes: 4 cluster-mode Clustering mode to be used on detector output Integer 1=DBSCAN 2=NMS 3=DBSCAN+NMS Hybrid 4=None(No Clustering) cluster-mode: 2 output-blob-names Array of output layer names which are to be parsed String delimited by semicolon output-blob-names: conv2d_bbox;conv2d_cov/Sigmoid network-type Type of network to be parsed Integer 0=Detector 1=Classifier network-type: 1 labelfile-path Pathname of a text file containing the labels for the model String labelfile-path: /opt/nvidia/deepstream/deepstream/samples/models/Primary_Detector/labels.txt classifier-threshold Minimum threshold label probability. The GIE outputs the label having the highest probability if it is greater than this threshold Float, &gt;0.0 classifier-threshold: 0.4 operate-on-gie-id Unique ID of the GIE on whose metadata (bounding boxes) this GIE is to operate on, applicable for process-mode=2 Integer &gt;0 operate-on-gie-id: 1 parse-classifier-func-name Name of the custom classifier output parsing function. If not specified, post process lib uses the parsing function for softmax layers. String parse-classifier-func-name: NvDsPostProcessClassiferParseCustomSoftmax parse-bbox-func-name Name of the custom bounding box parsing function. If not specified, post process lib uses the function for the resnet model provided by the SDK String parse-bbox-func-name: NvDsPostProcessParseCustomResnet Property Meaning Type and Range Example topk Keep only top K objects with highest detection scores. Integer, &gt;0. -1 to disable topk: 10 nms-iou-threshold Maximum IOU score between two proposals after which the proposal with the lower confidence will be rejected. Float, &gt;0.0 nms-iou-threshold: 0.2 pre-cluster-threshold Detection threshold to be applied prior to clustering operation Float, &gt;0.0 pre-cluster-threshold: 0.5 post-cluster-threshold Detection threshold to be applied post clustering operation Float, &gt;0.0 post-cluster-threshold: 0.5 eps Epsilon values for DBSCAN algorithm Float, &gt;0.0 eps: 0.2 dbscan-min-score Minimum sum of confidence of all the neighbors in a cluster for it to be considered a valid cluster. Float, &gt;0.0 dbscan-min-score: 0.7", "keywords": []}, {"id": 2798, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspostprocess#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdspostprocess plugin. Property Meaning Type and Range Example notes gpu-id Device ID of GPU to use for post-processing (dGPU only) Integer,0-4,294,967,295 gpu-id=1 postprocesslib-name Low level Post process library to be used for output parsing string postprocesslib-name=./postprocesslib_impl/libpostprocess_impl.so postprocesslib-config-file Set postprocess yaml config file to be used string postprocesslib-config-file= config_detector.yml", "keywords": []}, {"id": 2799, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspostprocess#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Input Video Gst Buffers Metadata (NvDsBatchMeta) Tensor Meta (NvDsInferTensorMeta) Control parameters postprocesslib-config-file postprocesslib-name gpu-id Output Output Video Gst Buffers Original Metadata (NvDsBatchMeta) (with addition of Object Meta/Classifier Meta)", "keywords": []}, {"id": 2800, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspostprocess#sample-pipelines", "display_name": "Sample pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "sample-pipelines", "priority": -1, "content": "Given below are some sample pipelines, please set appropriate configuration file and library paths. For multi-stream detector and classifier (dGPU): gst-launch-1.0 uridecodebin \\ uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 \\ ! m.sink_0 nvstreammux name=m width=1920 height=1080 batch-size=2 ! \\ nvinfer config-file-path=config_infer_primary_post_process.txt \\ ! nvdspostprocess \\ postprocesslib-config-file=config_detector.yml \\ postprocesslib-name= ./postprocesslib_impl/libpostprocess_impl.so \\ ! queue ! nvinfer \\ config-file-path= config_infer_secondary_vehiclemake_postprocess.txt \\ ! nvdspostprocess \\ postprocesslib-config-file= config_classifier_vehicle_make.yml \\ postprocesslib-name= ./postprocesslib_impl/libpostprocess_impl.so ! queue ! nvinfer \\ config-file-path= config_infer_secondary_vehicletypes_postprocess.txt \\ ! nvdspostprocess postprocesslib-config-file= \\ config_classifier_vehicle_type.yml postprocesslib-name= \\ ./postprocesslib_impl/libpostprocess_impl.so ! queue ! nvmultistreamtiler ! nvvideoconvert \\ gpu-id=0 ! nvdsosd ! nveglglessink sync=1 -v uridecodebin \\ uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! m.sink_1 For multi-stream detector and classifier (Jetson): gst-launch-1.0 uridecodebin \\ uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 \\ ! m.sink_0 nvstreammux name=m width=1920 height=1080 batch-size=2 ! \\ nvinfer config-file-path=config_infer_primary_post_process.txt \\ ! nvdspostprocess \\ postprocesslib-config-file=config_detector.yml \\ postprocesslib-name= ./postprocesslib_impl/libpostprocess_impl.so \\ ! queue ! nvinfer \\ config-file-path= config_infer_secondary_vehiclemake_postprocess.txt \\ ! nvdspostprocess \\ postprocesslib-config-file=config_classifier_vehicle_make.yml \\ postprocesslib-name= ./postprocesslib_impl/libpostprocess_impl.so ! queue ! nvinfer \\ config-file-path= config_infer_secondary_vehicletypes_postprocess.txt \\ ! nvdspostprocess postprocesslib-config-file= \\ config_classifier_vehicle_type.yml postprocesslib-name= \\ ./postprocesslib_impl/libpostprocess_impl.so ! queue ! nvmultistreamtiler ! nvvideoconvert \\ gpu-id=0 ! nvdsosd ! nv3dsink sync=1 -v uridecodebin \\ uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! m.sink_1", "keywords": []}, {"id": 2801, "doc_id": 2801, "filename": "text/DS_plugin_gst-nvdspostprocess.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdspostprocess", "display_name": "Gst-nvdspostprocess (Alpha)", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdspostprocess", "anchor": "", "priority": -1, "content": "The Gst-nvdspostprocess plugin is a customizable plugin which provides a custom library interface for post processing on Tensor output of inference plugins ( nvinfer/nvinferserver ). Currently the plugin supports detection and classification models for parsing. The plugin connects to post processing lib provided as plugin parameter. The parsing parameters can be specified via a config file. Refer to section Gst-nvdspostprocess File Configuration Specifications below for more details. For the plugin to perform parsing of inference tensor output, it is necessary to attach tensor output by setting output-tensor-meta as 1 in inference configuration file and disabling parsing in the inference plugin by setting network-type as 100 i.e. network type other. Similarly, in Gst-nvinferserver we can enable the following configs in the configuration file. output_control { output_tensor_meta : true } and to disable native post processing, update: infer_config { postprocess { other {} } } . Default plugin implementation provides following functionalities. It parses the tensor meta attached to frame meta or object meta. Attaches the output of tensor parsing either to frame meta or object meta. The default custom library (postprocesslib_impl) provided with the plugin implements these functionalities. It can be configured to parse detection and classification networks. For multiple inference plugins in pipeline require multiple post process plugin instances corresponding to them.", "keywords": []}, {"id": 2802, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#custom-library-interfaces", "display_name": "Custom library Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "custom-library-interfaces", "priority": -1, "content": "custom_transform =&gt; An Interface to implement custom transformation for different group of streams. Default implementation provides group transformation functionalities of ROIs specified in the config fie. custom_tensor_function =&gt; An interface to provide custom tensor preparation function. Default implementation prepares raw tensor from transformed ROIs", "keywords": []}, {"id": 2803, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Per stream/group of streams ROI processing Process on the pre-defined ROIs having same processing algorithm inside a group DS 6.0 Processing on full frames/ROIs Enable process-on-roi inside [group-*] to process on ROIs DS 6.0 Custom library interface Custom functionality using group transformation and tensor preparation functions DS 6.0 Custom group transformation function For each group separate custom transformation functions can be provided from custom lib (e.g. scale &amp; conversion) DS 6.0 Custom tensor preparation function Custom tensor preparation function from custom library to prepare raw tensor from already transformed ROIs/full-frames DS 6.0 Attach user meta at batch level User meta (NvDsPreProcessBatchMeta) having raw tensor and Scaled &amp; converted ROIs DS 6.0 Support for SGIE Mode Supports processing on objects detected by PGIE model DS 6.2", "keywords": []}, {"id": 2804, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#gst-nvdspreprocess-file-configuration-specifications", "display_name": "Gst-nvdspreprocess File Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "gst-nvdspreprocess-file-configuration-specifications", "priority": -1, "content": "The Gst-nvdspreprocess configuration file uses a \u201cKey File\u201d format described in https://specifications.freedesktop.org/desktop-entry-spec/latest . Refer to config_preprocess.txt at /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt . The [property] group configures the general behavior of the plugin. The [group-&lt;id&gt;] group configures ROIs/full-frames for a group of streams with src-ids and custom-input-transformation-function from custom lib. The [user-configs] group configures parameters required by the custom library, which is passed on to custom lib through a map of &lt;string,string&gt; as key-value pair. custom lib needs to parse the values accordingly. The following two tables describes the keys supported for [property] groups and [group-&lt;id&gt;] groups respectively. Property Meaning Type and Range Example enable If set then to enable the plugin else in passthrough mode Boolean enable=1 unique-id Uniquely identify the metadata generated by this element Integer, | 0 to 4,294,967,295 unique-id=1 gpu-id Device ID of GPU to use for pre-processing (dGPU only) Integer,0-4,294,967,295 gpu-id=1 process-on-frame Preprocessing Modes 1=PGIE Mode 0=SGIE Mode Boolean process-on-frame=1 target-unique-ids List of component gie-id for which tensor is prepared Semicolon delimited integer(gie-ids) array of values &gt;=0 target-unique-ids=3;4;5 operate-on-gie-id Unique gie-id whoes metadata is to be preprocessed (ignored if process-on-frame enabled) Integer, 0 to 4,294,967,295 operate-on-gie-id=1 network-input-order Order of the network input layer Integer 0=NCHW 1=NHWC 2=CUSTOM network-input-order=0 network-input-shape Tensor shape of network input layer as per network-input-order Semicolon delimited integer array of values &gt; 0 network-input-shape=60;3;368;640 maintain-aspect-ratio If set then maintain the aspect ratio while scaling Boolean maintain-aspect-ratio symmetric-padding If set then pad symmetrically (ignored if maintain-aspect-ratio disabled) Boolean symmetric-padding processing-width Width at which ROIs scaled Integer&gt;0 processing-width=640 processing-height Height at which ROIs scaled Integer&gt;0 processing-height=368 scaling-buf-pool-size Size of scaling buffer pool Integer&gt;0 scaling-buf-pool-size=6 tensor-buf-pool-size Size of tensor buffer pool Integer&gt;0 tensor-buf-pool-size=6 network-color-format Color format of model Integer 0=RGB 1=BGR 2=GRAY network-color-format=0 tensor-data-type Data format for inference Integer 0=FP32 1=UINT8 2=INT8 3=UINT32 4=INT32 5=FP16 tensor-data-type=0 tensor-name Network input layer name String tensor-name=Input_1 scaling-pool-memory-type Memory type for scaling buffer pool Integer 0=NVBUF_MEM_DEFAULT 1=NVBUF_MEM_CUDA_PINNED 2=NVBUF_MEM_CUDA_DEVICE 3=NVBUF_MEM_CUDA_UNIFIED 4=NVBUF_MEM_SURFACE_ARRAY scaling-pool-memory-type=2 scaling-pool-compute-hw Type of computing hardware for scaling Integer 0=NvBufSurfTransformCompute_Default 1=NvBufSurfTransformCompute_GPU 2=NvBufSurfTransformCompute_VIC scaling-pool-compute-hw=0 scaling-filter Scaling interpolation method Integer 0=NvBufSurfTransformInter_Nearest 1=NvBufSurfTransformInter_Bilinear 2=NvBufSurfTransformInter_Algo 3=NvBufSurfTransformInter_Algo2 4=NvBufSurfTransformInter_Algo3 5=NvBufSurfTransformInter_Algo4 6=NvBufSurfTransformInter_Default scaling-filter=0 custom-lib-path Path of custom library .so file String custom-lib-path=/opt/nvidia/deepstream/deepstream/lib/gst-plugins/libcustom2d_preprocess.so custom-tensor-preparation-function Name of tensor preparation function from custom lib String custom-tensor-preparation-function=CustomTensorPreparation Property Meaning Type and Range Example src-ids Source IDs on which this group applies Semicolon delimited integer array of values &gt;=0 src-ids=0;1;2;3 custom-input-transformation-function Name of Custom input transformation function from custom library String custom-input-transformation-function=CustomTransformation process-on-roi If enabled process on ROIs else on full-frames (ignored if process-on-frame disabled) Boolean process-on-roi=1 roi-params-src-&lt;id&gt; Roi coordinates for source &lt;id&gt;. for each ROI specify left;top;width;height defining the ROI if process-on-roi enabled. Semicolon delimited integer array of values &gt;=0 roi-params-0=0;540;900;500;960;0;900;500 operate-on-class-ids Preprocessing is done only on the objects belongs to these class-ids (ignored if process-on-frame enabled) Semicolon delimited integer(class-ids) array of values &gt;=0 operate-on-class-ids=0;1 process-on-all-objects If enabled process all the objects else process the objects within the roi (ignored if process-on-frame enabled) Boolean process-on-all-objects=1 draw-roi If enabled specified roi\u2019s are drawn on display else roi\u2019s are not drawn Boolean draw-roi=1 roi-color Color of roi to be displayed Semicolon delimited color components values R;G;B;A roi_color=0;1;1;1 input-object-min-width Minimum width of objects which are to be processed Integer, \u22650 input-object-min-width=100 input-object-min-height Minimum height of objects which are to be processed Integer, \u22650 input-object-min-height=100 input-object-max-width Maximum width of objects which are to be processed Integer, \u22650 input-object-max-width=500 input-object-max-height Maximum height of objects which are to be processed Integer, \u22650 input-object-max-height=500 The following table describes the keys supported for [user-configs] group for custom library nvdspreprocess_lib . Property Meaning Type and Range Example pixel-normalization-factor factor at which pixels are scaled Float pixel-normalization-factor=\u00ad0.031 offsets Array of mean values of color components to be subtracted from each pixel. Array length must equal the number of color components in the frame. The plugin multiplies mean values by pixel-normalization-factor Semicolon delimited float array of values \u22650 offsets=77.5;21.2;11.8 mean-file pathname of mean data file (PPM format) String mean-file=/home/ubuntu/model_meanfile.ppm The following table describes the keys supported for [user-configs] group for custom library libnvds_custom_sequence_preprocess.so . which gets used in deepstream-3d-action-recognition sample app. Property Meaning Type and Range Example channel-scale-factors scale factor list for each channel Semicolon delimited float array channel-scale-factors= 0.007843137;0.007843137;0.007843137 channel-mean-offsets data mean offsets for each channel Semicolon delimited float array channel-mean-offsets=127.5;127.5;127.5 stride sequence sliding stride for each batched sequnece Unsigned Integer, value &gt;= 1 stride=1 subsample Subsample rates for inference images in each sequence Unsigned Integer, value &gt;= 0 subsample=0", "keywords": []}, {"id": 2805, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdspreprocess plugin. Property Meaning Type and Range Example notes unique-id Uniquely identify the metadata generated by this element Integer, | 0 to 4,294,967,295 unique-id=1 gpu-id Device ID of GPU to use for pre-processing (dGPU only) Integer,0-4,294,967,295 gpu-id=1 config-file Path of configuration file for the Gst-nvdspreprocess element String config-file=config_preprocess.txt enable Enable gst-nvdspreprocess plugin or set in passthrough mode Boolean enable=1 process-on-frame Preprocessing Modes 1=PGIE Mode 0=SGIE Mode Boolean process-on-frame=1 target-unique-ids List of component gie-id for which tensor is prepared Semicolon delimited integer(gie-ids) array of values &gt;=0 target-unique-ids=3;4;5 operate-on-gie-id Unique gie-id whoes metadata is to be preprocessed (ignored if process-on-frame enabled) Integer, 0 to 4,294,967,295 operate-on-gie-id=1", "keywords": []}, {"id": 2806, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Input Video Gst Buffers Metadata (NvDsBatchMeta) Control parameters config-file Output Output Video Gst Buffers Metadata (NvDsBatchMeta) + User Metadata at batch level (NvDsPreProcessBatchMeta)", "keywords": []}, {"id": 2807, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdspreprocess#sample-pipelines", "display_name": "Sample pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "sample-pipelines", "priority": -1, "content": "Given below are some sample pipelines to demonstrate preprocess plugin\u2019s usage, please set the appropriate configuration file and library paths. Preprocess in PGIE mode for single stream (dGPU): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt \\ input-tensor-meta=1 batch-size=7 ! nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nveglglessink Preprocess in PGIE mode for single stream (Jetson): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt \\ input-tensor-meta=1 batch-size=2 ! nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nv3dsink Preprocess in PGIE mode for Multi-stream (dGPU): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=4 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt \\ input-tensor-meta=1 batch-size=8 ! nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nveglglessink \\ filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! \\ m.sink_1 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! \\ nvv4l2decoder ! m.sink_2 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_3 Preprocess in PGIE mode for Multi-stream (Jetson): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=4 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt \\ input-tensor-meta=1 batch-size=8 ! nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nv3dsink \\ filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! \\ m.sink_1 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! \\ nvv4l2decoder ! m.sink_2 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_3 Preprocess in PGIE and SGIE Mode for single stream (dGPU): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt unique-id=1 \\ batch-size=2 input-tensor-meta=1 ! nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess_sgie.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt input-tensor-meta=1 unique-id=3 ! \\ nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nveglglessink Preprocess in PGIE and SGIE Mode for single stream (Jetson): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt unique-id=1 \\ batch-size=2 input-tensor-meta=1 ! nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess_sgie.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt input-tensor-meta=1 unique-id=3 ! \\ nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nv3dsink Preprocess in PGIE and SGIE Mode for Multi-stream (dGPU): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt unique-id=1 \\ batch-size=8 input-tensor-meta=1 ! nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess_sgie.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt input-tensor-meta=1 unique-id=3 ! \\ nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nveglglessink filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! \\ qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! \\ m.sink_2 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_3 Preprocess in PGIE and SGIE Mode for Multi-stream (Jetson): gst-launch-1.0 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! \\ h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvvideoconvert ! \\ nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt unique-id=1 \\ batch-size=8 input-tensor-meta=1 ! nvdspreprocess config-file= /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspreprocess/config_preprocess_sgie.txt ! \\ nvinfer config-file-path= /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt input-tensor-meta=1 unique-id=3 ! \\ nvmultistreamtiler width=1920 height=1080 ! nvvideoconvert ! nvdsosd ! nv3dsink filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! \\ qtdemux ! h264parse ! nvv4l2decoder ! m.sink_1 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! \\ m.sink_2 filesrc location = /opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_3", "keywords": []}, {"id": 2808, "doc_id": 2808, "filename": "text/DS_plugin_gst-nvdspreprocess.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdspreprocess", "display_name": "Gst-nvdspreprocess (Alpha)", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdspreprocess", "anchor": "", "priority": -1, "content": "The Gst-nvdspreprocess plugin is a customizable plugin which provides a custom library interface for preprocessing on input streams. Each stream can have its own preprocessing requirements. (e.g. per stream ROIs - Region of Interests processing) Streams with same preprocessing requirements are grouped and processed together. These requirements can be specified via a config file. Refer to section Gst-nvdspreprocess File Configuration Specifications below for more details. Default plugin implementation provides two functionalities. Streams with predefined ROIs (Region of Interests) are scaled and format converted as per the network requirements for inference. Per stream ROIs are specified in the config file. It prepares a raw tensor from the scaled &amp; converted ROIs. It is passed to the downstream plugins via user metadata. Downstream plugins can access this tensor for inference. The default custom library (nvdspreprocess_lib) provided with the plugin implements these functionalities. It contains the group transformation (scaling and conversion functionality per group) and tensor preparation functions for 2d convolution NCHW/NHWC models. User can implement its own library with group transformation functions and tensor preparation function as per the requirements. This plugin can operate in two modes PGIE and SGIE. Preprocess with PGIE mode is used to process the given ROI/Frame on which we want to perform primary inferencing. Preprocess with SGIE mode is used to process the detected objects within the given ROI/Frame on which we want to perform secondary inferencing.", "keywords": []}, {"id": 2809, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsucx#description", "display_name": "Description", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "description", "priority": -1, "content": "Gst-NvDsUcx provides separate sink (to receive data from the pipeline) and source elements (to forward data to the pipeline), which connect to each other over the RDMA network. Furthermore, each sink or source type element can be a server or client, where the server element must be started before the client. As a result, the Gst-NvDsUcx plugin provides 4 elements: nvdsucxserversink, nvdsucxclientsink, nvdsucxserversrc, nvdsucxclientsrc . Since the Gst-NvDsUcx plugin needs to present itself as a sink and source to the Deepstream pipeline, you need to pair the elements based on which part of the pipeline needs to be started first: nvdsucxserversink &lt;-&gt; nvdsucxclientsrc (Sink side starts first) nvdsucxclientsink &lt;-&gt; nvdsucxserversrc (Source side starts first)", "keywords": []}, {"id": 2810, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsucx#examples", "display_name": "Examples", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "examples", "priority": -1, "content": "The DeepStream SDK 6.1+ includes three examples on how to use the Gst-NvDsUcx plugin to disaggregate/divide the Gstreamer pipeline to run on separate processes/servers. Note that each example has a server and client program to run different parts of the pipeline separately. Always start the server program before the client program. Example 1: The example here shows how to send/receive video data in the Gstreamer pipeline using serversink and clientsrc elements of the Gst-NvDsUcx plugin. The pipeline uses the uridecodebin and the nvvideoconverter plugins to pass the video frames to the serversink element based on the caps filter. The serversink forwards this video data to the clientsrc element (on another node/process using RDMA), which then forwards the data to the video converter. Finally, the data is stored in a file after encoding. On DS Node 1: gst-launch-1.0 uridecodebin uri=&quot;file:///sample_1080p.mp4&quot; async-handling=1 name=src1 src1. ! \\ queue ! nvvideoconvert ! &#x27;video/x-raw(memory:NVMM),format=NV12,width=1920,height=1080&#x27; ! \\ nvdsucxserversink addr=192.168.100.1 port=4000 buf-type=nvdsucx-buf-video On DS Node 2: gst-launch-1.0 nvdsucxclientsrc addr=192.168.100.1 port=4000 nvbuf-memory-type=2 num-nvbuf=4 buf-type=nvdsucx-buf-video ! \\ &#x27;video/x-raw(memory:NVMM),format=NV12,width=1920,height=1080,framerate=30/1&#x27; ! \\ queue ! nvvideoconvert ! nvv4l2h264enc ! h264parse ! qtmux name=mux_0 ! \\ filesink sync=1 async=0 qos=0 location=~/out_1080p.mp4 Example 2: This example shows how to distribute the DS pipeline using Gst-NvDsUcx plugin and use serialization / de-serialization components to send serialized data over RDMA network. The Deepstream pipeline here consists of the streammux plugin that takes input from the filesrc after decoding. The streammux passes the frames to the nvinfer plugin that identifies certain objects in the frames and add that metadata to the frame. The serialization plugin (part of the Gst-NvDsMetaUtils library) creates a binary object corresponding to the metadata and adds it to the frame. The clientsink and serversrc elements are used here to demonstrate the flexiblity of setup of the Gst-NvDsUcx here. The clientsink will send the additional metadata along with the video frame via RDMA to the serversrc. The serversrc then forwards the data to the deserialization plugin which extracts it to append the metadata correctly to the frame. The nvdsosd plugin interprets the metadata (bounding boxes) and then the file is stored after encoding. On DS Node 1: gst-launch-1.0 filesrc location=~/sample_1080p.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 ! \\ nvvideoconvert ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream-6.1/samples/configs/deepstream-app/config_infer_primary.txt ! \\ nvdsmetainsert serialize-lib = &quot;/opt/nvidia/deepstream/deepstream-6.1/lib/libnvds_video_metadata_serialization.so&quot; ! \\ nvdsucxclientsink addr=192.168.100.1 port=4000 buf-type=nvdsucx-buf-video On DS Node 2: gst-launch-1.0 nvdsucxserversrc addr=192.168.100.1 port=4000 nvbuf-memory-type=2 num-nvbuf=8 buf-type=nvdsucx-buf-video nvbuf-batch-size=1 ! \\ &#x27;video/x-raw(memory:NVMM),format=NV12,width=1920,height=1080,framerate=30/1&#x27; ! nvvideoconvert ! \\ nvdsmetaextract deserialize-lib = &quot;/opt/nvidia/deepstream/deepstream-6.1/lib/libnvds_video_metadata_serialization.so&quot; ! \\ nvdsosd ! nvvideoconvert ! nvv4l2h264enc ! h264parse ! qtmux ! filesink location=~/out_1080p.mp4 Example 3: This example demonstrates how audio data in a DS pipeline can be distributed across processes or nodes using the Gst-NvDsUcx and the Audio metadata serialization (part of Gst-NvDsMetaUtils) plugins. The streammux plugin interprets the audio data from the audio plugins and forwards it to the Gst-NvDsUcx plugin. Similar to the video metadata serialization plugin in Example 2, the audio metadata serialization plugin creates a binary object which the serversink element forwards to the clientsrc element. The audio metadata is extracted and added to the buffer for downstream plugins to interpret. The streammux and streamdemux plugins only support audio in the new versions, so an environment variable must be set before the example is run. On DS Node 1: USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 uridecodebin uri=&quot;file:///sample_1080p_h264.mp4&quot; ! audioconvert ! \\ audioresample ! &#x27;audio/x-raw,format=F32LE,rate=48000,channels=1,layout=interleaved&#x27; ! audiobuffersplit ! \\ a_streammux.sink_0 nvstreammux name=a_streammux batch-size=1 sync-inputs=1 max-latency=250000000 ! \\ nvdsmetainsert serialize-lib=&quot;libnvds_audio_metadata_serialization.so&quot; ! \\ nvdsucxserversink addr=192.168.100.2 port=4000 sync=1 async=0 buf-type=nvdsucx-buf-nv-audio On DS Node 2: USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 nvdsucxclientsrc addr=192.168.100.2 port=4000 nvbuf-memory-type=2 num-nvbuf=4 buf-type=nvdsucx-buf-nv-audio ! \\ &#x27;audio/x-raw(memory:NVMM),format=F32LE,rate=48000,channels=1,layout=interleaved&#x27; ! \\ nvdsmetaextract deserialize-lib = &quot;libnvds_audio_metadata_serialization.so&quot; ! nvstreamdemux name=asd asd.src_0 ! \\ audioconvert ! &quot;audio/x-raw,format=S16LE&quot; ! wavenc ! filesink sync=0 async=1 qos=0 location=out.wav", "keywords": []}, {"id": 2811, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsucx#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "gst-properties", "priority": -1, "content": "The Gst-nvdsucx plugin has the following properties based on which type of element is used: Property Type of Element Description Type and Range Examples addr Server The IP address to which a client will connect String Default: 127.0.0.1 addr = 192.168.100.1 addr Client The server IP address String Default: 127.0.0.1 addr = 192.168.100.1 port Server Listening port for connections from clients Integer 0 - 66535 Default: 7174 port = 4000 port Client The server port number Integer 0 - 65535 Default: 7174 port = 4000 buf-type All Type of data handled by UCX: 0 - video 1 - audio 2 - raw-audio 4 - text Default: 0 Integer buf-type = 0 gpu-id Source GPU ID to use Integer 0 - 4294967295 Default: 0 gpu-id=0 raw-buf-size All Size of raw buffer to allocate Integer 0 - 8192 Default: 8192 raw-buf-size=1024 nvbuf-memory-type Source Type of NvBufSurface Memory to allocate for output buffers 0 - Default memory 1 - cuda-pinned (Allocate Pinned/Host Cuda Memory) 2 - cuda-device (Allocate Device cuda Memory) 3 - cuda-unified (Allocate unified cuda memory) Default: 3 Integer nvbuf-memory-type = 2 num-nvbuf Source The number of Nv Buffers to allocate Integer 0 - 10 Default: 4 num-nvbuf = 8 nvbuf-batch-size All The maximal batch size of a Nv Buffer Integer 1 - 2147483647 Default: 1 nvbuf-batch-size = 4 num-conns ServerSink The number of client connections to expect 1 Integer 1 - 4 Default: 1 num-conns = 2 Footnote 1 These connections are established synchronously. The serversink plugin will always wait till all clients connect before starting the pipeline. Only, the serversink plugin supports more than one clientsrc connecting. The serversrc plugin will support only 1 connection from a clientsink.", "keywords": []}, {"id": 2812, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsucx#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs (for Nvdsucxserversink or Nvdsucxclientsink) Any one of the following: NV12/RGBA NVMM Gst Buffer + (NvDsBatchMeta + Serialized NvDsUserMeta/Gst Meta - optional) NVMM or Raw Audio Buffers + (NvDsBatchMeta - optional) Raw Text Gst Buffers Control parameters addr port buf-type gpu-id raw-buf-size nvbuf-memory-type num-nvbuf nvbuf-batch-size num-conns Output (from Nvdsucxserversrc or Nvdsucxclientsrc) Any one of the following: NV12/RGBA NVMM Gst Buffer + (NvDsBatchMeta + Serialized Video NvDsUserMeta/Gst Meta - optional) NVMM or Raw Audio Buffers + (NvDsBatchMeta + Serialized Audio NvDsUserMeta/Gst Meta - optional) Raw Text Gst Buffers", "keywords": []}, {"id": 2813, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsucx#requirements", "display_name": "Requirements", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "requirements", "priority": -1, "content": "The Gst-NvDsUcx plugin has the following requirements (in addition to the Deepstream 6.3 SDK requirements): NVIDIA ConnectX6-DX NIC or later. For more information on installing and configuring NICs, see: https://docs.nvidia.com/networking/display/ConnectX6VPI/Introduction Mellanox Open Fabrics Enterprise Distribution (MLNX_OFED) - version 5.5 or later, see https://network.nvidia.com/products/infiniband-drivers/linux/mlnx_ofed/ For installation instructions, see https://docs.nvidia.com/networking/display/MLNXOFEDv551032/Installing+MLNX_OFED If installing the Mellanox OFED within a container: Make sure to install the kernel drivers in the host OS by passing the --all flag to mlnxofedinstall script. In the container you can only install the user space libraries using the --user-space-only flag to the mlnxofedinstall script. UCX - version 1.13 or later - needs to be compiled with CUDA support or use CUDA-enabled UCX packages from the git repository directly, see openucx/ucx For installation instructions, follow the Release build instructions from here: openucx/ucx . Note that UCX library should be compiled with CUDA as follows: $ ./contrib/configure-release --prefix=/install/path --enable-examples --with-java=no --with-cuda=/path/to/cuda --enable-mt Docker container support If you wish to use the plugin inside a container, make sure to add the following flags during docker run command: --privileged --network host --cap-add CAP_SYS_PTRACE --shm-size=&quot;8g&quot; --device=/dev/infiniband/uverbs0 --device=/dev/infiniband/rdma_cm --ipc=host -e CUDA_CACHE_DISABLE=0 -v /dev/infiniband:/dev/infiniband For additional metadata processing, Gst-NvDsUcx depends on the serialization library provided by the Gst-NvDsMetaUtils plugin.Refer to the Gst-NvDsMetaUtils documentation for configuring and installing the serialization library. This plugin is only supported on x86_64 platforms.", "keywords": []}, {"id": 2814, "doc_id": 2814, "filename": "text/DS_plugin_gst-nvdsucx.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsucx", "display_name": "Gst-NvDsUcx", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsucx", "anchor": "", "priority": -1, "content": "Gst-NvDsUcx is a Gstreamer plugin that provides a set of elements that can be used to send and receive pipeline data using RDMA. This allows for distributing the Gstreamer pipeline to various hosts in order to use distributed GPU resources. It is built on top of the Unified Communication X (UCX) library to send/receive Gstreamer packets over an RDMA-enabled network. UCX is an open-source library that accelerates data over high-performance networks and can utilize GPUDirect RDMA technology for minimal network latencies and highest throughput of distributed GPU traffic. For more details on UCX, see https://openucx.org .", "keywords": []}, {"id": 2815, "doc_id": 2819, "filename": "text/DS_plugin_gst-nvdsudpsink.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsink#example-pipelines", "display_name": "Example pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsink", "anchor": "example-pipelines", "priority": -1, "content": "Pipeline to transmit 24 bit 2 channel 48k audio stream using Rivermax media API: gst-launch-1.0 audiotestsrc wave=8 ! &#x27;audio/x-raw, format=(string)S24BE, rate=48000, channels=2, payload=(int)97&#x27; ! rtpL24pay ptime-multiple=1000000 max-ptime=1000000 seqnum-offset=0 pt=97 ! nvdsudpsink host=&lt;ip address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; sdp-file=&lt;sdp file&gt; internal-thread-core=4 -v --gst-debug=3 Pipeline with separate payload component to transmit 10bit YUV 4:2:2 1080p30 video stream using Rivermax media API: gst-launch-1.0 videotestsrc ! &#x27;video/x-raw, width=1920, height=1080, format=(string)UYVP, framerate=30/1&#x27; ! queue ! rtpvrawpay mtu=1220 ! nvdsudpsink host=&lt;ip address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; payload-size=1220 packets-per-line=4 sdp-file=&lt;sdp file&gt; -v --gst-debug=3 Pipeline without additional payload component to transmit 10bit YUV 4:2:2 1080p60 video stream using Rivermax media API: gst-launch-1.0 videotestsrc ! &#x27;video/x-raw, width=1920, height=1080, format=(string)UYVP, framerate=60/1&#x27; ! queue ! nvdsudpsink host=&lt;ip address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; payload-size=1220 packets-per-line=4 sdp-file=&lt;sdp file&gt; -v --gst-debug=3 Pipeline that uses PTP hardware clock from NIC: gst-launch-1.0 videotestsrc ! &#x27;video/x-raw, width=1920, height=1080, format=(string)UYVP, framerate=60/1&#x27; ! queue ! nvdsudpsink host=&lt;ip address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; payload-size=1220 packets-per-line=4 sdp-file=&lt;sdp file&gt; ptp-src=&lt;ip addr of PTP source&gt; -v --gst-debug=3 Pipeline that uses separate render thread and bind it to CPU core(s): gst-launch-1.0 videotestsrc ! &#x27;video/x-raw, width=1920, height=1080, format=(string)UYVP, framerate=60/1&#x27; ! queue ! nvdsudpsink host=&lt;ip address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; payload-size=1220 packets-per-line=4 sdp-file=&lt;sdp file&gt; ptp-src=&lt;ip addr of PTP source&gt; render-thread-core=&quot;list of core(s)&quot; sync=0 -v --gst-debug=3", "keywords": []}, {"id": 2816, "doc_id": 2819, "filename": "text/DS_plugin_gst-nvdsudpsink.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsink#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsink", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Supports Rivermax Generic and Media APIs By default, it supports generic APIs, but media API can be enabled by setting sdp-file property. DS 6.1 Supports any type of RTP packet (Compressed, Uncompressed, audio etc.) with Generic APIs No restriction on content of RTP payload in case of Generic APIs. DS 6.1 Supports RTCP packets,In addition to RTP RTCP packets can also be transmitted. DS 6.1 Traffic shaping in case of Uncompressed streams (video and audio) By using Rivermax media APIs,packet pacing can be enabled for uncompressed video and audio streams. DS 6.1 Supports SMPTE 2110-20 Uncompressed SMPTE 2110-20 streams with packet pacing is supported through Rivermax media APIs. DS 6.1 Supports SMPTE 2110-30 Uncompressed SMPTE 2110-30 stream with packet pacing is supported through Rivermax media APIs. DS 6.1 Supports RTP packetization of uncompressed video Uncompressed video as input can be converted to RTP packets as per SMPTE 2110-20 before sending to network DS 6.2 Supports RTP packetization of uncompressed audio Uncompressed audio as input can be converted to RTP packets as per SMPTE 2110-30 before sending to network DS 6.2 Supports PTP clock In addition to system clock, hardware clock from the PTP source (Network card) can be used to generate RTP packet timestamp DS 6.2 Supports render thread affinity Separate thread to packetize and transmit the data. This thread can be bound to specific CPU core(s) DS 6.2", "keywords": []}, {"id": 2817, "doc_id": 2819, "filename": "text/DS_plugin_gst-nvdsudpsink.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsink#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsink", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvdsudpsink plugin\u2019s Gst properties. Property Meaning Type and Range Example / Notes Platforms port The port number to send the RTP packets to Integer, 0 to 65535 Port=5004 dGPU Jetson host Unicast / Multicast address to send the packets String address=192.168.4.60 dGPU Jetson chunk-size Number of chunks to allocate in case of generic APIs Integer, 1 to 65535 chunk-size=100 dGPU Jetson packets-per-chunk Number of packets per chunk Integer, 1 to 65535 packets-per-chunk=10 dGPU Jetson payload-size Size of payload in RTP packet Integer, 0 to 65535 payload-size=1400 dGPU Jetson packets-per-line Number of packets per line in case of media APIs Integer, 1 to 65535 packets-per-line=4 dGPU Jetson sdp-file Path to SDP file, to enable the use of Rivermax media APIs String sdp-file=\u201dsdp_video.txt\u201d dGPU Jetson local-iface-ip IP Address associated with network interface through which to transmit the data String local-iface-ip=\u201d192.168.2.20\u201d dGPU Jetson internal-thread-core CPU core to run Rivermax internal thread Integer, -1 to 1023 internal-thread-core=2 dGPU Jetson ptp-src IP Address of PTP source String ptp-src=\u201d192.168.2.20\u201d dGPU Jetson render-thread-core Comma seperated list of CPU core(s) for rendering thread String render-thread-core=\u201d2,3\u201d dGPU Jetson", "keywords": []}, {"id": 2818, "doc_id": 2819, "filename": "text/DS_plugin_gst-nvdsudpsink.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsink#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsink", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs GstBufferList having RTP packets as buffer content. GstBuffer having uncompressed audio or video frame. Control parameters LOCAL_IFACE_IP ENV flag or local-iface-ip property host port chunk-size packets-per-chunk payload-size sdp-file packets-per-line internal-thread-core ptp-src render-thread-core Output None", "keywords": []}, {"id": 2819, "doc_id": 2819, "filename": "text/DS_plugin_gst-nvdsudpsink.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsudpsink", "display_name": "Gst-nvdsudpsink", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsudpsink", "anchor": "", "priority": -1, "content": "The Gst-nvdsudpsink plugin is a sink type component which can be used to transmit the RTP packets over IP network. Internally, the plugin uses Rivermax SDK APIs for network communications. NVIDIA Rivermax \u00ae offers a unique IP-based solution for any media and data streaming use case. For more details see the Rivermax Product Page . nvdsudpsink can operate in three different modes based on the input type and properties set to the component. RTP packets with Rivermax Generic API This is default mode. In this mode nvdsudpsink will receive RTP packets and transmit it to network using Rivermax generic APIs. nvdsudpsink doesn\u2019t require any information about the content of RTP packets. RTP packets with Rivermax Media API This mode is for specific use case of SMPTE 2110-20, 30 streams. In this mode, nvdsudpsink supports SMPTE 2110-20 and SMPTE 2110-30 streams with traffic shaping. nvdsudpsink expects RTP packets having either uncompressed audio or video as payload and It will transmit those packets to network using Rivermax media APIs. Since Rivermax media APIs need to know the information about the data being transmitted for it to handle the traffic shaping, nvdsudpsink needs that information for Rivermax initialization in the form of SDP file. This mode can be enabled by setting sdp-file property of the component. In this mode, for uncompressed video streams, packets-per-line and payload-size properties along with sdp-file must be set. Similarly, value of mtu property of payloader component must be same as payload-size of nvdsudpsink . For uncompressed audio streams in this mode, max-ptime and ptime-multiple properties of payloader component must be set. Uncompressed data with Rivermax media API In this mode, nvdsudpsink expects uncompressed audio or video frames directly instead of RTP packets. The component will convert those frames to RTP packets and then transmit over network using Rivermax media API. This mode will be enabled if in addition to the requirements of mode #2 the incoming data is uncompressed video or audio frames instead of RTP packets. In this mode, if render-thread-core property is set, a separate thread will be created to packetize the frame and transmit the packets. That thread will also be bound to the CPU core(s) provided as the value of the property. In this mode as uncompressed video input, only YUV 4:2:2 and RGB with 8 or 10 bit depth is supported. Payload size and packets per line for some of common formats To calculate the payload size and packets per line, use the following steps: Calculate line stride as follows: line stride = (width * pgroup size) / pgroup coverage Divide this stride into number of packets having equal bytes. This will be value of packet-per-line. Add 20 bytes to size of each packet calculated in step 2 for RTP + Payload header. This will be value for payload-size. It is assumed that there is only single Sample Row Data per RTP packet and line stride is equally divisible. Following are values for some of the common formats: YCbCr-4:2:2 1920x1080 8 bit: payload-size:1300, packets-per-line:3 YCbCr-4:2:2 1920x1080 10 bit: payload-size:1220, packets-per-line:4 YCbCr-4:2:0 1920x1080 8 bit: payload-size:1460, packets-per-line:2 YCbCr-4:2:0 1920x1080 10 bit: payload-size:1220, packets-per-line:3 RGB 1920x1080 8 bit: payload-size:1460, packets-per-line:4 RGB 1920x1080 10 bit: payload-size:1220, packets-per-line:6 Refer to the SMPTE ST 2110-20:2017 for more information. System can also have Gstreamer provided OSS implementation of udp sink ( udpsink ) component. In that case system would have two implementations for udp sink - udpsink and nvdsudpsink . nvdsudpsink component can only be used with NVIDIA ConnectX-5 and above cards after having installed Rivermax SDK and its license. Download and setup the Rivermax 1.40.x SDK here: https://developer.nvidia.com/networking/rivermax-getting-started . Follow the instruction on the SDK page to obtain development license for Rivermax. To select nvdsudpsink out of two installations, use either LOCAL_IFACE_IP environment variable or local-iface-ip property. Use the command below to export the environment variable: export LOCAL_IFACE_IP=&lt;IP of NIC&gt; nvdsudpsink component also requires CAP_NET_RAW capability. Either run the application that uses nvdsudpsink component with superuser privilege or set the CAP_NET_RAW capabilities using the following command. sudo setcap CAP_NET_RAW=ep &lt;absolute path of application&gt; For example: sudo setcap CAP_NET_RAW=ep /opt/nvidia/deepstream/deepstream/bin/deepstream-app sudo setcap CAP_NET_RAW=ep /usr/bin/gst-launch-1.0", "keywords": []}, {"id": 2820, "doc_id": 2824, "filename": "text/DS_plugin_gst-nvdsudpsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsrc#example-pipelines", "display_name": "Example pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsrc", "anchor": "example-pipelines", "priority": -1, "content": "Pipeline to receive and play 24 bit 2 channel 48k audio stream: LOCAL_IFACE_IP=&lt;ip address of NIC&gt; gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; port=&lt;port number&gt; ! &#x27;application/x-rtp, media=(string)audio, clock-rate=(int)48000, encoding-name=(string)L24, encoding-params=(string)2, channels=(int)2, payload=(int)97&#x27; ! rtpL24depay ! rawaudioparse use-sink-caps=1 ! queue ! autoaudiosink -v --gst-debug=3 Pipeline to receive and display 10bit YUV 4:2:2 1080p30 video stream: gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; ! &#x27;application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)RAW, sampling=(string)YCbCr-4:2:2, depth=(string)10, width=(string)1920, height=(string)1080, colorimetry=(string)BT709, payload=(int)96&#x27; ! rtpvrawdepay ! nvvideoconvert ! nveglglessink -v --gst-debug=3 Pipeline to receive and display 10bit YUV 4:2:2 1080p30 video stream without additional depayload component : gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; caps=&#x27;video/x-raw(memory:NVMM), width=1920, height=1080, format=(string)UYVP, framerate=30/1&#x27; header-size=20 payload-size=1200 ! nvvideoconvert ! nveglglessink -v --gst-debug=3 Pipeline to receive and display 10bit YUV 4:2:2 1080p30 video stream without additional depayload component and using GPU Direct : gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; port=&lt;port number&gt; local-iface-ip=&lt;ip addr of NIC&gt; caps=&#x27;video/x-raw(memory:NVMM), width=1920, height=1080, format=(string)UYVP, framerate=30/1&#x27; header-size=20 payload-size=1200 gpu-id=0 ! nvvideoconvert ! nveglglessink -v --gst-debug=3 Pipeline to receive and play 24 bit 2 channel 48k audio stream without additional depayload component: gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; local-iface-ip=&lt;ip address of NIC&gt; port=&lt;port number&gt; caps=&#x27;audio/x-raw, format=(string)S24BE, layout=(string)interleaved, rate=(int)48000, channels=(int)2&#x27; payload-size=288 header-size=12 ! autoaudiosink -v --gst-debug=3 Pipeline to receive and depacketize generic payload. Following pipeline receives uncompressed video as generic paylaod: gst-launch-1.0 nvdsudpsrc address=&lt;unicast / multicast address&gt; local-iface-ip=&lt;ip address of NIC&gt; port=&lt;port number&gt; caps=&#x27;application/x-custom&#x27;, header-size=20, payload-size=1200, payload-multiple=4320 ! fakesink -v --gst-debug=3", "keywords": []}, {"id": 2821, "doc_id": 2824, "filename": "text/DS_plugin_gst-nvdsudpsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsrc#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsrc", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Supports header and payload separation Separate memories can be allocated for RTP header and payload DS 6.0 Supports any type of RTP packet (Compressed, Uncompressed, audio etc.) No restriction on content of RTP payload DS 6.0 Supports RTCP packets In addition to RTP, RTCP packets can also be received DS 6.0 Supports RTP payload directly in GPU memory Content of RTP payload can directly be in GPU memory. This can avoid copy if GPU processing of payload is required DS 6.0 Supports de-packetization of uncompressed video RTP packets having uncompressed video as payload can be depacketized and converted to video frame as per SMPTE 2110-20 specification DS 6.3 Supports de-packetization of uncompressed audio RTP packets having uncompressed audio as payload can be depacketized and converted to audio frame as per SMPTE 2110-30 specification DS 6.3 Supports de-packetization of generic payload RTP packets having fixed header and payload size can be depacketized to form a frame. In this mode headers will be removed and payloads will be combined to form a frame DS 6.3", "keywords": []}, {"id": 2822, "doc_id": 2824, "filename": "text/DS_plugin_gst-nvdsudpsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsrc#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsrc", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvdsudpsrc plugin\u2019s Gst properties. Property Meaning Type and Range Example / Notes Platforms port The port number to receive the RTP packets from Integer, 0 to 65535 Port=5004 dGPU Jetson address IP address of the server to receive packets from String address=192.168.4.60 dGPU Jetson uri Uri of the server in the form of udp://&lt;ip&gt;:&lt;port&gt; String uri=udp://192.168.4.60:5004 dGPU Jetson payload-size Size of payload in RTP packet Integer, 0 to 65535 payload-size=1500 dGPU Jetson header-size RTP header size Integer, 0 to 65535 header-size=12 dGPU Jetson num-packets Number of packets for which memory to allocate Integer, 0 to 2147483647 num-packets=10000 dGPU Jetson local-iface-ip IP Address associated with network interface through which to receive the data String local-iface-ip=192.168.2.20 dGPU Jetson buffer-size Size of the kernel receive buffer in bytes Integer, 0 to 2147483647 buffer-size=50000 dGPU Jetson reuse Enable reuse of the port Boolean reuse=1 dGPU Jetson multicast-iface The network interface on which to join the multicast group String multicast-iface=eth0 dGPU Jetson auto-multicast Automatically join/leave multicast groups Boolean auto-multicast=1 dGPU Jetson loop Used for setting the multicast loop parameter Boolean loop=1 dGPU Jetson source-address Unicast address to receive the data only from that sender String source-address=\u201d192.168.3.4\u201d dGPU Jetson gpu-id GPU device id to allocate the buffers Integer, -1 to 32767 gpu-id=0 dGPU Jetson payload-multiple Output buffer to be multiple of these number of packets Integer, 0 to 65535 payload-multiple=4320 dGPU Jetson", "keywords": []}, {"id": 2823, "doc_id": 2824, "filename": "text/DS_plugin_gst-nvdsudpsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsudpsrc#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsudpsrc", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs None Control parameters LOCAL_IFACE_IP ENV flag or local-iface-ip property payload-size header-size num-packets uri address port source-address caps gpu-id payload-multiple Output GstBufferList having RTP packets as buffer content. GstBuffer having uncompressed audio or video frame.", "keywords": []}, {"id": 2824, "doc_id": 2824, "filename": "text/DS_plugin_gst-nvdsudpsrc.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsudpsrc", "display_name": "Gst-nvdsudpsrc", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsudpsrc", "anchor": "", "priority": -1, "content": "The Gst-nvdsudpsrc plugin is a source type component which is used to receive the UDP-RTP packets from the network. Internally, the plugin uses Rivermax SDK APIs for network communications. NVIDIA Rivermax \u00ae offers a unique IP-based solution for any media and data streaming use case. For more details, see the Rivermax Product Page. . Rivermax utilizes the kernel bypass technology and RDMA capabilities to achieve better CPU performance, low latency, and higher bandwidth. On top of Rivermax based enhancements, some of memory and buffer management optimization have been implemented to further reduce the CPU utilization in case of high packet rate use cases. This component also supports RTP header and payload separation. RTP header and payloads can be received in separate memories. Header will always be in system memory while payload can directly be copied to GPU (Pinned) memory. This can avoid memory copies in cases when GPU processing is performed on the RTP payloads. Header and payload separation will happen only if header-size property is set to non-zero value and for fixed header size. High resolution uncompressed video streams have a very high number of RTP packets per second. In such case, OSS de-packetization component (rtpvrawdepay) becomes bottleneck to process stream real-time. To handle such cases, nvdsudpsrc has added support for de-packetization of uncompressed video and audio streams as per SMPTE 2110-20/30 specifications. In this mode, nvdsudpsrc will provide GstBuffer having complete video / audio frame as an output instead of RTP packets. To use de-packetization for uncompressed video and audio payloads within nvdsudpsrc , there are certain assumptions regarding input stream. Each RTP packet must be of fixed size with fixed header and payload size. There should not be more than one sample row data (SRD) per RTP packet. With the support for de-packetization, nvdsudpsrc can now have four different operating modes based on the value of caps property of the component. Default mode nvdsudpsrc will receive RTP packets having any type of payload from the network and push those packets to the downstream depayloader component for de-packetization. In this mode, nvdsudpsrc component is agnostic to content of the RTP packet. This is default mode and the source pad should have \u201capplication/x-rtp, \u2026\u2026\u201d as caps. Uncompressed video frame as output nvdsudpsrc will receive RTP packets having uncompressed video as payload and will do de-packetization as per SMPTE 2110-20 specification to form a video frame before sending to downstream components. This mode will be activated when caps property is set with \u201cvideo/x-raw(memory:NVMM), \u2026..\u201d caps. Uncompressed audio frame as output nvdsudpsrc will receive RTP packets having uncompressed audio as payload and will do de-packetization as per SMPTE 2110-30 specification to form an audio frame before sending to downstream components. This mode will be activated when the caps property is set with \u201caudio/x-raw, \u2026..\u201d caps. Generic data as output nvdsudpsrc will receive RTP packets having any type of payload and will do de-packetization to form a frame before sending to downstream components. In this case, the frame boundary is not decided based on the parsing of the RTP / payload header but based on the configurable value of the number of packets. i.e., the value of payload-multiple property will decide on how many packets are considered as a frame and nvdsudpsrc will remove the RTP header of those many packets and combine the payloads to form a frame. This mode will be activated when the caps property is set with \u201capplication/x-custom, \u2026..\u201d caps. System can also have Gstreamer provided OSS implementation of udp source ( udpsrc ) component. In that case system would have two implementations for udp source - udpsrc and nvdsudpsrc . nvdsudpsrc component can only be used with NVIDIA ConnectX-5 and above cards after having installed Rivermax SDK and its license. Download and setup the Rivermax 1.40.x SDK here: https://developer.nvidia.com/networking/rivermax-getting-started Follow the instruction on the SDK page to obtain Rivermax development license. To select nvdsudpsrc out of two installations, use either LOCAL_IFACE_IP environment variable or local-iface-ip property. Use the command below to export the environment variable: export LOCAL_IFACE_IP=&lt;IP of NIC&gt; nvdsudpsrc component also requires CAP_NET_RAW capability. Either run the application that uses nvdsudpsrc component with superuser privilege or set the CAP_NET_RAW capabilities using the following command. sudo setcap CAP_NET_RAW=ep &lt;absolute path of application&gt; For example: sudo setcap CAP_NET_RAW=ep /opt/nvidia/deepstream/deepstream/bin/deepstream-app sudo setcap CAP_NET_RAW=ep /usr/bin/gst-launch-1.0", "keywords": []}, {"id": 2825, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsvideotemplate#customlib-impl-interfaces", "display_name": "customlib_impl Interfaces", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "customlib-impl-interfaces", "priority": -1, "content": "SetInitParams =&gt; Based on the negotiated caps, this API creates output buffer pool of the negotiated resolution HandleEvent =&gt; This API handles standard Gstreamer events as well as custom events such as PAD_ADDED PAD_DELETED etc. GetCompatibleCaps =&gt; This API returns the fixated caps to be set on either SINK / SRC pad of the plugin ProcessBuffer =&gt; This API passes the GstBuffer to customlib for further processing SetProperty =&gt; This API sets the customlib properties that are used by the underlying library for processing", "keywords": []}, {"id": 2826, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsvideotemplate#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Simplified APIs Simplified interface to implement custom library to add any algorithm without implementing new plugin DS 5.1 Easy Data Accessing Easy access to GstBuffer and it\u2019s metadata inside custom library DS 5.1 Synchronous and Asynchronous Buffer Processing Buffer_Ok is the responsibility of the plugin to push the buffer downstream. Buffer_Async is the responsibility of the custom library to push the buffer downstream. Buffer_Error and Buffer_Drop are currently not implemented DS 5.1 Reference Impl. Reference implementation of custom library provides transform, transform-ip, metadata handling etc. which can be modified as per the use case. DS 5.1 Abstraction APIs Bufferpool creation, caps handling provided as an abstraction API inside customlib base class DS 5.1", "keywords": []}, {"id": 2827, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsvideotemplate#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvdsvideotemplate plugin. Property Meaning Type and Range Example/Notes Platforms gpu-id Device ID of GPU to use for decoding. Integer, 0 to 4,294,967,295 gpu-id=0 dGPU customlib-name custom library Name to be used String Default: null dGPU customlib-props Custom Library Properties (key:value) string, can be set multiple times,vector is maintained internally String Default: null dGPU dummy-meta-insert Set to enable dummy meta data insertion Boolean Default: false dGPU fill-dummy-batch-meta Set to fill dummy batch meta data sent from nvstreammux Boolean Default: false dGPU", "keywords": []}, {"id": 2828, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsvideotemplate#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NVMM or RAW Gst Buffers. Supported formats are NV12 and RGBA Control parameters customlib-name gpu-id customlib-props Output Transformed Gst Buffer", "keywords": []}, {"id": 2829, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsvideotemplate#sample-pipelines", "display_name": "Sample pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "sample-pipelines", "priority": -1, "content": "For single stream: gst-launch-1.0 filesrc location=/home/nvidia/sample_720p.mp4 ! decodebin ! \\ nvvideoconvert ! nvdsvideotemplate customlib-name=&quot;libcustom_impl.so&quot; \\ customlib-props=&quot;scale-factor:2.0&quot; ! nveglglessink For Multi-stream: gst-launch-1.0 filesrc location= ~/sample_720p.mp4 ! decodebin ! m.sink_0 \\ nvstreammux name=m width=640 height=480 batch-size=4 ! nvinfer config-file-path=config_infer_primary.txt \\ ! nvdsvideotemplate customlib-name=&quot;libcustom_impl.so&quot; customlib-props=&quot;scale-factor:2.0&quot; \\ ! nvmultistreamtiler ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM),width=320, height=240&quot; ! nvdsosd ! nveglglessink \\ filesrc location= ~/sample_720p.mp4 ! decodebin ! m.sink_1", "keywords": []}, {"id": 2830, "doc_id": 2830, "filename": "text/DS_plugin_gst-nvdsvideotemplate.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsvideotemplate", "display_name": "Gst-nvdsvideotemplate", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsvideotemplate", "anchor": "", "priority": -1, "content": "The OSS Gst-nvdsvideotemplate plugin is a template plugin which provides a custom library hooking interface for single/batched video frame(s) processing. Custom lib implementation may have algorithms to transform or process input buffers depending upon the use case. It can support NV12 and RGBA inputs. The plugin accepts batched NVMM HW and RAW SW buffers, and outputs batched NVMM HW buffers.", "keywords": []}, {"id": 2831, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "gst-properties", "priority": -1, "content": "The following tables describes the Gst properties of the Gst-nvdsxfer plugin. Property Meaning Type and Range Example notes batch-size Maximum number of buffers in a batch Unsigned Integer. Range: 0 - 4294967295 Default: 1 batch-size=2 buffer-pool-size Maximum number of buffers in muxer\u2019s internal pool Unsigned Integer. Range: 2 - 16 Default: 4 buffer-pool-size=2 gpu-id Set GPU Device ID Unsigned Integer. Range: 0 - 4294967295 Default: 0 gpu-id=1 p2p-gpu-id Set P2P GPU ID to enable P2P access.Default P2P access between GPUs is disabled. Integer. Range: -1 - 1024 Default: -1 p2p-gpu-id=0 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers Enum \u201cGstNvBufMemoryType\u201d Default: 0, \u201cnvbuf-mem-default\u201d (0): nvbuf-mem-default - Default memory allocated, specific to particular platform (1): nvbuf-mem-cuda-pinned - Allocate Pinned/Host cuda memory (2): nvbuf-mem-cuda-device - Allocate Device cuda memory (3): nvbuf-mem-cuda-unified - Allocate Unified cuda memory nvbuf-memory-type=2", "keywords": []}, {"id": 2832, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#how-to-test", "display_name": "How to test", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "how-to-test", "priority": -1, "content": "nvdsxfer is currently supported for X86 only. support with \u201c Jetson + dGPU \u201d is not yet enabled. Multi-dGPUs are connected using NVLINK Bridge Connector. Use below command to confirm the NVLINK state (active/inactive) if ready to use. nvidia-smi nvlink -s nvdsxfer plugin currently verified using 2 separate dGPU (discrete GPUs) only.Below listed gst-launch-1.0 pipelines simulates some of the reference use cases pipelines using 2 separate dGPU (discrete GPUs). Set property p2p_gpu_id=0 if Peer to Peer (P2P) access between discrete GPUs permitted. If P2P access is not possible then pipeline will fail, remove p2p_gpu_id=0 property to make it run without P2P access. Below mentioned reference gst-launch-1.0 pipelines use legacy streammux by default. New nvstreammux can also be used by enabling USE_NEW_NVSTREAMMUX=yes environment variable with appropriate properties set for new streammux plugin gst-launch-1.0 pipelines mentioned in the Use cases section, are not optimal pipelines though can demonstrate nvdsxfer plugin usage for various use cases to achieve better performance and GPU utilization. deepstream-multigpu-nvlink-test sample application can demonstrate nvdsxfer plugin based gstreamer pipeline. Refer /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-multigpu-nvlink-test/README for usage and application supported feature.", "keywords": []}, {"id": 2833, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs of the Gst-nvdsxfer plugin. Inputs Gst Buffer batched buffer NvDsBatchMeta Raw Video Format: NV12, I420, RGBA (NVMM) Control parameters gpu-id p2p-gpu-id batch-size buffer-pool-size nvbuf-memory-type Output Gst Buffer batched buffer NvDsBatchMeta Raw Video Format: NV12, I420, RGBA (NVMM)", "keywords": []}, {"id": 2834, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#multiple-streams-multi-dgpu-setup", "display_name": "Multiple Streams + Multi-dGPU Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "multiple-streams-multi-dgpu-setup", "priority": -1, "content": "Running \u201cMulti-instance(4) decode + Streammux + PGIE\u201d on single dGPU and \u201c tracker + SGIE - multiple models\u201d on separate dGPU gst-launch-1.0 nvstreammux name=m batch-size=4 gpu-id=0 width=1920 height=1080 nvbuf-memory-type=2 ! queue ! \\ nvinfer gpu-id=0 batch-size=4 config-file-path=samples/configs/deepstream-app/config_infer_primary.txt ! queue ! \\ nvdsxfer gpu-id=1 p2p_gpu_id=0 ! queue ! nvtracker gpu-id=1 enable-batch-process=1 \\ ll-lib-file=lib/libnvds_nvmultiobjecttracker.so ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! queue ! \\ nvinfer gpu-id=1 batch-size=16 unique-id=2 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! queue ! \\ nvinfer gpu-id=1 batch-size=16 unique-id=3 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! queue ! \\ fpsdisplaysink video-sink=fakesink sync=0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_1 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_2 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_3 -e -v Running \u201cMulti-instance(4) decode + StreamMux\u201d on single-dGPU and \u201cPGIE + Tracker + SGIE(Multiple)\u201d on separate dGPU gst-launch-1.0 nvstreammux name=m batch-size=4 gpu-id=0 width=1920 height=1080 nvbuf-memory-type=2 ! queue ! \\ nvdsxfer gpu-id=1 p2p_gpu_id=0 ! queue ! nvinfer gpu-id=1 batch-size=4 config-file-path=samples/configs/deepstream-app/config_infer_primary.txt ! queue ! \\ nvtracker gpu-id=1 enable-batch-process=1 ll-lib-file=lib/libnvds_nvmultiobjecttracker.so \\ ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! queue ! nvinfer gpu-id=1 batch-size=16 unique-id=2 \\ config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! queue ! nvinfer gpu-id=1 batch-size=16 unique-id=3 \\ config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! queue ! fpsdisplaysink video-sink=fakesink sync=0 \\ multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 \\ multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_1 \\ multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_2 \\ multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_3 -e -v Running \u201cMulti-instance(8) decode\u201d on multi-dGPU and \u201cStreamMux + PGIE + Tracker + SGIE(Multiple)\u201d on any one of the dGPU gst-launch-1.0 nvstreammux name=m batch-size=8 gpu-id=0 width=1920 height=1080 nvbuf-memory-type=2 ! queue ! nvinfer gpu-id=0 batch-size=8 \\ config-file-path=samples/configs/deepstream-app/config_infer_primary.txt ! queue ! nvtracker gpu-id=0 enable-batch-process=1 \\ ll-lib-file=lib/libnvds_nvmultiobjecttracker.so ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! queue ! \\ nvinfer gpu-id=0 batch-size=16 unique-id=2 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! queue ! \\ nvinfer gpu-id=0 batch-size=16 unique-id=3 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! queue ! \\ fpsdisplaysink video-sink=fakesink sync=0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_1 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_2 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_3 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_4 multifilesrc \\ location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! \\ nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_5 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_6 multifilesrc \\ location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! \\ nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_7 -e -v Running \u201cMulti-instance(8) decode\u201d on multi-dGPU, \u201cStreamMux + PGIE\u201d and \u201cTracker + SGIE(Multiple)\u201d on separate dGPU gst-launch-1.0 nvstreammux name=m batch-size=8 gpu-id=0 width=1920 height=1080 nvbuf-memory-type=2 ! queue ! nvinfer gpu-id=0 batch-size=8 \\ config-file-path=samples/configs/deepstream-app/config_infer_primary.txt ! queue ! nvdsxfer gpu-id=1 p2p_gpu_id=0 ! queue ! nvtracker gpu-id=1 \\ enable-batch-process=1 ll-lib-file=lib/libnvds_nvmultiobjecttracker.so ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! \\ queue ! nvinfer gpu-id=1 batch-size=16 unique-id=2 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! \\ queue ! nvinfer gpu-id=1 batch-size=16 unique-id=3 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! \\ queue ! fpsdisplaysink video-sink=fakesink sync=0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! \\ queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! \\ queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_1 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! \\ queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_2 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! \\ queue ! nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_3 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! \\ queue ! nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_4 multifilesrc \\ location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! \\ nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_5 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_6 multifilesrc \\ location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! nvv4l2decoder gpu-id=1 cudadec-memtype=0 ! queue ! \\ nvdsxfer gpu-id=0 p2p_gpu_id=1 ! queue ! m.sink_7 -e -v", "keywords": []}, {"id": 2835, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#single-stream-multi-dgpus-setup", "display_name": "Single Stream + Multi-dGPUs Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "single-stream-multi-dgpus-setup", "priority": -1, "content": "Running \u201cDecode + StreamMux + PGIE\u201d and \u201cTracker + SGIE (Multiple)\u201d on separate dGPUs gst-launch-1.0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 nvstreammux name=m batch-size=1 gpu-id=0 \\ width=1920 height=1080 nvbuf-memory-type=2 ! queue ! nvinfer gpu-id=0 batch-size=1 \\ config-file-path=samples/configs/deepstream-app/config_infer_primary.txt ! queue ! \\ nvdsxfer gpu-id=1 p2p_gpu_id=0 ! queue ! nvtracker gpu-id=1 enable-batch-process=1 \\ ll-lib-file=lib/libnvds_nvmultiobjecttracker.so ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! \\ queue ! nvinfer gpu-id=1 batch-size=16 unique-id=2 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! \\ queue ! nvinfer gpu-id=1 batch-size=16 unique-id=3 config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! \\ queue ! fpsdisplaysink video-sink=fakesink sync=0 -e -v Running \u201cDecode + StreamMux\u201d and \u201cPGIE + Tracker + SGIE (Multiple)\u201d on separate dGPUs gst-launch-1.0 multifilesrc location=samples/streams/sample_1080p.h265 loop=true ! h265parse ! queue ! \\ nvv4l2decoder gpu-id=0 cudadec-memtype=0 ! queue ! m.sink_0 nvstreammux name=m batch-size=1 gpu-id=0 \\ width=1920 height=1080 nvbuf-memory-type=2 ! queue ! nvdsxfer gpu-id=1 p2p_gpu_id=0 ! queue ! \\ nvinfer gpu-id=1 batch-size=1 config-file-path= samples/configs/deepstream-app/config_infer_primary.txt ! queue ! \\ nvtracker gpu-id=1 enable-batch-process=1 ll-lib-file=lib/libnvds_nvmultiobjecttracker.so \\ ll-config-file=samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml ! queue ! nvinfer gpu-id=1 batch-size=16 unique-id=2 \\ config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehiclemake.txt ! queue ! nvinfer gpu-id=1 batch-size=16 unique-id=3 \\ config-file-path=samples/configs/deepstream-app/config_infer_secondary_vehicletypes.txt ! queue ! fpsdisplaysink video-sink=fakesink sync=0 -e -v", "keywords": []}, {"id": 2836, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvdsxfer#use-cases", "display_name": "Use cases", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "use-cases", "priority": -1, "content": "Below reference gst-launch-1.0 commands uses h265 elementary stream as input. In order to use DeepStream SDK provided sample mp4 stream, use following command to convert from mp4 container file to h265 elementary stream. cd /opt/nvidia/deepstream/deepstream/ gst-launch-1.0 filesrc location= samples/streams/sample_1080p_h265.mp4 ! qtdemux ! h265parse ! &#x27;video/x-h265,stream-format=byte-stream&#x27; ! filesink location= samples/streams/sample_1080p.h265", "keywords": []}, {"id": 2837, "doc_id": 2837, "filename": "text/DS_plugin_gst-nvdsxfer.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvdsxfer", "display_name": "Gst-nvdsxfer", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvdsxfer", "anchor": "", "priority": -1, "content": "The Gst-nvdsxfer plugin performs data transfer between discrete GPUs. Currently it is supported on x86 platform only. It uses CUDA APIs to utilize NVIDIA NVLINK technology for high-speed, direct GPU-to-GPU interconnect for optimized data transfer between discrete GPUs. The plugin accepts CUDA memory based ( NvBufSurface allocated) video Gst Buffers from upstream component. It transfer the input data to CUDA memory based ( NvBufSurface allocated) video output Gst Buffer using the optimized NVLINK based data copy. The Gst-nvdsxfer plugin is currently supports Single Node, Single Application with Multi-dGPU setup based use case pipelines. Video format conversion or scaling is not supported while doing data copy between two discrete GPUs. Multi-dGPUs are connected using NVLINK Bridge Connector. Users must confirm the NVLINK state (active/inactive - Use command \u201c nvidia-smi nvlink -s \u201d to check) between two discrete GPUs before using the nvdsxfer plugin in the gst-pipeline . As shown in the diagram below input video data is copied to output over a NVLINK connected discrete GPUs.", "keywords": []}, {"id": 2838, "doc_id": 2841, "filename": "text/DS_plugin_gst-nvimagedec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimagedec#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimagedec", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvimagedec plugin. Feature Description Release Supports toggling buffer pool plugin can toggle output buffer pool based on use cases DS 6.4", "keywords": []}, {"id": 2839, "doc_id": 2841, "filename": "text/DS_plugin_gst-nvimagedec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimagedec#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimagedec", "anchor": "gst-properties", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvimagedec plugin. Property Meaning Type and Range Example and Notes Platforms gpu-id Device ID of GPU to use for decoding. Integer, 0 to 4,294,967,295 gpu-id=0 dGPU, ARM+dGPU needs-pool Enabling / Disabling output buffer pool Boolean, 0 or 1 needs-pool=1 dGPU, ARM+dGPU", "keywords": []}, {"id": 2840, "doc_id": 2841, "filename": "text/DS_plugin_gst-nvimagedec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimagedec#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimagedec", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Elementary JPEG Control parameters gpu-id needs-pool Output Gst Buffer with decoded output in RGB format.", "keywords": []}, {"id": 2841, "doc_id": 2841, "filename": "text/DS_plugin_gst-nvimagedec.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvimagedec", "display_name": "Gst-nvimagedec", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvimagedec", "anchor": "", "priority": -1, "content": "The Gst-nvimagedec plugin decodes images on dGPU and (ARM + dGPU) platforms like arm-sbsa. This plugin is based on the libnvjpeg library which part of the CUDA toolkit. The plugin accepts a JPEG encoded bitstream and produces RGB output. jpegparse plugin should be used to parse the encoded frame before nvimagedec , since it does not have an internal bitstream parser.", "keywords": []}, {"id": 2842, "doc_id": 2845, "filename": "text/DS_plugin_gst-nvimageenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimageenc#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimageenc", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvimageenc plugin. Feature Description Release Supports JPEG Encode \u2014 DS 6.4", "keywords": []}, {"id": 2843, "doc_id": 2845, "filename": "text/DS_plugin_gst-nvimageenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimageenc#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimageenc", "anchor": "gst-properties", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvimageenc plugin. Property Meaning Type and Range Example and Notes Platforms gpu-id Device ID of GPU to use for encoding. Integer, 0 to 4,294,967,295 gpu-id=0 dGPU, ARM+dGPU", "keywords": []}, {"id": 2844, "doc_id": 2845, "filename": "text/DS_plugin_gst-nvimageenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvimageenc#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvimageenc", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer in RGB format Control parameters gpu-id Output Gst Buffer with encoded output in JPEG format", "keywords": []}, {"id": 2845, "doc_id": 2845, "filename": "text/DS_plugin_gst-nvimageenc.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvimageenc", "display_name": "Gst-nvimageenc", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvimageenc", "anchor": "", "priority": -1, "content": "The Gst-nvimageenc plugin encodes images on dGPU and (ARM + dGPU) platforms like arm-sbsa. This plugin is based on the libnvjpeg library which is part of the CUDA toolkit. The plugin accepts RGB input and produces JPEG encoded bitstream.", "keywords": []}, {"id": 2846, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#cluster-mode-0-grouprectangles", "display_name": "cluster-mode = 0 | GroupRectangles", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "cluster-mode-0-grouprectangles", "priority": -1, "content": "GroupRectangles is a clustering algorithm from OpenCV library which clusters rectangles of similar size and location using the rectangle equivalence criteria. Link to API documentation - https://docs.opencv.org/3.4/d5/d54/group__objdetect.html#ga3dba897ade8aa8227edda66508e16ab9", "keywords": []}, {"id": 2847, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#cluster-mode-1-dbscan", "display_name": "cluster-mode = 1 | DBSCAN", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "cluster-mode-1-dbscan", "priority": -1, "content": "Density-based spatial clustering of applications with noise or DBSCAN is a clustering algorithm which which identifies clusters by checking if a specific rectangle has a minimum number of neighbors in its vicinity defined by the eps value. The algorithm further normalizes each valid cluster to a single rectangle which is outputted as valid bounding box if it has a confidence greater than that of the threshold.", "keywords": []}, {"id": 2848, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#cluster-mode-2-nms", "display_name": "cluster-mode = 2 | NMS", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "cluster-mode-2-nms", "priority": -1, "content": "Non maximum suppression or NMS is a clustering algorithm which filters overlapping rectangles based on a degree of overlap(IOU) which is used as threshold. Rectangles with the highest confidence score is first preserved while the rectangles which overlap greater than the threshold are removed iteratively.", "keywords": []}, {"id": 2849, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#cluster-mode-3-hybrid", "display_name": "cluster-mode = 3 | Hybrid", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "cluster-mode-3-hybrid", "priority": -1, "content": "Hybrid clustering algorithm is a method which uses both DBSCAN and NMS algorithms in a two step process. DBSCAN is first applied to form unnormalized clusters in proposals whilst removing the outliers. NMS is later applied on these clusters to select the final rectangles for output.", "keywords": []}, {"id": 2850, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#cluster-mode-4-no-clustering", "display_name": "cluster-mode=4 | No clustering", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "cluster-mode-4-no-clustering", "priority": -1, "content": "No clustering is applied and all the bounding box rectangle proposals are returned as it is.", "keywords": []}, {"id": 2851, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Explicit Full Dimension Network Support Refer to https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#work_dynamic_shapes for more details. DS 5.0 Non-maximum Suppression (NMS) New bounding box clustering algorithm. DS 5.0 On-the-fly model update (Engine file only) Update the model-engine-file on-the-fly in a running pipeline. DS 5.0 Configurable frame scaling params Configurable options to select the compute hardware and the filter to use while scaling frame/object crops to network resolution DS 5.0 TAO toolkit encoded model support \u2014 DS 4.0 Gray input model support Support for models with single channel gray input DS 4.0 Tensor output as meta Raw tensor output is attached as meta data to Gst Buffers and flowed through the pipeline DS 4.0 Segmentation model Supports segmentation model DS 4.0 Maintain input aspect ratio Configurable support for maintaining aspect ratio when scaling input frame to network resolution DS 4.0 Custom cuda engine creation interface Interface for generating CUDA engines from TensorRT INetworkDefinition and IBuilder APIs instead of model files DS 4.0 ONNX Model support \u2014 DS 3.0 Multiple modes of operation Support for cascaded inferencing DS 2.0 Asynchronous mode of operation for secondary inferencing Infer asynchronously for secondary classifiers DS 2.0 Grouping using CV::Group rectangles For detector bounding box clustering DS 2.0 Configurable batch-size processing User can configure batch size for processing DS 2.0 No Restriction on number of output blobs Supports any number of output blobs DS 3.0 Configurable number of detected classes (detectors) Supports configurable number of detected classes DS 3.0 Support for Classes: configurable (&gt; 32) Supports any number of classes DS 3.0 Application access to raw inference output Application can access inference output buffers for user specified layer DS 3.0 Support for single shot detector (SSD) \u2014 DS 3.0 Secondary GPU Inference Engines (GIEs) operate as detector on primary bounding box Supports secondary inferencing as detector DS 2.0 Multiclass secondary support Supports multiple classifier network outputs DS 2.0 Grouping using DBSCAN For detector bounding box clustering DS 3.0 Loading an external lib containing IPlugin implementation for custom layers (IPluginCreator &amp; IPluginFactory) Supports loading (dlopen()) a library containing IPlugin implementation for custom layers DS 3.0 Multi GPU Select GPU on which we want to run inference DS 2.0 Detection width height configuration Filter out detected objects based on min/max object size threshold DS 2.0 Allow user to register custom parser Supports final output layer bounding box parsing for custom detector network DS 2.0 Bounding box filtering based on configurable object size Supports inferencing in secondary mode objects meeting min/max size threshold DS 2.0 Configurable operation interval Interval for inferencing (number of batched buffers skipped) DS 2.0 Select Top and bottom regions of interest (RoIs) Removes detected objects in top and bottom areas DS 2.0 Operate on Specific object type (Secondary mode) Process only objects of define classes for secondary inferencing DS 2.0 Configurable blob names for parsing bounding box (detector) Support configurable names for output blobs for detectors DS 2.0 Allow configuration file input Support configuration file as input (mandatory in DS 3.0) DS 2.0 Allow selection of class id for operation Supports secondary inferencing based on class ID DS 2.0 Support for Full Frame Inference: Primary as a classifier Can work as classifier as well in primary mode DS 2.0 Multiclass secondary support Support multiple classifier network outputs DS 2.0 Secondary GIEs operate as detector on primary bounding box Support secondary inferencing as detector \u2014 DS 2.0 Supports FP16, FP32 and INT8 models FP16 and INT8 are platform dependent \u2014 DS 2.0 Supports TensorRT Engine file as input \u2014 DS 2.0 Inference input layer initialization Initializing non-video input layers in case of more than one input layers \u2014 DS 3.0 Support for FasterRCNN \u2014 DS 3.0 Support for Yolo detector (YoloV3/V3-tiny/V2/V2-tiny) \u2014 DS 4.0 Support for yolov3-spp detector \u2014 DS 5.0 Support Instance segmentation with MaskRCNN Support for instance segmentation using MaskRCNN. It includes output parser and attach mask in object metadata. DS 5.0 Support for NHWC network input \u2014 DS 6.0 Added support for TAO ONNX model \u2014 DS 6.0 Support for input tensor meta Inferences using already preprocessed raw tensor from input tensor meta (attached as user meta at batch level) and skips preprocessing in nvinfer. In this mode, the batch-size of nvinfer must be equal to the sum of ROIs set in the gst-nvdspreprocess plugin config file. DS 6.0 Support for clipping bounding boxes to ROI boundary \u2014 DS 6.2", "keywords": []}, {"id": 2852, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#gst-nvinfer-file-configuration-specifications", "display_name": "Gst-nvinfer File Configuration Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "gst-nvinfer-file-configuration-specifications", "priority": -1, "content": "The Gst-nvinfer configuration file uses a \u201cKey File\u201d format described in https://specifications.freedesktop.org/desktop-entry-spec/latest . The [property] group configures the general behavior of the plugin. It is the only mandatory group. The [class-attrs-all] group configures detection parameters for all classes. The [class-attrs-&lt;class-id&gt;] group configures detection parameters for a class specified by &lt;class-id&gt; . For example, the [class-attrs-23] group configures detection parameters for class ID 23 . This type of group has the same keys as [class-attrs-all] . The following two tables respectively describe the keys supported for [property] groups and [class-attrs-\u2026] groups. Property Meaning Type and Range Example Notes Network Types / Applicable to GIEs (Primary/\u00adSecondary) num-detected-classes Number of classes detected by the network Integer, &gt;0 num-detected-classes=\u00ad91 Detector Both net-scale-factor Pixel normalization factor (ignored if input-tensor-meta enabled) Float, &gt;0.0 net-scale-factor=\u00ad0.031 All Both model-file Pathname of the model file. Not required if model-engine-file is used String model-file= /home/\u00adubuntu/\u00admodel All Both proto-file Pathname of the prototxt file. Not required if model-engine-file is used String proto-file= /home/\u00adubuntu/\u00admodel.prototxt All Both int8-calib-file Pathname of the INT8 calibration file for dynamic range adjustment with an FP32 model String int8-calib-file=\u00ad/home/\u00adubuntu/\u00adint8_calib All Both batch-size Number of frames or objects to be inferred together in a batch Integer, &gt;0 batch-size=30 All Both input-tensor-from-meta Use preprocessed input tensors attached as metadata instead of preprocessing inside the plugin. If this is set, ensure that the batch-size of nvinfer is equal to the sum of ROIs set in the gst-nvdspreprocess plugin config file. Boolean input-tensor-from-meta=1 All Primary tensor-meta-pool-size Size of the output tensor meta pool Integer, &gt;0 tensor-meta-pool-size=20 All Both model-engine-file Pathname of the serialized model engine file String model-engine-file= /home/\u00adubuntu/\u00admodel.engine All Both onnx-file Pathname of the ONNX model file String onnx-file= /home/\u00adubuntu/\u00admodel.onnx All Both enable-dbscan Indicates whether to use DBSCAN or the OpenCV groupRectangles() function for grouping detected objects. DEPRECATED. Use cluster-mode instead. Boolean enable-dbscan=1 Detector Both labelfile-path Pathname of a text file containing the labels for the model String labelfile-path= /home/\u00adubuntu/\u00admodel_labels.txt Detector &amp; classifier Both mean-file Pathname of mean data file in PPM format (ignored if input-tensor-meta enabled) String mean-file=\u00ad /home/\u00adubuntu/\u00admodel_meanfile.ppm All Both gie-unique-id Unique ID to be assigned to the GIE to enable the application and other elements to identify detected bounding boxes and labels Integer, &gt;0 gie-unique-id=2 All Both operate-on-gie-id Unique ID of the GIE on whose metadata (bounding boxes) this GIE is to operate on Integer, &gt;0 operate-on-gie-id=1 All Both operate-on-class-ids Class IDs of the parent GIE on which this GIE is to operate on Semicolon delimited integer array operate-on-class-ids=1;2 Operates on objects with class IDs 1, 2 generated by parent GIE If operate-on-class-ids is set to -1, it will operate on all class-ids All Both interval Specifies the number of consecutive batches to be skipped for inference Integer, &gt;0 interval=1 All Primary input-object-min-width Secondary GIE infers only on objects with this minimum width Integer, \u22650 input-object-min-width=40 All Secondary input-object-min-height Secondary GIE infers only on objects with this minimum height Integer, \u22650 input-object-min-height=40 All Secondary input-object-max-width Secondary GIE infers only on objects with this maximum width Integer, \u22650 input-object-max-width=256 0 disables the threshold All Secondary input-object-max-height Secondary GIE infers only on objects with this maximum height Integer, \u22650 input-object-max-height=256 All Both network-mode Data format to be used by inference Integer 0: FP32 1: INT8 2: FP16 3: BEST network-mode=0 All Both offsets Array of mean values of color components to be subtracted from each pixel. Array length must equal the number of color components in the frame. The plugin multiplies mean values by net-scale-factor.(ignored if input-tensor-meta enabled) Semicolon delimited float array, all values \u22650 offsets=77.5 21.2 All Both parse-bbox-func-name Name of the custom bounding box parsing function. If not specified, Gst-nvinfer uses the internal function for the resnet model provided by the SDK String parse-bbox-func-name= parse_bbox_resnet Detector Both parse-bbox-instance-mask-func-name Name of the custom instance segmentation parsing function. It is mandatory for instance segmentation network as there is no internal function. String parse-bbox-instance-mask-func-name= NvDsInferParseCustomMrcnnTLT Instance Segmentation Primary custom-lib-path Absolute pathname of a library containing custom method implementations for custom models String custom-lib-path= /home/\u00adubuntu/\u00adlibresnet_custom_impl.so All Both model-color-format Color format required by the model (ignored if input-tensor-meta enabled) Integer 0: RGB 1: BGR 2: GRAY model-color-format=0 All Both classifier-async-mode Enables inference on detected objects and asynchronous metadata attachments. Works only when tracker-ids are attached. Pushes buffer downstream without waiting for inference results. Attaches metadata after the inference results are available to next Gst Buffer in its internal queue. Boolean classifier-async-mode=1 Classifier Secondary process-mode Mode (primary or secondary) in which the element is to operate on (ignored if input-tensor-meta enabled) Integer 1=Primary 2=Secondary gie-mode=1 All Both classifier-threshold Minimum threshold label probability. The GIE outputs the label having the highest probability if it is greater than this threshold Float, \u22650 classifier-threshold=0.4 Classifier Both secondary-reinfer-interval Re-inference interval for objects, in frames Integer, \u22650 secondary-reinfer-interval=15 Detector &amp; Classifier Secondary output-tensor-meta Gst-nvinfer attaches raw tensor output as Gst Buffer metadata. Boolean output-tensor-meta=1 All Both output-instance-mask Gst-nvinfer attaches instance mask output in object metadata. Boolean output-instance-mask=1 Instance Segmentation Primary enable-dla Indicates whether to use the DLA engine for inferencing. Note: DLA is supported only on NVIDIA\u00ae Jetson AGX Orin\u2122 and NVIDIA\u00ae Jetson Orin NX\u2122. Currently work in progress. Boolean enable-dla=1 All Both use-dla-core DLA core to be used. Note: Supported only on Jetson AGX Orin and Jetson Orin NX. Currently work in progress. Integer, \u22650 use-dla-core=0 All Both network-type Type of network Integer 0: Detector 1: Classifier 2: Segmentation 3: Instance Segmentation network-type=1 All Both maintain-aspect-ratio Indicates whether to maintain aspect ratio while scaling input. Boolean maintain-aspect-ratio=1 All Both symmetric-padding Indicates whether to pad image symmetrically while scaling input. DeepStream pads the images asymmetrically by default. Boolean symmetric-padding=1 All Both parse-classifier-func-name Name of the custom classifier output parsing function. If not specified, Gst-nvinfer uses the internal parsing function for softmax layers. String parse-classifier-func-name=\u00ad parse_bbox_softmax Classifier Both custom-network-config Pathname of the configuration file for custom networks available in the custom interface for creating CUDA engines. String custom-network-config= /home/\u00adubuntu/\u00adnetwork.config All Both tlt-encoded-model Pathname of the TAO toolkit encoded model. String tlt-encoded-model=\u00ad /home/\u00adubuntu/\u00admodel.etlt All Both tlt-model-key Key for the TAO toolkit encoded model. String tlt-model-key=abc All Both segmentation-threshold Confidence threshold for the segmentation model to output a valid class for a pixel. If confidence is less than this threshold, class output for that pixel is \u22121. Float, \u22650.0 segmentation-threshold=0.3 Segmentation, Instance segmentation Both segmentation-output-order Segmentation network output layer order Integer 0: NCHW 1: NHWC segmentation-output-order=1 Segmentation Both workspace-size Workspace size to be used by the engine, in MB Integer, &gt;0 workspace-size=45 All Both force-implicit-batch-dim When a network supports both implicit batch dimension and full dimension, force the implicit batch dimension mode. Boolean force-implicit-batch-dim=1 All Both engine-create-func-name Name of the custom TensorRT CudaEngine creation function. Refer to the \u201cCustom Model Implementation Interface\u201d section for details String engine-create-func-name= NvDsInferYoloCudaEngineGet All Both cluster-mode Clustering algorithm to use. Refer to the next table for configuring the algorithm specific parameters. Refer Clustering algorithms supported by nvinfer for more information Integer 0: OpenCV groupRectangles() 1: DBSCAN 2: Non Maximum Suppression 3: DBSCAN + NMS Hybrid 4: No clustering cluster-mode=2 cluster-mode=4 for instance segmentation Detector Both filter-out-class-ids Filter out detected objects belonging to specified class-ids Semicolon delimited integer array filter-out-class-ids=1 2 scaling-filter The filter to use for scaling frames / object crops to network resolution (ignored if input-tensor-meta enabled) Integer, refer to enum NvBufSurfTransform_Inter in nvbufsurftransform.h for valid values scaling-filter=1 All Both scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution (ignored if input-tensor-meta enabled) Integer 0: Platform default \u2013 GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) scaling-compute-hw=2 All Both output-io-formats Specifies the data type and order for bound output layers. For layers not specified, defaults to FP32 and CHW Semi-colon separated list of format. &lt;output-layer1-name&gt;:&lt;data-type&gt;:&lt;order&gt;;&lt;output-layer2-name&gt;:&lt;data-type&gt;:&lt;order&gt; data-type should be one of [fp32, fp16, int32, int8] order should be one of [chw, chw2, chw4, hwc8, chw16, chw32] output-io-formats= conv2d_bbox:fp32:chw;conv2d_cov/Sigmoid:fp32:chw All Both Layer-device-precision Specifies the device type and precision for any layer in the network Semi-colon separated list of format. &lt;layer1-name&gt;:&lt;precision&gt;:&lt;device-type&gt;;&lt;layer2-name&gt;:&lt;precision&gt;:&lt;device-type&gt;; precision should be one of [fp32, fp16, int8] Device-type should be one of [gpu, dla] layer-device-precision= output_cov/Sigmoid:fp32:gpu;output_bbox/BiasAdd:fp32:gpu; All Both network-input-order Order of the network input layer (ignored if input-tensor-meta enabled) Integer 0:NCHW 1:NHWC network-input-order=1 All Both classifier-type Description of what the classifier does String (alphanumeric, \u2018-\u2019 and \u2018_\u2019 allowed, no spaces) classifier-type=vehicletype Classifier Both crop-objects-to-roi-boundary Clip the object bounding boxes to fit within the specified ROI boundary. Boolean crop-objects-to-roi-boundary=1 Detector Both Name Description Type and Range Example Notes (Primary/Secondary) threshold Detection threshold Float, \u22650 threshold=0.5 Object detector Both pre-cluster-threshold Detection threshold to be applied prior to clustering operation Float, \u22650 pre-cluster-threshold= 0.5 Object detector Both post-cluster-threshold Detection threshold to be applied post clustering operation Float, \u22650 post-cluster-threshold= 0.5 Object detector Both eps Epsilon values for OpenCV grouprectangles() function and DBSCAN algorithm Float, \u22650 eps=0.2 Object detector Both group-threshold Threshold value for rectangle merging for OpenCV grouprectangles() function Integer, \u22650 group-threshold=1 0 disables the clustering functionality Object detector Both minBoxes Minimum number of points required to form a dense region for DBSCAN algorithm Integer, \u22650 minBoxes=1 0 disables the clustering functionality Object detector Both dbscan-min-score Minimum sum of confidence of all the neighbors in a cluster for it to be considered a valid cluster. Float, \u22650 dbscan-min-score= 0.7 Object detector Both nms-iou-threshold Maximum IOU score between two proposals after which the proposal with the lower confidence will be rejected. Float, \u22650 nms-iou-threshold= 0.2 Object detector Both roi-top-offset Offset of the RoI from the top of the frame. Only objects within the RoI are output. Integer, \u22650 roi-top-offset= 200 Object detector Both roi-bottom-offset Offset of the RoI from the bottom of the frame. Only objects within the RoI are output. Integer, \u22650 roi-bottom-offset= 200 Object detector Both detected-min-w Minimum width in pixels of detected objects to be output by the GIE Integer, \u22650 detected-min-w= 64 Object detector Both detected-min-h Minimum height in pixels of detected objects to be output by the GIE Integer, \u22650 detected-min-h= 64 Object detector Both detected-max-w Maximum width in pixels of detected objects to be output by the GIE Integer, \u22650 detected-max-w=200 0 disables the property Object detector Both detected-max-h Maximum height in pixels of detected objects to be output by the GIE Integer, \u22650 detected-max-h=200 0 disables the property Object detector Both topk Keep only top K objects with highest detection scores. Integer, \u22650. -1 to disable topk=10 Object detector Both UFF model support is removed from TRT 10.3.", "keywords": []}, {"id": 2853, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "gst-properties", "priority": -1, "content": "The values set through Gst properties override the values of properties in the configuration file. The application does this for certain properties that it needs to set programmatically. The following table describes the Gst-nvinfer plugin\u2019s Gst properties. Property Meaning Type and Range Example notes config-file-path Absolute pathname of configuration file for the Gst-nvinfer element String config-file-path=\u00adconfig_infer_primary.txt process-mode Infer Processing Mode 1=Primary Mode 2=Secondary Mode Integer, 1 or 2 process-mode=1 unique-id Unique ID identifying metadata generated by this GIE Integer, | 0 to 4,294,967,295 unique-id=1 infer-on-gie-id See operate-on-gie-id in the configuration file table Integer, 0 to 4,294,967,295 infer-on-gie-id=1 operate-on-class-ids See operate-on-class-ids in the configuration file table An array of colon- separated integers (class-ids) operate-on-class-ids=1:2:4 filter-out-class-ids See filter-out-class-ids in the configuration file table Semicolon delimited integer array filter-out-class-ids=1;2 model-engine-file Absolute pathname of the pre-generated serialized engine file for the mode String model-engine-file=\u00admodel_b1_fp32.engine batch-size Number of frames/objects to be inferred together in a batch Integer, 1 \u2013 4,294,967,295 batch-size=4 Interval Number of consecutive batches to be skipped for inference Integer, 0 to 32 interval=0 gpu-id Device ID of GPU to use for pre-processing/inference (dGPU only) Integer, 0-4,294,967,295 gpu-id=1 raw-output-file-write Pathname of raw inference output file Boolean raw-output-file-write=1 raw-output-generated-callback Pointer to the raw output generated callback function Pointer Cannot be set through gst-launch raw-output-generated-userdata Pointer to user data to be supplied with raw-output-generated-callback Pointer Cannot be set through gst-launch output-tensor-meta Indicates whether to attach tensor outputs as meta on GstBuffer. Boolean output-tensor-meta=0 output-instance-mask Gst-nvinfer attaches instance mask output in object metadata. Boolean output-instance-mask=1 input-tensor-meta Use preprocessed input tensors attached as metadata instead of preprocessing inside the plugin Boolean input-tensor-meta=1 crop-objects-to-roi-boundary Clip the object bounding boxes to fit within the specified ROI boundary Boolean crop-objects-to-roi-boundary=1", "keywords": []}, {"id": 2854, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvinfer plugin. Inputs Gst Buffer NvDsBatchMeta (attaching NvDsFrameMeta) ONNX TAO Encoded Model and Key Offline: Supports engine files generated by TAO Toolkit SDK Model converters Layers: Supports all layers supported by TensorRT, see: https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html . Control parameters Gst-nvinfer gets control parameters from a configuration file. You can specify this by setting the property config-file-path. For details, see Gst-nvinfer File Configuration Specifications. Other control parameters that can be set through GObject properties are: Batch size Inference interval Attach inference tensor outputs as buffer metadata Attach instance mask output as in object metadata The parameters set through the GObject properties override the parameters in the Gst-nvinfer configuration file. Outputs Gst Buffer Depending on network type and configured parameters, one or more of: NvDsObjectMeta NvDsClassifierMeta NvDsInferSegmentationMeta NvDsInferTensorMeta", "keywords": []}, {"id": 2855, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#segmentation-metadata", "display_name": "Segmentation Metadata", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "segmentation-metadata", "priority": -1, "content": "The Gst-nvinfer plugin attaches the output of the segmentation model as user meta in an instance of NvDsInferSegmentationMeta with meta_type set to NVDSINFER_SEGMENTATION_META . The user meta is added to the frame_user_meta_list member of NvDsFrameMeta for primary (full frame) mode, or the obj_user_meta_list member of NvDsObjectMeta for secondary (object) mode. For guidance on how to access user metadata, see User/Custom Metadata Addition inside NvDsBatchMeta and Tensor Metadata sections.", "keywords": []}, {"id": 2856, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#tensor-metadata", "display_name": "Tensor Metadata", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "tensor-metadata", "priority": -1, "content": "The Gst-nvinfer plugin can attach raw output tensor data generated by a TensorRT inference engine as metadata. It is added as an NvDsInferTensorMeta in the frame_user_meta_list member of NvDsFrameMeta for primary (full frame) mode, or in the obj_user_meta_list member of NvDsObjectMeta for secondary (object) mode.", "keywords": []}, {"id": 2857, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinfer#to-read-or-parse-inference-raw-tensor-data-of-output-layers", "display_name": "To read or parse inference raw tensor data of output layers", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "to-read-or-parse-inference-raw-tensor-data-of-output-layers", "priority": -1, "content": "Enable property output-tensor-meta or enable the same-named attribute in the configuration file for the Gst-nvinfer plugin. When operating as primary GIE,` NvDsInferTensorMeta` is attached to each frame\u2019s (each NvDsFrameMeta object\u2019s) frame_user_meta_list . When operating as secondary GIE, NvDsInferTensorMeta is attached to each each NvDsObjectMeta object\u2019s obj_user_meta_list . Metadata attached by Gst-nvinfer can be accessed in a GStreamer pad probe attached downstream from the Gst-nvinfer instance. The NvDsInferTensorMeta object\u2019s metadata type is set to NVDSINFER_TENSOR_OUTPUT_META . To get this metadata you must iterate over the NvDsUserMeta user metadata objects in the list referenced by frame_user_meta_list or obj_user_meta_list . For more information about Gst-infer tensor metadata usage, see the source code in sources/apps/sample_apps/deepstream_infer_tensor_meta-test.cpp , provided in the DeepStream SDK samples.", "keywords": []}, {"id": 2858, "doc_id": 2858, "filename": "text/DS_plugin_gst-nvinfer.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvinfer", "display_name": "Gst-nvinfer", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvinfer", "anchor": "", "priority": -1, "content": "The Gst-nvinfer plugin does inferencing on input data using NVIDIA \u00ae TensorRT\u2122. The plugin accepts batched NV12/RGBA buffers from upstream. The NvDsBatchMeta structure must already be attached to the Gst Buffers. The low-level library ( libnvds_infer ) operates on any of INT8 RGB, BGR, or GRAY data with dimension of Network Height and Network Width. The Gst-nvinfer plugin performs transforms (format conversion and scaling), on the input frame based on network requirements, and passes the transformed data to the low-level library. The low-level library preprocesses the transformed frames (performs normalization and mean subtraction) and produces final float RGB/BGR/GRAY planar data which is passed to the TensorRT engine for inferencing. The output type generated by the low-level library depends on the network type. The pre-processing function is: y = net scale factor*(x-mean) Where: x is the input pixel value. It is an int8 with range [0,255]. mean is the corresponding mean value, read either from the mean file or as offsets[c], where c is the channel to which the input pixel belongs, and offsets is the array specified in the configuration file. It is a float. net-scale-factor is the pixel scaling factor specified in the configuration file. It is a float. y is the corresponding output pixel value. It is a float. Gst-nvinfer currently works on the following type of networks: Multi-class object detection Multi-label classification Segmentation (semantic) Instance Segmentation The Gst-nvinfer plugin can work in three modes: Primary mode: Operates on full frames Secondary mode: Operates on objects added in the meta by upstream components Preprocessed Tensor Input mode: Operates on tensors attached by upstream components When operating in preprocessed tensor input mode, the pre-processing inside Gst-nvinfer is completely skipped. The plugin looks for GstNvDsPreProcessBatchMeta attached to the input buffer and passes the tensor as is to TensorRT inference function without any modifications. This mode currently supports processing on full-frame and ROI. The GstNvDsPreProcessBatchMeta is attached by the Gst-nvdspreprocess plugin. When the plugin is operating as a secondary classifier along with the tracker, it tries to improve performance by avoiding re-inferencing on the same objects in every frame. It does this by caching the classification output in a map with the object\u2019s unique ID as the key. The object is inferred upon only when it is first seen in a frame (based on its object ID) or when the size (bounding box area) of the object increases by 20% or more. This optimization is possible only when the tracker is added as an upstream element. Detailed documentation of the TensorRT interface is available at: https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html The plugin supports the IPlugin interface for custom layers. Refer to section IPlugin Interface for details. The plugin also supports the interface for custom functions for parsing outputs of object detectors and initialization of non-image input layers in cases where there is more than one input layer. Refer to sources/includes/nvdsinfer_custom_impl.h for the custom method implementations for custom models. Downstream components receive a Gst Buffer with unmodified contents plus the metadata created from the inference output of the Gst-nvinfer plugin. The plugin can be used for cascaded inferencing. That is, it can perform primary inferencing directly on input data, then perform secondary inferencing on the results of primary inferencing, and so on. See the sample application deepstream-test2 for more details.", "keywords": []}, {"id": 2859, "doc_id": 2862, "filename": "text/DS_plugin_gst-nvinferaudio.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferaudio#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferaudio", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release nvinferaudio plugin for audio inference Introducing nvinferaudio DeepStream 5.1.0 The Gst-nvinferaudio configuration file uses a \u201cKey File\u201d format described in https://specifications.freedesktop.org/desktop-entry-spec/latest . The [property] group configures the general behavior of the plugin. It is the only mandatory group. The [class-attrs-all] group configures detection parameters for all classes. The [class-attrs-&lt;class-id&gt;] group configures detection parameters for a class specified by &lt;class-id&gt;. For example, the [class-attrs-23] group configures detection parameters for class ID 23. This type of group has the same keys as [class-attrs-all]. The following two tables respectively describe the keys supported for [property] groups and [class-attrs-\u2026] groups. Property Meaning Type and Range Example Notes Network Types / Applicable to GIEs (Primary/\u00adSecondary) num-detected-classes Number of classes detected by the network Integer, &gt;0 num-detected-classes=\u00ad91 Detector Both net-scale-factor Pixel normalization factor Float, &gt;0.0 net-scale-factor=\u00ad0.031 All Both model-file Pathname of the caffemodel file. Not required if model-engine-file is used String model-file=\u00ad/home/\u00adubuntu/\u00admodel.caffemodel All Both proto-file Pathname of the prototxt file. Not required if model-engine-file is used String proto-file=\u00ad/home/\u00adubuntu/\u00admodel.prototxt All Both int8-calib-file Pathname of the INT8 calibration file for dynamic range adjustment with an FP32 model String int8-calib-file=\u00ad/home/\u00adubuntu/\u00adint8_calib All Both batch-size Number of frames or objects to be inferred together in a batch Integer, &gt;0 batch-size=30 All Both model-engine-file Pathname of the serialized model engine file String model-engine-file=\u00ad/home/\u00adubuntu/\u00admodel.engine All Both onnx-file Pathname of the ONNX model file String onnx-file=\u00ad/home/\u00adubuntu/\u00admodel.onnx All Both labelfile-path Pathname of a text file containing the labels for the model String labelfile-path=\u00ad/home/\u00adubuntu/\u00admodel_labels.txt Detector &amp; classifier Both output-blob-names Array of output layer names Semicolon delimited string array For detector: output-blob-names=coverage;bbox For multi-label classifiers: output-blob-names = coverage_attrib1;coverage_attrib2 All Both custom-lib-path Absolute pathname of a library containing custom method implementations for custom models String custom-lib-path=\u00ad/home/\u00adubuntu/\u00adlibresnet_custom_impl.so All Both classifier-threshold Minimum threshold label probability. The GIE outputs the label having the highest probability if it is greater than this threshold Float, \u22650 classifier-threshold=0.4 Classifier Both output-tensor-meta Gst-nvinfer attaches raw tensor output as Gst Buffer metadata. Boolean output-tensor-meta=1 All Both network-type Type of network Integer 0: Detector 1: Classifier 2: Segmentation 3: Instance Segmentation network-type=1 All Both parse-classifier-func-name Name of the custom classifier output parsing function. If not specified, Gst-nvinfer uses the internal parsing function for softmax layers. String parse-classifier-func-name=\u00adparse_bbox_softmax Classifier Both custom-network-config Pathname of the configuration file for custom networks available in the custom interface for creating CUDA engines. String custom-network-config=\u00ad/home/\u00adubuntu/\u00adnetwork.config All Both workspace-size Workspace size to be used by the engine, in MB Integer, &gt;0 workspace-size=45 All Both force-implicit-batch-dim When a network supports both implicit batch dimension and full dimension, force the implicit batch dimension mode. Boolean force-implicit-batch-dim=1 All Both infer-dims Binding dimensions to set on the image input layer. channel; infer-dims=3;224;224 All Both uff-input-order UFF input layer order Integer 0: NCHW 1: NHWC 2: NC uff-input-order=1 All Both engine-create-func-name Name of the custom TensorRT CudaEngine creation function. Refer to the \u201cCustom Model Implementation Interface\u201d section for details String engine-create-func-name=NvDsInferYoloCudaEngineGet All Both output-io-formats Specifies the data type and order for bound output layers. For layers not specified, defaults to FP32 and CHW Semi-colon separated list of format. &lt;output-layer1-name&gt;:&lt;data-type&gt;:&lt;order&gt;;&lt;output-layer2-name&gt;:&lt;data-type&gt;:&lt;order&gt; data-type should be one of [fp32, fp16, int32, int8] order should be one of [chw, chw2, chw4, hwc8, chw16, chw32] output-io-formats=conv2d_bbox:fp32:chw;conv2d_cov/Sigmoid:fp32:chw All Both Layer-device-precision Specifies the device type and precision for any layer in the network Semi-colon separated list of format. &lt;layer1-name&gt;:&lt;precision&gt;:&lt;device-type&gt;;&lt;layer2-name&gt;:&lt;precision&gt;:&lt;device-type&gt;; precision should be one of [fp32, fp16, int8] Device-type should be one of [gpu, dla] layer-device-precision= output_cov/Sigmoid:fp32:gpu;output_bbox/BiasAdd:fp32:gpu; All Both Name Description Type and Range Example Notes (Primary/\u00adSecondary) threshold Detection threshold Float, \u22650 threshold=0.5 Object detector Both", "keywords": []}, {"id": 2860, "doc_id": 2862, "filename": "text/DS_plugin_gst-nvinferaudio.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferaudio#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferaudio", "anchor": "gst-properties", "priority": -1, "content": "The values set through Gst properties override the values of properties in the configuration file. The application does this for certain properties that it needs to set programmatically. The following table describes the Gst-nvinferaudio plugin\u2019s Gst properties. Property Meaning Type and Range Example notes config-file-path Absolute pathname of configuration file for the Gst-nvinfer element String config-file-path=\u00adconfig_infer_primary.txt unique-id Unique ID identifying metadata generated by this GIE Integer, | 0 to 4,294,967,295 unique-id=1 infer-on-gie-id See operate-on-gie-id in the configuration file table Integer, 0 to 4,294,967,295 infer-on-gie-id=1 operate-on-class-ids See operate-on-class-ids in the configuration file table An array of colon- separated integers (class-ids) operate-on-class-ids=1:2:4 filter-out-class-ids See filter-out-class-ids in the configuration file table Semicolon delimited integer array filter-out-class-ids=1;2 model-engine-file Absolute pathname of the pre-generated serialized engine file for the mode String model-engine-file=\u00admodel_b1_fp32.engine batch-size Number of audio frames to be inferred together in a batch Integer, 1 \u2013 4,294,967,295 batch-size=4 Interval Number of consecutive batches to be skipped for inference Integer, 0 to 32 interval=0 gpu-id Device ID of GPU to use for pre-processing/inference (dGPU only) Integer, 0-4,294,967,295 gpu-id=1 raw-output-file-write Pathname of raw inference output file Boolean raw-output-file-write=1 raw-output-generated-callback Pointer to the raw output generated callback function Pointer Cannot be set through gst-launch raw-output-generated-userdata Pointer to user data to be supplied with raw-output-generated-callback Pointer Cannot be set through gst-launch output-tensor-meta Indicates whether to attach tensor outputs as meta on GstBuffer. Boolean output-tensor-meta=0 output-instance-mask Gst-nvinfer attaches instance mask output in object metadata. Boolean output-instance-mask=1 audio-transform Transform name and parameters Boxed pointer of type \u201cGstStructure\u201d audio-transform= melsdb,fft_length=2560,hop_size=692,dsp_window=hann, num_mels=128,sample_rate=44100,p2db_ref=(float)1.0, p2db_min_power=(float)0.0,p2db_top_db=(float)80.0 audio-framesize Frame size to use for transform Unsigned Integer. Range: 0 - 4294967295 audio-framesize=441000 audio-hopsize Hop size to use for transform Unsigned Integer. Range: 0 - 4294967295 audio-hopsize=110250 Audio Transform parameters Description audio-transform Options: melsdb fft_length FFT length (unsigned int) hop_size Hop size (unsigned int) num_frequencies Number of frequency bins for specified FFT length (unsigned int) dsp_window DSP Window type (char*) Options: none hann hamming num_mels Number of mel bins (unsigned int) sample_rate Sample rate (unsigned int) p2db_ref DSP parameters for power_to_db Reference (float) p2db_min_power DSP parameters for power_to_db Min power (float) p2db_top_db DSP parameters for power_to_db Top DB (float) attach-sys-ts Support pending and shall be added with future releases.", "keywords": []}, {"id": 2861, "doc_id": 2862, "filename": "text/DS_plugin_gst-nvinferaudio.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferaudio#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferaudio", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvinferaudio plugin. Inputs Gst Buffer NvDsBatchMeta (attaching NvDsFrameMeta) ONNX Layers: Supports all layers supported by TensorRT, see: https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html Control parameters Gst-nvinferaudio gets control parameters from a configuration file. You can specify this by setting the property config-file-path. For details, see Gst-nvinferaudio File Configuration Specifications. Other control parameters that can be set through GObject properties are: Batch size Inference interval Attach inference tensor outputs as buffer metadata Attach instance mask output as in object metadata The parameters set through the GObject properties override the parameters in the Gst-nvinferaudio configuration file. Outputs Gst Buffer NvDsFrameMeta NvDsClassifierMeta", "keywords": []}, {"id": 2862, "doc_id": 2862, "filename": "text/DS_plugin_gst-nvinferaudio.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvinferaudio", "display_name": "Gst-nvinferaudio", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvinferaudio", "anchor": "", "priority": -1, "content": "The Gst-nvinferaudio plugin does inferencing on input data using NVIDIA\u00ae TensorRT\u2122. The plugin accepts batched audio buffers from upstream. The NvDsBatchMeta structure must already be attached to the Gst Buffers. The low-level library (libnvds_infer) operates on transformed audio data with dimension CHW. The Gst-nvinferaudio plugin performs transform (log mel spectogram), on the input frame based on audio-transform property setting and transformed audio data is passed to the TensorRT engine for inferencing. The output type generated by the low-level library depends on the network type. Gst-nvinferaudio currently works on the following type of networks: Encoder Decoder RNN Architecture CNN Detailed documentation of the TensorRT interface is available at: https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html Downstream components receive a Gst Buffer with unmodified contents plus the metadata created from the inference output of the Gst-nvinferaudio plugin.", "keywords": []}, {"id": 2863, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#custom-process-interface-iinfercustomprocessor-for-extra-input-lstm-loop-output-tensor-postprocess", "display_name": "Custom Process interface IInferCustomProcessor for Extra Input, LSTM Loop, Output Tensor Postprocess", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "custom-process-interface-iinfercustomprocessor-for-extra-input-lstm-loop-output-tensor-postprocess", "priority": -1, "content": "Gst-nvinferserver plugin supports extra(multiple) input tensors custom preprocessing, input / output tensor custom loop processing (LSTM-based) with multiple streams, output tensor data custom parsing and attaching into NvDsBatchMeta. This custom function is loaded though gst-nvinferserver\u2019s config file: infer_config { backend { triton { model_name: &quot;yolov3-10_onnx&quot; # option 1: for CAPI inference # model_repo { root: &quot;./model_repo&quot; } # option 2: for gRPC inference # grpc { url: &quot;localhost:8001&quot; } } # specify output tensor memory type, MEMORY_TYPE_CPU/MEMORY_TYPE_GPU output_mem_type: MEMORY_TYPE_CPU } preprocess { ... } # specify scale and normalization # postprocess{ other{} } # skip generic postprocess # specify custom processing library custom_lib { path: &quot;/path/to/libnvdsinferserver_custom_process.so&quot; } extra { # specify custom processing function entrypoint from custom_lib custom_process_funcion: &quot;CreateInferServerCustomProcess&quot; } } The interface IInferCustomProcessor is defined in sources/includes/nvdsinferserver/infer_custom_process.h . class IInferCustomProcessor { virtual void supportInputMemType(InferMemType&amp; type); // return supported memory type for `extraInputs` virtual bool requireInferLoop() const; // indicate whether LSTM loop is needed. return &#x27;false&#x27; if not needed. // custom implementation for extra input tensors processing, `primaryInputs` is processed by preprocess{} from config file. // param `options` is helpful to carry extra information such as stream_ids, `NvBufSurface`, `NvDsBatchMeta`, `GstBuffer` virtual NvDsInferStatus extraInputProcess(const vector&lt;IBatchBuffer*&gt;&amp; primaryInputs, vector&lt;IBatchBuffer*&gt;&amp; extraInputs, const IOptions* options) = 0; // param `outputs` is a array of all batched output tensors. param `inOptions` is same as extraInputProcess virtual NvDsInferStatus inferenceDone(const IBatchArray* outputs, const IOptions* inOptions) = 0; virtual void notifyError(NvDsInferStatus status) = 0; }; Users need derive from IInferCustomProcessor to implement their own extra preprocessing through extraInputProcess and fully postprocessing through inferenceDone . the param structred in IOptions carry all information from GstBuffer and NvDsBatchMeta. Users can query them through IOptions for each frame and batch. see more examples in /opt/nvidia/deepstream/deepstream/sources/TritonOnnxYolo/nvdsinferserver_custom_impl_yolo/nvdsinferserver_custom_process_yolo.cpp Take a example for a simple postprocessing to add output tensors. #include &lt;inttypes.h&gt; #include &lt;unistd.h&gt; #include &lt;cassert&gt; #include &lt;unordered_map&gt; #include &quot;infer_custom_process.h&quot; #include &quot;nvbufsurface.h&quot; #include &quot;nvdsmeta.h&quot; typedef struct _GstBuffer GstBuffer; using namespace nvdsinferserver; #defin INFER_ASSERT assert class NvInferServerCustomProcess : public IInferCustomProcessor { // memtype for ``extraInputs``, set ``kGpuCuda`` for performance void supportInputMemType(InferMemType&amp; type) override { type = InferMemType::kGpuCuda; } // for LSTM loop. return false if not required. bool requireInferLoop() const override { return false; } // skip extraInputProcess if there is no extra input tensors NvDsInferStatus extraInputProcess(const std::vector&lt;IBatchBuffer*&gt;&amp; primaryInputs, std::vector&lt;IBatchBuffer*&gt;&amp; extraInputs, const IOptions* options) override { return NVDSINFER_SUCCESS; } // output tensor postprocessing function. NvDsInferStatus inferenceDone(const IBatchArray* outputs, const IOptions* inOptions) override { GstBuffer* gstBuf = nullptr; std::vector&lt;uint64_t&gt; streamIds; NvDsBatchMeta* batchMeta = nullptr; std::vector&lt;NvDsFrameMeta*&gt; frameMetaList; NvBufSurface* bufSurf = nullptr; std::vector&lt;NvBufSurfaceParams*&gt; surfParamsList; int64_t unique_id = 0; INFER_ASSERT (inOptions-&gt;getValueArray(OPTION_NVDS_SREAM_IDS, streamIds) == NVDSINFER_SUCCESS); INFER_ASSERT(inOptions-&gt;getObj(OPTION_NVDS_BUF_SURFACE, bufSurf) == NVDSINFER_SUCCESS); INFER_ASSERT(inOptions-&gt;getObj(OPTION_NVDS_BATCH_META, batchMeta) == NVDSINFER_SUCCESS); INFER_ASSERT(inOptions-&gt;getInt(OPTION_NVDS_UNIQUE_ID, unique_id) == NVDSINFER_SUCCESS); INFER_ASSERT(inOptions-&gt;getValueArray(OPTION_NVDS_BUF_SURFACE_PARAMS_LIST, surfParamsList) == NVDSINFER_SUCCESS); INFER_ASSERT(inOptions-&gt;getValueArray(OPTION_NVDS_FRAME_META_LIST, frameMetaList) == NVDSINFER_SUCCESS); uint64_t nsTimestamp = UINT64_MAX; // nano-seconds if (inOptions-&gt;hasValue(OPTION_TIMESTAMP)) { INFER_ASSERT(inOptions-&gt;getUInt(OPTION_TIMESTAMP, nsTimestamp) == NVDSINFER_SUCCESS); } std::unordered_map&lt;std::string, SharedIBatchBuffer&gt; tensors; for (uint32_t i = 0; i &lt; outputs-&gt;getSize(); ++i) { SharedIBatchBuffer outTensor = outputs-&gt;getSafeBuf(i); INFER_ASSERT(outTensor); auto desc = outTensor-&gt;getBufDesc(); tensors.emplace(desc.name, outTensor); } // parsing output tensors float* boxesPtr = (float*)tensors[&quot;output_bbox&quot;]-&gt;getBufPtr(0); auto&amp; bboxDesc = tensors[&quot;output_bbox&quot;]-&gt;getBufDesc(); float* scoresPtr = (float*)tensors[&quot;output_score&quot;]-&gt;getBufPtr(0); float* numPtr = (float*)tensors[&quot;output_bbox_num&quot;]-&gt;getBufPtr(0); int32_t batchSize = bboxDesc.dims.d[0]; // e.g. tensor shape [Batch, num, 4] std::vector&lt;std::vector&lt;NvDsInferObjectDetectionInfo&gt;&gt; batchedObjs(batchSize); // parsing data into batchedObjs ... // attach to NvDsBatchMeta for (int iB = 0; iB &lt; batchSize; ++iB) { const auto&amp; objs = batchedObjs[iB]; for (const auto&amp; obj : objs) { NvDsObjectMeta* objMeta = nvds_acquire_obj_meta_from_pool(batchMeta); objMeta-&gt;unique_component_id = unique_id; objMeta-&gt;confidence = obj.detectionConfidence; objMeta-&gt;class_id = obj.classId; objMeta-&gt;rect_params.left = obj.left; objMeta-&gt;rect_params.top = obj.top; objMeta-&gt;rect_params.width = obj.width; objMeta-&gt;rect_params.height = obj.height; // other settings ... // add NvDsObjectMeta obj into NvDsFrameMeta frame. nvds_add_obj_meta_to_frame(frameMetaList[iB], objMeta, NULL); } } } }; extern &quot;C&quot; { IInferCustomProcessor* CreateInferServerCustomProcess(const char* config, uint32_t configLen) { return new NvInferServerCustomProcess(); } } For extra input tensors preprocess: If the model requires multiple tensor inputs more than the primary image input, Users can derive from this interface IInferCustomProcessor and implement extraInputProcess() to process extra inputs tensors. This function is for extra input process only. the parameter IOptions* options would carry all the information from GstBuffer, NvDsBatchMeta, NvDsFrameMeta, NvDsObjectMeta and so on. User can leverage all of the information from options to fill the extra input tensors. All of the input tensor memory is allocated by nvdsinferserver low-level lib. For output tensor postprocess(parsing and metadata attaching): If user want to do custom parsing on output tensors into user metadata and attach them into GstBuffer, NvDsBatchMeta, NvDsFrameMeta or NvDsObjectMeta. User can implement \u2018inferenceDone(outputs, inOptions)\u2019 to parse all output tensors in outputs , and get above GstBuffer, NvDsBatchMeta and other DeepStream information from inOptions . Then attach the parsed user metadata into NvDs metadata. This function supports multiple-streams parsing and attaching. See examples in /opt/nvidia/deepstream/deepstream/sources/TritonOnnxYolo/nvdsinferserver_custom_impl_yolo/nvdsinferserver_custom_process_yolo.cpp: NvInferServerCustomProcess::inferenceDone() how to parse and attach output metadata. If user need specific memory type(e.g. CPU) for output tensors in inferenceDone() . Update config file. infer_config { backend { output_mem_type: MEMORY_TYPE_CPU } } For multi-stream custom loop process: If the model is LSTM based, and next frame\u2019s inputs are generated by previous frame\u2019s output data. User can derive interface IInferCustomProcessor , then implement extraInputProcess() and inferenceDone() for loop process. extraInputProcess() could initialize first input tensor states. Then \u2018inferenceDone()\u2019 can get the output data and do post processing and store the result into the context. When next \u2018extraInputProcess()\u2019 is coming, it can check the stored results and feedback into tensor states. When user override bool requireInferLoop() const { return true; } . The nvdsinferver low-level lib shall keep the extraInputProcess and inferenceDone running in sequence along with its nvds_stream_ids which could be get from options-&gt;getValueArray(OPTION_NVDS_SREAM_IDS, streamIds) . see examples and details in /opt/nvidia/deepstream/deepstream/sources/TritonOnnxYolo/nvdsinferserver_custom_impl_yolo/nvdsinferserver_custom_process_yolo.cpp . Inside this example, see function NvInferServerCustomProcess::feedbackStreamInput how to feedback output into next input loop.", "keywords": []}, {"id": 2864, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#deepstream-triton-grpc-support", "display_name": "DeepStream Triton gRPC support", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "deepstream-triton-grpc-support", "priority": -1, "content": "In addition to native Triton server, gst-nvinferserver supports the Triton Inference Server running as independent process. Communication to the server happens through gRPC. Config files to run the application in gRPC mode are located at samples/config/deepstream-app-triton-grpc . Follow the instructions in samples/configs/deepstream-app-triton-grpc/README to run the samples.", "keywords": []}, {"id": 2865, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#deepstream-triton-samples", "display_name": "DeepStream Triton samples", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "deepstream-triton-samples", "priority": -1, "content": "DeepStream Triton samples are located in the folder samples/configs/deepstream-app-triton . In terms of Triton model specification, all related models and Triton config files( config.pbtxt ) must be gathered into same root directory which is samples/triton_model_repo . Follow the instructions in samples/configs/deepstream-app-triton/README to run the samples.", "keywords": []}, {"id": 2866, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature dGPU Jetson Release Gst-nvinferserver Running on Host No Yes DS 5.0 Running on Docker Image Yes Yes(DS 6.0) DS 5.0 DS Preprocessing: Network input format: RGB/BGR/Gray Yes Yes DS 5.0 DS Preprocessing: Network input data types FP32/FP16/UINT8/INT8/UINT16/INT16/UINT32/INT32 Yes Yes DS 5.0 DS Preprocessing: Network input tensor orders NCHW / NHWC Yes Yes DS 5.0 Mem: Cuda(GPU) buf-sharing for Input Tensors Yes Yes DS 5.0 Mem: Cuda Memory (GPU / CPU-pinned) for output tensors Yes Yes DS 5.0 Backend: TensorRT runtime (plan engine file) Yes Yes DS 5.0 Backend: Tensorflow Runtime CPU/GPU (graphdef/savedmodel) Yes Yes DS 5.0 Backend: Tensorflow Runtime with TF-TRT acceleration Yes Yes DS 5.0 Backend: ONNX Runtime Yes Yes(DS 6.0) DS 5.0 Backend: ONNX Runtime with ONNX-TRT acceleration Yes Yes(DS 6.0) DS 5.0 Backend: Pytorch Runtime Yes No DS 5.0 Postprocessing: DS Detection / Classification/ Segmentation Yes Yes DS 5.0 Postprocessing: DS Detection cluster method: NMS / GroupRectangle / DBSCan / None Yes Yes DS 5.0 Postprocessing: custom parsing (NvDsInferParseCustomTfSSD) Yes Yes DS 5.0 Postprocessing: Triton native classification Yes Yes DS 5.0 Triton Ensemble Mode (Triton preproc/postproc) with specified media-format (RGB/BGR/Gray) with Cuda GPU buffer as inputs Yes Yes DS 5.0 Postprocessing: Attach Triton raw tensor output in NvDsInferTensorMeta for downstream or application postprocessing Yes Yes DS 5.0 deepstream-app: pipeline works with PGIE / SGIE / nvtracker Yes Yes DS 5.0 Sample App: deepstream-segmentation-test / deepstream-infer-tensor-meta-test Yes Yes DS 5.0 Basic LSTM features on single batch and single stream (beta version, config file might be changed in future version) Yes Yes DS 5.0 gRPC: Triton Server running as independent process and plugin communicates through gRPC Yes Yes DS 6.0 Custom process interface IInferCustomProcessor for extra multi-input tensors preprocess, multi-streams LSTM loop process, custom output data postprocess(parsing and metadata attaching). Basic single-stream LSTM could be replaced by custom loop process Yes Yes DS 6.0 gRPC: CUDA buffer sharing with local Triton server for input tensors Yes Yes DS 6.2 Postprocessing: Clip object bounding boxes to fit within the ROI Yes Yes DS 6.3 Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) infer_config Low-level libnvds_infer_server inference configuration settings InferenceConfig infer_config { \u2026 } see details in InferenceConfig All Both input_control Control plugin input buffers, objects filtering policy for inference PluginControl ::InputControl input_control{ process_mode: PROCESS_MODE_FULL_FRAME } see details in InputControl All Both output_control Control plugin output metadata filtering policy after inference PluginControl ::OutputControl output_control { \u2026 } see details in OutputControl All Both process_mode Processing mode, selected from PluginControl::ProcessMode. In deepstream-app PGIE uses PROCESS_MODE_FULL_FRAME by default, SGIE use PROCESS_MODE_CLIP_OBJECTS by default enum PluginControl::ProcessMode process_mode: PROCESS_MODE_FULL_FRAME All Both operate_on_gie_id Unique ID of the GIE on whose metadata (bounding boxes) this GIE is to operate on int32, &gt;=0, valid gie-id. -1, disable gie-id check, inference on all GIE Ids operate_on_gie_id: 1 All Secondary operate_on_class_ids Class IDs of the parent GIE on which this GIE is to operate on Comma delimited int32 array operate_on_class_ids: [1, 2] Operates on objects with class IDs 1, 2 generated by parent GIE All Secondary interval Specifies the number of consecutive, batches to be skipped for inference. default is 0 uint32 interval: 1 All Primary async_mode Enables inference on detected objects and asynchronous metadata attachments. Works only when tracker-ids are attached. Pushes buffer downstream without waiting for inference results. Attaches metadata after the inference bool async_mode: false Classifier Secondary object_control input object filter settings PluginControl::InputObjectControl object_control { bbox_filter { min_width: 64 min_height: 64 } } see details in InputObjectControl All Secondary Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) process_mode Processing mode, selected from PluginControl::ProcessMode. In deepstream-app PGIE uses PROCESS_MODE_FULL_FRAME by default, SGIE use PROCESS_MODE_CLIP_OBJECTS by default enum PluginControl::ProcessMode process_mode: PROCESS_MODE_FULL_FRAME All Both operate_on_gie_id Unique ID of the GIE on whose metadata (bounding boxes) this GIE is to operate on int32, &gt;=0, valid gie-id. -1, disable gie-id check, inference on all GIE Ids operate_on_gie_id: 1 All Secondary operate_on_class_ids Class IDs of the parent GIE on which this GIE is to operate on Comma delimited int32 array operate_on_class_ids: [1, 2] Operates on objects with class IDs 1, 2 generated by parent GIE All Secondary interval Specifies the number of consecutive, batches to be skipped for inference. default is 0 uint32 interval: 1 All Primary async_mode Enables inference on detected objects and asynchronous metadata attachments. Works only when tracker-ids are attached. Pushes buffer downstream without waiting for inference results. Attaches metadata after the inference bool async_mode: false Classifier Secondary object_control input object filter settings PluginControl::InputObjectControl object_control { bbox_filter { min_width: 64 min_height: 64 } } see details in InputObjectControl All Secondary secondary_reinfer_interval Re-inference interval for objects, in frames uint32 secondary_reinfer_interval: 90 All Secondary Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) output_tensor_meta Enable attaching Inference output tensor metadata, tensor buffer pointer for host only bool output_tensor_meta: false All Both detect_control Specifies detection output filter policy PluginControl::OutputDetectionControl detect_control { default_filter { bbox_filter { min_width: 32 min_height: 32 } } } see details in OutputDetectionControl Detector Both classifier_type The classifier type to be added in the NvDsClassifierMeta in case of classification networks string classifier_type: multi_class_classification Classifier Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) bbox_filter Bounding box filter PluginControl::BBoxFilter bbox_filter { min_width: 32 min_height: 32 } see details in BBoxFilter All Secondary Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) min_width Bounding box minimum width uint32 min_width: 64 All Both min_height Bounding box minimum height uint32 min_height: 64 All Both max_width Bounding box maximum width, default 0, max_width is ignored uint32 max_width: 640 All Both max_height Bounding box maximum height, default 0, max_height is ignored uint32 max_height: 640 All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) default_filter default detection filter for output controls PluginControl::DetectClassFilter default_filter { bbox_filter { min_width: 32 min_height: 32 } } see details in DetectClassFilter All Both specific_class_filters specifies detection filters per class to replace default filter map&lt;uint32, DetectClassFilter&gt; specific_class_filters: [ { key: 1, value {\u2026} }, { key: 2, value {\u2026} } ] All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) bbox_filter detection bounding box filter PluginControl::BBoxFilter bbox_filter { min_width: 64 min_height: 64 } Detection Both roi_top_offset Offset of the RoI from the top of the frame. Only objects within the RoI are output. uint32 roi_top_offset: 128 Detection Both roi_bottom_offset Offset of the RoI from the bottom of the frame. Only objects within the RoI are output. uint32 roi_bottom_offset: Detection Both border_color specify border color for detection bounding boxes PluginControl::Color border_color { r: 1.0 g: 0.0 b: 0.0 a: 1.0 } Detection Both bg_color specify background color for detection bounding boxes PluginControl::Color border_color { r: 0.0 g: 1.0 b: 0.0 a: 0.5 } Detection Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) r Red color value float Range[0.0, 1.0] r: 0.5 All Both g Green color value float. Range[0.0, 1.0] g: 0.5 All Both b Blue color value float. Range[0.0, 1.0] b: 0.3 All Both a Alpha blending value float. Range[0.0, 1.0] a: 1.0 All Both", "keywords": []}, {"id": 2867, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#gst-nvinferserver-configuration-file-specifications", "display_name": "Gst-nvinferserver Configuration File Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "gst-nvinferserver-configuration-file-specifications", "priority": -1, "content": "The Gst-nvinferserver configuration file uses prototxt format described in https://developers.google.com/protocol-buffers . The protobuf message structures of this configuration file are defined by nvdsinferserver_plugin.proto and nvdsinferserver_config.proto . All the basic data-type values are set to 0 or false from protobuf\u2019s guide. Map, arrays and oneof are set to empty by default. See more details for each message definition. The message PluginControl in nvdsinferserver_plugin.proto is the entry point for this config-file. The message InferenceConfig configures the low-level settings for libnvds_infer_server . The message PluginControl::InputControl configures the input buffers, objects filtering policy for model inference. The message PluginControl::OutputControl configures inference output policy for detections and raw tensor metadata. The message BackendParams configures backend input/output layers and Triton settings in InferenceConfig. The message PreProcessParams configures network preprocessing information in InferenceConfig. The message InputTensorFromMeta enables the preprocessed tensor input mode and configures the input tensor information in InferenceConfig. The message PostProcessParams configures the output tensor parsing methods such as detection, classification, semantic segmentation and others in InferenceConfig. There are also other messages (e.g. CustomLib, ExtraControl) and enum types (e.g. MediaFormat, TensorOrder, \u2026) defined in the proto file for miscellaneous settings for InferenceConfig and PluginControl.", "keywords": []}, {"id": 2868, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "gst-properties", "priority": -1, "content": "The values set through Gst properties override the values of properties in the configuration file. The application does this for certain properties that it needs to set programmatically. If user set property though plugin, these values would replace the original value in config files. The following table describes the Gst-nvinferserver plugin\u2019s Gst properties. Property Meaning Type and Range Example Notes config-file-path Absolute pathname of configuration file for the Gst-nvinferserver element String config-file-path=config_infer_primary.txt process-mode Infer Processing Mode (0):None, (1)FullFrame, (2)ClipObject. If set, it could replace input_control.process_mode Integer, 0, 1 or 2 process-mode=1 unique-id Unique ID identifying metadata generated by this GIE. If set, it could replace infer_config.unique_id Integer, 0 to 4,294,967,295 unique-id=1 infer-on-gie-id See input_control.operate_on_gie_id in the configuration file table Integer, 0 to 4,294,967,295 infer-on-gie-id=1 operate-on-class-ids See input_control.operate_on_class_ids in the configuration file table An array of colon- separated integers (class-ids) operate-on-class-ids=1:2:4 batch-size Number of frames/objects to be inferred together in a batch. If set, it could replace infer_config.max_batch_size Integer, 1 \u2013 4,294,967,295 batch-size=4 Interval Number of consecutive batches to be skipped for inference If set, it could replace input_control.interval Integer, 0 to 32 interval=0 raw-output-generated-callback Pointer to the raw output generated callback function Pointer Cannot be set through gst-launch raw-output-generated-userdata Pointer to user data to be supplied with raw-output-generated-callback Pointer Cannot be set through gst-launch", "keywords": []}, {"id": 2869, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvinferserver plugin. Inputs Gst Buffer NvDsBatchMeta (attaching NvDsFrameMeta) Model repository directory path (model_repo.root) gRPC endpoint URL (grpc.url) Runtime model file with config.pbtxt file in model repository Control parameters Gst-nvinferserver gets control parameters from a configuration file. You can specify this by setting the property config-file-path. For details, see Gst-nvinferserver Configuration File Specifications . Other control parameters that can be set through GObject properties are: Batch size Process mode Unique id Inference on GIE id and operate on class ids [secondary mode only] Inference interval Raw output generated callback function The parameters set through the GObject properties override the parameters in the Gst-nvinferserver configuration file. Outputs Gst Buffer Depending on network type and configured parameters, one or more of: NvDsObjectMeta NvDsClassifierMeta NvDsInferSegmentationMeta NvDsInferTensorMeta", "keywords": []}, {"id": 2870, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#low-level-libnvds-infer-server-so-configuration-file-specifications", "display_name": "Low Level libnvds_infer_server.so Configuration File Specifications", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "low-level-libnvds-infer-server-so-configuration-file-specifications", "priority": -1, "content": "The message InferenceConfig defines all the low-level structure fields in nvdsinferserver_config.proto . It has major settings for inference backend, network preprocessing and postprocessing. Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) unique_id Unique ID identifying metadata generated by this GIE uint32, \u22650 unique_id: 1 All Both gpu_ids Device IDs of GPU to use for pre-processing/inference (single GPU support only) int32 array, \u22650 gpu_ids: [0] All Both max_batch_size Max number of frames/objects to be inferred together in a batch uint32, \u22650 max_batch_size: 1 All Both backend Inference backend settings BackendParams backend { trt_is { ... } } see details in BackendParams All Both preprocessing One of preprocess or input_tensor_from_meta. Use preprocess if using frame or object processing mode and input_tensor_from_meta when using preprocessed tensor input mode preprocess or input_tensor_from_meta \u201cN/A. Refer preprocess and input_tensor_from_meta below\u201d All Both preprocess Network preprocessing settings for color conversion\uff0c scale and normalization applicable when using frame or object processing mode PreProcessParams preprocess { normalize { \u2026 } } see details in PreProcessParams All Both input_tensor_from_meta Configuration for the input tensor applicable when using preprocessed tensor as input InputTensorFromMeta input_tensor_from_meta { is_first_dim_batch : true } see details in InputTensorFromMeta All Preprocessed tensor input mode postprocess Inference output tensor parsing methods such as detection, classification, semantic segmentation and others PostProcessParams postprocess { detection {...} } see details in PostProcessParams All Both custom_lib Specify custom lib path for custom parsing functions and preloads, optional CustomLib custom_lib { path : ./libcustom_parsing.so } All Both extra extra controls for inference config. ExtraControl extra { output_buffer_pool_size: 2 } see details in ExtraControl All Both lstm LSTM control parameters, limited on batch-size 1 and single stream LstmParams [optional] `` lstm { loops { input: \u201cinit_lstm_c\u201d output: \u201coutput/lstm_c\u201d init_const { value: 0 } } }`` See details in LstmParams All Both clip_object_outside_roi Clip the object bounding boxes to fit within the specified ROI boundary. bool clip_object_outside_roi: false Detector Both Name Description Type and Range Example Notes Network Types/Applicable to GIEs (Primary/Secondary) inputs Backend input layer settings, optional InputLayer arrays see details in InputLayer All/Both outputs Backend output layer settings, optional OutputLayer arrays see details in OutputLayer All/Both triton backend of Triton Inference Server settings TritonParams see details in TritonParams All/Both output_mem_type Triton native output tensor memory type MemoryType select from [MEMORY_TYPE_DEFAULT, MEMORY_TYPE_CPU, MEMORY_TYPE_GPU] output_mem_type: MEMORY_TYPE_CPU All/Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) name input tensor name string name: \u201cinput_0\u201d All Both dims input tensor shape, optional. Only required if backend cannot figure out fixed input shapes int32 array, &gt; 0 dims: [299, 299, 3] All Both data_type enum TensorDataType with types: TENSOR_DT_NONE, TENSOR_DT_FP32, TENSOR_DT_FP16, TENSOR_DT_INT8, TENSOR_DT_INT16, TENSOR_DT_INT32, TENSOR_DT_UINT8, TENSOR_DT_UINT16, TENSOR_DT_UINT32 Default TENSOR_DT_NONE, usually can be deduced from Triton model config.pbtxt TensorDataType data_type: TENSOR_DT_FP32 All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) name output tensor name string name: \u201cdetection_boxes\u201d All Both max_buffer_bytes output tensor reserved buffer bytes uint64 max_buffer_bytes: 2048 All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) model_name Triton inference model name string model_name: \u201cssd_inception_graphdef\u201d All Both version Triton model version number. -1, latest version number. &gt;0, reserved for specific version number in future version int64 version: -1 All Both model_repo Triton model repository settings. Note, all model_repo settings must be same in single process TritonParams::TritonModelRepo model_repo { root: \u201c../triton_model_repo\u201d log_level: 2 } Refer the details in TritonModelRepo All Both grpc Triton gRPC server settings. TritonParams::TritonGrpcParams grpc { url: \u201clocalhost:8001\u201d enable_cuda_buffer_sharing: false } Refer the details in TritonGrpcParams All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) root Triton inference model repository directory path string root: \u201c../triton_model_repo\u201d All Both log_level Triton log output levels uint32; 0, ERROR; 1, WARNING; 2, INFO; &gt;=3, VERBOSE Level log_level: 1 All Both strict_model_config Enable Triton strict model configuration, see details in Triton Generated Model Configuration . Suggest setting value true bool strict_model_config: true All Both tf_gpu_memory_fraction TensorFlow GPU memory fraction per process. Valid for Tensorflow models only. Default 0 means no GPU memory limitation. Suggest tuning to a proper value (e.g. in range of [0.2, 0.6]) in case Tensorflow uses up whole GPU memory float, Range (0, 1.0] tf_gpu_memory_fraction: 0.6 All Both tf_disable_soft_placement Disable TensorFlow soft placement of operators. It\u2019s enabled by default. bool tf_disable_soft_placement: false All Both min_compute_capacity Specify minimal GPU compute capacity. The default value is 6.0 on x86 and 5.0 on Jetson. min_compute_capacity: 6.0 All Both backend_dir Specify Triton backend directory which store Tensorflow/Onnx/Pytorch and custom backends. The Default value is /opt/tritonserver/backends on X86 and opt/nvidia/deepstream/deepstream-x.x/lib/triton_backends on Jetson. string backend_dir: /opt/tritonserver/backends/ All Both cuda_device_memory Specify a list of CudaDeviceMem blocks with pre-allocated memory pool. Use Triton\u2019s default value if list is empty. message list cuda_device_memory [ { device: 0 memory_pool_byte_size: 2000000000 } ] All Both CudaDeviceMem::device Specify device ID uint32; &gt;= 0 device: 0 All Both CudaDeviceMem::memory_pool_byte_size Indicate pre-allocated memory pool byte size on according device for Triton runtime uint64; &gt;= 0 memory_pool_byte_size: 8000000000 All Both pinned_memory_pool_byte_size Indicate pre-allocated Pinned memory on host for Triton runtime. Use Triton\u2019s defult value (around 256MB) if not set. uint64; &gt;= 0 pinned_memory_pool_byte_size: 128000000 All Both backend_configs A list of BackendConfig blocks for Tritonserver backend config settings message list backend_configs [ { backend: tensorflow setting: \u201callow-soft-placement\u201d value: \u201ctrue\u201d } ] All Both BackendConfig::backend Specify backend name string backend: tensorflow All Both BackendConfig::setting Specify backend setting name string setting: \u201callow-soft-placement\u201d All Both BackendConfig::value Specify backend setting values string value: \u201ctrue\u201d All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) url Triton server name and port string url: \u201clocalhost:8001\u201d All Both enable_cuda_buffer_sharing \u201cEnable sharing of CUDA buffers with local Triton server for input tensors. If enabled the input CUDA buffers are shared with the Triton server to improve performance. This feature should be enabled only when the Triton server is on the same machine. Applicable for x86 dGPU platform not supported on Jetson devices. By default disabled i.e. CUDA buffers are copied to system memory while creating the inference request.\u201d Bool enable_cuda_buffer_sharing: true All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) network_format enum MediaFormat with formats: MEDIA_FORMAT_NONE IMAGE_FORMAT_RGB IMAGE_FORMAT_BGR IMAGE_FORMAT_GRAY . use IMAGE_FORMAT_RGB by default. MediaFormat network_format: IMAGE_FORMAT_RGB All Both tensor_order enum TensorOrder with order types: TENSOR_ORDER_NONE, TENSOR_ORDER_LINEAR(this includes NCHW, CHW, DCHW, \u2026 orders), TENSOR_ORDER_NHWC. It can deduce the value from backend layers info if set to TENSOR_ORDER_NONE TensorOrder tensor_order: TENSOR_ORDER_NONE All Both tensor_name Specify the tensor name for the preprocessing buffer. This is in the case when multiple input tensors in a single network. string; Optional tensor_name: \u201cinput_0\u201d All Both frame_scaling_hw Compute hardware to use for scaling frames / object crops to network resolution enum FrameScalingHW FRAME_SCALING_HW_DEFAULT: Platform default \u2013 GPU (dGPU), VIC (Jetson) FRAME_SCALING_HW_GPU FRAME_SCALING_HW_VIC (Jetson only) frame_scaling_hw: FRAME_SCALING_HW_GPU All Both frame_scaling_filter The filter to use for scaling frames / object crops to network resolution int32, refer to enum NvBufSurfTransform_Inter in nvbufsurftransform.h for valid values frame_scaling_filter: 1 All Both maintain_aspect_ratio Indicates whether to maintain aspect ratio while scaling input. int32; 0 or 1 maintain_aspect_ratio: 0 All Both symmetric_padding Indicates whether to pad image symmetrically while scaling input. DeepStream pads the images asymmetrically by default. int32; 0 or 1 symmetric_padding: 0 All Both normalize Network input tensor normalization settings for scale-factors, offsets and mean-subtraction PreProcessParams::ScaleNormalize normalize { scale_factor: 1.0 channel_offsets: [0, 0, 0] } see details in PreProcessParams::ScaleNormalize Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) scale_factor Pixel normalization factor float scale_factor: 0.0078 All Both channel_offsets Array of mean values of color components to be subtracted from each pixel. Array length must equal the number of color components in the frame. The plugin multiplies mean values by scale_factor. float array, Optional channel_offsets: [77.5, 21.2, 11.8] All Both mean_file Pathname of mean data file (PPM format) string; Optional mean_file: \u201c./model_meanfile.ppm\u201d All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) is_first_dim_batch Boolean indicating whether the preprocessed input tensor has first dimention as batch. Set true for batched input, false otherwise. Boolean is_first_dim_batch: true All Preprocessed tensor input mode Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) labelfile_path Pathname of a text file containing the labels for the model string labelfile_path: \u201c=/home/ubuntu/model_labels.txt\u201d All Both oneof process_type Indicates one of the postprocessing type detection; classification; segmentation; other; None N/A All Both detection Specify detection parameters for the network. It must be oneof process_type DetectionParams detection { num_detected_classes: 4 simple_cluster { threshold: 0.2 } } see details in DetectionParams Detector Both classification Specify classification parameters for the network It is oneof process_type ClassificationParams classification { threshold: 0.6 } see details in ClassificationParams Classifier Both segmentation Specify semantic segmentation parameters for the network It is oneof process_type SegmentationParams segmentation { threshold: 0.2 num_segmentation_classes: 2 } Segmentation Both other Specify other network parameters. This is for user-defined networks and usually coexists with output_control.output_tensor_meta: true. Tensor output data would be attached into GstBuffer. Data can be parsed in application. User can increase extra.output_buffer_pool_size if need to hold metadata longer. It is oneof process_type OtherNetworkParams other {} see details in OtherNetworkParams Others Both triton_classification Specify Triton classification parameters for the network It is oneof process_type TritonClassifyParams Triton_classification { topk: 1 } see details in TritonClassifyParams Classifier Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) num_detected_classes Define number of classes detected by the network int32, &gt; 0 num_detected_classes:4 Detector Both per_class_params Map of specific detection parameters per class. Key-value follows &lt;class_id: per_class_params&gt; order. map&lt;int32, PerClassParams&gt;; Optional per_class_params [ { key: 1, value { pre_threshold : 0.4} }, { key: 2, value { pre_threshold : 0.5} } ] see details for PerClassParams Detector Both custom_parse_bbox_func Name of the custom bounding box parsing function. If not specified, Gst-nvinferserver uses the internal function for the resnet model provided by the SDK. If specified, also need to set custom_lib to load custom library. string; custom_parse_bbox_func: \u201cNvDsInferParseCustomTfSSD\u201d Detector Both oneof clustering_policy Indicates one of the clustering policies from nms; dbscan; group_rectangle; simple_cluster; None N/A Detector Both nms Indicates clustering bounding boxes by Non-Maximum-Suppression method detected objects. It is oneof clustering_policy Nms nms { confidence_threshold: 0.3 iou_threshold: 0.4 } see details in Nms Detector Both dbscan Indicates clustering bounding boxes by DBSCAN method for detected objects. It is oneof clustering_policy DbScan dbscan { pre_threshold: 0.3 eps: 0.7 min_boxes: 3 } see details in DbScan Detector Both group_rectangle Indicates clustering bounding boxes by groupRectangles() function for grouping detected objects It is oneof clustering_policy GroupRectangle group_rectangle { confidence_threshold: 0.2 group_threshold: 2 eps: 0.2 } Detector Both simple_cluster Indicates simple clustering method by outlier boxes through threshold SimpleCluster simple_cluster { threshold: 0.2 } Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) pre_threshold Define confidence threshold per class float pre_threshold:0.3 Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) confidence_threshold Detection score lesser than this threshold would be rejected float confidence_threshold:0.5 Detector Both iou_threshold Maximum IOU score between two proposals after which the proposal with the lower confidence will be rejected. float iou_threshold: 0.3 Detector Both topk Specify top k detection results to keep after nms int32, &gt;= 0 topk: 2; value 0, means keep all. Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) pre_threshold Detection score lesser than this threshold would be rejected before DBSCAN clustering float pre_threshold:0.2 Detector Both eps DBSCAN epsilon to control merging of overlapping boxes. float eps: 0.7 Detector Both min_boxes Minimum boxes in DBSCAN cluster to be considered an object int32, &gt; 0 min_boxes: 3; Detector Both min_score Minimum score in DBSCAN cluster for it to be considered as an object float min_score: 0.7 Default value is 0 Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) confidence_threshold Detection score lesser than this threshold would be rejected float confidence_threshold:0.2 Detector Both group_threshold Threshold value for rectangle merging for OpenCV grouprectangles() function int32; &gt;= 0 group_threshold: 1 Detector Both eps Epsilon to control merging of overlapping boxes float eps: 0.2 Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) threshold Detection score lesser than this threshold would be rejected float confidence_threshold:0.6 Detector Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) threshold Classification score lesser than this threshold would be rejected float threshold: 0.5 Classifier Both custom_parse_classifier_func Name of the custom classifier output parsing function. If not specified, Gst-nvinfer uses the internal parsing function with NCHW tensor order for softmax layers. User can reshape other output tensor order to NCHW in Triton config.pbtxt to run internal parsing. If specified, also need to set custom_lib to load custom library. string parse-classifier-func-name: \u201cparse_bbox_softmax\u201d Classifier Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) threshold Segmentation score lesser than this threshold would be rejected float threshold: 0.5 Segmentation Both num_segmentation_classes Number of output classes for the segmentation network int32, &gt;0 num_segmentation_classes: 2 Segmentation Both custom_parse_segmentation_func Name of the custom segmentation output parsing function. If not specified, Gst-nvinferserver uses the internal function for the UNet model provided by the SDK. If specified, users also need to set custom_lib to load custom library. string custom_parse_segmentation_func: \u201cNvDsInferParseCustomPeopleSemSegNet\u201d Segmentation Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) type_name Specify a user-defined network name string; | Optional type_name: \u201cface\u201d Others Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) topk Specify top k elements need to keep from Triton\u2019s native classification uint32; &gt;=0 topk : 1 Value 0 or empty would keep the top 1 result. Classifier Both threshold Classification score lesser than this threshold would be rejected float threshold: 0.5 Classifier Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) path Pathname that points to a custom library for preload string path: \u201c/home/ubuntu/lib_custom_impl.so\u201d All Both Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) copy_input_to_host_buffers Enable to copy input. If enabled, input tensor would be attached as NvDsInferTensorMeta into GstBuffer with output tensors together tensor data to host buffers. bool copy_input_to_host_buffers: false All Both output_buffer_pool_size Specify the buffer pool size for each output tensor. When infer_config.postprocess.other is specified or output_control.output_tensor_meta is enabled, the output tensor would be attached as NvDsInferTensorMeta into GstBuffer int32; Range [2, 10] output_buffer_pool_size: 4 All Both custom_process_funcion custom function to create a specific user-defined processor IInferCustomProcessor. The function symbol is loaded by infer_config.custom_lib String path: \u201clibnvdsinfer_custom_impl_fasterRCNN.so\u201d All Both LstmParams structures may be changed in future versions Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) loops Specify LSTM loops between input and output tensors. LstmLoop [repeated] loops [ { input: \u201cinit_state\u201d output: \u201cout_state\u201d } ] See details in LstmParams::LstmLoop All Both Input and output tensors must have same datatype/dimensions, FP16 is not supported LstmParams::LstmLoop structures might be changed in future versions Name Description Type and Range Example Notes Network Types / Applicable to GIEs (Primary/Secondary) input Specify input tensor name of the current loop. string Input: \u201cinit_state\u201d All Both output Specify input tensor name of the current loop. Tensor data will feedback to the input tensor string onput: \u201coutput_state\u201d All Both init_const Specify the constant values for the input in first frame InitConst | value: float Init_const { value: 0 } All Both", "keywords": []}, {"id": 2871, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#segmentation-metadata", "display_name": "Segmentation Metadata", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "segmentation-metadata", "priority": -1, "content": "The Gst-nvinferserver plugin attaches the output of the semantic segmentation model as user metadata in an instance of NvDsInferSegmentationMeta with meta_type set to NVDSINFER_SEGMENTATION_META. The user metadata is added to the frame_user_meta_list member of NvDsFrameMeta for primary (full frame) mode, or the obj_user_meta_list member of NvDsObjectMeta for secondary (object) mode. For guidance on how to access user metadata, see User/Custom Metadata Addition Inside NvDsMatchMeta and Tensor Metadata, above.", "keywords": []}, {"id": 2872, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#tensor-metadata-output-for-downstream-plugins", "display_name": "Tensor Metadata Output for Downstream Plugins", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "tensor-metadata-output-for-downstream-plugins", "priority": -1, "content": "The Gst-nvinferserver plugin can attach raw output tensor data generated by the inference backend as metadata. It is added as an NvDsInferTensorMeta in the frame_user_meta_list member of NvDsFrameMeta for primary (full frame) mode, or in the obj_user_meta_list member of NvDsObjectMeta for secondary (object) mode. It uses same metadata structure with Gst-nvinferserver plugin. Gst-nvinferserver plugin does not attach device buffer pointer NvDsInferTensorMeta::attach out_buf_ptrs_dev at this moment.", "keywords": []}, {"id": 2873, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#to-read-or-parse-inference-raw-tensor-data-of-output-layers", "display_name": "To read or parse inference raw tensor data of output layers", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "to-read-or-parse-inference-raw-tensor-data-of-output-layers", "priority": -1, "content": "Enable the following fields in the configuration file for the Gst-nvinferserver plugin: output_control { output_tensor_meta : true } If native postprocessing need be disabled, update: infer_config { postprocess { other {} } } When operating as primary GIE, NvDsInferTensorMeta is attached to each frame\u2019s (each NvDsFrameMeta object\u2019s) frame_user_meta_list . When operating as secondary GIE, NvDsInferTensorMeta is attached to each NvDsObjectMeta object\u2019s obj_user_meta_list . Metadata attached by Gst-nvinferserver can be accessed in a GStreamer pad probe attached downstream from the Gst-nvinferserver instance. The NvDsInferTensorMeta object\u2019s metadata type is set to NVDSINFER_TENSOR_OUTPUT_META. To get this metadata you must iterate over the NvDsUserMeta user metadata objects in the list referenced by frame_user_meta_list or obj_user_meta_list. For more information about Gst-infer tensor metadata usage, see the source code in sources/apps/sample_apps/deepstream_infer_tensor_meta-test.cpp , provided in the DeepStream SDK samples.", "keywords": []}, {"id": 2874, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvinferserver#triton-ensemble-models", "display_name": "Triton Ensemble Models", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "triton-ensemble-models", "priority": -1, "content": "The Gst-nvinferserver plugin can support Triton ensemble models for further custom preprocessing, backend and postprocessing through Triton custom-backends. Triton ensemble model represents a pipeline of one or more models and the connection of input and output tensors between those models, such as \u201cdata preprocessing -&gt; inference -&gt; data postprocessing\u201d . See more details triton-inference-server/server . To manage memory efficiency and keep clean interface, The Gst-nvinferserver Plugin\u2019s default preprocessing cannot be disabled. Color conversion, datatype conversion, input scaling and object cropping are continue working in nvds_infer_server natively. For example, in the case native normalization is not needed, update scale_factor to 1.0: infer_config { preprocess { network_format: IMAGE_FORMAT_RGB tensor_order: TENSOR_ORDER_LINEAR normalize { scale_factor: 1.0 } } } The low level nvds_infer_server library could deliver specified media-format (RGB/BGR/Gray) in any kind of tensor orders and datatypes as a Cuda GPU buffer input to Triton backend. User\u2019s custom-backend must support GPU memory on this input. Triton custom-backend sample identity can work with Gst-nvinferserver plugin. Custom backend API must have same Triton codebase version (24.08). Read more details from Triton server release triton-inference-server/server To learn details how to implement Triton custom-backend, please refer to triton-inference-server/backend For Triton model\u2019s output, TRTSERVER_MEMORY_GPU and TRTSERVER_MEMORY_CPU buffer allocation are supported in nvds_infer_server according to Triton output request. This also works for ensemble model\u2019s final output tensors. Finally, inference data can be parsed by default for detection, classification, or semantic segmentation. Alternatively, user can implement custom-backend for postprocessing, then deliver the final output to Gst-nvinferserver plugin to do further processing. Besides that, User can also optionally attach raw tensor output data into metadata for downstream or application to parse.", "keywords": []}, {"id": 2875, "doc_id": 2875, "filename": "text/DS_plugin_gst-nvinferserver.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvinferserver", "display_name": "Gst-nvinferserver", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvinferserver", "anchor": "", "priority": -1, "content": "The Gst-nvinferserver plugin does inferencing on input data using NVIDIA\u00ae Triton Inference Server (previously called TensorRT Inference Server) Release 2.49.0, NGC Container 24.08 for both Jetson and dGPU on x86. Refer to the following README triton-inference-server/server The plugin accepts batched NV12/RGBA buffers from upstream. The NvDsBatchMeta structure must already be attached to the Gst Buffers. The low-level library (libnvds_infer_server) operates on any of NV12 or RGBA buffers. The Gst-nvinferserver plugin passes the input batched buffers to the low-level library and waits for the results to be available. Meanwhile, it keeps queuing input buffers to the low-level library as they are received. Once the results are available from the low-level library, the plugin translates and attaches the results back in to Gst-buffer for downstream plugins. The low-level library preprocesses the transformed frames (performs color conversion and scaling, normalization and mean subtraction) and produces final FP32/FP16/INT8/UINT8/INT16/UINT16/INT32/UINT32 RGB/BGR/GRAY planar/ packed data which is passed to the Triton for inferencing. The output type generated by the low-level library depends on the network type. The pre-processing function is: y = netscalefactor * (x - mean) Where: x is the input pixel value. It is an uint8 with range [0,255]. mean is the corresponding mean value, read either from the mean file or as offsets[c], where c is the channel to which the input pixel belongs, and offsets is the array specified in the configuration file. It is a float. netscalefactor is the pixel scaling factor specified in the configuration file. It is a float. y is the corresponding output pixel value. It can be of type float / half / int8 / uint8 / int16 / uint16 / int32 / uint32 . Take specific example for uint8 to int8 conversion. set netscalefactor = 1.0 and mean = [128, 128, 128] . Then the function looks like: y = (1.0) * (x - 128) Gst-nvinferserver currently works on the following type of networks: Multi-class object detection Multi-label classification Segmentation The Gst-nvinferserver plugin can work in three process modes: Primary mode: Operates on full frames. Secondary mode: Operates on objects added in the metadata by upstream components. When the plugin is operating as a secondary classifier in async mode along with the tracker, it tries to improve performance by avoiding re-inferencing on the same objects in every frame. It does this by caching the classification output in a map with the object\u2019s unique ID as the key. The object is inferred upon only when it is first seen in a frame (based on its object ID) or when the size (bounding box area) of the object increases by 20% or more. This optimization is possible only when the tracker is added as an upstream element. Preprocessed Tensor Input mode: Operates on tensors attached by upstream components. When operating in preprocessed tensor input mode, the pre-processing inside Gst-nvinferserver is completely skipped. The plugin looks for GstNvDsPreProcessBatchMeta attached to the input buffer and passes the tensor as is to the Tirton Inference Server without any modifications. This mode currently supports processing on full-frame and ROI. The GstNvDsPreProcessBatchMeta is attached by the Gst-nvdspreprocess plugin. This mode is enabled by adding the input_tensor_from_meta configuration message in the InferenceConfig message. Detailed documentation of the Triton Inference Server is available at: triton-inference-server/server The plugin supports Triton features along with multiple deep-learning frameworks such as TensorRT, TensorFlow (GraphDef / SavedModel), ONNX and PyTorch on Tesla platforms. On Jetson, it also supports TensorRT and TensorFlow (GraphDef / SavedModel). TensorFlow and ONNX can be configured with TensorRT acceleration. For details, see Framework-Specific Optimization . The plugin requires a configurable model repository root directory path where all the models need to reside. All the plugin instances in a single process must share the same model root. For details, see Model Repository . Each model also needs a specific config.pbtxt file in its subdirectory. For details, see Model Configuration . The plugin supports Triton ensemble mode to enable users to perform preprocessing or postprocessing with Triton custom backend. The plugin also supports the interface for custom functions for parsing outputs of object detectors, classifiers, and initialization of non-image input layers in cases where there is more than one input layer. Refer to sources/includes/nvdsinfer_custom_impl.h for the custom method implementations for custom models. Downstream components receive a Gst Buffer with unmodified contents plus the metadata created from the inference output of the Gst-nvinferserver plugin. The plugin can be used for cascaded inferencing. That is, it can perform primary inferencing directly on input data, then perform secondary inferencing on the results of primary inferencing, and so on. This is similar with Gst-nvinfer, see more details in Gst-nvinfer.", "keywords": []}, {"id": 2876, "doc_id": 2879, "filename": "text/DS_plugin_gst-nvjpegdec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegdec#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegdec", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvjpegdec plugin. Feature Description Release Supports JPEG Decode \u2014 DS 4.0 Supports MJPEG Decode \u2014 DS 4.0", "keywords": []}, {"id": 2877, "doc_id": 2879, "filename": "text/DS_plugin_gst-nvjpegdec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegdec#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegdec", "anchor": "gst-properties", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvjpegdec plugin. Property Meaning Type and Range Example and Notes Platforms gpu-id Device ID of GPU to use for decoding. Integer, 0 to 4,294,967,295 gpu-id=0 dGPU", "keywords": []}, {"id": 2878, "doc_id": 2879, "filename": "text/DS_plugin_gst-nvjpegdec.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegdec#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegdec", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Elementary JPEG Control parameters gpu-id (dGPU only) DeepStream (Jetson only) Output Gst Buffer with decoded output in RGB format for dGPU, and I420 format for Jetson", "keywords": []}, {"id": 2879, "doc_id": 2879, "filename": "text/DS_plugin_gst-nvjpegdec.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvjpegdec", "display_name": "Gst-nvjpegdec", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvjpegdec", "anchor": "", "priority": -1, "content": "The Gst-nvjpegdec plugin decodes images on both dGPU and Jetson platforms. It is the preferred method for decoding JPEG images. On the dGPU platform this plugin is based on the libnvjpeg library, part of the CUDA toolkit. On Jetson it uses a platform-specific hardware accelerator. The plugin uses an internal software parser to parse JPEG streams. Thus, there is no need to use a jpegparse open source plugin separately to parse the encoded frame. The plugin accepts a JPEG encoded bitstream and produces RGB output on the dGPU platform and produces I420 output on the Jetson platform. This plugin is not applicable on (ARM + dGPU) platforms like arm-sbsa. Use nvimagedec plugin instead. OSS nvjpegdec plugin may be listed in these platforms, but don\u2019t use that.", "keywords": []}, {"id": 2880, "doc_id": 2883, "filename": "text/DS_plugin_gst-nvjpegenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegenc#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegenc", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvjpegenc plugin. Feature Description Release Supports JPEG Encode \u2014 DS 6.3", "keywords": []}, {"id": 2881, "doc_id": 2883, "filename": "text/DS_plugin_gst-nvjpegenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegenc#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegenc", "anchor": "gst-properties", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvjpegenc plugin. Property Meaning Type and Range Example and Notes Platforms quality quality value for encoding Integer, 0 to 100 Quality=90 dGPU, Jetson Enableperf Enable encode time measurement Boolean Enableperf=1 Jetson Idct-method IDCT algorithm to use Enum 0: iSlow 1: iFast 2: Float Idct-method=2 Jetson OutputGray Output JPEG image in GRAYSCALE, needs I420 INPUT Boolean OutputGray=1 dGPU", "keywords": []}, {"id": 2882, "doc_id": 2883, "filename": "text/DS_plugin_gst-nvjpegenc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvjpegenc#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvjpegenc", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer in I420, RGB format (dGPU) Gst Buffer in I420, NV12 format (Jetson) Gst SW Buffer in I420, YV12, GRAY8 format (Jetson) Control parameters Enableperf (Jetson Only) idct-method (Jetson Only) quality (Both Jetson and dGPU) OutputGray (dGPU only) Output Gst Buffer with encoded output in JPEG format", "keywords": []}, {"id": 2883, "doc_id": 2883, "filename": "text/DS_plugin_gst-nvjpegenc.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvjpegenc", "display_name": "Gst-nvjpegenc", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvjpegenc", "anchor": "", "priority": -1, "content": "The Gst-nvjpegenc plugin encodes images on both dGPU and Jetson platforms. It is the preferred method for encoding JPEG images. On the dGPU platform this plugin is based on the libnvjpeg library, part of the CUDA toolkit. On Jetson it uses a platform-specific hardware accelerator. The plugin accepts I420, RGB input on dGPU platform and I420, NV12 input on Jetson platform and produces JPEG encoded bitstream. On Jetson platform nvjpegenc can also accept SW RAW buffers in I420, YV12, GRAY8 formats. This plugin is not available on (ARM + dGPU) platforms like arm-sbsa. Use nvimageenc plugin instead.", "keywords": []}, {"id": 2884, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#amqp-broker", "display_name": "AMQP broker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "amqp-broker", "priority": -1, "content": "The AMQP protocol communicates with an AMQP 0-9-1 compliant message broker. If you do not have a functioning broker already, you can deploy one by installing the rabbitmq-server package, available at: https://www.rabbitmq.com/install-debian.html You can install this package on your local system or on the remote machine where you want the broker to be installed. To install the package, enter the command: sudo apt-get install rabbitmq-server To determine whether the rabbitmq service is running, enter the command: sudo service rabbitmq-server status If rabbitmq is not running, enter this command to start it: sudo service rabbitmq-server start", "keywords": []}, {"id": 2885, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#amqp-protocol-adapter", "display_name": "AMQP Protocol Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "amqp-protocol-adapter", "priority": -1, "content": "DeepStream includes an AMQP protocol adapter that DeepStream applications can use out of the box to publish messages using AMQP 0-9-1 message protocol. The AMQP protocol adapter shared library is in the deepstream package at: /opt/nvidia/deepstream/deepstream/lib/libnvds_amqp_proto.so", "keywords": []}, {"id": 2886, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#autoreconnect-feature", "display_name": "Autoreconnect feature", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "autoreconnect-feature", "priority": -1, "content": "nvmsgbroker library features autoreconnect capability wherein after network connection with the endpoint is down, a periodic reconnect attempt is made with the external entity. configurations applicable for nvmsgbroker library to avail this feature are listed in cfg_nvmsgbroker.txt: (0):disable (1):enable auto-reconnect=1 #connection retry interval in seconds retry-interval=&lt;value&gt; #connection max retry limit in seconds max-retry-limit=&lt;value&gt; #interval at which to perform work, in microseconds work-interval=10000 The autoreconnect feature is not currently supported for use with the MQTT protocol adapter.", "keywords": []}, {"id": 2887, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#azure-device-client-library-log-messages", "display_name": "Azure device client library log messages", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "azure-device-client-library-log-messages", "priority": -1, "content": "The Azure device client adapter uses the nvds_logger framework to generate log messages which can help you monitor execution. The adapter generates separate logs for the INFO, DEBUG, and ERROR severity levels, as described in nvds_logger: Logging Framework . You can limit the generated log messages by setting the level at which log messages are filtered in the logging setup script. If the severity level is set to DEBUG, the nvds_logger framework logs the entire contents of each message sent by the Azure device client protocol adapter.", "keywords": []}, {"id": 2888, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#azure-module-client-library-log-messages", "display_name": "Azure Module Client Library Log Messages", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "azure-module-client-library-log-messages", "priority": -1, "content": "The log messages from the Azure module client adapter library are emitted to stdout, and the log output is captured in the docker/iotedge module logs.", "keywords": []}, {"id": 2889, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#azure-mqtt-protocol-adapter-libraries", "display_name": "Azure MQTT Protocol Adapter Libraries", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "azure-mqtt-protocol-adapter-libraries", "priority": -1, "content": "DeepStream includes protocol adapters that supports direct messaging from device to cloud (using the Azure device client adapter) and through Azure IoT Edge runtime (using the Azure module client adapter). The adapters provide out-of-the-box capability for DeepStream applications to publish messages to Azure IoT Hub using the MQTT protocol. The Azure IoT protocol adapters are encapsulated by their respective shared libraries found within the DeepStream package at /opt/nvidia/deepstream/deepstream/lib . The Azure device client adapter library is named libnvds_azure_proto.so . The Azure module client adapter library is named libnvds_azure_edge_proto.so .", "keywords": []}, {"id": 2890, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#configure-adapter-settings", "display_name": "Configure Adapter Settings", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "configure-adapter-settings", "priority": -1, "content": "You can place AMQP protocol adapter specific information in a custom configuration named, for example, cfg_amqp.txt . Here is an example of configuration file entries for an AMQP broker installed on the local machine: [message-broker] hostname = localhost username = guest password = guest port = 5672 exchange = amq.topic topic = topicname amqp-framesize = 131072 #amqp-heartbeat = 0 #share-connection = 1 The properties in the configuration file are: hostname: Hostname of the host on which the AMQP broker is installed username: Username used to log in to the broker \u2013 TO BE DEPRECATED, USE ENV VARIABLE password: Password used to log in to the broker \u2013 TO BE DEPRECATED, USE ENV VARIABLE port: Port used to communicate with the AMQP broker exchange: Name of the exchange on which to publish messages topic: Message topic amqp-framesize: Maximum size of an AMQP frame on the wire to request of the broker for this connection. 4096 is the minimum size, 2^31-1 is the maximum, a good default is 131072 (128KB). amqp-heartbeat: Uncomment the field amqp-heartbeat in cfg_amqp.txt and set its value to an integer &gt; 0 to enable the heartbeat protocol. This integer is the number of seconds between heartbeat frames requested of the broker. After 2 missed frames, rabbitmq will consider the connection unreachable. A value of 0 disables the heartbeat protocol. share-connection: Uncomment the field share-connection in cfg_amqp.txt and set its value to 1 if you need to generate a connection signature. This signature is a unique string which is generated by parsing all the amqp connection related params used for making a connection. Uncommenting this field signifies that the connection created can be shared with other components within the same process.", "keywords": []}, {"id": 2891, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#configuring-adapter-settings", "display_name": "Configuring Adapter Settings", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "configuring-adapter-settings", "priority": -1, "content": "Place Azure IoT specific information in a custom configuration file named, e.g., cfg_azure.txt . The entries in the configuration file vary slightly between the Azure device client and the module client. For an Azure device client: [message-broker] connection_str = HostName=&lt;my-hub&gt;.azure-devices.net;DeviceId=&lt;device_id&gt;; custom_msg_properties = &lt;key1&gt;=&lt;value1&gt;; &lt;key2&gt;=&lt;value2&gt;; &lt;key3&gt;=&lt;value3&gt;; For an Azure module client: [message-broker] #custom_msg_properties = &lt;key1&gt;=&lt;value1&gt;; &lt;key2&gt;=&lt;value2&gt;; &lt;key3&gt;=&lt;value3&gt;; Here is useful information about some of the configuration file properties: connection_str : You can obtain the Azure connection string from the Azure IoT Hub web interface. A connection string uniquely identifies each device associated with the IoT Hub instance. It is under the \u201cPrimary Connection String\u201d entry in the \u201cDevice detail\u201d section. custom_msg_properties : Use this property to embed custom key/value pairs in the MQTT messages sent from the device to Azure IoT. You can embed multiple key values separated by semicolons, as in this example: custom_msg_properties = ex2: key1=value1;key2=value2;key3=value3; The connection_str and custom_msg_properties strings are each limited to 512 characters.", "keywords": []}, {"id": 2892, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#configuring-protocol-settings", "display_name": "Configuring Protocol Settings", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "configuring-protocol-settings", "priority": -1, "content": "You can define configuration setting for the Kafka protocol adapter as described by the documentation at edenhill/librdkafka . You can set these options in the Gst-nvmsgbroker configuration file. Like the rest of DeepStream, the configuration file uses the gkey format. The Kafka settings must be in a group named [message-broker] and must be specified as part of a key named proto-cfg . The settings can be a series of key-value pairs separated by semicolons. For example: [message-broker] proto-cfg=&quot;message.timeout.ms=2000;retries=5&quot; consumer-group-id = groupid partition-key = keyid The Kafka adapter lets you specify the name of the field in messages that is to be used to define the partition key. For each message, the specified message field is extracted and send to the topic partitioner along with the message. The partitioner uses it to identify the partition in the Kafka cluster that handles the message. The partition key information must be specified in the Gst-nvmsgbroker configuration file\u2019s [message-broker] group, using an entry named partition-key. Fields embedded in a hierarchy of JSON objects in the message are specified using dotted notation. For example, for the sample JSON message shown below, the id field in the sensor object is identified as sensor.id { &quot;sensor&quot; { &quot;id&quot;: &quot;cam1&quot; } } Additionally, the Kafka adapter lets you specify the consumer group id. The consumer group is a string that uniquely identifies the group of consumer processes to which this Kafka consumer belongs. The key name consumer-group-id can be specified in the Gst-nvmsgbroker configuration file\u2019s [message-broker] group. If this field is unspecified, the default consumer group name \u201ctest-consumer-group\u201d will be used. For the DeepStream reference application and the 360 D application, both distributed with the DeepStream SDK, you can add the proto-cfg setting to the [message-broker] group of the top-level configuration file passed to the application.", "keywords": []}, {"id": 2893, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#connection-details-for-the-device-client-adapter", "display_name": "Connection Details for the Device Client Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "connection-details-for-the-device-client-adapter", "priority": -1, "content": "Set the plugin\u2019s conn-str property to the full Azure connection string in the format: HostName=&lt;my-hub&gt;.azure-devices.net;DeviceId=&lt;device_id&gt;;SharedAccessKey=&lt;my-policy-key&gt; Alternatively, you can specify the connection string details in the Azure configuration file: [message-broker] connection_str = HostName=&lt;my-hub&gt;.azure-devices.net;DeviceId=&lt;device_id&gt;;SharedAccessKey=&lt;my-policy-key&gt;", "keywords": []}, {"id": 2894, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#connection-details-for-the-module-client-adapter", "display_name": "Connection Details for the Module Client Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "connection-details-for-the-module-client-adapter", "priority": -1, "content": "Leave the connection string empty, since the Azure IoT Edge library automatically fetches the connection string from the file /etc/iotedge/config.yaml . Once the connection details have been configured, you can integrate the Azure device client and module client adapters into custom user code by using the nvds_msgapi interface to call its functions. Note the following points about the functions defined by the interface: The connection string passed to nvds_msgapi_connect() may be NULL for both the Azure device client and the module client. For the device client the Azure configuration file has an option to specify a connection string. For the module client the connection string is always specified in /etc/iotedge/config.yaml . Both \u201csend\u201d functions use the topic name specified in the Gst-nvmsgbroker plugin\u2019s property \u201ctopic.\u201d It may be null. The application must call nvds_msgapi_do_work() after each call to nvds_msgapi_send_async() . The frequency of calls to nvds_msgapi_do_work() determines the rate at which messages waiting to be sent are processed. It is safe for multiple application threads to share connection handles. The library libiothubclient is thread-safe, so Azure protocol adapters need not implement separate locking mechanisms for functions calling this library directly. The Azure protocol adapters expects the client to manage usage and retirement of the connection handle. The client must ensure that once a handle is disconnected, it is not used for either a \u201csend\u201d call or a call to nvds_msgapi_do_work() . While the library attempts to ensure graceful failure if the application calls these functions with retired handles, it does not do so in a thread-safe manner.", "keywords": []}, {"id": 2895, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#eclipse-mosquitto", "display_name": "Eclipse Mosquitto", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "eclipse-mosquitto", "priority": -1, "content": "Eclipse mosquitto is a lightweight and open source message broker implementing the MQTT protocol. Read more about it here: https://mosquitto.org/ . The broker, the mosquitto_pub and mosquitto_sub command line clients, and the C library on which the protocol adapter depends, are all installed via the instructions in the last section. Run the mosquitto broker: adduser --system mosquitto mosquitto To run with specific mosquitto broker config file: mosquitto -c &lt;path_to_config_file&gt; For example: mosquitto -c /etc/mosquitto/mosquitto.conf Enable authentication: Create a simple text file and enter the username and password pairs, one for each line such as below: user1:password1 user2:password2 Encrypt the password file using the following command: :: mosquitto_passwd -U &lt;path_to_password_file&gt; Change the following configurations at /etc/mosquitto/mosquitto.conf (or write a new config file): allow_anonymous false password_file &lt;path_to_password_file&gt; Run the mosquitto broker using the updated config file To set user and password in the protocol adaptor: Export the following environmental variables: export USER_MQTT=username export PASSWORD_MQTT=password If username and password are also set in the config, the adaptor will set according to the environmental variables and not the config. Enable TLS encryption: mosquitto provides TLS support for encrypted network connections and authentication. The broker can be configured to accept CA certificates, the broker server certificate, and broker server key, and to require certification from clients attempting to connect. The CA certificates, client server certificate, and client server key can be passed to the mqtt protocol adapter through the adapter config file. Change the following configurations at /etc/mosquitto/mosquitto.conf (or write a new config file): # At least one of cafile or capath must be defined # cafile is a file ending in &quot;.crt&quot; containing PEM encoded CA certificates cafile &lt;path to CA crt file&gt; # capath is a directory contaning PEM encoded CA certificate files ending in &quot;.pem&quot;. # For capath to work correctly, the certificates files must have &quot;.pem&quot; as the file ending # and you must run &quot;openssl rehash &lt;path to capath&gt;&quot; each time you add/remove a certificate. capath &lt;path to directory containing CA certificates&gt; # Path to the PEM encoded server certificate for the broker. certfile &lt;path to broker crt file&gt; # Path to the PEM encoded keyfile for the broker. keyfile &lt;path to broker key file&gt; # By setting require_certificate to true, # the client must provide a valid certificate in order for the network # connection to proceed. This allows access to the broker to be controlled # outside of the mechanisms provided by MQTT. require_certificate true Run the broker using the updated config file Test the broker configuration using mosquitto_pub: $ mosquitto_pub -p 1883 --cafile &lt;path to CA crt file&gt; --cert &lt;path to client crt file&gt; --key &lt;path to client key file&gt; -h localhost -m hello -t /world or $ mosquitto_pub -p 1883 --capath &lt;path to directory containing CA certificates&gt; --cert &lt;path to client crt file&gt; --key &lt;path to client key file&gt; -h localhost -m hello -t /world Update the mqtt protocol adapter config with the cafile/capath. If require_certificate is set to true in the broker config, the client certfile, and client keyfile must also be provided.", "keywords": []}, {"id": 2896, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#enabling-logging", "display_name": "Enabling Logging", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "enabling-logging", "priority": -1, "content": "To enable logging, run the setup_nvds_logger.sh script. Note that this script must be run with sudo. You may have to modify the permissions associated with this script to make it executable. The script accepts an optional parameter specifying the pathname of log file to be written. By default, the pathname is /tmp/nvds/ds.log . Once logging is enabled, you can access the generated log messages by reading the log file. By default, you must have sudo permissions to read the log file. Standard techniques for syslog-based logging configuration can eliminate this requirement.", "keywords": []}, {"id": 2897, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvmsgbroker plugin. Feature Description Release Payload in JSON format Accepts message payload in JSON format DS 3.0 Kafka protocol support Kafka protocol adapter implementation DS 3.0 Azure IOT support Integration with Azure IOT framework DS 4.0 AMQP support AMQP 0-9-1 protocol adapter implementation DS 4.0 REDIS support Redis protocol adapter using Redis Streams DS 5.1 MQTT support MQTT protocol adapter using Eclipse mosquitto DS 6.3 Custom protocol support Provision to support custom protocol through a custom implementation of the adapter interface DS 3.0 Configurable parameters Protocol specific options through configuration file DS 3.0", "keywords": []}, {"id": 2898, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#filtering-logs", "display_name": "Filtering Logs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "filtering-logs", "priority": -1, "content": "nvds_logger allows logs to be associate with a severity level similar to that which syslog offers. You can filter log messages based on severity level by modifying the setup script. By default, the script enables logging for messages at the INFO level (level 6) and above. You can modify this as outlined in the comments in the script: # Modify log severity level as required and rerun this script # 0 Emergency: system is unusable # 1 Alert: action must be taken immediately # 2 Critical: critical conditions # 3 Error: error conditions # 4 Warning: warning conditions # 5 Notice: normal but significant condition # 6 Informational: informational messages # 7 Debug: debug-level messages # refer https://tools.ietf.org/html/rfc5424.html for more information echo &quot;if (\\$msg contains &#x27;DSLOG&#x27;) and (\\$syslogseverity &lt;= 6) then $nvdslogfilepath&quot; &gt;&gt; 11-nvds.conf", "keywords": []}, {"id": 2899, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#generating-logs", "display_name": "Generating Logs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "generating-logs", "priority": -1, "content": "You can implement modules that use the logger by including /opt/nvidia/deepstream/deepstream/sources/includes/nvds_logger.h in the source code and linking to the libnvds_logger.so library. Generating logs programmatically involves three steps: Call nvds_log_open() before you write any log messages. Call nvds_log() to write log messages. Call nvds_log_close() upon completion to flush and close the logs. Note the nvds_logger is a process-based logging mechanism, so the recommended procedure is to call nvds_log_open() from the main application routine rather than the individual plugins. Similarly, call nvds_log_close() from the main application when it shuts down the application before exit.", "keywords": []}, {"id": 2900, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvmsgbroker plugin. Property Meaning Type and Range Example Notes Platforms config Absolute pathname of configuration file required by nvds_msgapi_* interface String config=&lt;msgapi_\u00adconfig.txt&gt; dGPU Jetson conn-str Connection string as end point for communication with server String Format must be &lt;name&gt;;&lt;port&gt;;&lt;specifier&gt; conn-str= foo.bar.com;80 ;user-id dGPU Jetson proto-lib Absolute pathname of library that contains the protocol adapter as an implementation of nvds_msgapi_* String proto-lib=&lt;libnvds_kafka_proto.so&gt; dGPU Jetson comp-id ID of component from which metadata should be processed Integer, 0 to 4,294,967,295 comp-id=3 Default: plugin processes metadata from any component dGPU Jetson topic Message topic name String topic=dsapp1 dGPU Jetson new-api To use protocol adapter library apis directly or use new msgbroker library wrapper apis Integer 0 : Use adapter api\u2019s directly 1 : msgbroker lib wrapper api\u2019s (Refer to nv_msgbroker: Message Broker interface ) new-api = 0 dGPU Jetson sleep-time Sleep time between consecutive do_work calls in milliseconds Integer &gt;= 0. For Azure, use value &gt;= 10 depending on IoT Hub service tier message rate limit. Warning: Failure is likely with unreasonably high sleep times, e.g. 10000000 ms sleep-time=10 dGPU Jetson", "keywords": []}, {"id": 2901, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id1", "display_name": "Installing Dependencies", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id1", "priority": -1, "content": "Azure adapters use libiothub_client.so from the Azure IoT C SDK (v1.11.0) for the underlying protocol implementation. After you install the DeepStream package you can find the precompiled library at: /opt/nvidia/deepstream/deepstream/lib/libiothub_client.so . You can also compile libiothub_client.so manually by entering these commands: git clone https://github.com/Azure/azure-iot-sdk-c.git cd azure-iot-sdk-c git checkout tags/1.11.0 git submodule update --init mkdir cmake cd cmake cmake -Dbuild_as_dynamic:BOOL=ON -Duse_edge_modules:BOOL=ON .. cmake --build . # append &#x27;-- -j &lt;n&gt;&#x27; to run &lt;n&gt; jobs in parallel To install some other required dependencies, enter one of these commands. For an x86 computer using Ubuntu 22.04: sudo apt-get install -y libcurl3 libssl-dev uuid-dev libglib2.0 libglib2.0-dev For other platforms or OS: sudo apt-get install -y libcurl4-openssl-dev libssl-dev uuid-dev libglib2.0 libglib2.0-dev", "keywords": []}, {"id": 2902, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id10", "display_name": "Using the Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id10", "priority": -1, "content": "To use the REDIS protocol client adapter in a DeepStream application, set the Gst-nvmsgbroker plugin\u2019s proto-lib property to the pathname of the adapter\u2019s shared library, libnvds_redis_proto.so . proto-lib = &lt;path to libnvds_redis_proto.so&gt; You can specify the REDIS connection details in the REDIS adapter specific configuration file (e.g., cfg_redis.txt ) as described above. This is the recommended method. The path to the REDIS configuration file is specified by the Gst property config: config = &lt;path to cfg_redis.txt&gt; Alternatively, you can specify the REDIS protocol\u2019s hostname, port number in the Gst plugin\u2019s conn-str property, and specify the password in the configuration file. In the Gst properties: conn-str = hostname;6379 config = &lt;pathname of REDIS configuration file&gt; You can set the Gst-nvmsgbroker plugin\u2019s topic property to specify the message topic. topic = &lt;redis streamname&gt;", "keywords": []}, {"id": 2903, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id11", "display_name": "Programmatic Integration", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id11", "priority": -1, "content": "Once you have configured the connection, you can integrate the REDIS protocol adapter into your application by using the nvds_msgapi interface to call its functions. Note the following points about the functions defined by the interface: The connection string passed to nvds_msgapi_connect() has the format`` Hostname;&lt;port&gt;``. For both \u201csend\u201d functions, the topic name is specified either by the Gst-nvmsgbroker plugin\u2019s topic property. The application must call nvds_msgapi_do_work() after each call to nvds_msgapi_send_async() . The frequency of calls to nvds_msgapi_do_work() determines the rate at which messages waiting to be sent are processed. The REDIS protocol adapter expects the client to manage usage and retirement of the connection handle. The client must ensure that once a handle is disconnected, it is not used for either a \u201csend\u201d call or a call to nvds_msgapi_do_work() . While the library attempts to ensure graceful failure, if the application calls these functions with retired handles, it does not do so in a thread-safe manner.", "keywords": []}, {"id": 2904, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id12", "display_name": "Monitor Adapter Execution", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id12", "priority": -1, "content": "The REDIS protocol adapter uses the nvds_logger framework to generate log messages which can help you monitor execution. The adapter generates separate logs for the INFO, DEBUG, and ERROR severity levels, as described in nvds_logger : Logging Framework. You can limit the log messages being generated by setting the level at which log messages are filtered in the logging setup script. If the severity level is set to DEBUG, nvds_logger logs the entire contents of each message sent by the REDIS protocol adapter.", "keywords": []}, {"id": 2905, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id13", "display_name": "Installing Dependencies", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id13", "priority": -1, "content": "MQTT protocol adapter for DeepStream uses the libmosquitto.so library, built from mosquitto 2.0.15 . glib 2.0: sudo apt-get install libglib2.0 libglib2.0-dev ssl: sudo apt-get install libssl-dev cjson: sudo apt-get install libcjson-dev mosquitto 2.0.15: wget https://mosquitto.org/files/source/mosquitto-2.0.15.tar.gz tar -xvf mosquitto-2.0.15.tar.gz cd mosquitto-2.0.15 make make install sudo cp /usr/local/lib/libmosquitto* /opt/nvidia/deepstream/deepstream/lib/ sudo ldconfig", "keywords": []}, {"id": 2906, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id14", "display_name": "Configure Adapter Settings", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id14", "priority": -1, "content": "You can place MQTT protocol adapter specific information in a custom configuration file named, for example, cfg_mqtt.txt . Here is an example of configuration file entries for an MQTT broker installed on the local machine: [message-broker] username = user password = password client-id = uniqueID #enable-tls = 1 #tls-cafile = #tls-capath = #tls-certfile = #tls-keyfile = #share-connection = 1 #loop-timeout = 2000 #keep-alive = 60 The properties in the configuration file are: username - the username to be set to authenticate with the mosquitto broker, if enabled \u2013 TO BE DEPRECATED, USE ENV VARIABLE password - the password to be set to authenticate with the mosquitto broker, if enabled \u2013 TO BE DEPRECATED, USE ENV VARIABLE client-id - string to use as client ID. If empty, a random client ID will be generated. Each client ID must be unique to connect to the same broker enable-tls - 0 for no, 1 for yes Enable TLS encryption. If enabled, at least one of tls-cafile and tls-capath must be set. tls-cafile - path to a file containing the PEM encoded trusted CA certificate files. Either cafile or capath must be provided. tls-capath - path to a directory containing the PEM encoded trusted CA certificate files. Either cafile or capath must be provided. For capath to work correctly, the certificates files must have \u201c.pem\u201d as the file ending and you must run \u201copenssl rehash &lt;path to capath&gt;\u201d each time you add/remove a certificate. tls-certfile - path to a file containing the PEM encoded certificate file for this client. If not provided, no client certificate will be used. tls-keyfile - path to a file containing the PEM encoded private key for this client. If not provided. no client certificate will be used. share-connection - 0 for no, 1 for yes Uncomment the field share-connection in cfg_mqtt.txt and set its value to 1 if you need to generate a connection signature. This signature is a unique string which is generated by parsing all the mqtt connection related params used for making a connection Uncommenting this field signifies that the connection created can be shared with other components within the same process. loop-timeout - timeout in ms to pass to the mosquitto_loop() call, which is called by nvds_msgapi_do_work() . Default is 2000 ms. This refers to the maximum number of milliseconds to wait for network activity before the call times out. Set to 0 for instant return. keep-alive - number of seconds after which the broker should send a PING message to the client if no other messages have been exchanged in that time.", "keywords": []}, {"id": 2907, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id15", "display_name": "Using the Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id15", "priority": -1, "content": "To use the MQTT protocol client adapter in a DeepStream application, set the Gst-nvmsgbroker plugin\u2019s proto-lib property to the pathname of the adapter\u2019s shared library, libnvds_mqtt_proto.so .: proto-lib = &lt;path to libnvds_mqtt_proto.so&gt; You can specify the MQTT protocol\u2019s hostname and port number in the Gst plugin\u2019s conn-str property, and specify the username and password in the configuration file. In the Gst properties: conn-str = localhost;1883 config = &lt;pathname of MQTT configuration file&gt; In the MQTT configuration file: [message-broker] username = user password = password You can set the Gst-nvmsgbroker plugin\u2019s topic property to specify the message topic. topic = &lt;topicname&gt;", "keywords": []}, {"id": 2908, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id16", "display_name": "Programmatic Integration", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id16", "priority": -1, "content": "Once you have configured the connection, you can integrate the MQTT protocol adapter into your application by using the nvds_msgapi interface to call its functions. Note the following points about the functions defined by the interface: The connection string passed to nvds_msgapi_connect() has the format Hostname;&lt;port&gt; . For nvds_msgapi_send_async() , the topic name is specified by the Gst-nvmsgbroker plugin\u2019s topic property. The application must call nvds_msgapi_do_work() after each call to nvds_msgapi_send_async() . The frequency of calls to nvds_msgapi_do_work() determines the rate at which messages waiting to be sent are processed. The MQTT protocol adapter expects the client to manage usage and retirement of the connection handle. The client must ensure that once a handle is disconnected, it is not used for either a \u201csend\u201d call or a call to nvds_msgapi_do_work() . While the library attempts to ensure graceful failure, if the application calls these functions with retired handles, it does not do so in a thread-safe manner. The synchronous send function nvds_msgapi_send() is not supported by the MQTT protocol adapter. Only nvds_msgapi_send_async() can be called to send messages.", "keywords": []}, {"id": 2909, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id17", "display_name": "Monitor Adapter Execution", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id17", "priority": -1, "content": "The MQTT protocol adapter uses the nvds_logger framework to generate log messages which can help you monitor execution. The adapter generates separate logs for the INFO, DEBUG, and ERROR severity levels, as described in nvds_logger : Logging Framework. You can limit the log messages being generated by setting the level at which log messages are filtered in the logging setup script. If the severity level is set to DEBUG, nvds_logger logs the entire contents of each message sent by the MQTT protocol adapter.", "keywords": []}, {"id": 2910, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id2", "display_name": "Using the Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id2", "priority": -1, "content": "To use the Azure device client adapter in an application, set the Gst-nvmsgbroker plugin\u2019s proto-lib property to the pathname of the adapter\u2019s shared library - libnvds_azure_proto.so for the device client case, or libnvds_azure_edge_proto.so for the module client case. The next step in using the adapter is to specify the connection details. The procedure for specifying connection details is different for the Azure device client and module client cases, as described in the following sections.", "keywords": []}, {"id": 2911, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id3", "display_name": "Installing Dependencies", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id3", "priority": -1, "content": "AMQP protocol adapter for DeepStream uses the librabbitmq.so library. Install rabbitmq-c library: sudo apt-get install librabbitmq-dev Install glib 2.0: sudo apt-get install libglib2.0 libglib2.0-dev", "keywords": []}, {"id": 2912, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id4", "display_name": "Using the Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id4", "priority": -1, "content": "To use the AMQP protocol client adapter in a DeepStream application, set the Gst-nvmsgbroker plugin\u2019s proto-lib property to the pathname of the adapter\u2019s shared library, libnvds_amqp_proto.so .: proto-lib = &lt;path to libnvds_amqp_proto.so&gt; You can specify the AMQP connection details in the AMQP adapter specific configuration file (e.g., cfg_amqp.txt ) as described above. This is the recommended method. The path to the AMQP configuration file is specified by the Gst property config: config = &lt;path to cfg_amqp.txt&gt; Alternatively, you can specify the AMQP protocol\u2019s hostname, port number, and username in the Gst plugin\u2019s conn-str property, and specify the password in the configuration file. In the Gst properties: conn-str = hostname;5672;username config = &lt;pathname of AMQP configuration file&gt; In the AMPQ configuration file: [message-broker] password = &lt;password&gt; You can set the Gst-nvmsgbroker plugin\u2019s topic property to specify the message topic. topic = &lt;topicname&gt; Alternatively, you can specify a topic in the AMQP configuration file (cfg_amqp.txt). In the Gst properties, set: config = &lt;path to cfg_amqp.txt&gt; In the AMQP configuration file: [message-broker] Topic = topicname NOTE: Option to pass in username and password through config file and connection string is to be deprecated. Follow the below steps to set user credentials in environmental variables instead. Only acceptable connection string format after deprecation will be \u201curl;port\u201d.", "keywords": []}, {"id": 2913, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id5", "display_name": "Programmatic Integration", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id5", "priority": -1, "content": "Once you have configured the connection, you can integrate the AMQP protocol adapter into your application by using the nvds_msgapi interface to call its functions. Note the following points about the functions defined by the interface: The connection string passed to nvds_msgapi_connect() has the format`` Hostname;&lt;port&gt;;username``. For both \u201csend\u201d functions, the topic name is specified either by the Gst-nvmsgbroker plugin\u2019s topic property or by the topic parameter in the AMQP configuration file. The application must call nvds_msgapi_do_work() after each call to nvds_msgapi_send_async() . The frequency of calls to nvds_msgapi_do_work() determines the rate at which messages waiting to be sent are processed. The AMQP protocol adapter expects the client to manage usage and retirement of the connection handle. The client must ensure that once a handle is disconnected, it is not used for either a \u201csend\u201d call or a call to nvds_msgapi_do_work() . While the library attempts to ensure graceful failure, if the application calls these functions with retired handles, it does not do so in a thread-safe manner. As stated at alanxz/rabbitmq-c , you cannot share a socket, an amqp_connection_state_t , or a channel between threads using the librabbitmq library. This library is designed for use by event-driven, single-threaded applications, and does not yet meet the requirements of threaded applications. To deal with this limitation, your application must open an AMQP connection (and an associated socket) per thread. If it needs to access a single AMQP connection or any of its channels from more than one thread, you must implement an appropriate locking mechanism. It is generally simpler to have a connection dedicated to each thread.", "keywords": []}, {"id": 2914, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id6", "display_name": "Monitor Adapter Execution", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id6", "priority": -1, "content": "The AMQP protocol adapter uses the nvds_logger framework to generate log messages which can help you monitor execution. The adapter generates separate logs for the INFO, DEBUG, and ERROR severity levels, as described in nvds_logger : Logging Framework. You can limit the log messages being generated by setting the level at which log messages are filtered in the logging setup script. If the severity level is set to DEBUG, nvds_logger logs the entire contents of each message sent by the AMQP protocol adapter.", "keywords": []}, {"id": 2915, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id7", "display_name": "Installing Dependencies", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id7", "priority": -1, "content": "REDIS protocol adapter for DeepStream uses the libhiredis.so library, built from Hiredis v1.0.2 . Build dependencies with installation instructions: libhiredis: git clone https://github.com/redis/hiredis.git cd hiredis git checkout tags/v1.2.0 make USE_SSL=1 sudo cp libhiredis* /opt/nvidia/deepstream/deepstream/lib/ sudo ln -sf /opt/nvidia/deepstream/deepstream/lib/libhiredis.so /opt/nvidia/deepstream/deepstream/lib/libhiredis.so.1.1.0 sudo ldconfig Note that for using TLS/SSL security, make sure to build libhiredis with SSL support enabled by using the USE_SSL option as specified in the README here: redis/hiredis glib 2.0: apt-get install libglib2.0 libglib2.0-dev", "keywords": []}, {"id": 2916, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id8", "display_name": "Configure Adapter Settings", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id8", "priority": -1, "content": "You can place REDIS protocol adapter specific information in a custom configuration file, for example, cfg_redis.txt . Here is an example of configuration file entries for a redis server installed on the local machine: [message-broker] hostname=localhost port=6379 password=password payloadkey=metadata consumergroup=mygroup consumername=myname streamsize=10000 The properties in the configuration file are: hostname: Hostname of the host on which the REDIS server is installed port: Port used to communicate with the REDIS server password: password for connection to the server. Use if requirepass is enabled in the redis server config file: https://redis.io/docs/latest/operate/oss_and_stack/management/security/ (CONFIG TO BE DEPRECATED: password should be set in an environmental variable instead) payloadkey: Specify the redis stream key for the payload (More info on streams key: https://redis.io/topics/streams-intro ) consumergroup: Specify redis streams consumer groupname (More info on redis streams consumer groups : https://redis.io/commands/xgroup ) consumername: Specify redis streams consumer name streamsize: Specify the max stream size for the redis stream where data is being published", "keywords": []}, {"id": 2917, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#id9", "display_name": "User Authentication", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "id9", "priority": -1, "content": "Enable requirepass in the redis server config file to set password in the broker (see https://redis.io/docs/latest/operate/oss_and_stack/management/security/ ). Set the password in the adaptor by setting the following environmental variable: export PASSWORD_REDIS=password If the password is also set in the config, the adaptor will set according to the environmental variable and not the config.", "keywords": []}, {"id": 2918, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer with NvDsPayload Control parameters Config conn-str proto-lib comp-id topic new-api Output None, as this is a sink component", "keywords": []}, {"id": 2919, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#installing-dependencies", "display_name": "Installing Dependencies", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "installing-dependencies", "priority": -1, "content": "The Kafka adapter uses librdkafka for the underlying protocol implementation. This library must be installed prior to use. To install librdkakfa , enter these commands: git clone https://github.com/confluentinc/librdkafka.git cd librdkafka git checkout tags/v2.2.0 ./configure --enable-ssl make sudo make install sudo cp /usr/local/lib/librdkafka* /opt/nvidia/deepstream/deepstream/lib/ sudo ldconfig Install additional dependencies: sudo apt-get install libglib2.0 libglib2.0-dev sudo apt-get install libjansson4 libjansson-dev", "keywords": []}, {"id": 2920, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#message-topics-and-routes", "display_name": "Message Topics and Routes", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "message-topics-and-routes", "priority": -1, "content": "You can specify a message topic in a GStreamer property topic. However, the Azure device client and module client use the topic property in different ways. The Azure device client does not support topics. Thus, the value of the topic property is ignored, and you cannot use it to filter messages on Azure IoT Hub. The Azure module client uses the topic property to determine the route of messages, i.e. how messages are passed within a system. For more information about message routes, see: https://docs.microsoft.com/en-us/azure/iot-edge/module-composition#declare-routes )", "keywords": []}, {"id": 2921, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#monitor-adapter-execution", "display_name": "Monitor Adapter Execution", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "monitor-adapter-execution", "priority": -1, "content": "The Azure device client and module client use different logging mechanisms.", "keywords": []}, {"id": 2922, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#mqtt-protocol-adapter", "display_name": "MQTT Protocol Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "mqtt-protocol-adapter", "priority": -1, "content": "DeepStream 6.4 includes the release of an MQTT protocol adapter that DeepStream applications can use out of the box to publish messages using the MQTT V5.0 protocol. The MQTT protocol adapter shared library is in the deepstream package at: /opt/nvidia/deepstream/deepstream/lib/libnvds_mqtt_proto.so", "keywords": []}, {"id": 2923, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-connect-create-a-connection", "display_name": "nv_msgbroker_connect(): Create a Connection", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-connect-create-a-connection", "priority": -1, "content": "NvMsgBrokerClientHandle nv_msgbroker_connect(char *broker_conn_str, char *broker_proto_lib, nv_msgbroker_connect_cb_t connect_cb, char *cfg); The function accepts a connection string and configures a connection. The broker adapter proto lib implementation can choose whether the function makes a connection to accommodate connectionless protocols such as HTTP. Parameters broker_conn_str : A connection string with format specific for protocol adapter broker_proto_lib : Full Path to Message protocol adapter library connect_cb : A pointer to a callback function for events associated with the connection. Cfg : Pathname of a configuration file passed to be passed to the protocol adapter Connect callback typedef void (*nv_msgbroker_connect_cb_t)(NvMsgBrokerClientHandle h_ptr, NvMsgBrokerErrorType status ); Where the callback\u2019s parameters are: h_ptr : The connection handle to identify the initiating call. status : A code that indicates the status of the connection. Return Value A connection handle for use in subsequent interface calls if successful, or NULL otherwise.", "keywords": []}, {"id": 2924, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-disconnect-terminate-a-connection", "display_name": "nv_msgbroker_disconnect(): Terminate a Connection", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-disconnect-terminate-a-connection", "priority": -1, "content": "NvMsgBrokerErrorType nv_msgbroker_disconnect(NvMsgBrokerClientHandle h_ptr); The function terminates the connection, if the underlying protocol requires it, and frees resources associated with h_ptr . Parameters h_ptr : A handle for the connection, obtained by a call to nv_msgbroker_connect()", "keywords": []}, {"id": 2925, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-message-broker-interface", "display_name": "nv_msgbroker: Message Broker interface", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-message-broker-interface", "priority": -1, "content": "Deepstream 5.0 features a new messagebroker library which can be used to make connections with multiple external brokers. This library acts as a wrapper around the message adapter libraries described in the above section and provides its own API\u2019s Gst-msgbroker plugin has an option to directly call in to the adapter library API\u2019s for connecting with external entity or use the nvmsgbroker library interface to have the ability to connect with multiple external entities at a time. Additionally, autoreconnect feature is introduced within nvmsgbroker library as of Deepstream 6.0 wherein a periodic reconnection attempt is made to re-establish connection with the external entity. Source code for this library is now available at /opt/nvidia/deepstream/deepstream/sources/libs/nvmsgbroker as of DeepStream 7.1. As of Deepstream-6.2, a new configuration work-interval is available, which allows the user to set the wait time between execution of adapter logic. The Gst-nvmsgbroker plugin can call the Api\u2019s in the nvmsgbroker library as shown in the diagram above. The Api\u2019s support: Creating a connection Sending messages by asynchronous means Terminating the connection Fetching the nvmsgbroker library version number The nvmsgbroker interface is defined in the header file /opt/nvidia/deepstream/deepstream/sources/includes/nvmsgbroker.h . This header file defines a set of function pointers which provide an interface analogous to an interface in C++. The following sections describe the methods defined by the nvmsgbroker interface.", "keywords": []}, {"id": 2926, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-send-async-send-an-event-asynchronously", "display_name": "nv_msgbroker_send_async(): Send an event asynchronously", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-send-async-send-an-event-asynchronously", "priority": -1, "content": "NvMsgBrokerErrorType nv_msgbroker_send_async (NvMsgBrokerClientHandle h_ptr, NvMsgBrokerClientMsg message, nv_msgbroker_send_cb_t cb, void *user_ctx); The API sends data to the endpoint of a connection. It accepts a message topic and a message payload. Send is asynchronous; it accepts a callback function that is called when the \u201csend\u201d operation is completed. Parameters h_ptr : connection handle to Message Broker library message : Message packet which has details of message payload, payload length , topic cb : callback to be invoked to notify status of send user_ctx : pointer to pass to callback for context Message Packet structure typedef struct { char *topic; void *payload; size_t payload_len; } NvMsgBrokerClientMsg; Send callback typedef void (*nv_msgbroker_send_cb_t)(void *user_ptr, NvMsgBrokerErrorType flag); Where the callback\u2019s parameters are: user_ptr : The user pointer (user_ptr) from the call to nv_msgbroker_send_async() that initiated the \u201csend\u201d operation. Enables the callback function to identify the initiating call. flag : A code that indicates the completion status of the send operation.", "keywords": []}, {"id": 2927, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-subscribe-consume-data-by-subscribing-to-topics", "display_name": "nv_msgbroker_subscribe(): Consume data by subscribing to topics", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-subscribe-consume-data-by-subscribing-to-topics", "priority": -1, "content": "NvMsgBrokerErrorType nv_msgbroker_subscribe(NvMsgBrokerClientHandle h_ptr, char ** topics, int num_topics, nv_msgbroker_subscribe_cb_t cb, void *user_ctx); This API is used to subscribe to topic(s) and consume messages from the external entity. The API is asynchronous and must be called with an already created valid connection handle as parameter. The caller must also provide a pointer to the callback function to receive the consumed messages from the connection endpoint and an optional user_ctx pointer for specifying user context Parameters h_ptr : A handle for the connection, obtained by a call to nv_msgbroker_connect() topics : A 2d pointer which points to a char array of topic names num_topics : num of topics to subscribe cb : A pointer to a callback function to get notified of the consumed messages on subscribed topic(s) user_ctx : user ptr to be passed to callback for context The pointer to a callback function which is specified as a param in subscribe API is of type nv_msgbroker_subscribe_cb_t defined as: typedef void (*nv_msgbroker_subscribe_cb_t)(NvMsgBrokerErrorType flag, void *msg, int msglen, char *topic, void *user_ptr); Where the callback\u2019s parameters are: flag : To specify the error status of message consumed msg : Consumed message / payload msg_len : Length of message in bytes topic : Topic name where the message was received user_ptr : pointer passed during subscribe() for context", "keywords": []}, {"id": 2928, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nv-msgbroker-version-get-version-number", "display_name": "nv_msgbroker_version(): Get Version Number", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nv-msgbroker-version-get-version-number", "priority": -1, "content": "char *nv_msgbroker_version(); This function returns a string that identifies the nv_msgbroker version supported by this protocol adapter implementation. The string must use the format &lt;major&gt;.&lt;minor&gt; , where &lt;major&gt; is a major version number and &lt;minor&gt; is a minor version number. A change in the major version number indicates an API change that may cause incompatibility. When the major version number changes, the minor version number is reset to 1.", "keywords": []}, {"id": 2929, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-kafka-proto-kafka-protocol-adapter", "display_name": "nvds_kafka_proto: Kafka Protocol Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-kafka-proto-kafka-protocol-adapter", "priority": -1, "content": "DeepStream includes a protocol adapter that supports Apache Kafka. The adapter provides out-of-the-box capability for DeepStream applications to publish messages to Kafka brokers.", "keywords": []}, {"id": 2930, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-logger-logging-framework", "display_name": "nvds_logger: Logging Framework", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-logger-logging-framework", "priority": -1, "content": "DeepStream provides a logging framework named nvds_logger . The Kafka protocol adapter uses this framework to generate a run time log. nvds_logger is based on syslog, and offers many related features, including: Choice of priorities (log levels) Log filtering and redirection Shared logging across different DeepStream instances running concurrently Log retirement and management using logrotate Cross-platform support", "keywords": []}, {"id": 2931, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-connect-create-a-connection", "display_name": "nvds_msgapi_connect(): Create a Connection", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-connect-create-a-connection", "priority": -1, "content": "NvDsMsgApiHandle nvds_msgapi_connect(char *connection_str, nvds_msgapi_connect_cb_t connect_cb, char *config_path ); The function accepts a connection string and configures a connection. The adapter implementation can choose whether the function makes a connection to accommodate connectionless protocols such as HTTP. Parameters connection_str : A pointer to a string that specifies connection parameters in the general format &lt;url&gt;;&lt;port&gt;;&lt;specifier&gt; . &lt;url&gt; and &lt;port&gt; specify the network address of the remote entity. &lt;specifier&gt; specifies information specific to a protocol. Its content depends on the protocol\u2019s implementation. It may be, for example, a client identifier for making the connection. Note that this connection string format is not binding, and an adapter may omit some fields (e.g.: specifier) from its format, provided the omission is described in its documentation. A special case of such connection string adaptation is where the adapter expects all connection parameters to be specified as fields in the configuration file (see config path below), in which case the connection string is passed as NULL. connect_cb : A callback function for events associated with the connection. config_path : The pathname of a configuration file that defines protocol parameters used by the adapter. Return Value A handle for use in subsequent interface calls if successful, or NULL otherwise.", "keywords": []}, {"id": 2932, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-connection-signature-get-connection-signature", "display_name": "nvds_msgapi_connection_signature(): Get Connection signature", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-connection-signature-get-connection-signature", "priority": -1, "content": "NvDsMsgApiErrorType nvds_msgapi_connection_signature(char *broker_str, char *cfg, char *output_str, int max_len); This function returns a string that uniquely identifies the signature of the connection parameters passed to the adapter library for making a connection. On success, a connection signature string(generated by SHA256) is returned. Upon error or invalid connection parameters, empty string \u201c\u201d is returned. Parameters: broker_str : Broker connection string used to create connection cfg : Path to config file output_str : Output Connection signature max_len : max length of output_str", "keywords": []}, {"id": 2933, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-disconnect-terminate-a-connection", "display_name": "nvds_msgapi_disconnect(): Terminate a Connection", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-disconnect-terminate-a-connection", "priority": -1, "content": "NvDsMsgApiErrorType nvds_msgapi_disconnect(NvDsMsgApiHandle h_ptr); The function terminates the connection, if the underlying protocol requires it, and frees resources associated with h_ptr . Parameters h_ptr : A handle for the connection, obtained by a call to nvds_msgapi_connect() .", "keywords": []}, {"id": 2934, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-do-work-incremental-execution-of-adapter-logic", "display_name": "nvds_msgapi_do_work(): Incremental Execution of Adapter Logic", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-do-work-incremental-execution-of-adapter-logic", "priority": -1, "content": "void nvds_msgapi_do_work(); The protocol adapter must periodically surrender control to the client during processing of nvds_msgapi_send() and nvds_msgapi_send_async() calls. The client must periodically call nvsd_msgapi_do_work() to let the protocol adapter resume execution. This ensures that the protocol adapter receives enough CPU resources. The client can use this convention to control the protocol adapter\u2019s use of multi-threading and thread scheduling. The protocol adapter can use it to support heartbeat functionality, if the underlying protocol requires that. The nvds_msgapi_do_work() convention is needed when the protocol adapter executes in the client thread. Alternatively, the protocol adapter may execute time-consuming operations in its own thread. In this case the protocol adapter need not surrender control to the client, the client need not call nvsd_msgapi_do_work() , and the implementation of nvds_msgapi_do_work() may be a no-op. The protocol adapter\u2019s documentation must specify whether the client must call nvds_msgapi_do_work() , and if so, how often.", "keywords": []}, {"id": 2935, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-get-protocol-name-get-name-of-the-protocol", "display_name": "nvds_msgapi_get_protocol_name(): Get name of the protocol", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-get-protocol-name-get-name-of-the-protocol", "priority": -1, "content": "char *nvds_msgapi_get_protocol_name(void); This function returns a string that identifies the underlying protocol used in the adapter library. for example, &quot;KAFKA\u201d , \u201cAMQP\u201d , \u201cAZURE_DEVICE_CLIENT\u201d , \u201cAZURE_MODULE_CLIENT\u201d", "keywords": []}, {"id": 2936, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-getversion-get-version-number", "display_name": "nvds_msgapi_getversion(): Get Version Number", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-getversion-get-version-number", "priority": -1, "content": "char *nvds_msgapi_getversion(); This function returns a string that identifies the nvds_msgapi version supported by this protocol adapter implementation. The string must use the format &lt;major&gt;.&lt;minor&gt; , where &lt;major&gt; is a major version number and &lt;minor&gt; is a minor version number. A change in the major version number indicates an API change that may cause incompatibility. When the major version number changes, the minor version number is reset to 1.", "keywords": []}, {"id": 2937, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-protocol-adapter-interface", "display_name": "nvds_msgapi: Protocol Adapter Interface", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-protocol-adapter-interface", "priority": -1, "content": "You can use the DeepStream messaging interface, nvds_msgapi , to implement a custom protocol message handler and integrate it with DeepStream applications. Such a message handler, known as a protocol adapter, enables you to integrate DeepStream applications with backend data sources, such as data stored in the cloud. New with DeepStream 7.1, the source code for all protocol adaptors provided with DeepStream is available at /opt/nvidia/deepstream/deepstream/sources/libs/*_protocol_adaptor . The Gst-nvmsgbroker plugin calls the functions in your protocol adapter as shown in the figure above. These functions support: Creating a connection Sending messages by synchronous or asynchronous means Terminating the connection Coordinating the client\u2019s and protocol adapter\u2019s use of CPU resources and threads Getting the protocol adapter\u2019s version number The nvds_msgapi interface is defined in the header file /opt/nvidia/deepstream/deepstream/sources/includes/nvds_msgapi.h . This header file defines a set of function pointers which provide an interface analogous to an interface in C++. The following sections describe the methods defined by the nvds_msgapi interface.", "keywords": []}, {"id": 2938, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-send-and-nvds-msgapi-send-async-send-an-event", "display_name": "nvds_msgapi_send() and nvds_msgapi_send_async(): Send an event", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-send-and-nvds-msgapi-send-async-send-an-event", "priority": -1, "content": "NvDsMsgApiErrorType nvds_msgapi_send(NvDsMsgApiHandle *h_ptr, char *topic, uint8_t *payload, size_t nbuf ); NvDsMsgApiErrorType nvds_msgapi_send_async(NvDsMsgApiHandle h_ptr, char *topic, const uint8_t *payload, size_t nbuf, nvds_msgapi_send_cb_t send_callback, void *user_ptr ); Both functions send data to the endpoint of a connection. They accept a message topic and a message payload. The nvds_send() function is synchronous. The nvds_msgapi_send_async() function is asynchronous; it accepts a callback function that is called when the \u201csend\u201d operation is completed. Both functions allow the API client to control execution of the adapter logic by calling nvds_msgapi_do_work() . See the description of the nvds_msgapi_do_work() function. Parameters h_ptr : A handle for the connection, obtained by a call to nvds_msgapi_connect() . topic : A pointer to a string that specifies a topic for the message; may be NULL if topic is not meaningful for the semantics of the protocol adapter. payload : A pointer to a byte array that contains the payload for the message. nbuf : Number of bytes to be sent. send_callback : A pointer to a callback function that the asynchronous function calls when the \u201csend\u201d operation is complete. The signature of the callback function is of type nvds_msgapi_send_cb_t , defined as: typedef void (*nvds_msgapi_send_cb_t)(void *user_ptr, NvDsMsgApiErrorType completion_flag ); where the callback\u2019s parameters are: user_ptr : The user pointer (user_ptr) from the call to nvds_msgapi_send() or`` nvds_msgapi_send_async()`` that initiated the \u201csend\u201d operation. Enables the callback function to identify the initiating call. completion_flag : A code that indicates the completion status of the asynchronous send operation.", "keywords": []}, {"id": 2939, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#nvds-msgapi-subscribe-consume-data-by-subscribing-to-topics", "display_name": "nvds_msgapi_subscribe(): Consume data by subscribing to topics", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "nvds-msgapi-subscribe-consume-data-by-subscribing-to-topics", "priority": -1, "content": "NvDsMsgApiErrorType nvds_msgapi_subscribe (NvDsMsgApiHandle h_ptr, char ** topics, int num_topics, nvds_msgapi_subscribe_request_cb_t cb, void *user_ctx); This API is used to subscribe to topic(s) and consume messages from the external entity. The API is asynchronous and must be called with an already created valid Kafka connection handle as parameter. The caller must also provide a pointer to the callback function to receive the consumed messages from the connection endpoint and an optional user_ctx pointer for specifying user context Parameters h_ptr : A handle for the connection, obtained by a call to nvds_msgapi_connect() topics : A 2d pointer which points to a char array of topic names num_topics : num of topics to subscribe cb : A pointer to a callback function to get notified of the consumed messages on subscribed topic(s) user_ctx : user ptr to be passed to callback for context The pointer to a callback function which is specified as a param in subscribe API is of type nvds_msgapi_subscribe_request_cb_t defined as: typedef void (*nvds_msgapi_subscribe_request_cb_t)(NvDsMsgApiErrorType flag, void *msg, int msg_len, char *topic, void *user_ptr); where the callback\u2019s parameters are: * ``flag``: To specify the error status of message consumed * ``msg``: Consumed message / payload * ``msg_len``: Length of message in bytes * ``topic``: Topic name where the message was received * ``user_ptr``: pointer passed during subscribe() for context", "keywords": []}, {"id": 2940, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#programmatic-integration", "display_name": "Programmatic Integration", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "programmatic-integration", "priority": -1, "content": "You can integrate the Kafka adapter into custom user code by using the nvds_msgapi interface to call its functions. Note the following points regarding the functions defined by the interface: The connection string passed to the nvdm_msgapi_connect() has the format &lt;kafka broker address&gt;;&lt;port&gt; . For both \u201csend\u201d functions, the topic name must be passed as param to nvds_msgapi_send() . or nvds_msgapi_send_async( ) For the subscribe API, a 2D pointer to a char array of topic-names must be passed as param. Also, a pointer to a user callback function must be provided. When there\u2019s a new message from the remote entity, the Kafka consumer will forward the message to the application by calling the user callback function. The application must call nvds_msgapi_do_work() at least once a second, and preferably more often. The frequency of calls to nvds_msgapi_do_work() determines the rate at which messages waiting to be sent are processed. It is safe for multiple application threads to share connection handles. The library librdkafka is thread-safe, so Kafka protocol adapter does not need to implement separate locking mechanisms for functions calling directly to this library. The Kafka protocol adapter expects the client to manage usage and retirement of the connection handle. The client must ensure that once a handle is disconnected, it is not used for either a \u201csend\u201d call or a call to nvds_msgapi_do_work() . While the library attempts to ensure graceful failure if the application calls these functions with retired handles, it does not do so in a thread-safe manner.", "keywords": []}, {"id": 2941, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#redis-protocol-adapter", "display_name": "REDIS Protocol Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "redis-protocol-adapter", "priority": -1, "content": "DeepStream includes a REDIS protocol adapter that DeepStream applications can use out of the box to publish messages using REDIS streams https://redis.io/topics/streams-intro The REDIS protocol adapter shared library is in the deepstream package at: /opt/nvidia/deepstream/deepstream/lib/libnvds_redis_proto.so", "keywords": []}, {"id": 2942, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#redis-server", "display_name": "REDIS server", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "redis-server", "priority": -1, "content": "Install &amp; setup redis-server on your machine. Follow instructions here and download the redis version(6.0.8) : https://redis.io/download wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar xzf redis-6.0.8.tar.gz cd redis-6.0.8 make Run the server src/redis-server &amp;", "keywords": []}, {"id": 2943, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#retiring-and-managing-logs", "display_name": "Retiring and Managing Logs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "retiring-and-managing-logs", "priority": -1, "content": "It is recommended that you limit the size of log files by retiring them periodically. logrotate is a popular utility for this purpose. You can use it in cron jobs so that the log files are automatically archived periodically and are discarded after a desired interval.", "keywords": []}, {"id": 2944, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#security-for-kafka", "display_name": "Security for Kafka", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "security-for-kafka", "priority": -1, "content": "To learn more about security for Kafka, see the Secure Edge-to-Cloud Messaging section in the NVIDIA DeepStream SDK Developer Guide 6.0 Release . Monitor Adapter Execution The Kafka adapter generates log messages based on the nvds_logger framework to help you monitor execution. The adapter generates separate logs for the INFO, DEBUG, and ERROR severity levels, as described in nvds_logger: Logging Framework . You can limit the log messages generated by setting the level at which log messages are filtered as part of the logging setup script. If the severity level is set to DEBUG, the nvds_logger framework logs the entire contents of each message sent by the Kafka protocol adapter.", "keywords": []}, {"id": 2945, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#setting-up-azure-iot", "display_name": "Setting Up Azure IoT", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "setting-up-azure-iot", "priority": -1, "content": "Azure IoT adapter needs a functioning Azure IoT Hub instance to which is can publish messages. To set up an Azure IoT Hub instance if required, see the instructions at: https://docs.microsoft.com/en-us/azure/iot-hub/tutorial-connectivity . After you create the Azure IoT instance, create a device entry corresponding to the device that is running DeepStream. To set up Azure IoT Edge runtime on the edge device, see the instructions at https://docs.microsoft.com/en-us/azure/iot-edge/how-to-install-iot-edge-linux . Note the message rate limitations for your IoT Hub service tier: https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-quotas-throttling#standard-tier-operations . Please set the sleep-time property for the nvmsgbroker plugin accordingly to prevent throttling.", "keywords": []}, {"id": 2946, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#user-authentication", "display_name": "User authentication", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "user-authentication", "priority": -1, "content": "To set username and password, export the following environmental variables: export USER_AMQP=username export PASSWORD_AMQP=password If username and password are also set in the config, the adaptor will set according to the environmental variables and not the config.", "keywords": []}, {"id": 2947, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#using-the-adapter", "display_name": "Using the Adapter", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "using-the-adapter", "priority": -1, "content": "You can use the Kafka adapter in an application by setting the Gst-nvmsgbroker plugin\u2019s proto-lib property to the pathname of the adapter\u2019s shared library, libnvds_kafka_proto.so . The plugin\u2019s conn-str property must be set to a string with format: &lt;kafka broker address&gt;;&lt;port&gt; This instantiates the Gst-nvmsgbroker plugin and makes it use the Kafka protocol adapter to publish messages that the application sends to the broker at the specified broker address and topic.", "keywords": []}, {"id": 2948, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgbroker#work-interval-configuration", "display_name": "Work-interval configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "work-interval-configuration", "priority": -1, "content": "The user can now set the interval in microseconds at which protocol adapter work is performed by changing the work-interval configuration in cfg_nvmsgbroker.txt. The default is 10000 microseconds, aka 10 ms. ... #interval at which to perform work, in microseconds work-interval=10000", "keywords": []}, {"id": 2949, "doc_id": 2949, "filename": "text/DS_plugin_gst-nvmsgbroker.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvmsgbroker", "display_name": "Gst-nvmsgbroker", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvmsgbroker", "anchor": "", "priority": -1, "content": "This plugin sends payload messages to the server using a specified communication protocol. It accepts any buffer that has NvDsPayload metadata attached and uses the nvds_msgapi_* interface to send the messages to the server. You must implement the nvds_msgapi_* interface for the protocol to be used and specify the implementing library in the proto-lib property.", "keywords": []}, {"id": 2950, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Payload in JSON format Message payload is generated in JSON format DS 3.0 Supports DeepStream schema specification DeepStream schema spec implementation for messages DS 3.0 Custom schema specification Provision for custom schemas for messages DS 3.0 Key-value file parsing for static properties Read static properties of sensor/place/module in the form of key-value pair from a text file DS 3.0 CSV file parsing for static properties Read static properties of sensor/place/module from a CSV file DS 3.0 DeepStream 4.0.1 minimalistic schema Minimal variation of the DeepStream message schema DS 4.0 New msgconv api Supports generation of deepStream message schema payloads(full &amp; minimal) directly using Gst buffer frame &amp; object metadata DS 6.0 Payload generation interval Set frame intervals at which payloads are generated DS 6.0", "keywords": []}, {"id": 2951, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvmsgconv plugin\u2019s Gst properties. Property Meaning Type and Range Example / Notes Platforms config Absolute pathname of a configuration file that defines static properties of various sensors, places, and modules. String config=msgconv_config.txt or config=msgconv_config.csv dGPU Jetson msg2p-lib Absolute pathname of the library containing a custom implementation of the nvds_msg2p_* interface for custom payload generation. String msg2p-lib=libnvds_msgconv_custom.so dGPU Jetson payload-type Type of schema payload to be generated. Possible values are: PAYLOAD_DEEPSTREAM: Payload using DeepStream schema. PAYLOAD_DEEPSTREAM_MINIMAL: Payload using minimal DeepStream schema. PAYLOAD_CUSTOM: Payload using custom schemas. Integer, 0 to 4,294,967,295 payload-type=0 or payload-type=257 dGPU Jetson comp-id Component ID of the plugin from which metadata is to be processed. Integer, 0 to 4,294,967,295 comp-id=2 Default is NvDsEventMsgMeta dGPU Jetson debug-payload-dir Directory to dump payload String debug-payload-dir=&lt;absolute path&gt; Default is NULL dGPU Jetson multiple-payloads Generate multiple message payloads Boolean multiple-payloads=1 Default is 0 dGPU Jetson msg2p-newapi Generate payloads using Gst buffer frame/object metadata Boolean msg2p-newapi=1 Default is 0 dGPU Jetson frame-interval Frame interval at which payload is generated Integer, 1 to 4,294,967,295 frame-interval=25 Default is 30 dGPU Jetson dummy-payload By default payload is generated if NVDS_EVENT_MSG_META is attached to buffer. With this dummy payload can be generated if there is no NVDS_EVENT_MSG_META attached to buffer Boolean dummy-payload=true Default is false dGPU Jetson", "keywords": []}, {"id": 2952, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer with NvDsEventMsgMeta or NvDsFrameMeta/NvDsObjectMeta Control parameters config msg2p-lib payload-type comp-id debug-payload-dir (optional) multiple-payloads (optional) msg2p-newapi (optional) frame-interval (optional) Output Same Gst Buffer with additional NvDsPayload metadata. This metadata contains information about the payload generated by the plugin.", "keywords": []}, {"id": 2953, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#nvmsgconv-low-level-library-api-s", "display_name": "NvMsgConv low level library API\u2019s", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "nvmsgconv-low-level-library-api-s", "priority": -1, "content": "Gst-nvmsgconv plugin interface with a low level nvmsgconv library which provides APIs for payload generation: nvds_msg2p_generate to generate message payload using NVDS_EVENT_MSG_META (NvDsEventMsgMeta) type nvds_msg2p_generate_new to generate message payload using GST buffers( NVDS_FRAME_META (NvDsFrameMeta) and NVDS_OBJECT_META (NvDsObjectMeta) type) Deepstream sample test apps have options to use either of API\u2019s to generate message payload deepstream-test4-app Use commandline option \u2013msg2p-meta to choose the metadata type to create payload. 0=Event Msg meta(default), Create NVDS_EVENT_MSG_META type of meta and attach to buffer 1=nvdsmeta, Use the fields within NvDsFrameMeta/NvDsObjectMeta to populate payload deepstream-test5-app Config options present as below and default option creates payload using NvdsEventMsgMeta #(0): Create payload using NvdsEventMsgMeta #(1): New Api to create payload using NvDsFrameMeta msg-conv-msg2p-new-api=0 For payload generation using NVDS_EVENT_MSG_META type, users need: Create NVDS_EVENT_MSG_META type of meta and attach to buffer. Use NVDS_EVENT_MSG_META for different types of objects e.g. vehicle, person etc. Provide copy / free functions if meta data is extended through \u201cextMsg\u201d field. Whereas using the new NvMsgConv low level library API to generate payload, users do not need to worry about creating/destroying any payload object in their sample test application. The nvmsgconv low level library directly uses GST buffers( NVDS_FRAME_META / NVDS_OBJECT_META ) to create payload.", "keywords": []}, {"id": 2954, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#payload-with-custom-objects", "display_name": "Payload with Custom Objects", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "payload-with-custom-objects", "priority": -1, "content": "You can add a group of custom objects to the NvDsEventMsgMeta structure in the extMsg field and specify their size in the extMsgSize field. The meta copy ( copy_func ) and free ( release_func ) functions must handle the custom fields accordingly. The payload generator library handles some standard types of objects (Vehicle, Person, Face, etc.) and generates the payload according to the schema selected. To handle custom object types, you must modify the payload generator library nvmsgconv.cpp . See deepstream-test4 for details about adding custom objects as NVDS_EVENT_MSG_META user metadata with buffers for generating a custom payload to send to back end. If using Deepstream GST buffers( NVDS_FRAME_META (NvDsFrameMeta) type and NVDS_OBJECT_META (NvDsObjectMeta) type) to generate payload instead of NvDsEventMsgMeta , You can attach a custom message blob(string) to payload using NVDS_CUSTOM_MSG_BLOB type by creating NvDsCustomMsgInfo object and specifying the fields message (custom message blob) and len (size of the custom message). The low-level payload generation library parses every frame metadata and checks for NVDS_CUSTOM_MSG_BLOB type and if present attaches it to the payload. This option is available when gst property msg2p-newapi = true (Using the new msgconv API). Similar to generating custom objects to the NvDsEventMsgMeta structure, refer deepstream-test4 for details about adding custom objects, you can use the meta copy ( copy_func ) and free ( release_func ) functions to handle the custom fields and modify the application to attach a custom message using NVDS_CUSTOM_MSG_BLOB (and NvDsCustomMsgInfo object) type instead of NvDsEventMsgMeta type.", "keywords": []}, {"id": 2955, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmsgconv#schema-customization", "display_name": "Schema Customization", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "schema-customization", "priority": -1, "content": "This plugin can be used to implement a custom schema in two ways: By modifying the payload generator library: To perform a simple customization of DeepStream schema fields, modify the low-level payload generation library files inside directory sources/libs/nvmsgconv . Payload generated using NVDS_EVENT_MSG_META (NvDsEventMsgMeta) type can be customized by modifying sources/libs/nvmsgconv/deepstream_schema/eventmsg_payload.cpp . If payload is generated using metadata within DS GST buffers( NVDS_FRAME_META (NvDsFrameMeta) type and NVDS_OBJECT_META (NvDsObjectMeta) type), you can customize payload genertion by modifying the file sources/libs/nvmsgconv/deepstream_schema/dsmeta_payload.cpp . By implementing the nvds_msg2p interface: If a library that implements the custom schema needs to be integrated with the DeepStream SDK, wrap the library in the nvds_msg2p interface and set the plugin\u2019s msg2p-lib property to the library\u2019s name. Set the payload-type property to PAYLOAD_CUSTOM . See sources/libs/nvmsgconv/nvmsgconv.cpp for an example implementation of the nvds_msg2p interface.", "keywords": []}, {"id": 2956, "doc_id": 2956, "filename": "text/DS_plugin_gst-nvmsgconv.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvmsgconv", "display_name": "Gst-nvmsgconv", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvmsgconv", "anchor": "", "priority": -1, "content": "The Gst-nvmsgconv plugin is responsible for converting metadata into message payloads based on schema. DeepStream 5.0 supports two variations of the schema, full and minimal. The Gst-nvmsgconv plugin can be configured to use either one of the schemas. By default, the plugin uses the full DeepStream schema to generate the payload in JSON format. The full schema supports elaborate semantics for object detection, analytics modules, events, location, sensor and 3D tracking. Each payload has information about a single object. You can use the minimal variation of the schema to communicate minimal information with the back end. This provides a small footprint for the payload to be transmitted from DeepStream to a message broker. Each payload can have information for multiple objects in the frame. Gst-nvmsgconv plugin interface with a low level nvmsgconv library which provides APIs for payload generation using below metadata types: NVDS_EVENT_MSG_META (NvDsEventMsgMeta) type metadata attached to the buffer as user metadata of frame meta. For the batched buffer, metadata of all objects of a frame must be under the corresponding frame meta. This is the default option. By parsing the NVDS_FRAME_META (NvDsFrameMeta) type and NVDS_OBJECT_META (NvDsObjectMeta) type in Gst buffer and available fields in these metadata types are used to create message payload based on schema type. To use this option, set gst property msg2p-newapi = true. This API also supports attaching a custom user message blob(a json formatted string) for each payload if the msg blob is added as user metadata of NvDsFrameMeta. Additionally, with this API there\u2019s also an other gst property you can use to set the frame interval at which each payload is generated. frame-interval = &lt;interval&gt;. If this is not set, the default frame interval at which frames are generates is every 30 frames The generated payload (NvDsPayload) in both the above cases are attached back to the input buffer as NVDS_PAYLOAD_META type user metadata. Additionally, Gst-nvmsgconv plugin provides optional properties: - debug-payload-dir : Absolute path of the directory to dump payloads for debugging - multiple-payloads : Generate multiple message payloads", "keywords": []}, {"id": 2957, "doc_id": 2960, "filename": "text/DS_plugin_gst-nvmultistreamtiler.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultistreamtiler#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultistreamtiler", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Composites a 2D tile of input buffers \u2014 DS 2.0 Scales bounding box with metadata coordinates according to scaling and position in tile \u2014 DS 2.0 Multi-GPU support \u2014 DS 2.0 Shows expanded preview for a single source \u2014 DS 2.0 User configurable CUDA memory type (Pinned/Device/Unified) for output buffers \u2014 DS 3.0 Reconfigures 2D tile for new sources added at runtime \u2014 DS 3.0", "keywords": []}, {"id": 2958, "doc_id": 2960, "filename": "text/DS_plugin_gst-nvmultistreamtiler.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultistreamtiler#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultistreamtiler", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvmultistreamtiler plugin\u2019s Gst properties. Property Meaning Type and Range Example Notes rows Number of rows in 2D tiled output Integer, 1 to 4,294,967,295 row=2 columns Number of columns in 2D tiled output Integer, 1 to 4,294,967,295 columns=2 width Width of 2D tiled output in pixels Integer, 1 to 4,294,967,295 width=1920 height Height of 2D tiled output in pixels Integer, 1 to 4,294,967,295 height=1080 show-source Scale and show frames from a single source. -1: composite and show all sources For values \u22650, frames from that source are zoomed. Signed integer, \u22121 to 2,147,483,647 show-source=2 gpu-id ID of the GPU on which device/unified memory is to be allocated, and in which buffers are copied or scaled. (dGPU only.) Integer, 1 to 4,294,967,295 gpu-id=1 nvbuf-memory-type Type of CUDA memory to be allocated. For dGPU: 0 (nvbuf-mem-default): Default memory, cuda-device 1 (nvbuf-mem-cuda-pinned): Pinned/Host CUDA memory 2 (nvbuf-mem-cuda-device) Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For Jetson: 0 (nvbuf-mem-default): Default memory, surface array 4 (nvbuf-mem-surface-array): Surface array memory Integer, 0-4 nvbuf-memory-type=1 custom-tile-config Custom tile position and resolution. Can be configured programmatically for all or none of the sources. Values of enum CustomTileConfig Reserved for future use. Default: null. compute-hw Compute Scaling HW to use. Applicable only for Jetson. dGPU systems uses GPU by default. 0 (Default): Default, GPU for Tesla, VIC for Jetson 1 (GPU): GPU 2 (VIC): VIC Integer: 0-2 compute-hw=1 square-seq-grid Enable automatic square tiling according to number of sources. The tiles are placed sequentially on the grid with empty tiles at the end Boolean square-seq-grid=1", "keywords": []}, {"id": 2959, "doc_id": 2960, "filename": "text/DS_plugin_gst-nvmultistreamtiler.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultistreamtiler#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultistreamtiler", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer batched buffer NvDsBatchMeta with Gst Buffer batched (batch is one or more buffers) Formats supported: NV12/RGBA Control Parameters rows columns width height gpu-id (dGPU only) compute-hw (Jetson only) show-source nvbuf-memory-type custom-tile-config square-seq-grid Output Gst Buffer (single frame) with composited input frames Transformed metadata (NvDsBatchMeta) Formats supported: NV12/RGBA", "keywords": []}, {"id": 2960, "doc_id": 2960, "filename": "text/DS_plugin_gst-nvmultistreamtiler.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvmultistreamtiler", "display_name": "Gst-nvmultistreamtiler", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvmultistreamtiler", "anchor": "", "priority": -1, "content": "The Gst-nvmultistreamtiler plugin composites a 2D tile from batched buffers. The plugin accepts batched NV12/RGBA data from upstream components. The plugin composites the tile based on stream IDs, obtained from NvDsBatchMeta and NvDsFrameMeta in row-major order (starting from source 0, left to right across the top row, then across the next row). Each source frame is scaled to the corresponding location in the tiled output buffer. The plugin can reconfigure if a new source is added and it exceeds the space allocated for tiles. It also maintains a cache of old frames to avoid display flicker if one source has a lower frame rate than other sources.", "keywords": []}, {"id": 2961, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#add-a-new-stream-to-a-deepstream-pipeline", "display_name": "ADD a new stream to a DeepStream pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "add-a-new-stream-to-a-deepstream-pipeline", "priority": -1, "content": "DS-7.1 supports REST API version /api/v1 . Refer below schema details. Payload definition and the sample curl command: 1.curl -XPOST &#x27;http://localhost:9000/api/v1/stream/add&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;value&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;, &quot;change&quot;: &quot;camera_add&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27; 2.curl -XPOST &#x27;http://localhost:9000/api/v1/stream/add&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;event&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;rtsp://xyz.mp4&quot;, &quot;change&quot;: &quot;camera_streaming&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27;", "keywords": []}, {"id": 2962, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#features", "display_name": "2. Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the bin. Feature Description Release nvmultiurisrcbin integrating REST API Server, nvurisrcbin, and nvstreammux Introducing nvmultiurisrcbin DS 6.2 REST API to add and remove sensors runtime Dynamically add/remove sensors DS 6.2 Stream specific Stream addition and removal DS 6.2 nvdspreprocess Update ROI for preprocess DS 6.4 nvv4l2decoder \u201cdrop-frame-interval\u201d and \u201cskip-frame\u201d property update DS 6.4 nvdsinfer \u201cinterval\u201d property update DS 6.4 nvdsinferserver \u201cinterval\u201d property update DS 6.4 nvv4l2encoder \u201cforce-idr\u201d, \u201cforce-intra\u201d, \u201ciframeinterval\u201d and \u201cbitrate\u201d property update DS 6.4 nvstreammux \u201cbatched-push-timeout\u201d property update DS 6.4 nvvideoconvert \u201csrc-crop\u201d, \u201cdest-crop\u201d, \u201cflip-method\u201d and \u201cinterpolation-method\u201d property update DS 6.4 nvdsosd \u201cprocess-mode\u201d property update DS 6.4 Application specific Application quit DS 6.4 GET requests Get the stream-info DS 7.0", "keywords": []}, {"id": 2963, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#gst-properties-directly-configuring-nvmultiurisrcbin", "display_name": "Gst Properties directly configuring nvmultiurisrcbin", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "gst-properties-directly-configuring-nvmultiurisrcbin", "priority": -1, "content": "Property Meaning Type and Range Example Notes uri-list comma separated URI list of sources; URI of the file or rtsp source string uri-list=file:///opt/file.mp4,file:///opt/file.mp4 sensor-id-list comma separated list of unique source sensor IDs; this vector is one to one mapped with the uri-list string sensor-id-list=uniqueSensorID1,uniqueSensorID2 sensor-name-list OPTIONAL comma separated list of source sensor names; this vector is one to one mapped with the uri-list string sensor-name-list=SensorName1,SensorName2 mode Video-only or Audio-only modes available 0: for video-only 1: for audio-only mode=0 (default) ip-address Set REST API HTTP IP Address string ip-address=localhost (default) port Set REST API HTTP Port number; Note: User may pass 0 to disable REST API Server string port=9000 (default) max-batch-size Set the maximum batch size to be used for nvstreammux; Maximum number of sources to be supported with this instance of nvmultiurisrcbin Integer, 1 to 4,294,967,295 max-batch-size=30 (default)", "keywords": []}, {"id": 2964, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#gst-properties-to-configure-each-instance-of-nvurisrcbin-created-inside-this-bin", "display_name": "Gst Properties to configure each instance of nvurisrcbin created inside this bin", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "gst-properties-to-configure-each-instance-of-nvurisrcbin-created-inside-this-bin", "priority": -1, "content": "Property Meaning Type and Range Example Notes num-extra-surfaces Set extra decoder surfaces; Number of surfaces in addition to minimum decode surfaces given by the decoder Integer, 1 to 4,294,967,295 num-extra-surfaces=1 (default) gpu-id Set GPU Device ID used by nvurisrcbin components like decoder (nvv4l2decoder) and nvvideoconvert Integer, 1 to 4,294,967,295 gpu-id=0 (default) cudadec-memtype Memory type for cuda decoder buffers, Memory type for CUDA decoder buffers. Represented internally by enum CudaDecMemType. 0 (memtype_device): Device 1 (memtype_pinned): Host Pinned 2 (memtype_unified): Unified Integer, 0, 1, or 2 cudadec-memtype=0 (default) drop-frame-interval Interval to drop the frames, e.g. a value of 5 means the decoder outputs every fifth frame, and others are dropped. Integer, 1 to 30 Default: 0, dGPU / Jetson dec-skip-frames Type of frames to skip during decoding. Represented internally by enum SkipFrame. 0 (decode_all): decode all frames 1 (decode_non_ref): skips non-ref frames (Applicable only on Jetson platform) 2 (decode_key): decode key frames Integer, 0, 1, or 2 skip-frames=0 Default: 0 ,dGPU / Jetson select-rtp-protocol Transport Protocol to use for RTP Enum RtpProtocol Default: 0, rtp-multi (0): rtp-multi - UDP + UDP Multicast + TCP (4): rtp-tcp - TCP Only select-rtp-protocol=0 (default) file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with \u2018 file:/ \u2019 boolean file-loop=false (default) rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0=disable timeout Integer, 1 to 4,294,967,295 rtsp-reconnect-interval=10 rtsp-reconnect-attempts Maximum number of times a reconnection is attempted. Setting it to -1 means reconnection will be attempted infinitely. Valid when type of source is 4 and rtsp-reconnect-interval-sec is a non-zero positive value. Integer, &gt;=-1 rtsp-reconnect-attempts=4 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Integer, 1 to 4,294,967,295 latency=100 (default) udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Integer, 1 to 4,294,967,295 udp-buffer-size=524288 (default) smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp (0):smart-rec-disable - Disable Smart Record (1):smart-rec-cloud - Trigger Smart Record through cloud messages only (2):smart-rec-multi - Trigger Smart Record through cloud and local events smart-record=0 (default) smart-rec-dir-path Path of directory to save the recorded file. string Absolute or relative path smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix string Absolute or relative path smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead Integer, 1 to 4,294,967,295 smart-rec-video-cache=0 (default) smart-rec-cache Size of cache in seconds, applies to both audio and video cache Integer, 1 to 4,294,967,295 smart-rec-cache=0 (default) smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp (0): smart-rec-mp4 - MP4 container (1): smart-rec-mkv - MKV container smart-rec-container=0 (default) smart-rec-mode Smart record mode (0):smart-rec-mode-av - Record audio and video if available (1):smart-rec-mode-video - Record video only if available (2):smart-rec-mode-audio - Record audio only if available smart-rec-mode=0 (default) smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Integer, 1 to 4,294,967,295 smart-rec-default-duration=20 (default) disable-passthrough To disable the passhthrough mode of nvvideoconvert used inside the nvurisrcbin boolean disable-passhtorugh=false(default) drop-pipeline-eos Boolean property so that EOS is not propagated downstream when all source pads are at EOS. boolean drop-pipeline-eos=false(default) async-handling Boolean property so that will handle Asynchronous state changes boolean async-handling=true(default) disable-audio Disable audio path mode at init time boolean disable-audio=true(default) ipc-buffer-timestamp-copy Copy buffer timestamp for nvunixfdsrc plugin boolean ipc-buffer-timestamp-copy=false(default) ipc-connection-attempts Max number of attempts for connection (-1 = unlimited) Integer. Range: -1 - 2147483647 Default: -1 ipc-connection-attempts=-1(default) ipc-connection-interval connection interval between connection attempts in micro seconds Unsigned Integer64. Range: 0 - 18446744073709551615 ipc-connection-interval=1000000(default) ipc-socket-path The path to the control socket used to control the shared memory transport. This may be modified during the NULL-&gt;READY transition String ipc-socket-path=null(default) low-latency-mode Set low latency mode for bitstreams having I and IPPP frames on decoder boolean low-latency-mode=false(default) message-forward Forwards all children messages boolean message-forward=false(default)", "keywords": []}, {"id": 2965, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#gst-properties-to-configure-the-instance-of-nvstreammux-created-inside-this-bin", "display_name": "Gst Properties to configure the instance of nvstreammux created inside this bin", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "gst-properties-to-configure-the-instance-of-nvstreammux-created-inside-this-bin", "priority": -1, "content": "All properties except \u201cbatch-size\u201d can be configured using the same property names as defined for nvstreammux here .", "keywords": []}, {"id": 2966, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#how-to-use-nvmultiurisrcbin-in-a-pipeline", "display_name": "3. How to use nvmultiurisrcbin in a pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "how-to-use-nvmultiurisrcbin-in-a-pipeline", "priority": -1, "content": "Below pipeline is a sample gstreamer pipeline which is configured to accept upto 10 input sources and the pipline starts up with two sources: gst-launch-1.0 nvmultiurisrcbin \\ port=9000 ip-address=localhost \\ batched-push-timeout=33333 max-batch-size=10 \\ drop-pipeline-eos=1 live-source=1 \\ uri-list=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4,file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 width=1920 height=1080 \\ ! nvmultistreamtiler ! nveglglessink Below diagram illustrates a similar pipeline (with different plugins like nvinfer, nvmsgconv, and nvmsgbroker downstream).", "keywords": []}, {"id": 2967, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#introduction", "display_name": "1. Introduction", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "introduction", "priority": -1, "content": "This GstBin is a GStreamer source bin. The bin exposes only one source pad that provide batched buffers from an nvstreammux instance. Users can add/remove streams to the bin for batching over the REST APIs defined in the Section REST API Payload definitions . Users can also provide a static list of streams and their sensor IDs to start the pipeline with. This can be done using the Gst properties uri-list and sensor-id-list described below. The nvmultiurisrcbin component output batched buffers from an nvstreammux instance.", "keywords": []}, {"id": 2968, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#limitations", "display_name": "6. Limitations", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "limitations", "priority": -1, "content": "SL Limitations 1 Usage of new nvstreammux for video and audio usecases are not supported at this time and might not work.", "keywords": []}, {"id": 2969, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#nvmultiurisrcbin-config-recommendations-and-notes-on-expected-behavior", "display_name": "nvmultiurisrcbin config recommendations and notes on expected behavior", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "nvmultiurisrcbin-config-recommendations-and-notes-on-expected-behavior", "priority": -1, "content": "SL Expected Behavior and Recommendation 1 nvstreammux, live-source property. live-source=1 live-source need to be turned ON to allow batching of available buffers when number of sources is &lt; max-batch-size configuration. 2 REST API stream/add or stream/remove payload value of the change key must contain substring add or remove respectively. Expected Behavior: If \u2018add\u2019 is in the change field value, the sensorId and uri will be used to create a new stream. If \u2018remove\u2019 is in the change field value, the sensorId and uri will be used to find and remove the matching running stream. 3 Boolean property to inform muxer to skip sending EOS downstream is recommended to be set to 1. When using nvmultiurisrcbin drop-pipeline-eos=1 is preferred default to allow pipeline to stay alive for new sensor add requests after the last added sensor EOS. drop-pipeline-eos=1 4 nvstreammux, max-batch-size property. The value set signgifies the maximum number of streams that can be added at a given instance. Once the streams are removed or EOS is reached, the pad id would be reused", "keywords": []}, {"id": 2970, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#remove-a-new-stream-to-a-deepstream-pipeline", "display_name": "REMOVE a new stream to a DeepStream pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "remove-a-new-stream-to-a-deepstream-pipeline", "priority": -1, "content": "Payload definition and the sample curl command: curl -XPOST &#x27;http://localhost:9000/api/v1/stream/remove&#x27; -d &#x27;{ &quot;key&quot;: &quot;sensor&quot;, &quot;value&quot;: { &quot;camera_id&quot;: &quot;uniqueSensorID1&quot;, &quot;camera_name&quot;: &quot;front_door&quot;, &quot;camera_url&quot;: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;, &quot;change&quot;: &quot;camera_remove&quot;, &quot;metadata&quot;: { &quot;resolution&quot;: &quot;1920 x1080&quot;, &quot;codec&quot;: &quot;h264&quot;, &quot;framerate&quot;: 30 } }, &quot;headers&quot;: { &quot;source&quot;: &quot;vst&quot;, &quot;created_at&quot;: &quot;2021-06-01T14:34:13.417Z&quot; } }&#x27;", "keywords": []}, {"id": 2971, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvmultiurisrcbin#rest-api-payload-definitions-and-sample-curl-commands-for-reference", "display_name": "REST API payload definitions and sample curl commands for reference", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "rest-api-payload-definitions-and-sample-curl-commands-for-reference", "priority": -1, "content": "Note: Currently only few fields from the JSON schema described below are used/mandatory. The remaining fields are optional and ignored. List of mandatory (and used) fields are: value/camera_id value/camera_url value/change", "keywords": []}, {"id": 2972, "doc_id": 2972, "filename": "text/DS_plugin_gst-nvmultiurisrcbin.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvmultiurisrcbin", "display_name": "Gst-nvmultiurisrcbin", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvmultiurisrcbin", "anchor": "", "priority": -1, "content": "The DeepStream 6.2 onwards support nvmultiurisrcbin with REST API support for dynamic sensor add/remove capability. This bin integrates three major DeepStream components viz. nvds_rest_server , nvurisrcbin, and nvstreammux ( Gst-nvstreammux ) into a single GstBin. For more details on nvurisrcbin , please run gst-inspect-1.0 nvurisrcbin on a machine/docker container with DeepStream installed. The bin allows users to create simple gstreamer pipelines for AI multimedia analytics. Users can add or remove sensors over REST API calls made to a HTTP endpoint. A sensor is defined as a streaming entity with a valid unique Sensor ID, and URI. The below High Level Overview diagram and table illustrate how nvmultiurisrcbin integrates nvds_rest_server, nvurisrcbin, and nvstreammux. Component Name Source path in DeepStreamSDK Package for more info REST API Server; nvds_rest_server /opt/nvidia/deepstream/deepstream/sources/libs/nvds_rest_server/ Bin Manipulation API Library /opt/nvidia/deepstream/deepstream/sources/libs/gstnvdscustomhelper/ nvmultiurisrcbin /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvmultiurisrcbin/ deepstream-test5-app Demonstrating usage of nvmultiurisrcbin with nvmsgconv and nvmsgbroker /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test5/ nvurisrcbin /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvurisrcbin/ nvstreammux Source not available. For more info please run gst-inspect-1.0 nvstreammux", "keywords": []}, {"id": 2973, "doc_id": 2976, "filename": "text/DS_plugin_gst-nvof.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvof#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvof", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Configure GPU selection Sets the gpu ID to be used for optical flow operation (valid only for dGPU platforms) DS 4.0 Configure dumping of optical flow metadata Enables dumping of optical flow output (motion vector data) DS 4.0 Configure preset level Sets the desired preset level DS 4.0 Configure grid size Sets the flow vector block size DS 4.0", "keywords": []}, {"id": 2974, "doc_id": 2976, "filename": "text/DS_plugin_gst-nvof.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvof#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvof", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvof plugin. Property Meaning Type and Range Example Notes gpu-id Device ID of the GPU to be used for decoding (dGPU only). Integer, 0 to 4,294,967,295 gpu-id=0 dump-of-meta Dumps optical flow output into a .bin file. dump-of-meta=1 preset-level Selects a preset level, default preset level is 0 i.e. NV_OF_PERF_LEVEL_FAST Possible values are: 0 (NV_OF_PERF_LEVEL_FAST): high performance, low quality. 1 (NV_OF_PERF_LEVEL_MEDIUM): intermediate performance and quality. 2 (NV_OF_PERF_LEVEL_SLOW): low performance, best quality (valid only for dGPU platforms). Enum, 0 to 2 preset-level=0 grid-size Selects the grid size. The hardware generates flow vectors blockwise, one vector for each block of 4\u00d74 pixels. Currently only the 4x4 grid size is supported. Enum, 0 grid-size=0 pool-size Sets the number of internal motion vector output buffers to be allocated. Integer, 1 to 4,294,967,295 pool-size=7", "keywords": []}, {"id": 2975, "doc_id": 2976, "filename": "text/DS_plugin_gst-nvof.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvof#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvof", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs GStreamer buffer containing NV12 frame(s) Control parameters gpu-id: selects the GPU ID (valid only for dGPU platforms) dump-of-meta: enables dumping of optical flow map vector into a .bin file preset-level: sets the preset level pool-size: sets the pool size grid-size: sets the grid size Outputs GStreamer buffer containing NV12 frame(s) NvDsOpticalFlowMeta metadata", "keywords": []}, {"id": 2976, "doc_id": 2976, "filename": "text/DS_plugin_gst-nvof.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvof", "display_name": "Gst-nvof", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvof", "anchor": "", "priority": -1, "content": "NVIDIA GPUs, starting with the dGPU Turing generation (except TU117 GPU) and Jetson Orin generation, contain a hardware accelerator for computing optical flow. Optical flow vectors are useful in various use cases such as object detection and tracking, video frame rate up-conversion, depth estimation, stitching, and so on. The Gst-nvof plugin collects a pair of NV12 images and passes it to the low-level optical flow library. The low-level library returns a map of flow vectors between the two frames as its output. The map of flow vectors is encapsulated in the NvDsOpticalFlowMeta structure and is added as a user meta with meta_type set to NVDS_OPTICAL_FLOW_META . The user meta is added to the frame_user_meta_list member of NvDsFrameMeta. For guidance on how to access user metadata, see User/Custom Metadata Addition Inside NvDsMatchMeta and Tensor Metadata. Flow vectors are bi-dimensional vector and each component of flow vector is stored using S10.5 in a fixed-point representation of a 16-bit number. Structure NvOFFlowVector is used to store Flow Vector. /** * Holds motion vector information about an element. */ typedef struct _NvOFFlowVector { /** Holds the motion vector X component. */ gshort flowx; /** Holds the motion vector Y component. */ gshort flowy; } NvOFFlowVector; MSB specifies the sign bit, the next 10 bits specify the integer value and the last 5 bits represent the fractional value of the flow vector. HW support only quarter pixel resolution and only the first 2 bits from 5 available fraction bits are used. We can convert the flow vector from fixed-point representation to floating-point using the following formula. NvOFFlowVector output; float32_t flow_vector.x = output.flowx/32.0f; float32_t flow_vector.y = output.flowy/32.0f;", "keywords": []}, {"id": 2977, "doc_id": 2980, "filename": "text/DS_plugin_gst-nvofvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvofvisual#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvofvisual", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Configure GPU selection Sets the GPU ID to be used for optical flow visualization operations (valid only for dGPU platforms) DS 4.0", "keywords": []}, {"id": 2978, "doc_id": 2980, "filename": "text/DS_plugin_gst-nvofvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvofvisual#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvofvisual", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvofvisual plugin. Property Meaning Type and Range Example Notes gpu-id Device ID of the GPU to be used (dGPU only) Integer, 0 to 4,294,967,295 gpu-id=0", "keywords": []}, {"id": 2979, "doc_id": 2980, "filename": "text/DS_plugin_gst-nvofvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvofvisual#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvofvisual", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs GStreamer buffer containing NV12/RGBA frame(s) NvDsOpticalFlowMeta containing the motion vector (MV) data generated by the gst-nvof plugin Control parameters gpu-id, selects the GPU ID Output GStreamer buffer containing RGBA frame(s) RGBA buffer generated by transforming MV data into color-coded RGBA image reference", "keywords": []}, {"id": 2980, "doc_id": 2980, "filename": "text/DS_plugin_gst-nvofvisual.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvofvisual", "display_name": "Gst-nvofvisual", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvofvisual", "anchor": "", "priority": -1, "content": "The Gst-nvofvisual plugin is useful for visualizing motion vector data. The plugin solves the optical flow problem by computing the magnitude and direction of optical flow from a two-channel array of flow vectors. It then visualizes the angle (direction) of flow by hue and the distance (magnitude) of flow by value of Hue Saturation Value (HSV) color representation. The strength of HSV is always set to a maximum of 255 for optimal visibility.", "keywords": []}, {"id": 2981, "doc_id": 2984, "filename": "text/DS_plugin_gst-nvsegvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvsegvisual#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvsegvisual", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Configure GPU selection Sets the GPU ID to be used for segmentation visualization operations (valid only for dGPU platforms) DS 4.0 Configure width Sets width according to the segmentation output size DS 4.0 Configure height Sets height according to the segmentation output size DS 4.0", "keywords": []}, {"id": 2982, "doc_id": 2984, "filename": "text/DS_plugin_gst-nvsegvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvsegvisual#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvsegvisual", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvsegvisual plugin. Property Meaning Type and Range Example and Notes gpu-id Device ID of the GPU to be used for decoding Integer, 0 to 4,294,967,295 gpu-id=0 width Segmentation output width Integer, 0 to 4,294,967,295 width=512 height Segmentation output height Integer, 0 to 4,294,967,295 height=512", "keywords": []}, {"id": 2983, "doc_id": 2984, "filename": "text/DS_plugin_gst-nvsegvisual.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvsegvisual#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvsegvisual", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs GStreamer buffer containing NV12/RGBA frame(s) NvDsInferSegmentationMeta containing class numbers, pixel class map, width, height, etc. generated by Gst-nvinfer. gpu-id: selects the GPU ID width, set according the segmentation output size height, set according the segmentation output size Output This plugin allocates different colors for different classes. For example, the industrial model\u2019s output has only one representing defective areas. Thus, defective areas and background have different colors. The semantic model outputs four classes with four different colors: car, pedestrian, bicycle, and background. This plugin shows only the segmentation output. It does not overlay output on the original NV12 frame.", "keywords": []}, {"id": 2984, "doc_id": 2984, "filename": "text/DS_plugin_gst-nvsegvisual.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvsegvisual", "display_name": "Gst-nvsegvisual", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvsegvisual", "anchor": "", "priority": -1, "content": "The Gst-nvsegvisual plugin visualizes segmentation results. Segmentation is based on image recognition, except that the classifications occur at the pixel level as opposed to the image level as with image recognition. The segmentation output size is generally same as the input size. For more information, see the segmentation training reference at: qubvel/segmentation_models", "keywords": []}, {"id": 2985, "doc_id": 2989, "filename": "text/DS_plugin_gst-nvstreamdemux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreamdemux#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreamdemux", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer (batched) NvDsBatchMeta Other meta Control parameters None Output Gst Buffer (non-batched, single source) Meta related to each Gst Buffer source This plugin can be tested with the following pipelines:", "keywords": []}, {"id": 2986, "doc_id": 2989, "filename": "text/DS_plugin_gst-nvstreamdemux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreamdemux#use-case-1", "display_name": "Use case 1", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreamdemux", "anchor": "use-case-1", "priority": -1, "content": "Two video sources are mux\u2019ed together using nvstreammux. The muxer\u2019s output goes to nvinfer which is configured with batch-size=2 . After nvinfer, we use nvstreamdemux to display the contents of video source 0, and 1 along with inference output for each overlaid using nvdsosd plugin on two separate windows. Pipeline (x86): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/ opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nvdsosd ! nvvideoconvert ! nveglglessink demux.src_1 ! queue ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nvdsosd ! nveglglessink Pipeline (Jetson): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! qtdemux ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nvdsosd ! nvvideoconvert ! nv3dsink demux.src_1 ! queue ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nv3dsink", "keywords": []}, {"id": 2987, "doc_id": 2989, "filename": "text/DS_plugin_gst-nvstreamdemux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreamdemux#use-case-2", "display_name": "Use case 2", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreamdemux", "anchor": "use-case-2", "priority": -1, "content": "Two video sources are mux\u2019ed together using nvstreammux. The muxer\u2019s output goes to nvinfer which is configured with batch-size=2 . After nvinfer, we use nvstreamdemux to write the contents of video source 0 along with inference output overlaid using nvdsosd plugin to a file. The contents of video source 1 post demux is directly displayed on screen using nveglglessink plugin Pipeline (x86): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nvdsosd ! nvvideoconvert ! nvv4l2h264enc ! h264parse ! qtmux ! filesink location=./out.mp4 demux.src_1 ! queue ! nveglglessink Pipeline (Jetson): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! &quot;video/x-raw(memory:NVMM), format=NV12&quot; ! queue ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), format=RGBA&quot; ! nvdsosd ! nvvideoconvert ! nvv4l2h264enc ! h264parse ! qtmux ! filesink location=./out.mp4 demux.src_1 ! queue ! nv3dsink", "keywords": []}, {"id": 2988, "doc_id": 2989, "filename": "text/DS_plugin_gst-nvstreamdemux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreamdemux#use-case-3", "display_name": "Use case 3", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreamdemux", "anchor": "use-case-3", "priority": -1, "content": "Use case 3 demonstrates displaying both streams as it is in two separate windows. Two video sources are mux\u2019ed together using nvstreammux. The muxer\u2019s output goes to nvinfer which is configured with batch-size=2 . After nvinfer, we use nvstreamdemux to display the contents of video source 0, and 1 on two separate windows. Pipeline (x86): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! queue ! nvvideoconvert ! nveglglessink demux.src_1 ! queue ! nveglglessink Pipeline (Jetson): gst-launch-1.0 -e nvstreammux name=mux batch-size=2 width=1920 height=1080 ! nvinfer config-file-path=/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.txt batch-size=2 ! nvstreamdemux name=demux filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.h264 ! h264parse ! nvv4l2decoder ! queue ! mux.sink_1 demux.src_0 ! queue ! nv3dsink demux.src_1 ! queue ! nv3dsink", "keywords": []}, {"id": 2989, "doc_id": 2989, "filename": "text/DS_plugin_gst-nvstreamdemux.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvstreamdemux", "display_name": "Gst-nvstreamdemux", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvstreamdemux", "anchor": "", "priority": -1, "content": "The Gst-nvstreamdemux plugin demuxes batched frames into individual buffers. It creates a separate Gst Buffer for each frame in the batch. It does not copy the video frames. Each Gst Buffer contains a pointer to the corresponding frame in the batch. The plugin pushes the unbatched Gst Buffer objects downstream on the pad corresponding to each frame\u2019s source. The plugin gets this information through the NvDsBatchMeta attached by Gst-nvstreammux. The original buffer timestamps (PTS) of individual frames are also attached back to the Gst Buffer. Since there is no frame copy, the input Gst Buffer is not returned upstream immediately. When all of the non-batched Gst Buffer objects demuxed from an input batched Gst Buffer are returned to the demuxer by the downstream component, the input batched Gst Buffer is returned upstream. The demuxer does not scale the buffer back to the source\u2019s original resolution even if Gst-nvstreammux has scaled the buffers.", "keywords": []}, {"id": 2990, "doc_id": 2994, "filename": "text/DS_plugin_gst-nvstreammux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release Configurable batch size \u2014 DS 2.0 Configurable batching timeout \u2014 DS 2.0 Allows multiple input streams with different resolutions \u2014 DS 2.0 Allows multiple input streams with different frame rates \u2014 DS 2.0 Scales to user-determined resolution in muxer \u2014 DS 2.0 Scales while maintaining aspect ratio with padding \u2014 DS 2.0 Multi-GPU support \u2014 DS 2.0 Input stream DRC support \u2014 DS 3.0 User-configurable CUDA memory type (Pinned/Device/Unified) for output buffers \u2014 DS 3.0 Custom message to inform application of EOS from individual sources \u2014 DS 3.0 Supports adding and deleting run time sinkpads (input sources) and sending custom events to notify downstream components \u2014 DS 3.0 Supports RGBA data handling at output \u2014 DS 3.0", "keywords": []}, {"id": 2991, "doc_id": 2994, "filename": "text/DS_plugin_gst-nvstreammux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux#gst-inspect-is-not-updated-properly-when-switching-between-legacy-and-new-streammux", "display_name": "1. gst-inspect is not updated properly when switching between legacy and new streammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux", "anchor": "gst-inspect-is-not-updated-properly-when-switching-between-legacy-and-new-streammux", "priority": -1, "content": "Delete gstreamer cache present by default in home directory (rm ~/.cache/gstreamer-1.0/registry.x86_64.bin) and rerun gst-inspect on the streammux plugin", "keywords": []}, {"id": 2992, "doc_id": 2994, "filename": "text/DS_plugin_gst-nvstreammux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvstreammux plugin\u2019s Gst properties. Property Meaning Type and Range Example Notes batch-size Maximum number of frames in a batch. Integer, 0 to 4,294,967,295 batch-size=30 batched-push-timeout Timeout in microseconds to wait after the first buffer is available to push the batch even if a complete batch is not formed. Signed integer, -1 to 2,147,483,647 batched-push-timeout= 40000 40 msec width If non-zero, muxer scales input frames to this width. Integer, 0 to 4,294,967,295 width=1280 height If non-zero, muxer scales input frames to this height. Integer, 0 to 4,294,967,295 height=720 enable-padding Maintains aspect ratio by padding with black borders when scaling input frames. Boolean enable-padding=1 gpu-id ID of the GPU on which to allocate device or unified memory to be used for copying or scaling buffers. (dGPU only.) Integer, 0 to 4,294,967,295 gpu-id=1 live-source Indicates to muxer that sources are live, e.g. live feeds like an RTSP or USB camera. Boolean live-source=1 nvbuf-memory-type Type of memory to be allocated. For dGPU: 0 (nvbuf-mem-default): Default memory, cuda-device 1 (nvbuf-mem-cuda-pinned): Pinned/Host CUDA memory 2 (nvbuf-mem-cuda-device) Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For Jetson: 0 (nvbuf-mem-default): Default memory, surface array 4 (nvbuf-mem-surface-array): Surface array memory Integer, 0-4 nvbuf-memory-type=1 num-surfaces-per-frame Maximum number of surfaces per frame Integer, 1-4 num-surfaces-per-frame=4 buffer-pool-size Number of buffers in output buffer pool Integer&lt;=1024 buffer-pool-size=4 attach-sys-ts Attach system timestamp as ntp timestamp, otherwise ntp timestamp calculated from RTCP sender reports boolean attach-sys-ts=TRUE compute-hw Compute engine to use for scaling. 0 - Default 1 - GPU 2 - VIC (Jetson only) Integer, 0-2 compute-hw=1 interpolation-method Set interpolation methods Integer, refer to enum NvBufSurfTransform_Inter in nvbufsurftransform.h for valid values interpolation-method=1 sync-inputs Boolean property to sychronization of input frames using PTS Boolean sync-inputs=1 frame-duration Duration of input frames in milliseconds for use in NTP timestamp correction based on frame rate. If set to 0, frame duration is inferred automatically from PTS values seen at RTP jitter buffer. When there is change in frame duration between the RTP jitter buffer and the nvstreammux, this property can be used to indicate the correct frame rate to the nvstreammux, for e.g. when there is an audiobuffersplit GstElement before nvstreammux in the pipeline. If set to -1 (GST_CLOCK_TIME_NONE), disables frame rate based NTP timestamp correction. (default) Unsigned Integer64, 0 to 18446744073709551615 frame-duration=10 drop-pipeline-eos Boolean property to control EOS propagation downstream from nvstreammux when all the sink pads are at EOS. (Experimental) Boolean drop-pipeline-eos=0(default) for dGPU/Jetson", "keywords": []}, {"id": 2993, "doc_id": 2994, "filename": "text/DS_plugin_gst-nvstreammux.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NV12/RGBA buffers from an arbitrary number of sources Control Parameters batch-size batched-push-timeout width height enable-padding gpu-id (dGPU only) live-source nvbuf-memory-type num-surfaces-per-frame buffer-pool-size attach-sys-ts frame-duration Output NV12/RGBA batched buffer GstNvBatchMeta (meta containing information about individual frames in the batched buffer)", "keywords": []}, {"id": 2994, "doc_id": 2994, "filename": "text/DS_plugin_gst-nvstreammux.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvstreammux", "display_name": "Gst-nvstreammux", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvstreammux", "anchor": "", "priority": -1, "content": "The Gst-nvstreammux plugin forms a batch of frames from multiple input sources. When connecting a source to nvstreammux (the muxer), a new pad must be requested from the muxer using gst_element_get_request_pad() and the pad template sink_%u . For more information, see link_element_to_streammux_sink_pad() in the DeepStream app source code. The muxer forms a batched buffer of batch-size frames. (batch-size is specified using the gst object property.) If the muxer\u2019s output format and input format are the same, the muxer forwards the frames from that source as a part of the muxer\u2019s output batched buffer. The frames are returned to the source when muxer gets back its output buffer. If the resolution is not the same, the muxer scales frames from the input into the batched buffer and then returns the input buffers to the upstream component. The muxer pushes the batch downstream when the batch is filled, or the batch formation timeout batched-pushed-timeout is reached. The timeout starts running when the first buffer for a new batch is collected. The muxer uses a round-robin algorithm to collect frames from the sources. It tries to collect an average of (batch-size/num-source) frames per batch from each source (if all sources are live and their frame rates are all the same). The number varies for each source, though, depending on the sources\u2019 frame rates. The muxer outputs a single resolution (i.e. all frames in the batch have the same resolution). This resolution can be specified using the width and height properties. The muxer scales all input frames to this resolution. The enable-padding property can be set to true to preserve the input aspect ratio while scaling by padding with black bands. For DGPU platforms, the GPU to use for scaling and memory allocations can be specified with the gpu-id property. For each source that needs scaling to the muxer\u2019s output resolution, the muxer creates a buffer pool and allocates four buffers each of size: output width*output height*f Where f is 1.5 for NV12 format, or 4.0 for RGBA . The memory type is determined by the nvbuf-memory-type property. Set the live-source property to true to inform the muxer that the sources are live. In this case the muxer attaches the PTS of the last copied input buffer to the batched Gst Buffer\u2019s PTS. If the property is set to false, the muxer calculates timestamps based on the frame rate of the source which first negotiates capabilities with the muxer. The muxer attaches an NvDsBatchMeta metadata structure to the output batched buffer. This meta contains information about the frames copied into the batch (e.g. source ID of the frame, original resolutions of the input frames, original buffer PTS of the input frames). The source connected to the Sink_N pad will have pad_index  N in NvDsBatchMeta . The muxer supports addition and deletion of sources at run time. When the muxer receives a buffer from a new source, it sends a GST_NVEVENT_PAD_ADDED event. When a muxer sink pad is removed, the muxer sends a GST_NVEVENT_PAD_DELETED event. Both events contain the source ID of the source being added or removed (see sources/includes/gst-nvevent.h ). Downstream elements can reconfigure when they receive these events. Additionally, the muxer also sends a GST_NVEVENT_STREAM_EOS to indicate EOS from the source. The muxer supports calculation of NTP timestamps for source frames. It supports two modes. In the system timestamp mode, the muxer attaches the current system time as NTP timestamp. In the RTCP timestamp mode, the muxer uses RTCP Sender Report to calculate NTP timestamp of the frame when the frame was generated at source. The NTP timestamp is set in ntp_timestamp field of NvDsFrameMeta . The mode can be toggled by setting the attach-sys-ts property. For more details, refer to section NTP Timestamp in DeepStream.", "keywords": []}, {"id": 2995, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#accessing-gstmeta-post-nvstreammux", "display_name": "Accessing GstMeta post nvstreammux.", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "accessing-gstmeta-post-nvstreammux", "priority": -1, "content": "The GstMeta on input GstBuffers at nvstreammux will be copied into output batch buffer\u2019s NvDsBatchMeta. Reference code to dereference the NvDsBatchMeta on nvstreammux source pad with an attached GStreamer probe function or downstream plugin is available below: #include &quot;gstnvdsmeta.h&quot; static GstPadProbeReturn mux_src_side_probe_video (GstPad * pad, GstPadProbeInfo * info, gpointer u_data) { GstBuffer *buf = (GstBuffer *) info-&gt;data; NvDsBatchMeta *batch_meta = gst_buffer_get_nvds_batch_meta (buf); if (batch_meta == nullptr) { /** Every buffer out of nvstreammux will have batch_meta */ return GST_PAD_PROBE_OK; } /** Now make sure NvDsBatchMeta-&gt;NvDsFrameMeta-&gt;user_meta_list * has the user meta with meta_type == NVDS_BUFFER_GST_AS_FRAME_USER_META */ for(GList* nodeFrame = batch_meta-&gt;frame_meta_list; nodeFrame; nodeFrame = g_list_next(nodeFrame)) { NvDsFrameMeta* frame_meta = static_cast&lt;NvDsFrameMeta*&gt;(nodeFrame-&gt;data); //Uncomment below line when using nvstreammux to batch audio buffers //NvDsAudioFrameMeta* frame_meta = static_cast&lt;NvDsAudioFrameMeta*&gt;(nodeFrame-&gt;data); NvDsMetaList* l_user_meta; for (l_user_meta = frame_meta-&gt;frame_user_meta_list; l_user_meta != NULL; l_user_meta = l_user_meta-&gt;next) { NvDsUserMeta* user_meta = (NvDsUserMeta *) (l_user_meta-&gt;data); if(user_meta-&gt;base_meta.meta_type == NVDS_BUFFER_GST_AS_FRAME_USER_META) { /** dereference the empty GstBuffer with GstMeta copied */ GstBuffer* meta_buffer = (GstBuffer*)user_meta-&gt;user_meta_data; gpointer state = NULL; GstMeta *gst_meta = NULL; while ((gst_meta = gst_buffer_iterate_meta (meta_buffer, &amp;state))) { /** * Note to users: Here, your GstMeta will be accessible as gst_meta. */ } } } } return GST_PAD_PROBE_OK; }", "keywords": []}, {"id": 2996, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#adaptive-batching", "display_name": "Adaptive Batching", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "adaptive-batching", "priority": -1, "content": "Does nvstreammux support dynamic batching? This is in the context of use-cases where we don\u2019t know the exact number of inputs initially. Once the pipeline starts, inputs may get connected / disconnected. Solution: Yes, nvstreammux support dynamic batch-size when adaptive-batching=1,[property] group in the mux config-file. When adaptive-batching is enabled, batch-size is equal to the number of source pads on the muxer. By default this is enabled. Refer to Mux Config Properties for more information.", "keywords": []}, {"id": 2997, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#adding-gstmeta-post-nvstreammux", "display_name": "Adding GstMeta post nvstreammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "adding-gstmeta-post-nvstreammux", "priority": -1, "content": "The user could add GstMeta to each source\u2019s batched frame into the NvDsFrameMeta-&gt;user_meta_list corresponding to the source\u2019s frame. Copy all GstMeta into a newly created empty GstBuffer and leverage the API\u2019s available at /opt/nvidia/deepstream/deepstream/sources/includes/gstnvdsmeta.h ( /opt/nvidia/deepstream/deepstream/lib/libnvdsgst_meta.so ) : For video: nvds_copy_gst_meta_to_frame_meta() For audio: nvds_copy_gst_meta_to_audio_frame_meta()", "keywords": []}, {"id": 2998, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#adding-gstmeta-to-buffers-before-nvstreammux", "display_name": "Adding GstMeta to buffers before nvstreammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "adding-gstmeta-to-buffers-before-nvstreammux", "priority": -1, "content": "Users may add probes on nvstreammux sink pads and attach GstMeta to the GstBuffers flowing into nvstreammux. GstMeta attached on the GstBuffer pushed into nvstreammux sink pads will be copied and available: After nvstreamdemux as GstMeta on the demuxed output GstBuffer. After nvstreammux as NvDsUserMeta on the batched GstBuffer\u2019s NvDsBatchMeta-&gt;NvDsFrameMeta-&gt;user_meta_list.", "keywords": []}, {"id": 2999, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#aim", "display_name": "Aim", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "aim", "priority": -1, "content": "nvstreammux provide many knobs to tune the way batching algorithm works. This is essential to support a wide range of applications/use-cases the muxer supports. More documentation is available at Mux Config Properties . Tuning nvstreammux for specific use cases that we work with customers are good learning exercises. Details discussed here include observations, the configs, pipeline changes, etc that worked well for specific use-cases. Users/Contributors - Please feel free to create a New forum Topic with the contribution here .", "keywords": []}, {"id": 3000, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#cascaded-muxing", "display_name": "Cascaded Muxing", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "cascaded-muxing", "priority": -1, "content": "New streammux supports batching of batched buffers or cascaded muxers and appropriate debatching by demuxers for audio/video. Sample Pipelines: mux1(batch-size 2) + mux2(batch-size2) &gt; mux3 (batch-size4) mux1(batch-size 2) &gt; mux1 (batch-size2) &gt; demuxer Following table summarizes important notes for expected nvstreammux configuration for cascaded usecase: S.No Configuration Property Note 1 nvstreammux pad index. mux.sink_%d Note: The user is responsible for maintaining unique pad_indexes across a single pipeline. pad_indexes are assigned by application when requesting sink pads on nvstreammux instances that does raw stream batching. This unique pad_index (which translates into NvDsFrameMeta-&gt;stream_id) is to avoid duplicate pad_indexes and source_ids. 2 Adaptive-batching Note: Adaptive batching (ON by default) need to be turned off for an nvstreammux instance downstream from another instance. This can be done with the nvstreammux config-file-path setting when using multiple nvstreammux instances in series (batching batched buffers). This is because downstream nvstreammux instances does not know how many streams are attached to each of the upstream muxers and we ask user to configure batch-size of the downstream muxer(s) accordingly 3 [property] algorithm-type=1 batch-size=4 overall-max-fps-n=90 overall-max-fps-d=1 overall-min-fps-n=5 overall-min-fps-d=1 max-same-source-frames=1 Adaptive-batching=0 Sample configuration for the nvstreammux instance that is expected to batch already batched buffers Sample pipeline here (with cascaded nvstreammux instances: m1,m2,m3) is: 2 sources -&gt;m1 2 sources -&gt;m2 m1 -&gt; m3 m2 -&gt; m3 m3 -&gt; demux Special nvmessage/EOS Handling Requirement in the application. Only the last nvstreammux instance in the pipeline will send GST_EVENT_EOS. GST_EVENT_EOS from upstream nvstreammux instances will be handled in the downstream nvstreammux instance and will not be forwarded. However, if the application utilize nvmessage EOS from nvstreammux, the application will have to make sure it received this message from all nvstreammux instances before tearing down the pipeline. The nvmessage discussed here is the GST_MESSAGE_ELEMENT event application receive on the bus callback ( API used to parse this message is: gst_nvmessage_is_stream_eos() and gst_nvmessage_parse_stream_eos() ).", "keywords": []}, {"id": 3001, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the plugin. Feature Description Release New streammux with numerous config-keys supported in a separate mux config-file. Introducing new streammux DS 5.0 Buffer TimeStamp Synchronization support Please check sync-inputs and max-latency property documentation DS 6.0 GstMeta and NvDsMeta copy support Supported in both nvstreammux and nvstreamdemux DS 6.1 Batching batched buffers from another nvstreammux instance Cascaded nvstreammux usage in a pipeline DS 6.1 Runtime config-file change Please check config-file-path property documentation DS 6.1 Latency Measurement support for video and audio buffers Supported in both nvstreammux and nvstreamdemux DS 6.1 New nvstreammux do not scale batched buffers to a single resolution. A batch can have buffers from different streams of different resolutions. So with new mux, a single resolution for the batched buffer is invalid and the muxer\u2019s source-pad-caps is not valid either.", "keywords": []}, {"id": 3002, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#gst-inspect-is-not-updated-properly-when-switching-between-legacy-and-new-streammux", "display_name": "gst-inspect is not updated properly when switching between legacy and new streammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "gst-inspect-is-not-updated-properly-when-switching-between-legacy-and-new-streammux", "priority": -1, "content": "Delete gstreamer cache present by default in home directory (rm ~/.cache/gstreamer-1.0/registry.x86_64.bin) and rerun gst-inspect on the streammux plugin.", "keywords": []}, {"id": 3003, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst-nvstreammux plugin\u2019s Gst properties. Property Meaning Type and Range Example Notes batch-size Maximum number of frames in a batch. Integer, 0 to 4,294,967,295 batch-size=30 batched-push-timeout Timeout in microseconds to wait after the first buffer is available to push the batch even if a complete batch is not formed. Signed integer, -1 to 2,147,483,647 batched-push-timeout= 40000 40 msec num-surfaces-per-frame Maximum number of surfaces per frame. Note: This needs to be set &gt; 1 for dewarper usecases; for more info, please check documentation for nvdewarper plugin Integer, 0 to 4,294,967,295 num-surfaces-per-frame=1 (Default) config-file-path Absolute or relative (to DS config-file location) path of configuration file for the Gst-nvstreammux element String config-file-path=config_mux_source30.txt sync-inputs Synchronize Inputs. Boolean property to force timestamp sychronization of input frames. Boolean, 0 or 1 sync-inputs=0 (Default) max-latency The maximum upstream latency in nanoseconds. When sync-inputs=1, buffers coming in after max-latency shall be dropped. Integer, 0 to 4,294,967,295 max-latency=0 (Default) frame-duration Duration of input frames in milliseconds for use in NTP timestamp correction based on frame rate. If set to 0, frame duration is inferred automatically from PTS values seen at RTP jitter buffer. When there is change in frame duration between the RTP jitter buffer and the nvstreammux, this property can be used to indicate the correct frame rate to the nvstreammux, for e.g. when there is an audiobuffersplit GstElement before nvstreammux in the pipeline. If set to -1 (GST_CLOCK_TIME_NONE), disables frame rate based NTP timestamp correction. (default) Unsigned Integer64, 0 to 18446744073709551615 frame-duration=10 drop-pipeline-eos Boolean property to control EOS propagation downstream from nvstreammux when all the sink pads are at EOS. (Experimental) Boolean drop-pipeline-eos=0(default) for dGPU/Jetson Differences between default and new streammux with respect to the GStreamer plugin properties are discussed in the table below: Default nvstreammux Properties New nvstreammux Properties batch-size batch-size num-surfaces-per-frame num-surfaces-per-frame batched-push-timeout batched-push-timeout width N/A; Scaling and color conversion support Deprecated. height N/A; Scaling and color conversion support Deprecated. enable-padding N/A; Scaling and color conversion support Deprecated. gpu-id N/A; Accelerated Scaling and color conversion support Deprecated. live-source Deprecated nvbuf-memory-type N/A buffer-pool-size N/A attach-sys-ts attach-sys-ts N/A config-file-path sync-inputs sync-inputs max-latency max-latency", "keywords": []}, {"id": 3004, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#gstaggregator-plugin-filesink-does-not-write-data-into-the-file", "display_name": "GstAggregator plugin -> filesink does not write data into the file", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "gstaggregator-plugin-filesink-does-not-write-data-into-the-file", "priority": -1, "content": "To troubleshoot this issue, try increasing the GstAggregator based flvumx/qtmux \u201clatency\u201d setting. Try latency=18446744073709551614 - the max value to see if it works and then you could tune for an optimal latency according to the type of media source in use. Also, set environment variable export GST_DEBUG=3 for WARNING logs. Also see, nvstreammux WARNING \u201cLot of buffers are being dropped\u201d .", "keywords": []}, {"id": 3005, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#heterogeneous-batching", "display_name": "Heterogeneous batching", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "heterogeneous-batching", "priority": -1, "content": "New nvstreammux does not transform/scale batched buffers to a single color-format/resolution unlike the default nvstreammux. A batch can have buffers from different streams of different resolutions and formats. So with new mux, a single resolution for this heterogeneous batched buffer is invalid. When we have plugins that could transform the input buffers (example: change resolution or color format of video buffers in the batch) between nvstreammux and nvstreamdemux, we need to add support for heterogenous query handling in this transform plugin for proper stream-wise resolution flow in CAPS. Below is sample implementation for reference: static gboolean gst_&lt;transform_plugin&gt;_query (GstBaseTransform *trans, GstPadDirection direction, GstQuery *query) { GstTransform *filter; filter = GST_TRANSFORM (trans); if (gst_nvquery_is_update_caps(query)) { guint stream_index; const GValue *frame_rate = NULL; GstStructure *str; gst_nvquery_parse_update_caps(query, &amp;stream_index, frame_rate); str = gst_structure_new (&quot;update-caps&quot;, &quot;stream-id&quot;, G_TYPE_UINT, stream_index, &quot;width-val&quot;, G_TYPE_INT, filter-&gt;out_video_info.width, &quot;height-val&quot;, G_TYPE_INT, filter-&gt;out_video_info.height, NULL); if (frame_rate) { gst_structure_set_value (str, &quot;frame-rate&quot;, frame_rate); } return gst_nvquery_update_caps_peer_query(trans-&gt;srcpad, str); } return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;query (trans, direction, query); } Work Around: Without query implementation, it is necessary to add nvvideoconvert + capsfiler before each nvstreammux sink pad (enforcing same resolution and format of all sources connecting to new nvstreammux). This ensure that the heterogeneous nvstreammux batch output have buffers of same caps (resolution and format). Example; video use-case: gst-launch-1.0 \\ uridecodebin ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), width=1920, height=1080, format=NV12&quot; ! m.sink_0 \\ uridecodebin ! nvvideoconvert ! &quot;video/x-raw(memory:NVMM), width=1920, height=1080, format=NV12&quot; ! m.sink_1 \\ nvstreammux name=m batch-size=2 ! fakesink async=0 Where the fixed caps: \u201c1920 X 1080; NV12\u201d ensure every buffer in the batch is transformed to this same caps. Example; audio use-case: gst-launch-1.0 \\ uridecodebin ! audioconvert ! audioresample ! &quot;audio/x-raw, format=S16LE, layout=interleaved, channels=1, rate=48000&quot; ! m.sink_0 \\ uridecodebin ! audioconvert ! audioresample ! &quot;audio/x-raw, format=S16LE, layout=interleaved, channels=1, rate=48000&quot; ! m.sink_1 \\ nvstreammux name=m batch-size=2 ! fakesink async=0 Where the fixed caps: \u201c48kHz; mono S16LE interleaved\u201d ensure every buffer in the batch is transformed to this same caps.", "keywords": []}, {"id": 3006, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#important-tuning-parameters", "display_name": "Important Tuning parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "important-tuning-parameters", "priority": -1, "content": "To ensure smooth streaming experience, configure/tune the below parameters properly. Tuning Use-Case or Mux Config Property used Notes nvstreammux/sync-inputs sync-inputs=1 ensure nvstreammux to queue early buffers. This could be useful in the audio muxer which could be faster than video muxer when reading from files as audio frames are lighter than video frames. nvstreammux/config-file-path min-overall-fps and max-overall-fps need to be properly set. The min-overall-fps shall be set to the highest framerate of all sources. b) max-overall-fps shall be &gt;= min-overall-fps Check Mux Config Properties for more information. nvstreammux/max-latency Please set/tune the latency parameter to a value &gt; than 1/fps of the slowest stream. Applicable only when sync-inputs=1 Inputs with different frame rates Highest frame-rate to be considered for overall-min-fps value. e.g. for 2 inputs with 15fps and 30fps each, overall-min-fps=30 Input with varying frame rate Individual stream\u2019s frame-rate may vary based on network condition. Highest possible to be considered for overall-min-fps value.e.g. For single stream with varying frame-rate of 15fps to 30fps, overall-min-fps=30 Inputs with different bitrates Nvstreammux will not need specific handling for individual stream bitrates. Inputs with different resolutions Please read the section Heterogeneous batching Dynamic addition/removal of input stream This is supported by adaptive-batching. With adaptive-batching=1, the Gst application needs to create/destroy sinkpads dynamically for addition/removal respectively. flvmux/qtmux/latency The latency parameter (Gst-Property on these plugins when used) shall be set/tuned to a value &gt; nvstreammux/max-latency. The recommended value is 2 X nvstreammux/max-latency User could set \u201clatency=18446744073709551614\u201d (max) to avoid tuning for this parameter.", "keywords": []}, {"id": 3007, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs NV12/RGBA buffers from an arbitrary number of sources mono S16LE/F32LE audio buffers from an arbitrary number of sources Control Parameters batch-size config-file-path [config-keys detailed below] num-surfaces-per-frame attach-sys-ts frame-duration Output NV12/RGBA batched video buffer NvBufSurface or batch audio buffer NvBufAudio GstNvBatchMeta (meta containing information about individual frames in the batched buffer)", "keywords": []}, {"id": 3008, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#latency-measurement-api-usage-guide-for-audio", "display_name": "Latency Measurement API Usage guide for audio", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "latency-measurement-api-usage-guide-for-audio", "priority": -1, "content": "For latency measurement of video buffers, please refer to the usage of latency_measurement_buf_prob() probe function in the deepstream reference application implementation at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-app/deepstream_app.c . Assume an audio pipeline viz: 32 X udpsrc ! rtpopusdepay ! opusdecode ! audiobuffersplit output-buffer-duration=1/50 ! queue ! mux.sink_%d nvstreammux name=mux ! queue ! nvdsaudiotemplate ! fakesink You may want to measure latency of each buffer from the moment its decoded until the time it reaches final sink plugin in the pipeline. In this example, the latency from opusdecode source pad (output) to fakesink sink pad (input). To do this, Add a GStreamer buffer probe programmatically on opusdecode source pad following documentation here . Inside the probe, call DeepStream API nvds_add_reference_timestamp_meta() at /opt/nvidia/deepstream/deepstream/sources/includes/nvds_latency_meta.h Pseudocode reference: static GstPadProbeReturn probe_on_audiodecoder_src_pad (GstPad * pad, GstPadProbeInfo * info, gpointer u_data) { GstBuffer *buf = (GstBuffer *) info-&gt;data; /* frame_id/frame_num is passed 0 and ignored here. * Its assigned and available in NvDsFrameMeta by nvstreammux; * Thus not required in this pipeline where nvstreammux is used. */ nvds_add_reference_timestamp_meta(buf, &quot;audiodecoder&quot;, 0); return GST_PAD_PROBE_OK; } Next, add a probe on the sink pad of fakesink following documentation here . Inside this probe, use API nvds_measure_buffer_latency() . Pseudocode reference: static GstPadProbeReturn probe_on_fakesink_sink_pad (GstPad * pad, GstPadProbeInfo * info, gpointer u_data) { GstBuffer *buf = (GstBuffer *) info-&gt;data; GstMapInfo map_info = {0}; gboolean ok = gst_buffer_map(buf, &amp;map_info, GST_MAP_READ); fail_unless(ok == TRUE); NvBufAudio* bufAudio = (NvBufAudio*)map_info.data; NvDsBatchMeta *batch_meta = gst_buffer_get_nvds_batch_meta (buf); fail_unless(batch_meta != nullptr); gst_buffer_unmap(buf, &amp;map_info); if(nvds_enable_latency_measurement) { NvDsFrameLatencyInfo* latency_info = (NvDsFrameLatencyInfo*)g_malloc0(sizeof(NvDsFrameLatencyInfo) * batch_meta-&gt;max_frames_in_batch); int num_sources_in_batch = nvds_measure_buffer_latency(buf, latency_info); for(int i = 0; i &lt; num_sources_in_batch; i++) { /** Following are the details to profile */ g_print(&quot;Source id = %d Frame_num = %d Frame latency = %lf (ms) \\n&quot;, latency_info[i].source_id, latency_info[i].frame_num, latency_info[i].latency); } } return GST_PAD_PROBE_OK; } Latency Measurement relies on NvDsUserMeta that is added to NvDsBatchMeta for every batched buffer post nvstreammux . This metadata and hence latency measurement support is available after an nvstreammux instance until nvstreamdemux instance in the GStreamer pipeline.", "keywords": []}, {"id": 3009, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#metadata-propagation-through-nvstreammux-and-nvstreamdemux", "display_name": "Metadata propagation through nvstreammux and nvstreamdemux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "metadata-propagation-through-nvstreammux-and-nvstreamdemux", "priority": -1, "content": "For NvDsMeta propagation through nvstreammux and sample code, please refer to the deepstream reference application supplied at: /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-gst-metadata-test/ Illustration of GstMeta at Input and Output of nvstreammux: Illustration of how GstMeta and NvDsMeta are copied as NvDsUserMeta on the batched buffer\u2019s NvDsBatchMeta after nvstreammux. The same illustration holds good for the NvDsBatchMeta available on the demuxed GstBuffer after nvstreamdemux. Only difference is that the GstMeta won\u2019t be available as NvDsUserMeta anymore - and will be directly copied on to the demuxed GstBuffer. Illustration of GstMeta at Input and Output of nvstreammux:", "keywords": []}, {"id": 3010, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#mux-config-properties", "display_name": "Mux Config Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "mux-config-properties", "priority": -1, "content": "Details on Streammux config-file groups and keys are summarized the following table. Group config-key Description [property] algorithm-type Defines the batching algorithm; uint 1 : Round-robbin if all sources have same priority key setting. Otherwise higher priority streams will be batched until no more buffers from them. Default: 1 batch-size The desired batch size; uint. This value will override plugin property and DS config file key \u201cbatch-size\u201d for nvstreammux If batch-size not specified in the config-file, plugin property batch-size shall override the default. Default: 1 (or == number of sources if adaptive-batching=1) overall-max-fps-n Numerator of the desired overall muxer output max frame rate fps_n/fps_d; uint Default:120/1 Note: This value needs to be configured to a value &gt;= overall-min-fps even when max-fps-control=0. overall-max-fps-d Denominator of the desired overall muxer output max frame rate fps_n/fps_d; uint overall-min-fps-n Numerator of the desired overall muxer output min frame rate fps_n/fps_d; uint Default: 5/1 overall-min-fps-d Denominator of the desired overall muxer output max frame rate fps_n/fps_d; uint max-same-source-frames Max number of any stream\u2019s frames allowed to be muxed per output batch buffer; uint The minimum of this value and key (max-num-frames-per-batch) will be used. Default: 1 adaptive-batching Enable (1) or disable (0) adaptive batching; uint Default: 1 If enabled, batch-size is == number of sources X num-surfaces-per-frame. max-fps-control Enable (1) or disable (0) controlling the maximum frame-rate at which nvstreammux pushes out batch buffers based on the overall-max-fps-n/d configuration. Default: 0 [source-config-N] max-fps-n Numerator of this source\u2019s max frame rate fps_n/fps_d. Deprecated (shall remove support from next release). Please use overall-max-fps instead; uint Default: 60/1 max-fps-d Denominator of this source\u2019s max frame rate fps_n/fps_d. Deprecated (shall remove support from next release). Please use overall-max-fps instead. ; uint min-fps-n Numerator of this source\u2019s min frame rate fps_n/fps_d. Deprecated (shall remove support from next release). Please use overall-min-fps instead; uint min-fps-d Denominator of this source\u2019s min frame rate fps_n/fps_d. Deprecated (shall remove support from next release). Please use overall-min-fps instead; uint priority The priority of this stream. Deprecated (shall remove support from next release). Please use algorithm-type instead; uint Default: 0 (highest priority) A higher value is a lower priority. max-num-frames-per-batch Max number of this stream\u2019s frames allowed to be muxed per output batch buffer; uint The minimum of this value and key (max-same-source-frames) will be used.", "keywords": []}, {"id": 3011, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#nvstreammux-warning-lot-of-buffers-are-being-dropped", "display_name": "nvstreammux WARNING \u201cLot of buffers are being dropped\u201d", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "nvstreammux-warning-lot-of-buffers-are-being-dropped", "priority": -1, "content": "To troubleshoot this issue, try increasing the max-latency setting to allow late buffers. Also ensure to set min-overall-fps and max-overall-fps with the nvstreammux config file.", "keywords": []}, {"id": 3012, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#observing-video-and-or-audio-stutter-low-framerate", "display_name": "Observing video and/or audio stutter (low framerate)", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "observing-video-and-or-audio-stutter-low-framerate", "priority": -1, "content": "Solution: You\u2019ll need to configure max-latency parameter on nvstreammux when stutters are observed or when pipeline latency is known to be \u201cnon-real-time\u201d.", "keywords": []}, {"id": 3013, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#optimizing-nvstreammux-config-for-low-latency-vs-compute", "display_name": "Optimizing nvstreammux config for low-latency vs Compute", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "optimizing-nvstreammux-config-for-low-latency-vs-compute", "priority": -1, "content": "You may want to design for use-cases where compute resource (GPU) utilization is more important than throughput. On the other hand, there could be use cases where minimum pipeline latency is of utmost importance. The following guidance is intended to help in tuning nvstreammux configuration parameters (passed with config-file-path property on nvstreammux) for optimal resource (compute) utilization and low-pipeline-latency. Recommended Config params are shared in the table below. Optimized config for low-latency (example) Optimized config for compute utilization Pipeline example: 32 X udpsrc ! rtpopus depay ! opusdec ! audiobuffersplit output-buffer-duration=1/50 ! queue ! mux.sink_%d nvstreammux name=mux ! queue ! nvdsaudiotemplate ! fakesink [property] algorithm-type=1 batch-size= 32 max-fps-control=0 overall-max-fps-n=50 overall-max-fps-d=1 overall-min-fps-n=50 overall-min-fps-d=1 max-same-source-frames= 2 \u201cPipeline example: 32 X udpsrc ! rtpopus depay ! opusdec ! audiobuffersplit output-buffer-duration=1/50 ! queue ! mux.sink_%d nvstreammux name=mux ! queue ! nvdsaudiotemplate ! Fakesink [property] algorithm-type=1 batch-size= 32 max-fps-control=0 overall-max-fps-n=50 overall-max-fps-d=1 overall-min-fps-n= 40 overall-min-fps-d=1 max-same-source-frames= 1 Partial batches possible in this configuration. Partial batch is when the batched buffer have less number of buffers than the configured batch-size. (batchBuffer-&gt;numFilled &lt; batchBuffer-&gt;batchSize) Configured to create fully formed batch buffers. Full batch is when the batched buffer have configured batch-size number of buffers batched. (batchBuffer-&gt;numFilled == batchBuffer-&gt;batchSize) CPU load may be higher (as we operate nvstreammux batching algorithm at a higher overall framerate). \u201cCPU load optimized for the rate at which input streams into nvstreammux plugin.\u201d Note 1: Here, exact overall-max/min-fps configuration matching input framerate from audiobuffersplit ensure minimum latency inside nvstreammux plugin to create batches. Note 2: For this reason, if input throughput falls occasionally (possible), Output batch buffer from nvstreammux will still be created at the configured min-fps. However the batch will be partial (batchBuffer-&gt;numFilled could be less than batchBuffer-&gt;batchSize). Note 1: Here, user could use overall-min-fps less than the input framerate from audiobuffersplit. This way, even if input sources (especially when streamed over network) fall short in framerate, nvstreammux still gets more time to create full-batch (batchBuffer-&gt;numFilled == batchBuffer-&gt;batchSize). Note 3: Users are encouraged to use max-same-source-frames &gt; 1 when input is from the network to control jitter and allow nvstreammux to batch multiple frames from one source when others may fall short during jitter. Note 4: User may have to confirm the behavior of plugins that consume batches with max-same-source-frames &gt; 1. Example: Certain plugins could introduce additional latency. In such cases, user may configure max-same-source-frames=1. Note 2: max-same-source-frames=1 is a good config.max-same-source-frames &gt; 1 can still be used to lower the impact of jitter with network sources. A sample pipeline diagram below illustrates the use of common OSS components in an audio pipeline use case for reference, like: udpsrc audiodecoder audiobuffersplit udpsink And NVIDIA components like nvstreammux, nvdsaudiotemplate.", "keywords": []}, {"id": 3014, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#sink-plugin-shall-not-move-asynchronously-to-paused", "display_name": "Sink plugin shall not move asynchronously to PAUSED", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "sink-plugin-shall-not-move-asynchronously-to-paused", "priority": -1, "content": "Solution: When using new nvstreammux in a GStreamer pipeline, it is recommended that the sink elements shall be configured to set the plugin property async to false . Based on how Application is designed async=1 can cause a hang. Below is the way in which users may use async=1 Sample pipeline diagram (for n sources): BIN_BEFORE_MUX X n -&gt; nvstreammux -&gt; nvstreamdemux -&gt; BIN_AFTER_DEMUX X n BIN_BEFORE_MUX is [audiosource] BIN_AFTER_MUX is [fakesink] However this was needed because of the way app is designed. Sample pipeline/app Design recommended: Add stream and remove stream operations shall be mutually exclusive. Add stream algorithm/steps: create bin_before_muxer and bin_after_demuxer add it to pipeline move it to PLAYING. WAIT for the state change to happen Remove stream algorithm/steps: move bins before mux and after demux to STATE_NULL. WAIT for state change to happen remove bin_before_muxer and bin_after_demuxer from pipeline. sink plugin async=1 cause the step (1).(d) to block if app is not supplying buffers needed by sink element to PREROLL. To fix this, async=0 on sink plugin is required. Users may set async=1 with the app design being able to supply buffers between (1).(c) and (1).(d) .", "keywords": []}, {"id": 3015, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#to-access-nvdsmeta-after-nvstreamdemux-src-pad", "display_name": "To access NvDsMeta after nvstreamdemux.src_pad", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "to-access-nvdsmeta-after-nvstreamdemux-src-pad", "priority": -1, "content": "Reference code to access NvDsMeta after nvstreamdemux.src_pad with an attached GStreamer probe function or downstream plugin is available below: static GstPadProbeReturn demux_src_side_probe_audio (GstPad * pad, GstPadProbeInfo * info, gpointer u_data) { GstBuffer *buf = (GstBuffer *) info-&gt;data; GstMeta* gst_meta = nullptr; bool got_NVDS_BUFFER_GST_AS_FRAME_USER_META = false; bool got_NVDS_DECODER_GST_META_EXAMPLE = false; NvDsBatchMeta *batch_meta = gst_buffer_get_nvds_batch_meta (buf); fail_unless(batch_meta != nullptr); /** Now make sure every NvDsBatchMeta-&gt;NvDsFrameMeta-&gt;user_meta_list * has the GST_META user meta */ for(GList* nodeFrame = batch_meta-&gt;frame_meta_list; nodeFrame; nodeFrame = g_list_next(nodeFrame)) { NvDsAudioFrameMeta* frame_meta = static_cast&lt;NvDsAudioFrameMeta*&gt;(nodeFrame-&gt;data); NvDsMetaList* l_user_meta; for (l_user_meta = frame_meta-&gt;frame_user_meta_list; l_user_meta != NULL; l_user_meta = l_user_meta-&gt;next) { NvDsUserMeta* user_meta = (NvDsUserMeta *) (l_user_meta-&gt;data); if(user_meta-&gt;base_meta.meta_type == NVDS_BUFFER_GST_AS_FRAME_USER_META) { got_NVDS_BUFFER_GST_AS_FRAME_USER_META = true; g_print(&quot;got NVDS_BUFFER_GST_AS_FRAME_USER_META\\n&quot;); } } } /** We expect gstMeta in both user_meta and directly * as GST_META on the buffer */ gpointer state = NULL; /** make sure Gst Meta is copied on demux output buffer */ while ((gst_meta = gst_buffer_iterate_meta (buf, &amp;state))) { /*Note to users: Here, your GstMeta will be accessible as gst_meta*/ } return GST_PAD_PROBE_OK; }", "keywords": []}, {"id": 3016, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#video-and-audio-muxing-file-sources-of-different-fps", "display_name": "Video and Audio muxing - file sources of different fps", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "video-and-audio-muxing-file-sources-of-different-fps", "priority": -1, "content": "In a single pipeline, we could have file sources with different video framerate, but same audio framerate (typical for most camera footages with reduced video framerate to save bandwidth while keeping the less heavy audio sampling rate intact). In this scenario, video buffers might get mux\u2019d slower than audio buffers. When this happens GstAggregator based flvmux or qtmux could block the pipeline when the difference between video and audio buffer-timestamps are higher than the set \u201clatency\u201d parameter. When dealing with file sources/ live sources of different framerates, we need nvstreammux tuned for min-overall-fps. Without this, the muxing always happens at the slowest stream\u2019s framerate adding latency to the video buffers. When dealing with file sources of different frame rates and RTMP sources of different framerates, we recommend users to turn on sync-inputs=1 on nvstreammux and tune proper max-latency to ensure video and audio buffers from a single source are regulated and are flowing together in the pipeline after streammux. This is essential for the proper working of GstAggregator based muxers like flvmux, qtmux. etc. To ensure smooth streaming experience, configure/tune the parameters discussed in Section Important Tuning parameters properly.", "keywords": []}, {"id": 3017, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#video-and-audio-muxing-rtmp-rtsp-sources", "display_name": "Video and Audio muxing - RTMP/RTSP sources", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "video-and-audio-muxing-rtmp-rtsp-sources", "priority": -1, "content": "When using live sources: make sure that nvstreammux/sync-inputs is set to 1 When using RTMP sources, in-built upstream latency query does not work. So you\u2019ll need to provide/tune a non-zero nvstreammux/max-latency setting. Tune for nvstreammux/max-latency and other parameters as discussed in Section Important Tuning parameters .", "keywords": []}, {"id": 3018, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvstreammux2#video-and-audio-muxing-use-cases", "display_name": "Video and Audio muxing Use cases", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "video-and-audio-muxing-use-cases", "priority": -1, "content": "When nvstreammux is fed streams with different frame-rates, tuning is necessary to ensure standard muxer behavior. A sample pipeline diagram below illustrates the use of common components like nvstreammux, nvstreamdemux, flv or qtmux, etc., in a video and audio muxing use case for reference. When the same pipeline includes two nvstreammux modules to mux video and audio from different sources of different video framerate, depending on the type of sources, behavior could differ. Some of the scenarios and recommended tuning guidance are discussed below.", "keywords": []}, {"id": 3019, "doc_id": 3019, "filename": "text/DS_plugin_gst-nvstreammux2.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvstreammux2", "display_name": "Gst-nvstreammux New", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvstreammux2", "anchor": "", "priority": -1, "content": "The Gst-nvstreammux plugin forms a batch of frames from multiple input sources. When connecting a source to nvstreammux (the muxer), a new pad must be requested from the muxer using gst_element_get_request_pad() and the pad template sink_%u . For more information, see link_element_to_streammux_sink_pad() in the DeepStream app source code. The muxer forms a batched buffer of batch-size frames. (batch-size is specified using the gst object property.) The muxer forwards the frames from that source as a part of the muxer\u2019s output batched buffer. The frames are returned to the source when muxer gets back its output buffer. The muxer pushes the batch downstream when the batch is filled or the batch formation timeout calculated from the overall and stream specific \u201cfps\u201d control configuration keys in provided streammux config file is reached. The timeout starts running when the first buffer for a new batch is collected. The default overall max and min fps for batch generation are 120 and 5 respectively. The muxer\u2019s default batching uses a round-robin algorithm to collect frames from the sources. It tries to collect an average of ( batch-size/num-source ) frames per batch from each source (if all sources are live and their frame rates are all the same). The number varies for each source, though, depending on the sources\u2019 frame rates. The muxer attaches an NvDsBatchMeta metadata structure to the output batched buffer. This meta contains information about the frames copied into the batch (e.g. source ID of the frame, original resolutions of the input frames, original buffer PTS of the input frames). The source connected to the Sink_N pad will have pad_index  N in NvDsBatchMeta . The muxer supports addition and deletion of sources at run time. When the muxer receives a buffer from a new source, it sends a GST_NVEVENT_PAD_ADDED event. When a muxer sink pad is removed, the muxer sends a GST_NVEVENT_PAD_DELETED event. Both events contain the source ID of the source being added or removed (see sources/includes/gst-nvevent.h ). Downstream elements can reconfigure when they receive these events. Additionally, the muxer also sends a GST_NVEVENT_STREAM_EOS to indicate EOS from the source. The muxer supports calculation of NTP timestamps for source frames. It supports two modes. In the system timestamp mode, the muxer attaches the current system time as NTP timestamp. In the RTCP timestamp mode, the muxer uses RTCP Sender Report to calculate NTP timestamp of the frame when the frame was generated at source. The NTP timestamp is set in ntp_timestamp field of NvDsFrameMeta . The mode can be toggled by setting the attach-sys-ts property. For more details, refer to NTP Timestamp in DeepStream . The current nvsteammux shall be employed by default. Users will be able to use the new nvstreammux by setting the environment variable export USE_NEW_NVSTREAMMUX=yes . New nvstreammux is no longer a beta feature. In upcoming DeepStream releases, usage of this environment variable and current nvstreammux will be deprecated to load new nvstreammux by default.", "keywords": []}, {"id": 3020, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#bounding-box-unclipping", "display_name": "Bounding-box Unclipping", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "bounding-box-unclipping", "priority": -1, "content": "Another small experimental feature is the bounding box unclipping. If a target is fully visible within the field-of-view (FOV) of the camera but starts going out of the FOV, the target would be partially visible and the bounding box (i.e., bbox ) may capture only a part of the target (i.e., clipped by the FOV) until it fully exits the scene. If it is expected that the size of the bbox doesn\u2019t change much around the border of the video frame, the full bbox can be estimated beyond the FOV limit using the bbox size estimated when the target was fully visible. This feature can be enabled by setting enableBboxUnClipping: 1 under TargetManagement module in the low-level config file.", "keywords": []}, {"id": 3021, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#configuration-parameters", "display_name": "Configuration Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "configuration-parameters", "priority": -1, "content": "The following table summarizes the configuration parameters for the common modules in the NvMultiObjectTracker low-level tracker library. Module Property Meaning Type and Range Default value Base Config minDetectorConfidence Minimum detector confidence for a valid object Float, -inf to inf minDetectorConfidence: 0.0 Target Management preserveStreamUpdateOrder Whether to ensure target ID update order the same as input stream ID order Boolean preserveStreamUpdateOrder: 0 maxTargetsPerStream Max number of targets to track per stream Integer, 0 to 65535 maxTargetsPerStream: 30 minIouDiff4NewTarget Min IOU to existing targets for discarding new target Float, 0 to 1 minIouDiff4NewTarget: 0.5 enableBboxUnClipping Enable bounding-box unclipping Boolean enableBboxUnClipping: 0 probationAge Length of probationary period in #of frames Integer, \u22650 probationAge: 5 maxShadowTrackingAge Maximum length of shadow tracking Integer, \u22650 maxShadowTrackingAge: 38 earlyTerminationAge Early termination age Integer, \u22650 earlyTerminationAge: 2 outputTerminatedTracks Output total frame history for terminated tracks to the tracker plugin for downstream usage Boolean outputTerminatedTracks: 0 outputShadowTracks Output shadow track state information to the tracker plugin for downstream usage Boolean outputShadowTracks: 0 terminatedTrackFilename File name prefix to save terminated tracks String terminatedTrackFilename: \u201c\u201d Trajectory Management useUniqueID Enable unique ID generation scheme Boolean useUniqueID: 0 enableReAssoc Enable motion-based target re-association Boolean enableReAssoc: 0 minMatchingScore4Overall Min total score for re-association Float, 0.0 to 1.0 minMatchingScore4Overall: 0.4 minTrackletMatchingScore Min tracklet similarity score for matching in terms of average IOU between tracklets Float, 0.0 to 1.0 minTrackletMatchingScore: 0.4 minMatchingScore4ReidSimilarity Min ReID score for re-association Float, 0.0 to 1.0 minMatchingScore4ReidSimilarity: 0.8 matchingScoreWeight4TrackletSimilarity Weight for tracklet similarity term in re-assoc cost function Float, 0.0 to 1.0 matchingScoreWeight4TrackletSimilarity: 1.0 matchingScoreWeight4ReidSimilarity Weight for ReID similarity term in re-assoc cost function Float, 0.0 to 1.0 matchingScoreWeight4ReidSimilarity: 0.0 minTrajectoryLength4Projection Min tracklet length of a target (i.e., age) to perform trajectory projection [frames] Integer, &gt;=0 minTrajectoryLength4Projection: 20 prepLength4TrajectoryProjection Length of the trajectory during which the state estimator is updated to make projections [frames] Integer, &gt;=0 prepLength4TrajectoryProjection: 10 trajectoryProjectionLength Length of the projected trajectory [frames] Integer, &gt;=0 trajectoryProjectionLength: 90 maxAngle4TrackletMatching Max angle difference for tracklet matching [degree] Integer, [0, 180] maxAngle4TrackletMatching: 40 minSpeedSimilarity4TrackletMatching Min speed similarity for tracklet matching Float, 0.0 to 1.0 minSpeedSimilarity4TrackletMatching: 0.3 minBboxSizeSimilarity4TrackletMatching Min bbox size similarity for tracklet matching Float, 0.0 to 1.0 minBboxSizeSimilarity4TrackletMatching: 0.6 maxTrackletMatchingTimeSearchRange Search space in time for max tracklet similarity Integer, &gt;=0 maxTrackletMatchingTimeSearchRange: 20 trajectoryProjectionProcessNoiseScale Trajectory state estimator\u2019s process noise scale Float, 0.0 to inf trajectoryProjectionProcessNoiseScale: 1.0 trajectoryProjectionMeasurement NoiseScale Trajectory state estimator\u2019s measurement noise scale Float, 0.0 to inf trajectoryProjectionMeasurement NoiseScale: 1.0 trackletSpacialSearchRegionScale Re-association peer tracklet search region scale Float, 0.0 to inf trackletSpacialSearchRegionScale: 0.0 reidExtractionInterval Frame interval to extract ReID features per target for re-association; -1 means only extracting the beginning frame per target Integer, \u2265-1 reidExtractionInterval: 0 Data Associator associationMatcherType Type of matching algorithm { GREEDY=0, CASCADED=1 } Integer, [0, 1] associationMatcherType: 0 checkClassMatch Enable associating only the same-class objects Boolean minMatchingScore4Overall Min total score for valid matching Float, 0.0 to 1.0 minMatchingScore4Overall: 0.0 minMatchingScore4SizeSimilarity Min bbox size similarity score for valid matching Float, 0.0 to 1.0 minMatchingScore4SizeSimilarity: 0.0 minMatchingScore4Iou Min IOU score for valid matching Float, 0.0 to 1.0 minMatchingScore4Iou: 0.0 matchingScoreWeight4SizeSimilarity Weight for size similarity term in matching cost function Float, 0.0 to 1.0 matchingScoreWeight4SizeSimilarity: 0.0 matchingScoreWeight4Iou Weight for IOU term in matching cost function Float, 0.0 to 1.0 matchingScoreWeight4Iou: 1.0 tentativeDetectorConfidence If a detection\u2019s confidence is lower than this but higher than minDetectorConfidence, then it\u2019s considered as a tentative detection Float, 0.0 to 1.0 tentativeDetectorConfidence: 0.5 minMatchingScore4TentativeIou Min iou threshold to match targets and tentative detection Float, 0.0 to 1.0 minMatchingScore4TentativeIou: 0.0 State Estimator stateEstimatorType Type of state estimator among { DUMMY=0, SIMPLE=1, REGULAR=2, SIMPLE_LOC=3 } Integer, [0,3] stateEstimatorType: 0 processNoiseVar4Loc Process noise variance for bbox center Float, 0.0 to inf processNoiseVar4Loc: 2.0 processNoiseVar4Size Process noise variance for bbox size Float, 0.0 to inf processNoiseVar4Size: 1.0 processNoiseVar4Vel Process noise variance for velocity Float, 0.0 to inf processNoiseVar4Vel: 0.1 measurementNoiseVar4Detector Measurement noise variance for detector\u2019s detection Float, 0.0 to inf measurementNoiseVar4Detector: 4.0 measurementNoiseVar4Tracker Measurement noise variance for tracker\u2019s localization Float, 0.0 to inf measurementNoiseVar4Tracker: 16.0 noiseWeightVar4Loc Noise covariance weight for bbox location; if set, location noise will be proportional to box height Float, &gt;0.0 considered as set noiseWeightVar4Loc: -0.1 noiseWeightVar4Vel Noise covariance weight for bbox velocity; if set, location noise will be proportional to box height Float, &gt;0.0 considered as set noiseWeightVar4Vel: -0.1 useAspectRatio Use aspect ratio in Kalman Filter\u2019s states Boolean useAspectRatio: 0 Object Re-ID reidType The type of Re-ID network among { DUMMY=0, NvDEEPSORT=1, Reid based reassoc=2, both NvDEEPSORT and reid based reassoc=3 } Integer, [0, 3] reidType: 0 batchSize Batch size of Re-ID network Integer, &gt;0 batchSize: 1 workspaceSize Workspace size to be used by Re-ID TensorRT engine, in MB Integer, &gt;0 workspaceSize: 20 reidFeatureSize Size of Re-ID feature Integer, &gt;0 reidFeatureSize: 128 reidHistorySize Size of feature gallery, i.e. max number of Re-ID features kept for one tracker Integer, &gt;0 reidHistorySize: 100 inferDims Re-ID network input dimension CHW or HWC based on inputOrder Integer, &gt;0 inferDims: [128, 64, 3] inputOrder Re-ID network input order {NCHW=0, NHWC=1} Integer, [0, 1] inputOrder: 1 colorFormat Re-ID network input color format among {RGB=0, BGR=1 } Integer, [0, 1] colorFormat: 0 networkMode Re-ID network inference precision mode among {FP32=0, FP16=1, INT8=2 } Integer, [0, 1, 2] networkMode: 0 offsets Array of values to be subtracted from each input channel, with length equal to number of channels Comma delimited float array offsets: [0.0, 0.0, 0.0] netScaleFactor Scaling factor for Re-ID network input after substracting offsets Float, &gt;0 netScaleFactor: 1.0 addFeatureNormalization If Re-ID network\u2019s output Re-ID feature vector is not l2 normalized, explicitly performs l2 normalization Boolean addFeatureNormalization: 0 tltEncodedModel Pathname of the TAO toolkit encoded model String tltEncodedModel: \u201c\u201d tltModelKey Key for the TAO toolkit encoded model String tltModelKey: \u201c\u201d onnxFile Pathname of the ONNX model file String onnxFile: \u201c\u201d modelEngineFile Absolute path to Re-ID engine file String modelEngineFile:\u201d\u201d calibrationTableFile Absolute path to calibration table, required by INT8 only String calibrationTableFile:\u201d\u201d keepAspc Whether to keep aspcect ratio when resizing input objects to Re-ID network Boolean keepAspc: 1 outputReidTensor Output Re-ID features to user meta for downstream usage Boolean outputReidTensor: 0 useVPICropScaler (Alpha feature) Use NVIDIA\u2019s VPI\u2122 Crop Scaler algorithm instead of built in implementation Boolean useVPICropScaler: 0 Object Model Projection cameraModelFilepath A list of file paths to camera info files. A valid camera info file should be provided to each video stream String cameraModelFilepath: \u201c\u201d outputVisibility Output object visibility to object meta and file dump Boolean outputVisibility: 0 outputFootLocation Output object (especially for human) foot location to object meta and file dump Boolean outputFootLocation: 0 outputConvexHull Output projected object convex hull (especially cylinder for human) to object meta and file dump Boolean outputConvexHull: 1 maxConvexHullSize Maximum number of points to consist an object convex hull Integer, &gt;0 maxConvexHullSize: 15", "keywords": []}, {"id": 3022, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#customize-re-id-model", "display_name": "Customize Re-ID Model", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "customize-re-id-model", "priority": -1, "content": "Users can also train a custom Re-ID model in ONNX format, whose output is a single vector for each object. Then the Re-ID similarity score will be computed based on the cosine metric and used to perform the data association in the same way as the official model. The steps are: Train a Re-ID network using deep learning frameworks such as PyTorch or TensorFlow. Make sure the network layers are supported by TensorRT and convert the model into ONNX. Mixed precision inference is still supported, and a calibration cache is required for INT8 mode. Specify the following parameters in tracker config file based on the custom model\u2019s properties. Then run DeepStream SDK with the new Re-ID model. reidFeatureSize reidHistorySize inferDims colorFormat networkMode offsets netScaleFactor addFeatureNormalization ONNX model must specify below parameters. onnxFile", "keywords": []}, {"id": 3023, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#data-association", "display_name": "Data Association", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "data-association", "priority": -1, "content": "For data association, various types of similarity metrics are used to calculate the matching score between the detector objects and the existing targets, including: Location similarity (i.e., proximity) Bounding box size similarity Re-ID feature similarity (specific to NvDeepSORT tracker) Visual appearance similarity (specific to NvDCF tracker) For the proximity between detector objects and targets, IOU is a typical metric that is widely used, but it also depends on the size similarity between them. The similarity of the box size between two objects can be used explicitly, which is calculated as the ratio of the size of the smaller box over the larger one. The total association score for a pair of detector object and target is the weighted sum of all the metrics: totalScore=w_1*IOU+w_2*sizeSimilarity+w_3*reidSimilarity+w_4*visualSimilarity where w_i is the weight for each metric set in config file. Users can also set a minimum threshold for each similarity and the total score. During the matching, a detector object is associated with a target that belongs to the same class by default to minimize the false matching. However, this can be disabled by setting checkClassMatch: 0 , allowing objects can be associated regardless of their object class IDs. This can be useful when employing a detector like YOLO, which can detect many classes of objects, where there could be false classification on the same object over time. Regarding the matching algorithm, users can set associationMatcherType as 0 to employ an efficient greedy algorithm for optimal bipartite matching with similarity metrics defined above, or 1 for a newly introduced method named cascaded data association for higher accuracy. The cascaded data association consists of multi-stage matching, assigning different priorities and similarity metrics based on detection and target confidence. Detector objects are split into two sets, confirmed (confidence between [ tentativeDetectorConfidence , 1.0]) and tentative (confidence between [ minDetectorConfidence , tentativeDetectorConfidence ]). Then three stage matching are performed sequentially: Confirmed detections and validated (both active and inactive) targets Tentative detections and active targets left Confirmed detections left and tentative targets The first stage uses the joint-similarity metrics defined above, while the later two stages only considers the IOU similarity, because proximity can be a more reliable metric than visual similarity or Re-ID when the detection confidence is low due to, say, partial occlusions or noise. Each stage takes different sets of bboxes as candidates and uses the efficient greedy algorithm for matching. The matched pairs are produced from each stage and combined together. The output of the data association module consists of three sets of objects/targets: The unmatched detector objects The matched pairs of the detector objects and the existing targets The unmatched targets The unmatched detector objects are among the objects detected by a PGIE detector, yet not associated with any of the existing targets. An unmatched detector object is considered as a newly observed object that needs to be tracked, unless they are determined to be duplicates to any of the existing target. If the maximum IOU score of a new detector object to any of the existing targets is lower than minIouDiff4NewTarget , a new target tracker would be created to track the object since it is not a duplicate to an existing target.", "keywords": []}, {"id": 3024, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvtracker plugin. Property Meaning Type and Range Example Notes tracker-width Frame width at which the tracker is to operate, in pixels. (To be a multiple of 32 when visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0) Integer, 0 to 4,294,967,295 tracker-width=640 tracker-height Frame height at which the tracker is to operate, in pixels. (To be a multiple of 32 when visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0) Integer, 0 to 4,294,967,295 tracker-height=384 ll-lib-file Pathname of the low-level tracker library to be loaded by Gst-nvtracker. String ll-lib-file=\u00ad/opt/nvidia/\u00addeepstream/\u00addeepstream/\u00adlib/libnvds_nvmultiobjecttracker.so ll-config-file Configuration file for the low-level library if needed. (Alpha feature) A list of configuration files can be specified when the property sub-batches is configured. Path to configuration file OR A list of paths to configuration files delimited by semicolon ll-config-file=config_tracker_NvDCF_perf.yml ll-config-file=config_tracker_NvDCF_perf1.yml; config_tracker_NvDCF_perf2.yml gpu-id ID of the GPU on which device/unified memory is to be allocated, and with which buffer copy/scaling is to be done. (dGPU only.) Integer, 0 to 4,294,967,295 gpu-id=0 tracking-surface-type Set surface stream type for tracking. (default value is 0) Integer, \u22650 tracking-surface-type=0 display-tracking-id Enables tracking ID display on OSD. Boolean display-tracking-id=1 compute-hw Compute engine to use for scaling. 0 - Default 1 - GPU 2 - VIC (Jetson only) Integer, 0 to 2 compute-hw=1 tracking-id-reset-mode Allow force-reset of tracking ID based on pipeline event. Once tracking ID reset is enabled and such event happens, the lower 32-bit of the tracking ID will be reset to 0 0: Not reset tracking ID when stream reset or EOS event happens 1: Terminate all existing trackers and assign new IDs for a stream when the stream reset happens (i.e., GST_NVEVENT_STREAM_RESET) 2: Let tracking ID start from 0 after receiving EOS event (i.e., GST_NVEVENT_STREAM_EOS) (Note: Only the lower 32-bit of tracking ID to start from 0) 3: Enable both option 1 and 2 Integer, 0 to 3 tracking-id-reset-mode=0 input-tensor-meta Use the tensor-meta from Gst-nvdspreprocess if available for tensor-meta-gie-id Boolean input-tensor-meta=1 tensor-meta-gie-id Tensor Meta GIE ID to be used, property valid only if input-tensor-meta is TRUE Unsigned Integer, \u22650 tensor-meta-gie-id=5 sub-batches (Alpha feature) Configures splitting of a batch of frames in sub-batches. There are two ways to configure sub-batches. First option allows static mapping of each source id to individual sub-batch. Second option lets the user configure the sub-batch sizes. Mapping of individual streams to sub-batch happens dynamically at runtime. Option 1 : Semicolon delimited integer array where each number corresponds to source id. Must include all values from 0 to (batch-size -1) where batch-size is configured in [streammux] . Option 2 : Colon delimited integer array where each number corresponds to size of a sub-batch (i.e. max number of stream a sub-batch can accommodate) Option 1 : sub-batches=0,1;2,3 In this example, a batch size of 4 is split into two sub-batches where the first sub-batch consists of source ids 0 &amp; 1 and second sub-batch consists of source ids 2 &amp; 3 Option 2 : sub-batches=2:1 The above example indicates that there are two sub-batches, first one can accommodate 2 streams and second one can accommodate 1. sub-batch-err-recovery-trial-cnt (Alpha feature) Configure the number of times the plugin can try to recover when the low level tracker in a sub-batch returns with a fatal error. To recover from the error, the plugin reinitializes the low level tracker library. Integer,\u2265-1 where, -1 corresponds to infinite trials sub-batch-err-recovery-trial-cnt=3 user-meta-pool-size The size of tracker miscellaneous data buffer pool Unsigned Integer, &gt;0 user-meta-pool-size=32", "keywords": []}, {"id": 3025, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#how-to-implement-a-custom-low-level-tracker-library", "display_name": "How to Implement a Custom Low-Level Tracker Library", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "how-to-implement-a-custom-low-level-tracker-library", "priority": -1, "content": "To write a custom low-level tracker library, users are expected to implement the API defined in sources/includes/nvdstracker.h , which is covered in an earlier section on NvDsTracker API , and parts of the API refer to sources/includes/nvbufsurface.h . Thus, the users would need to include nvdstracker.h to implement the API: #include &quot;nvdstracker.h&quot; Below is a sample implementation of each API. Assuming that the low-level tracker library defines and implements a custom class (e.g., NvMOTContext class in the sample code below) to perform actual operations corresponding to each API call. Below is a sample code for initialization and de-initialization APIs: The sample code below have some skeletons only. Users are expected to add proper error handling and additional codes as needed NvMOTStatus NvMOT_Init(NvMOTConfig *pConfigIn, NvMOTContextHandle *pContextHandle, NvMOTConfigResponse *pConfigResponse) { if(pContextHandle != nullptr) { NvMOT_DeInit(*pContextHandle); } /// User-defined class for the context NvMOTContext *pContext = nullptr; /// Instantiate the user-defined context pContext = new NvMOTContext(*pConfigIn, *pConfigResponse); /// Pass the pointer as the context handle *pContextHandle = pContext; /** * return NvMOTStatus_Error if something is wrong * return NvMOTStatus_OK if everything went well */ } /** * This is a sample code for the constructor of `NvMOTContext` * to show what may need to happen when NvMOTContext is instantiated in the above code for `NvMOT_Init` API */ NvMOTContext::NvMOTContext(const NvMOTConfig &amp;config, NvMOTConfigResponse&amp; configResponse) { // Set CUDA device as needed cudaSetDevice(m_Config.miscConfig.gpuId) // Instantiate an appropriate localizer/tracker implementation // Load and parse the config file for the low-level tracker using the path to a config file m_pLocalizer = LocalizerFactory::getInstance().makeLocalizer(config.customConfigFilePath); // Set max # of streams to be supported // ex) uint32_t maxStreams = config.maxStreams; // Use the video frame info for(uint i=0; i&lt;m_Config.numTransforms; i++) { // Use the expected color format from the input source images NvBufSurfaceColorFormat configColorFormat = (NvBufSurfaceColorFormat)m_Config.perTransformBatchConfig[i].colorFormat; // Use the frame width, height, and pitch as needed uint32_t frameHeight = m_Config.perTransformBatchConfig[i].maxHeight; uint32_t frameWidth = m_Config.perTransformBatchConfig[i].maxWidth; uint32_t framePitch = m_Config.perTransformBatchConfig[i].maxPitch; /* Add here to pass the frame info to the low-level tracker */ } // Set if everything goes well configResponse.summaryStatus = NvMOTConfigStatus_OK; } void NvMOT_DeInit(NvMOTContextHandle contextHandle) { /// Destroy the context handle delete contextHandle; } During the initialization stage (when NvMOT_Init() is called), the context for the low-level tracker is expected to be instantiated, and its pointer is passed as the context handle (i.e., pContextHandle ) as the output as well as the output status in pConfigResponse . Users may allocate memories based on the information about the video frames (e.g., width, height, pitch, and colorFormat) and streams (e.g., max # of streams) from the input NvMOTConfig *pConfigIn , where the definition of the struct NvMOTConfig can be found in nvdstracker.h . The path to the config file for the low-level tracker library in pConfigIn-&gt;customConfigFilePath can be also used to parse the config file to initialize the low-level tracker library. After initialization is finished, the tracker plugin queries parameters needed from low-level tracker library. The query function needs to be implemented like below: NvMOTStatus NvMOT_Query(uint16_t customConfigFilePathSize, char* pCustomConfigFilePath, NvMOTQuery *pQuery) { /** * Users can parse the low-level config file in pCustomConfigFilePath to check * the low-level tracker&#x27;s requirements */ /** An optional function queryParams(NvMOTQuery&amp;) can be implemented in context handle to fill query params. */ /* if (pQuery-&gt;contextHandle) { pQuery-&gt;contextHandle-&gt;queryParams(*pQuery); } */ /** Required configs for all custom trackers. */ pQuery-&gt;computeConfig = NVMOTCOMP_GPU; // among {NVMOTCOMP_GPU, NVMOTCOMP_CPU} pQuery-&gt;numTransforms = 1; // 0 for IOU and NvSORT tracker, 1 for NvDCF or NvDeepSORT tracker as they require the video frames pQuery-&gt;supportPastFrame = true; // Set true only if the low-level tracker supports the past-frame data pQuery-&gt;batchMode = NvMOTBatchMode_Batch; // batchMode must be set as NvMOTBatchMode_Batch pQuery-&gt;colorFormats[0] = NVBUF_COLOR_FORMAT_NV12; // among {NVBUF_COLOR_FORMAT_NV12, NVBUF_COLOR_FORMAT_RGBA} #ifdef __aarch64__ pQuery-&gt;memType = NVBUF_MEM_DEFAULT; #else pQuery-&gt;memType = NVBUF_MEM_CUDA_DEVICE; #endif // among {NVBUF_MEM_DEFAULT, NVBUF_MEM_CUDA_DEVICE, NVBUF_MEM_CUDA_UNIFIED, NVBUF_MEM_CUDA_PINNED, ... } pQuery-&gt;maxTargetsPerStream = 150; // Max number of targets stored for each stream /** Optional configs to set for additional features. */ pQuery-&gt;maxShadowTrackingAge = 30; // Maximum length of shadow tracking, required if supportPastFrame is true pQuery-&gt;outputReidTensor = true; // Set true only if the low-level tracker supports outputting reid feature pQuery-&gt;reidFeatureSize = 256; // Size of Re-ID feature, required if outputReidTensor is true /** * return NvMOTStatus_Error if something is wrong * return NvMOTStatus_OK if everything went well */ } Once the low-level tracker library creates the tracker context and performs query during the initialization stage, it needs to implement a function to process each frame batch, which is NvMOT_Process() . Make sure to set the stream ID properly in the output so that pParams-&gt;frameList[i].streamID matches with pTrackedObjectsBatch-&gt;list[j].streamID if they are for the same stream, regardless of i and j . The method NvMOTContext::processFrame() in the sample code below is expected to perform the required multi-object tracking operations with the input data of the video frames and the detector object information, while reporting the tracking outputs in NvMOTTrackedObjBatch *pTrackedObjectsBatch . Users can refer to Accessing NvBufSurface memory in OpenCV to know more about how to access the pixel data in the video frames. NvMOTStatus NvMOT_Process(NvMOTContextHandle contextHandle, NvMOTProcessParams *pParams, NvMOTTrackedObjBatch *pTrackedObjectsBatch) { /// Process the given video frame using the user-defined method in the context, and generate outputs contextHandle-&gt;processFrame(pParams, pTrackedObjectsBatch); /** * return NvMOTStatus_Error if something is wrong * return NvMOTStatus_OK if everything went well */ } /** * This is a sample code for the method of `NvMOTContext::processFrame()` * to show what may need to happen when it is called in the above code for `NvMOT_Process` API */ NvMOTStatus NvMOTContext::processFrame(const NvMOTProcessParams *params, NvMOTTrackedObjBatch *pTrackedObjectsBatch) { // Make sure the input frame is valid according to the MOT Config used to create this context for(uint streamInd=0; streamInd&lt;params-&gt;numFrames; streamInd++) { NvMOTFrame *motFrame = &amp;params-&gt;frameList[streamInd]; for(uint i=0; i&lt;motFrame-&gt;numBuffers; i++) { /* Add something here to check the validity of the input using the following info*/ motFrame-&gt;bufferList[i]-&gt;width motFrame-&gt;bufferList[i]-&gt;height motFrame-&gt;bufferList[i]-&gt;pitch motFrame-&gt;bufferList[i]-&gt;colorFormat } } // Construct the mot input frames std::map&lt;NvMOTStreamId, NvMOTFrame*&gt; nvFramesInBatch; for(NvMOTStreamId streamInd=0; streamInd&lt;params-&gt;numFrames; streamInd++) { NvMOTFrame *motFrame = &amp;params-&gt;frameList[streamInd]; nvFramesInBatch[motFrame-&gt;streamID] = motFrame; } if(nvFramesInBatch.size() &gt; 0) { // Perform update and construct the output data inside m_pLocalizer-&gt;update(nvFramesInBatch, pTrackedObjectsBatch); /** * The call m_pLocalizer-&gt;update() is expected to properly populate the ouput (i.e., `pTrackedObjectsBatch`). * * One thing to not forget is to fill `pTrackedObjectsBatch-&gt;list[i].list[j].associatedObjectIn`, where * `i` and `j` are indices for stream and targets in the list, respectively. * If the `j`th target was associated/matched with a detector object, * then `associatedObjectIn` is supposed to have the pointer to the associated detector object. * Otherwise, `associatedObjectIn` shall be set NULL. */ } } The low-level tracker can send miscellaneous data to the tracker plugin by NvMOT_RetrieveMiscData() API. Here past frame data is used as an example. Other types of customized miscellaneous data can be added in NvMOTTrackerMiscData struct and also be outputted in retrieveMiscData . NvMOTStatus NvMOT_RetrieveMiscData(NvMOTContextHandle contextHandle, NvMOTProcessParams *pParams, NvMOTTrackerMiscData *pTrackerMiscData) { /// Retrieve the past-frame data if there are contextHandle-&gt;retrieveMiscData(pParams, pTrackerMiscData); /** * return NvMOTStatus_Error if something is wrong * return NvMOTStatus_OK if everything went well */ } /** * This is a sample code for the method of `NvMOTContext::processFramePast()` * to show what may need to happen when it is called in the above code for `NvMOT_ProcessPast` API */ NvMOTStatus NvMOTContext::retrieveMiscData(const NvMOTProcessParams *params, NvMOTTrackerMiscData *pTrackerMiscData) { std::set&lt;NvMOTStreamId&gt; videoStreamIdList; ///\\ Indiate what streams we want to fetch past-frame data for(NvMOTStreamId streamInd=0; streamInd&lt;params-&gt;numFrames; streamInd++) { videoStreamIdList.insert(params-&gt;frameList[streamInd].streamID); } ///\\ Retrieve past frame data if (pTrackerMiscData &amp;&amp; pTrackerMiscData-&gt;pPastFrameObjBatch) { m_pLocalizer-&gt;outputPastFrameObjs(videoStreamIdList, pTrackerMiscData-&gt;pPastFrameObjBatch); } /** * Add other types of miscellaneous data here */ } For the cases where the video stream sources are dynamically removed and added, the API call NvMOT_RemoveStreams() can be implemented to clean-up the resources no longer needed. NvMOTStatus NvMOT_RemoveStreams(NvMOTContextHandle contextHandle, NvMOTStreamId streamIdMask) { /// Remove the specified video stream from the low-level tracker context contextHandle-&gt;removeStream(streamIdMask); /** * return NvMOTStatus_Error if something is wrong * return NvMOTStatus_OK if everything went well */ } /** * This is a sample code for the method of `NvMOTContext::removeStream()` * to show what may need to happen when it is called in the above code for `NvMOT_RemoveStreams` API */ NvMOTStatus NvMOTContext::removeStream(const NvMOTStreamId streamIdMask) { m_pLocalizer-&gt;deleteRemovedStreamTrackers(streamIdMask); } In sum, to work with the NvDsTracker APIs, users may want to define class NvMOTContext like below to implement the methods in the code above. The actual implementation of each method may differ depending on the tracking algorithm the user choose to implement. /** * @brief Context for input video streams * * The stream context holds all necessary state to perform multi-object tracking * within the stream. * */ class NvMOTContext { public: NvMOTContext(const NvMOTConfig &amp;configIn, NvMOTConfigResponse&amp; configResponse); ~NvMOTContext(); /** * @brief Process a batch of frames * * Internal implementation of NvMOT_Process() * * @param [in] pParam Pointer to parameters for the frame to be processed * @param [out] pTrackedObjectsBatch Pointer to object tracks output */ NvMOTStatus processFrame(const NvMOTProcessParams *params, NvMOTTrackedObjBatch *pTrackedObjectsBatch); /** * @brief Output the miscellaneous data if there are * * Internal implementation of retrieveMiscData() * * @param [in] pParam Pointer to parameters for the frame to be processed * @param [out] pTrackerMiscData Pointer to miscellaneous data output */ NvMOTStatus retrieveMiscData(const NvMOTProcessParams *params, NvMOTTrackerMiscData *pTrackerMiscData); /** * @brief Terminate trackers and release resources for a stream when the stream is removed * * Internal implementation of NvMOT_RemoveStreams() * * @param [in] streamIdMask removed stream ID */ NvMOTStatus removeStream(const NvMOTStreamId streamIdMask); protected: /** * Users can include an actual tracker implementation here as a member * `IMultiObjectTracker` can be assumed to an user-defined interface class */ std::shared_ptr&lt;IMultiObjectTracker&gt; m_pLocalizer; };", "keywords": []}, {"id": 3026, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#id11", "display_name": "Data Association", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "id11", "priority": -1, "content": "The association of target IDs across frames for robust tracking typically entails visual appearance-based similarity matching, for which the visual appearance features are extracted at each candidate location. Usually, this is a computationally expensive process and often plays as a performance bottleneck in object tracking. Unlike existing approaches that extract visual features from all the candidate locations and perform feature matching among all the candidate objects, the NvDCF tracker takes advantage of the correlation response (that is already obtained during target localization stage) as the tracking confidence map of each tracker over a search region and simply looks up the confidence values at each candidate location (i.e., the location of each detector object) to get the visual similarity without any explicit computation. By comparing those confidences between trackers, we can identify which tracker has a higher visual similarity to a particular detector object and use it as a part of the matching score for data association. Therefore, the visual similarity matching in the data association process can be carried out very efficiently through a simple look-up table (LUT) operation on existing correlation responses. In the animated figure below, the left side shows the target within its search region, while the right side shows the correlation response map (where the deep red color indicates higher confidence and deep blue indicates lower confidence). In the confidence map, the yellow cross (i.e., + ) around the center indicates the peak location of the correlation response, while the purple x indicate the center of nearby detector bboxes. The correlation response values at those purple x locations indicate the confidence score on how likely the same target exists at that location in terms of the visual similarity. If there are multiple detector bboxes (i.e., purple x ) around the target like the one in the figure below, the data association module will take care of the matching based on the visual similairty score and the configured weight and minimum value, which are matchingScoreWeight4VisualSimilarity and minMatchingScore4VisualSimilarity , respectively.", "keywords": []}, {"id": 3027, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#id12", "display_name": "Configuration Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "id12", "priority": -1, "content": "A few sample configuration files for the NvDCF tracker are provided as a part of DeepStream SDK package, which is named as: config_tracker_NvDCF_max_perf.yml config_tracker_NvDCF_perf.yml config_tracker_NvDCF_accuracy.yml The first max_perf config file is to configure the NvDCF tracker to consume the least amount of resources, while the second perf config file is for the use case where a decent balance between performance and accuracy is required. The last accuracy config file is to maximize the accuracy and robustness by enabling most of the features to their full capability, especially the target re-association. The following table summarizes the configuration parameters used in the config files for the NvDCF low-level tracker (except the common modules and parameters already mentioned in an earlier section). Module Property Meaning Type and Range Default value Visual Tracker visualTrackerType Type of visual tracker among { DUMMY=0, NvDCF=1, NvDCF_VPI=2 } NvDCF_VPI is an Alpha feature. Int, [0, 1, 2] visualTrackerType: 0 useColorNames Use ColorNames feature Boolean useColorNames: 1 useHog Use Histogram-of-Oriented-Gradient (HOG) feature Boolean useHog: 0 featureImgSizeLevel Size of a feature image Integer, 1 to 5 featureImgSizeLevel: 2 featureFocusOffsetFactor_y The offset for the center of hanning window relative to the feature height Float, -0.5 to 0.5 featureFocusOffsetFactor_y: 0.0 useHighPrecisionFeature Whether to use 16 bit high precision feature; otherwise use 8 bit Boolean useHighPrecisionFeature: 0 filterLr Learning rate for DCF filter in exponential moving average Float, 0.0 to 1.0 filterLr: 0.075 filterChannelWeightsLr Learning rate for weights for different feature channels in DCF Float, 0.0 to 1.0 filterChannelWeightsLr: 0.1 gaussianSigma Standard deviation for Gaussian for desired response Float, &gt;0.0 gaussianSigma: 0.75 vpiBackend4DcfTracker Compute backend among {CUDA=1, PVA=2} Valid when visualTrackerType: 2 Int, [1,2] vpiBackend4DcfTracker: 1 Target Management searchRegionPaddingScale Search region size Integer, 1 to 3 searchRegionPaddingScale: 1 minTrackerConfidence Minimum detector confidence for a valid target Float, 0.0 to 1.0 minTrackerConfidence: 0.6 Data Assoicator minMatchingScore4 VisualSimilarity Min visual similarity score for valid matching Float, 0.0 to 1.0 minMatchingScore4 VisualSimilarity: 0.0 matchingScoreWeight4 VisualSimilarity Weight for visual similarity term in matching cost function Float, 0.0 to 1.0 matchingScoreWeight4 VisualSimilarity: 0.0 See also the Troubleshooting in Tracker Setup and Parameter Tuning section for solutions to common problems in tracker behavior and tuning.", "keywords": []}, {"id": 3028, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#id13", "display_name": "Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "id13", "priority": -1, "content": "Here deepstream-app pipeline is used as an example, which can be naturally extended to other applications. Steps to setup a pipeline are: For TrafficCamNet , download the detector model files here , and place the files under /opt/nvidia/deepstream/deepstream/samples/models/trafficcamnet Copy detector and tracker config files in below sections for the specific tracker type (for example TrafficCamNet + NvDCF ) into work directory: cp config_infer_primary_TrafficCamNet.txt /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app Assuming deepstream-app config file is /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/deepstream_app_config.txt , set detector and tracker config files in it like the following: ## Other groups [primary-gie] ## Use TrafficCamNet as PGIE config-file=config_infer_primary_TrafficCamNet.txt ## Other [primary-gie] configs [tracker] ## Specify the low level tracker (for example NvDCF_accuracy) # ll-config-file=config_tracker_IOU.yml # ll-config-file=config_tracker_NvSORT.yml # ll-config-file=config_tracker_NvDCF_perf.yml ll-config-file=config_tracker_NvDCF_accuracy.yml # ll-config-file=config_tracker_NvDeepSORT.yml ## Other [tracker] configs /opt/nvidia/deepstream is the default DeepStream installation directory. The paths will be different if the user sets up in different directory.", "keywords": []}, {"id": 3029, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#id5", "display_name": "Data Association", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "id5", "priority": -1, "content": "For the data association in the NvDeepSORT tracker, there are two metrics are used: Proximity Re-ID based similarity For the proximity score, the Mahalanobis distance between the i-th detector object and the j-th target is calculated using the target\u2019s predicted location and its associated uncertainty: dist_{ij}=(D_i-Y_j)^TS_j^{-1}(D_i-Y_j) where: D_i denotes the i-th detector object in {x, y, a, h} format. Y_j denotes the predicted states {x&#x27;, y&#x27;, a&#x27;, h&#x27;} from state estimator for the j-th tracker. S_j denotes the predicted covariance from state estimator for the j-th tracker. In the original DeepSORT implementation, the maximum threshold of Mahalanobis distance for a valid pair of detector object and target is set 9.4877 , representing 95% confidence computed from the inverse Chi-square distribution. Note in NvDeepSORT, the value is configured by thresholdMahalanobis in tracker config to achieve higher accuracy for a particular detector model, such as the PeopleNet v2.6.2, so it may be different from the value in the original implementation. After filtering out invalid pairs, the Re-ID similarity score is computed as the maximum cosine similarity between a detector object and a target. Then the cascaded data association algorithm is used for high accuracy multi-stage matching.", "keywords": []}, {"id": 3030, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#id6", "display_name": "Configuration Parameters", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "id6", "priority": -1, "content": "A sample config file config_tracker_NvDeepSORT.yml is provided in DeepStream SDK package. The following table summarizes the configuration parameters for NvDeepSORT. Module Property Meaning Type and Range Default value Data Associator thresholdMahalanobis Max Mahalanobis distance based on Chi-square probabilities Float, &gt;0 considered as set thresholdMahalanobis: -1.0 minMatchingScore4ReidSimilarity Min Re-ID threshold to match targets and tentative detection Float, 0.0 to 1.0 minMatchingScore4ReidSimilarity: 0.0 matchingScoreWeight4ReIDSimilarity Weight for Re-ID similarity term in matching cost function Float, 0.0 to 1.0 matchingScoreWeight4ReIDSimilarity: 0.0", "keywords": []}, {"id": 3031, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#implementation-details-and-reference", "display_name": "Implementation Details and Reference", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "implementation-details-and-reference", "priority": -1, "content": "The difference between NvDeepSORT and the original implementation includes: For data association, the original implementation sorts the targets in an ascending order based on the tracking age and runs the matching algorithm for each age sequentially, while NvDeepSORT applies the cascaded data association algorithm with higher performance and accuracy. NvDeepSORT implementation in the NvMultiObjectTracker library adopts the same target management policy as the NvDCF tracker, which is advanced to the original DeepSORT. The cosine distance metric for two features is score_{ij}=1-feature\\_det_{i}\\cdot feature\\_track_{jk} , with smaller values representing more similarity. By contrast, NvDeepSORT directly uses dot product for computational efficiency, so larger values means higher similarity. Reference : Wojke, Nicolai, Alex Bewley, and Dietrich Paulus. \u201cSimple online and real-time tracking with a deep association metric.\u201d 2017 IEEE international conference on image processing (ICIP). IEEE, 2017. Check Paper and The original implementation on Github .", "keywords": []}, {"id": 3032, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "inputs-and-outputs", "priority": -1, "content": "This section summarizes the inputs, outputs, and communication facilities of the Gst-nvtracker plugin. Input Gst Buffer A frame batch from available source streams NvDsBatchMeta Includes the detected object info from primary inference module More details about NvDsBatchMeta can be found in the link. The color formats supported for the input video frame by the NvTracker plugin are NV12 and RGBA. A separate batch of video frames are created from the input video frames based on the color format and the resolution that is required to the low-level tracker library. Output Gst Buffer Same as the input. Unmodified. NvDsBatchMeta Updated with additional data from tracker low-level library There\u2019s no separate data structure for the output. Instead, the tracker plugin just adds/updates the data in the existing NvDsBatchMeta (and its NvDsObjectMeta ) with the output data from the tracker low-level library, including tracked object coordinates, tracker confidence, and object IDs. There are some other miscellaneous data that can be attached as user-meta, which is covered in Miscellaneous Data Output section. If the tracker algorithm does not generate confidence value, then tracker confidence value will be set to the default value (i.e., 1.0 ) for tracked objects. For IOU, NvSORT and NvDeepSORT trackers, tracker_confidence is set to 1.0 as these algorithms do not generate confidence values for tracked objects. NvDCF tracker, on the other hand, generates confidence for the tracked objects due to its visual tracking capability, and its value is set in tracker_confidence field in NvDsObjectMeta structure. Note that there are separate parameters in NvDsObjectMeta for detector\u2019s confidence and tracker\u2019s confidence, which are confidence and tracker_confidence , respectively. More details can be found in New metadata fields The following table summarizes the features of the plugin. Feature Description Release Configurable tracker width/height Frames are internally scaled in NvTracker plugin to the specified resolution for tracking and passed to the low-level lib DS 2.0 Multi-stream CPU/GPU tracker Supports tracking on batched buffers consisting of frames from multiple sources DS 2.0 NV12 Input DS 2.0 RGBA Input DS 3.0 Configurable GPU device User can select GPU for internal scaling/color format conversions and tracking DS 2.0 Dynamic addition/deletion of sources at runtime Supports tracking on new sources added at runtime and cleanup of resources when sources are removed DS 3.0 Support for user\u2019s choice of low-level library Dynamically loads user selected low-level library DS 4.0 Support for batch processing exclusively Supports sending frames from multiple input streams to the low-level library DS 4.0 Multiple buffer formats as input to low-level library Converts input buffer to formats requested by the low-level library, for up to 4 formats per frame DS 4.0 Enabling tracking-id display Supports enabling or disabling display of tracking-id DS 5.0 Tracking ID reset based on event Based on the pipeline event (i.e., GST_NVEVENT_STREAM_EOS and GST_NVEVENT_STREAM_RESET), the tracking IDs on a particular stream can be reset to start from 0 or new IDs. DS 6.0 Miscellaneous data Supports outputting user defined miscellaneous data (including the past-frame data, a list of terminated tracks, etc. ) if the low-level library supports the capability DS 6.3 Re-ID tensor output Supports outputting objects\u2019 Re-ID features (i.e., embeddings) if the low-level library uses a Re-ID model DS 6.3 Support for NVIDIA\u2019s VPI\u2122 based Crop-scaler and DCF-Tracker algorithms in NvDCF tracker (Alpha feature) Configuration options provided in NvDCF tracker which allow the user to switch to NVIDIA\u2019s VPI\u2122 implementation of Crop-scaler and DCF-Tracker. The user can also configure the compute backend to be used amongst the backends supported by VPI\u2122 DS 6.4 PVA-backend for NvDCF via VPI\u2122 \u2019s unified API (Alpha feature) Allow PVA-based execution of a significant part of NvDCF on Jetson, resulting in lower GPU utilization DS 6.4 Sub-batching (Alpha feature) Supports splitting of a batch of frames in sub-batches which are internally processed in parallel resulting in higher resource utilization. This feature also enables specification of a different config file for each sub-batch. DS 6.4 Single-View 3D Tracking (Alpha feature) Allow 3D world coordinate system based object tracking when camera/model info (3x4 projection matrix and 3D human model info) is provided for better handling of partial occlusion DS 6.4", "keywords": []}, {"id": 3033, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#iou-tracker", "display_name": "IOU Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "iou-tracker", "priority": -1, "content": "The NvMultiObjectTracker library provides an object tracker that has only the essential and minimum set of functionalities for multi-object tracking, which is called the IOU tracker. IOU tracker performs only the following functionalities: Greedy data association between the detector objects from a new video frame and the existing targets in the previous video frame Target management based on the data association results including the target state update and the creation and termination of targets The error handling mechanisms like Late Activation and Shadow Tracking are integral part of the target management module of the NvMultiObjectTracker library; thus, such features are inherently enabled in the IOU tracker. IOU tracker can be used as a performance baseline as it consumes the minimum amount of computational resources. A sample configuration file config_tracker_IOU.yml is provided in DeepStream SDK package.", "keywords": []}, {"id": 3034, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#low-level-tracker-comparisons-and-tradeoffs", "display_name": "Low-Level Tracker Comparisons and Tradeoffs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "low-level-tracker-comparisons-and-tradeoffs", "priority": -1, "content": "DeepStream SDK provides four reference low-level tracker libraries which have different resource requirements and performance characteristics, in terms of accuracy, robustness, and efficiency, allowing the users to choose the best tracker based on their use cases and requirements. See the following table for comparison. Tracker Type GPU Compute CPU Compute Pros Cons Best Use Cases IOU No Very Low Light weight No visual features for matching, so prone to frequent tracker ID switches and failures. Not suitable for fast moving scene. Objects are sparsely located, with distinct sizes Detector is expected to run every frame or very frequently (ex. every alternate frame) NvSORT No Very Low Light weight Motion estimation and prection with Kalman filter based state estimator Enhanced data association with reasonable tracking accuracy with medium or high accuracy detectors No visual features for matching, so prone to frequent tracker ID switches and failures. Medium or high accuracy detectors such as PeopleNet and YOLO Detector is expected to run every frame or very frequently (ex. every alternate frame) NvDeepSORT High Low Allow custom Re-ID model for appearance matching Less frequent ID switches Highly discriminative on targets with similar appearance Higher compute cost due to inferencing required for each object Cannot easily adjust accuracy/perf level unless switching Re-ID model Multi-object, complex scenes even with partial occlusion Objects with similar appearance NvDCF Medium Low Highly robust against partial occlusions, shadow, and other transient visual changes Less frequent ID switches Can be used with PGIE interval &gt; 0 without significant accuracy degradation Output tracking confidence based on visual similarity Easily adjust params for accuracy-perf tradeoff depending on application requirements Slower than IOU, NvSORT due to increased computational complexity for visual feature extraction Multi-object, complex scenes even with partial occlusion PGIE interval &gt; 0", "keywords": []}, {"id": 3035, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#miscellaneous-data-output", "display_name": "Miscellaneous Data Output", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "miscellaneous-data-output", "priority": -1, "content": "Miscellaneous data provides a mechanism to return additional data to the user outside of the Gst Buffer or NvDsBatchMeta. The miscellaneous data buffer will only be populated when options are enabled for specific feature. Currently the supported types of miscellaneous data are: Terminated Track List Shadow Tracking Target Data Past-frame Target Data Each type of data has a unique output variable within the miscellaneous data; however, they do share a common data structure, using the unified NvDsTargetMiscDataBatch data structure. A buffer pool is used for its memory management, whose size can be set with user-meta-pool-size . When the latency for downstream plugins to release the buffers is too long, the buffer pool may be empty so tracker will skip reporting the miscellaneous data for next batch. A warning gstnvtracker: Unable to acquire a user meta buffer will be shown, and users can increase the pool size from default 32 to larger values like 64. Specifics for each type of miscellaneous data is defined below in the following sections.", "keywords": []}, {"id": 3036, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvdcf-tracker", "display_name": "NvDCF Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvdcf-tracker", "priority": -1, "content": "NvDCF tracker employs a visual tracker that is based on the discriminative correlation filter (DCF) for learning a target-specific correlation filter and for localizing the same target in the next frames using the learned correlation filter. Such correlation filter learning and localization are usually carried out on per-object basis in a typical MOT implementation, creating a potentially large number of small CUDA kernel launches when processed on GPU. This inherently poses challenges in maximizing GPU utilization, especially when a large number of objects from multiple video streams are expected to be tracked on a single GPU. To address such performance issues, the GPU-accelerated operations for the NvDCF tracker are designed to be executed in the batch processing mode to maximize the GPU utilization despite the nature of small CUDA kernels in per-object tracking model. The batch processing mode is applied in the entire tracking operations, including the bbox cropping and scaling, visual feature extraction, correlation filter learning, and localization. This can be viewed as a similar model to the batched cuFFT or batched cuBLAS calls, but it differs in that the batched MOT execution model spans many operations in a higher level. The batch processing capability is extended from multi-object batching to the batching of multiple streams for even greater efficiency and scalability. Thanks to its visual tracking capability, the NvDCF tracker can localize and keep track of the targets even when the detector in PGIE misses them (i.e., false negatives) for potentially an extended period of time caused by partial or full occlusions, resulting in more robust tracking. The enhanced robustness characteristics allow users to use a higher maxShadowTrackingAge value for longer-term object tracking and also allows PGIE\u2019s interval to be higher only at the cost of slight degradation in accuracy. Unlike NvSORT and NvDeepSORT where the Kalman filter takes the detection bboxes as the only input, the Kalman filter in the NvDCF tracker also takes the localization results from the visual tracking module as an input as well. Once a target is being tracked, the visual tracker keeps trying to localize the same target in the next frames using the learned correlation filter, while there could be matched detector bboxes. The Kalman filter in NvDCF tracker fuses both the DCF-based localization results and the detection bboxes for better target state estimation and prediction.", "keywords": []}, {"id": 3037, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvdeepsort-tracker", "display_name": "NvDeepSORT Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvdeepsort-tracker", "priority": -1, "content": "NvDeepSORT tracker utilizes deep learning based object appearance information for accurate object matching in different frames and locations, resulting in enhanced robustness over occlusions and reduced ID switches. It applies a pre-trained re-identification (Re-ID) neural network to extract a feature vector for each object, compares the similarity between different objects using the extracted feature vector with a cosine distance metric, and combines it with a state estimator to perform the data association over frames. Before running NvDeepSORT, Re-ID model needs to be set up following Setup Sample Re-ID Models and Customize Re-ID Model .", "keywords": []}, {"id": 3038, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvdstracker-api-for-low-level-tracker-library", "display_name": "NvDsTracker API for Low-Level Tracker Library", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvdstracker-api-for-low-level-tracker-library", "priority": -1, "content": "A low-level tracker library can be implemented using the API defined in sources/includes/nvdstracker.h . Parts of the API refer to sources/includes/nvbufsurface.h . The names of API functions and data structures are prefixed with NvMOT , which stands for NVIDIA Multi-Object Tracker. Below is the general flow of the API from a low-level library\u2019s perspective: The first required function is: NvMOTStatus NvMOT_Query ( uint16_t customConfigFilePathSize, char* pCustomConfigFilePath, NvMOTQuery *pQuery ); The plugin uses this function to query the low-level library\u2019s capabilities and requirements before it starts any processing sessions (i.e., contexts) with the library. Queried properties include the input frame\u2019s color format (e.g., RGBA or NV12) and memory type (e.g., NVIDIA \u00ae  CUDA \u00ae device or CPU-mapped NVMM). The plugin performs this query once during initialization stage, and its results are applied to all contexts established with the low-level library. If a low-level library configuration file is specified, it is provided in the query for the library to consult. The query reply structure, NvMOTQuery , contains the following fields: NvMOTCompute computeConfig : Report compute targets supported by the library. The plugin currently only echoes the reported value when initiating a context. uint8_t numTransforms : The number of color formats required by the low-level library. The valid range for this field is 0 to NVMOT_MAX_TRANSFORMS . Set this to 0 if the library does not require any visual data. 0 does not mean that untransformed data will be passed to the library. NvBufSurfaceColorFormat colorFormats[NVMOT_MAX_TRANSFORMS] : The list of color formats required by the low-level library. Only the first numTransforms entries are valid. NvBufSurfaceMemType memType : Memory type for the transform buffers. The plugin allocates buffers of this type to store color- and scale-converted frames, and the buffers are passed to the low-level library for each frame. The support is currently limited to the following types: dGPU: NVBUF_MEM_CUDA_PINNED NVBUF_MEM_CUDA_UNIFIED Jetson: NVBUF_MEM_SURFACE_ARRAY bool supportBatchProcessing : True if the low-level library supports the batch processing across multiple streams; otherwise false. bool supportPastFrame : True if the low-level library supports outputting the past-frame data; otherwise false. After the query, and before any frames arrive, the plugin must initialize a context with the low-level library by calling: NvMOTStatus NvMOT_Init ( NvMOTConfig *pConfigIn, NvMOTContextHandle *pContextHandle, NvMOTConfigResponse *pConfigResponse ); The context handle is opaque outside the low-level library. In the batch processing mode, the plugin requests a single context for all input streams. In per-stream processing mode, on the other hand, the plugin makes this call for each input stream so that each stream has its own context. This call includes a configuration request for the context. The low-level library has an opportunity to: Review the configuration and create a context only if the request is accepted. If any part of the configuration request is rejected, no context is created, and the return status must be set to NvMOTStatus_Error . The pConfigResponse field can optionally contain status for specific configuration items. Pre-allocate resources based on the configuration. In the NvMOTMiscConfig structure, the logMsg field is currently unsupported and uninitialized. The customConfigFilePath pointer is only valid during the call. Once a context is initialized, the plugin sends frame data along with detected object bounding boxes to the low-level library whenever it receives such data from upstream. It always presents the data as a batch of frames, although the batch can contain only a single frame in per-stream processing contexts. Note that depending on the frame arrival timings to the tracker plugin, the composition of frame batches could either be a full batch (that contains a frame from every stream) or a partial batch (that contains a frame from only a subset of the streams). In either case, each batch is guaranteed to contain at most one frame from each stream. The function call for this processing is: NvMOTStatus NvMOT_Process ( NvMOTContextHandle contextHandle, NvMOTProcessParams *pParams, NvMOTTrackedObjBatch *pTrackedObjectsBatch ); , where: pParams is a pointer to the input batch of frames to process. The structure contains a list of one or more frames, with at most one frame from each stream. Thus, no two frame entries have the same streamID . Each entry of frame data contains a list of one or more buffers in the color formats required by the low-level library, as well as a list of object attribute data for the frame. Most libraries require at most one-color format. pTrackedObjectsBatch is a pointer to the output batch of object attribute data. It is pre-populated with a value for numFilled , which is the same as the number of frames included in the input parameters. If a frame has no output object attribute data, it is still counted in numFilled and is represented with an empty list entry ( NvMOTTrackedObjList ). An empty list entry has the correct streamID set and numFilled set to 0 . The output object attribute data NvMOTTrackedObj contains a pointer to the detector object (provied in the input) that is associated with a tracked object, which is stored in associatedObjectIn . You must set this to the associated input object only for the frame where the input object is passed in. For a pipeline with PGIE interval=1 , for example: Frame 0: NvMOTObjToTrack  X is passed in. The tracker assigns it ID 1, and the output object\u2019s associatedObjectIn points to X . Frame 1: Inference is skipped, so there is no input object from detector to be associated with. The tracker finds Object 1, and the output object\u2019s associatedObjectIn points to NULL . Frame 2: NvMOTObjToTrack  Y is passed in. The tracker identifies it as Object 1. The output Object 1 has associatedObjectIn pointing to Y . Depending on the capability of the low-level tracker, there could be some user-defined miscellaneous data to report to tracker plugin. batch_user_meta_list in NvDsBatchMeta as a user-meta: NvMOTStatus NvMOT_RetrieveMiscData ( NvMOTContextHandle contextHandle, NvMOTProcessParams *pParams, NvMOTTrackerMiscData *pTrackerMiscData ); where: pParams is a pointer to the input batch of frames to process. This structure is needed to check the list of stream ID in the batch. pTrackerMiscData is a pointer to the output miscellaneous data for the current batch to be filled by the low-level tracker. The data structure NvMOTTrackerMiscData is defined in nvdstracker.h . In case that a video stream source is removed on the fly, the plugin calls the following function so that the low-level tracker library can remove it as well. Note that this API is optional and valid only when the batch processing mode is enabled, meaning that it will be executed only when the low-level tracker library has an actual implementation for the API. If called, the low-level tracker library can release any per-stream resource that it may be allocated: void NvMOT_RemoveStreams ( NvMOTContextHandle contextHandle, NvMOTStreamId streamIdMask ); When all processing is complete, the plugin calls this function to clean up the context and deallocate its resources: void NvMOT_DeInit (NvMOTContextHandle contextHandle);", "keywords": []}, {"id": 3039, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvidia-tao-reidentificationnet", "display_name": "NVIDIA TAO ReIdentificationNet", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvidia-tao-reidentificationnet", "priority": -1, "content": "NVIDIA pre-trained ReIdentificationNet is a high accuracy ResNet-50 model with feature length 256. It can be downloaded and used directly with command: mkdir /opt/nvidia/deepstream/deepstream/samples/models/Tracker/ wget &#x27;https://api.ngc.nvidia.com/v2/models/nvidia/tao/reidentificationnet/versions/deployable_v1.0/files/resnet50_market1501.etlt&#x27; -P /opt/nvidia/deepstream/deepstream/samples/models/Tracker/ The tracker config file supports this model by default. Note the raw output from this network is not L2 normalized, so addFeatureNormalization: 1 is set to add L2 normalization as a post processing.", "keywords": []}, {"id": 3040, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvmultiobjecttracker-a-reference-low-level-tracker-library", "display_name": "NvMultiObjectTracker : A Reference Low-Level Tracker Library", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvmultiobjecttracker-a-reference-low-level-tracker-library", "priority": -1, "content": "Multi-object tracking (MOT) is a key building block for a large number of intelligent video analytics (IVA) applications that requires spatio-temporal analysis of objects of interest to draw further insights about the objects\u2019 behaviors in long term. Given a set of detected objects from the Primary GIE (PGIE) module on a single or multiple streams and with the APIs defined to work with the tracker plugin, the low-level tracker library is expected to carry out actual multi-object tracking operations to keep persistent IDs to the same objects over time. DeepStream SDK provides a single reference low-level tracker library, called NvMultiObjectTracker , that implements all four low-level tracking algorithms (i.e., IOU, NvSORT, NvDeepSORT, and NvDCF) in a unified architecture. It supports multi-stream, multi-object tracking in the batch processing mode for efficient processing on CPU and GPU (and PVA for Jetson). The following sections will cover the unified tracker architecture and the details of each reference tracker implementation.", "keywords": []}, {"id": 3041, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#nvsort-tracker", "display_name": "NvSORT Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "nvsort-tracker", "priority": -1, "content": "NvSORT tracker increases the tracking accuracy while maintaining the high performance on top of IOU tracker with the following improvements: State estimation with Kalman filter to better estimate and predict the states of the targets in the current frame. Cascaded data association to associate targets and detector objects in multiple stages based on their proximity and confidence, which is more accurate than the simple matching in original SORT tracker. As it fully relies on the bbox attributes for data association, the NvSORT\u2019s tracking accuracy is solely attributed to the detection accuracy. With a medium or high accuracy detector, NvSORT produces high quality tracking results with minimal computational resources. A sample configuration file config_tracker_NvSORT.yml is provided in DeepStream SDK package.", "keywords": []}, {"id": 3042, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#object-re-identification", "display_name": "Object Re-Identification", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "object-re-identification", "priority": -1, "content": "Re-identification (Re-ID) uses TensorRT\u2122-accelerated deep neural networks to extract unique feature vectors from detected objects that are robust to spatial-temporal variance and occlusion. It has two use-cases in NvMultiObjectTracker : (1) In NvDeepSORT, the Re-ID similarity is used for data association of objects over consecutive frames.; (2) In target re-association (which will be described in more detail in the following section), the Re-ID features of targets are extracted and kept, so that they can be used for re-association with the same target if they are seemingly lost. reidType selects the mode for each aforementioned use-case. In the Re-ID module, the detector objects are cropped and resized into the configured input size of the Re-ID network. The parameter keepAspc controls whether the object\u2019s aspect ratio is preserved after cropping. Then NVIDIA TensorRT\u2122 creates an engine from the network, which processes the input in batches and outputs a fixed-dimensional vector for each detector object as the Re-ID feature. The cosine similarity function requires each feature\u2019s L2 norm normalized to 1. Check Re-ID Feature Output on how to retrieve these features in the tracker plugin and downstream modules. For each target, a gallery of its Re-ID features in most recent frames are kept internally. The size of the feature gallery can be set by reidHistorySize . config_tracker_NvDeepSORT.yml and config_tracker_NvDCF_accuracy.yml configs use ReIdentificationNet by default, which is a ResNet-50 Re-ID network in NVIDIA TAO toolkit on NGC . Users need to follow instructions in Setup Sample Re-ID Models to setup, or check Customize Re-ID Model for more information on adding a custom Re-ID model for object tracking with different architectures and datasets. The Re-ID similarity between a detector object and a target is the cosine similarity between the detector object\u2019s Re-ID feature and its nearest neighbor in the target\u2019s featue gallery, whose value is in range [0.0, 1.0] . Specifically, each Re-ID feature in the target\u2019s gallery takes the dot product with the detector object\u2019s Re-ID feature. The maximum of all the dot products is the similarity score, i.e. score_{ij}=\\max_{k}(feature\\_det_{i}\\cdot feature\\_track_{jk}) where: \\cdot denotes the dot product. feature\\_det_{i} denotes the i-th detector object\u2019s feature. feature\\_track_{jk} denotes the k-th Re-ID feature in the j-th target\u2019s feature gallery. k =[1, reidHistorySize ]. The Re-ID has a spatial-temporal constraint. If an object moves out of frame or gets occluded beyond maxShadowTrackingAge , it will be assigned a new ID even if it returns into the frame. The extracted Re-ID features (i.e., embeddings) can be exported to the metadata, which is explained in a separate section in Re-ID Feature Output .", "keywords": []}, {"id": 3043, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#onnx-model", "display_name": "ONNX Model", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "onnx-model", "priority": -1, "content": "An open-sourced ONNX model sample is Simple Cues Lead to a Strong Multi-Object Tracker , which proposes a new Re-ID model using on-the-fly domain adaptation. The network is based on ResNet-50 with feature length being 512. mkdir /opt/nvidia/deepstream/deepstream/samples/models/Tracker/ wget &#x27;https://vision.in.tum.de/webshare/u/seidensc/GHOST/ghost_reid.onnx&#x27; -P /opt/nvidia/deepstream/deepstream/samples/models/Tracker/ Then update below parameters in tracker config file ReID session (keep reidType unchanged). ReID: batchSize: 100 workspaceSize: 1000 reidFeatureSize: 512 reidHistorySize: 100 inferDims: [3,384, 128] networkMode: 1 # [Input Preprocessing] inputOrder: 0 colorFormat: 0 offsets: [109.1250, 102.6000, 91.3500] netScaleFactor: 0.01742919 keepAspc: 1 # [Paths and Names] onnxFile: &quot;/opt/nvidia/deepstream/deepstream/samples/models/Tracker/ghost_reid.onnx&quot;", "keywords": []}, {"id": 3044, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#past-frame-target-data", "display_name": "Past-frame Target Data", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "past-frame-target-data", "priority": -1, "content": "Past-frame target data is always reported in miscellaneous data, and is appended to the current frame objects in tracker KITTI dump when enabled. To enable tracker KITTI dump: Add kitti-track-output-dir=&lt;dir name&gt; in deepstream-app config\u2019s application group properties create the folder &lt;dir name&gt; Run deepstream-app to save tracked objects files in &lt;dir name&gt; . Data format is defined below following the KITTI format. The foot location and visibility data will append to the end of each line if SV3DT output is enabled. object Label object Unique Id blank blank blank bbox left bbox top bbox right bbox bottom blank blank blank blank blank blank blank confidence visibility (optional) Foot Image Position X (optional) Foot Image Position Y (optional) string long unsigned float int float float float float float float float float float float float float float float float float A file will be created for each frame in each stream. Sample data is like: # SV3DT output disabled person 0 0.0 0 0.0 1302.667236 135.852036 1340.975830 241.724579 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.917301 person 1 0.0 0 0.0 878.249023 195.080475 913.410950 320.695618 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.899029 ... # SV3DT output enabled person 0 0.0 0 0.0 1302.667236 135.852036 1340.975830 241.724579 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.917301 0.966531 1314.492554 239.495193 person 1 0.0 0 0.0 878.249023 195.080475 913.410950 320.695618 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.899029 0.930824 899.187500 316.670013 ...", "keywords": []}, {"id": 3045, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#people-tracking", "display_name": "People Tracking", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "people-tracking", "priority": -1, "content": "NVIDIA\u00ae pre-trained PeopleNet detects person, bag, and face classes. The pre-trained model with ResNet-34 backbone is on NVIDIA NGC catalog . It can be used in PGIE module in conjunction with various low level trackers for people tracking.", "keywords": []}, {"id": 3046, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#peoplenet-nvdcf", "display_name": "PeopleNet + NvDCF", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "peoplenet-nvdcf", "priority": -1, "content": "This pipeline performs more accurate people tracking. For the output visualization, a deepstream-app pipeline is first constructed with the following components: Detector : PeopleNet v2.6.2 (w/ ResNet-34 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvDCF with config_tracker_NvDCF_accuracy.yml configuration in DeepStream release For better visualization, the following changes were also made: featureImgSizeLevel: 5 is set under VisualTracker section in config_tracker_NvDCF_accuracy.yml tracker-height=960 and tracker-width=544 under [tracker] section in the deepstream-app config file A set of recommended detector config params for PeopleNet v2.6.2 to be used with NvDCF_accuracy tracker is: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt labelfile-path=../../models/peoplenet/labels.txt onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=3 interval=0 gie-unique-id=1 ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=1 [class-attrs-all] pre-cluster-threshold=0.1429 nms-iou-threshold=0.4688 minBoxes=3 dbscan-min-score=0.7726 eps=0.2538 detected-min-w=20 detected-min-h=20 The resulting output video of the aforementioned pipeline with (PeopleNet + Hybrid clustering + NvDCF) is shown below, but please note that only \u2018Person\u2019-class objects are detected and shown in the video: While the video above shows the per-stream output, each animated figure below shows (1) the cropped &amp; scaled image patch used for each target on the left side and (2) the corresponding correlation response map for the target on the right side. As mentioned earlier, the yellow + mark shows the peak location of the correlation response map generated by using the learned correlation filter, while the puple x marks show the the center of nearby detector objects. Person 1 (w/ Blue hat + gray backpack) Person 6 (w/ Red jacket + gray backpack) Person 4 (w/ Green jacket) Person 5 (w/ Cyan jacket) The figures above show how the correlation responses progress over time for the cases of no occlusion, partial occlusion, and full occlusions happening. It can be seen that even when a target undergoes a full occlusion for a prolonged period, the NvDCF tracker is able to keep track of the targets in many cases. If featureImgSizeLevel: 3 is used instead for better performance, the resolution of the image patch used for each target would get lower like shown in the figure below. Person 1 (w/ Blue hat + gray backpack) Person 6 (w/ Red jacket + gray backpack)", "keywords": []}, {"id": 3047, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#peoplenet-nvdeepsort", "display_name": "PeopleNet + NvDeepSORT", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "peoplenet-nvdeepsort", "priority": -1, "content": "This pipeline enables people Re-ID capability during tracking. Such a deepstream-app pipeline is constructed with the following components: Detector : PeopleNet v2.6.2 (w/ ResNet-34 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvDeepSORT with config_tracker_NvDeepSORT.yml configuration in DeepStream release A set of recommended detector config params for PeopleNet v2.6.2 to be used with NvDeepSORT tracker is: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt labelfile-path=../../models/peoplenet/labels.txt onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=3 interval=0 gie-unique-id=1 ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=1 [class-attrs-all] pre-cluster-threshold=0.1653 nms-iou-threshold=0.5242 minBoxes=2 dbscan-min-score=1.7550 eps=0.1702 detected-min-w=20 detected-min-h=20", "keywords": []}, {"id": 3048, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#peoplenet-nvsort", "display_name": "PeopleNet + NvSORT", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "peoplenet-nvsort", "priority": -1, "content": "This pipeline performs high performance people tracking with reasonable accuracy. Such a deepstream-app pipeline is constructed with the following components: Detector : PeopleNet v2.6.2 (w/ ResNet-34 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvSORT with config_tracker_NvSORT.yml configuration in DeepStream release A set of recommended detector config params for PeopleNet v2.6.2 to be used with NvSORT tracker is: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/peoplenet/resnet34_peoplenet_int8.txt labelfile-path=../../models/peoplenet/labels.txt onnx-file=../../models/peoplenet/resnet34_peoplenet.onnx tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=3 interval=0 gie-unique-id=1 ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=1 [class-attrs-all] pre-cluster-threshold=0.1555 nms-iou-threshold=0.3386 minBoxes=2 dbscan-min-score=1.9224 eps=0.3596 detected-min-w=20 detected-min-h=20", "keywords": []}, {"id": 3049, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#re-id-feature-output", "display_name": "Re-ID Feature Output", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "re-id-feature-output", "priority": -1, "content": "Objects\u2019 Re-ID features can be accessed in the tracker plugin and downstream modules, which can be used for other tasks such as multi-target multi-camera tracking. Steps to retrieve those features using deepstream-app are: Add outputReidTensor: 1 in tracker config ReID section. Add reid-track-output-dir=&lt;dir name&gt; in deepstream-app config\u2019s application group properties and create the folder &lt;dir name&gt; . Run deepstream-app to save the Re-ID features in each frame into text files in &lt;dir name&gt; . In each text file, each line\u2019s first integer is object id, and the remaining floats are its feature vector. Users can check write_reid_track_output() in deepstream_app.c to understand how these features are retrieved. This feature is supported whenever NvDeepSORT or Re-ID based re-association is used. To retrieve Re-ID features for every frame, make sure interval=0 in PGIE config and reidExtractionInterval: 0 if re-association is enabled. Otherwise, the Re-ID features will be extracted at intervals only when PGIE generates bounding boxes and reidExtractionInterval is met.", "keywords": []}, {"id": 3050, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#setup", "display_name": "Setup", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "setup", "priority": -1, "content": "Here deepstream-app pipeline is used as an example, which can be naturally extended to other applications. Steps are: Download the detector model files here , and place the files under /opt/nvidia/deepstream/deepstream/samples/models/peoplenet Copy detector config file in below sections config_infer_primary_PeopleNet.txt for the specific low level tracker (for example PeopleNet + NvDCF ) into work directory: cp config_infer_primary_PeopleNet.txt /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app Assuming deepstream-app config file is /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/deepstream_app_config.txt , set PGIE and tracker config files in it: ## Other groups [primary-gie] ## Use PeopleNet as PGIE config-file=config_infer_primary_PeopleNet.txt ## Other [primary-gie] configs [tracker] ## Specify the low level tracker (for example NvSORT) # ll-config-file=config_tracker_IOU.yml ll-config-file=config_tracker_NvSORT.yml # ll-config-file=config_tracker_NvDCF_perf.yml # ll-config-file=config_tracker_NvDCF_accuracy.yml # ll-config-file=config_tracker_NvDeepSORT.yml ## Other [tracker] configs /opt/nvidia/deepstream is the default DeepStream installation directory. The paths will be different if the user sets up in different directory.", "keywords": []}, {"id": 3051, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#setup-and-usage-of-re-id-model", "display_name": "Setup and Usage of Re-ID Model", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "setup-and-usage-of-re-id-model", "priority": -1, "content": "This section describes how to download and setup Re-ID models in different formats, perform INT8 calibration for performance optimization and output Re-ID features to downstream modules.", "keywords": []}, {"id": 3052, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#setup-and-usage-of-sub-batching-alpha", "display_name": "Setup and Usage of Sub-batching (Alpha)", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "setup-and-usage-of-sub-batching-alpha", "priority": -1, "content": "This section describes how to use the sub-batching feature with multiple low-level tracker config files. Two use cases are explained: the first one with varied tracker algorithms and the second one with varied compute backends. Here, a deepstream-app pipeline is used as an example.", "keywords": []}, {"id": 3053, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#setup-and-visualization-of-tracker-sample-pipelines", "display_name": "Setup and Visualization of Tracker Sample Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "setup-and-visualization-of-tracker-sample-pipelines", "priority": -1, "content": "This section describes how to setup a multi-object tracking pipeline with various NVIDIA\u00ae pre-trained detector models and DeepStream multi-object trackers, and provides ready-to-use detector and tracker config files optimized for high accuracy tracking. The optimal tracker configs for People tracking (e.g., config_tracker_NvSORT.yml, config_tracker_NvDeepSORT.yml, config_tracker_NvDCF_accuracy.yml, etc.) are already provided in DeepStream release package, so here we present optimized detector parameters only. Then the visualization of some sample outputs and internal states (such as correlation responses for a few selected targets) are presented to help users to better understand how NvDsTracker works, especially on the visual tracker module. In addition, we present detector config params and tracker config params for vehicle tracking use-case as well.", "keywords": []}, {"id": 3054, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#setup-sample-re-id-models", "display_name": "Setup Sample Re-ID Models", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "setup-sample-re-id-models", "priority": -1, "content": "The supported Re-ID model formats are NVIDIA TAO and ONNX. Multiple ready-to-use sample models are listed below. Scripts and README file for users to setup the model are provided in sources/tracker_ReID . UFF is no longer supported by TensorRT, so please migrate to TAO or ONNX models.", "keywords": []}, {"id": 3055, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#shadow-tracking-target-data", "display_name": "Shadow Tracking Target Data", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "shadow-tracking-target-data", "priority": -1, "content": "As mentioned earlier, even when a target is not being associated with any of the detection bboxes, the target is still being tracked in a Shadow Tracking mode. When tracked in the Shadow Tracking mode, the target data is not being reported to the downstream because the target data may not be reliable. However, the users are allowed to still report these shadow tracking target data as a part of the miscellaneous data, when outputShadowTracks: 1 is set under TargetManagement section in a tracker config file. The shadow tracking data can be dumped in to a file when enabled in deepstream-app like below: Add shadow-track-output-dir=&lt;dir name&gt; in deepstream-app config\u2019s application group properties create the folder &lt;dir name&gt; Run deepstream-app to save the Shadow Track history into text files in &lt;dir name&gt; Data format is defined below. frame number object unique id class id blank blank bbox left bbox top bbox right bbox bottom blank blank blank blank blank blank blank confidence tracker state visibility unsigned int long unsigned int unsigned int int float float float float float float float float float float float float float int float A file will be created for each frame in each stream. Sample data is like: 1 11 2 0 0.0 296.346130 262.343445 333.428864 376.817291 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.407002 2 1.000000 1 22 2 0 0.0 1663.921875 857.167725 1752.483521 1049.053223 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.912138 2 1.000000 ... Both the terminated track data and the shadow tracking object data are not retained in the low-level tracker library when subsequent frames arrive. Thus, if users want to use these data, they should retrieve these miscellaneous data using the NvMOT_RetrieveMiscData() API at the end of every frame in the plugin. Otherwise, the data will be discarded within the tracker library.", "keywords": []}, {"id": 3056, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#single-view-3d-tracking-alpha", "display_name": "Single-View 3D Tracking (Alpha)", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "single-view-3d-tracking-alpha", "priority": -1, "content": "As mentioned earlier, partial occlusion is one of the most challenging problems that object trackers have to deal with and often lead to tracking failures. If the object detectors capture only the visible part of the object (which is often the case), the partial occlusion would cause the detection bboxes to have abrupt or gradual changes in attributes in terms of bbox location, size, aspect ratio, confidence, and most importantly the visual appearance within the bbox. Considering the object trackers rely on the bbox attributes as spatio-temporal measure and the visual appearance (e.g., ReID embedding) extracted within the bbox as visual similarity measure, such changes in bbox attributes is a major source of tracking failures, resulting in more frequent ID switches. To tackle these challenging problems, DeepStream SDK introduced a new feature called the Single-View 3D Tracking (SV3DT) that allows the object tracking to be carried out in a 3D world coordinate system (instead of the 2D camera image plane) when (1) a 3x4 projection matrix and (2) a 3D model info are provided for a video stream in a camera info file like below. # camInfo-01.yml # The 3x4 camera projection matrix (in row-major): # 996.229 -202.405 -9.121 -1.185 # 105.309 478.174 890.944 1.743 # -0.170 -0.859 0.481 -1085.484 projectionMatrix_3x4: - 996.229 - -202.405 - -9.121 - -1.185 - 105.309 - 478.174 - 890.944 - 1.743 - -0.170 - -0.859 - 0.481 - -1085.484 # The cylindrical human model modelInfo: height: 250.0 radius: 30.0 There are two options ( projectionMatrix_3x4 and projectionMatrix_3x4_w2p ) in which users can provide corresponding 3x4 camera projection matrices to support different usecase. Please refer to The 3x4 Camera Projection Matrix section for more details. Note that there are a few assumptions that this algorithm requires: A human is modeled as a cylinder with height and radius in 3D world coordinate system, and the height and radius are provided as 3D model info. A 3x4 projection matrix (that transforms a 3D world coordinate point to a 2D camera image coordinate point) is provided for a video stream or a camera. Video streams are captured from cameras that are mounted higher than the human height. The third assumption ensures that when a human is partially-occluded, the head is still visible, allowing us to use the top bbox edge as an anchor, which we will touch upon shortly. For each detection bounding box for a person, SV3DT algorithm tries to fit the 3D human model to the detection bbox in such a way that the bounding box of the projected 3D human model from the world coordinate system to the camera image plane matches with the detection bbox. A figure below shows how cylindrical 3D human models can be fitted to the input detection bboxes. In the cases where a person is partially occluded, the top edge of the detection bbox is used as an anchor to align the bbox of the projected 3D human model. Once aligned, we can recover the full-body bbox using the projected 3D human model, as if the person is not occluded. Therefore, if SV3DT is enabled, the input detection bboxes are always first recovered to the full-body bboxes based on the provided 3D model info especially when the input detection bboxes capture only the visible part of the person due to partial occlusions. This greatly enhances the multi-object tracking accuracy and robustness, since the bbox attributes are not altered during the course of partial occlusions. An animated image below shows how cylindrical 3D human models can be fitted into the input detection bboxes when the persons are partially occluded. The thin, gray bboxes on the persons indicate the input detection bboxes, which capture only the visible part of the objects. The figure demonstrates that the SV3DT algorithm is still able to estimate the accurate foot location of each person. The person trajectories are drawn based on the estimated foot locations, allowing robust spatio-temporal behavior analytics of persons in the scene despite varying degree of occlusions. Some of the persons in this example are barely seen only on the head and shoulders, but they are being successfully tracked as if not occluded at all. As a derived metric, the ratio between the bbox for the visible part and the bbox for the projected 3D human model can be considered as an approximated visibility of the object, which could be a useful information. Users can still get access to the corresponding detection bboxes by checking out detector_bbox_info in NvDsObjectMeta . To enable SV3DT feature, we introduced a new section in tracker config files, ObjectModelProjection , like below: ObjectModelProjection: cameraModelFilepath: # In order of the source streams - &#x27;camInfo-01.yml&#x27; - &#x27;camInfo_02.yml&#x27; ... Every camera view is different, so the 3x4 projection matrix is supposed to be unique to each camera. Therefore, the camera info file (e.g., camInfo-01.yml ) is to be provided for each stream, which include the 3x4 projection matrix and the model info that are shown at the beginning of the section. Once a 3D human model corresponding to an input detection bbox is estimated and located in the world coordinate system, the foot location (i.e., the center of the base of the cylindrical model) of a person on the world ground plane is what we want to keep estimating because it is a physical state that better follows the motion dynamics modeling than the motion of the object on 2D camera image plane. To perform the state estimation of the foot location of the objects on a 3D world ground plane, users need to set the state estimator type as stateEstimatorType: 3 like below: StateEstimator: stateEstimatorType: 3 # the type of state estimator among { DUMMY_ESTIMATOR=0, SIMPLE_BBOX_KF=1, REGULAR_BBOX_KF=2, SIMPLE_LOCATION_KF=3 } # [Dynamics Modeling] processNoiseVar4Loc: 6810.866 # Process noise variance for location processNoiseVar4Vel: 1348.487 # Process noise variance for velocity measurementNoiseVar4Detector: 100.000 # Measurement noise variance for detector&#x27;s detection measurementNoiseVar4Tracker: 293.323 # Measurement noise variance for tracker&#x27;s localization An additional miscellaneous data that can be useful for debugging or visualization is the convex hull of the projected 3D human model on 2D camera image plane. By using the convex hull data for each object, users can also create the visualization like the figures above. The additional miscellaneous data that is generated when SV3DT is enabled include (1) visibility, (2) foot location in both world plane and 2D image, and (3) convex hull (human cylinders projected on 2D image). These data can be saved in text files and/or outputted to object meta for downstream usage. To do that, users would need to set outputVisibility: 1 , outputFootLocation: 1 , outputConvexHull: 1 in ObjectModelProjection section respectively. The sample use cases includes saving in terminated track dump for low level tracker, attaching in KITTI track dump for deepstream-app, and converting them in schema through Gst-nvmsgconv . To allow users to easily try out and experience SV3DT, a sample usecase for SV3DT has been hosted on GitHub. So, users can just clone and run it with the sample data provided.", "keywords": []}, {"id": 3057, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#state-estimation", "display_name": "State Estimation", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "state-estimation", "priority": -1, "content": "The NvMultiObjectTracker library employs two types of state estimators, both of which are based on Kalman Filter (KF): Simple-bbox KF, Regular-bbox KF, and Simple-location KF. The Simple-bbox KF has 6 states defined, which are {x, y, w, h, dx, dy} , where x and y indicate the coordinates of the top-left corner of a target bbox, while w and h the width and the height of the bbox, respectively. dx and dy denote the velocity of x and y states. The Regular-bbox KF , on the other hand, have 8 states defined, which are {x, y, w, h, dx, dy, dw, dh} , where dw and dh are the velocity of w and h states and the rest is the same as the Simple-bbox KF. The Simple-location KF has 4 states only, which are {x, y, dx, dy} . Unlike the the two KFs that estimate the bbox attributes, note that the Simple-location KF is meant to estimate the object location in either 2D camera image plane or 3D world ground plane. All the Kalman Filter types employ a constant velocity model for generic use. The measurement vector for the Simple-bbox and Regular-bbox KF is defined as {x, y, w, h} , which represents the bbox attributes, while that for the Simple-location KF is defined as {x, y} . There is an option to use bbox aspect ratio a and its velocity da instead of w and dw when useAspectRatio is enabled, which is specially used by NvDeepSORT. In case the state estimator is used for a generic use case (like in the NvDCF tracker), the process noise variance for {x, y} , {w, h} , and {dx, dy, dw, dh} can be configured by processNoiseVar4Loc , processNoiseVar4Size , and processNoiseVar4Vel , respectively. When a visual tracker module is enabled (like in the NvDCF tracker), there could be two different measurements from the state estimator\u2019s point of view: (1) the bbox (or location) from the detector at PGIE and (2) the bbox (or location) from the tracker\u2019s localization. This is because the NvDCF tracker module is capable of localizing targets using its own learned filter. The measurement noise variance for these two different types of measurements can be configured by measurementNoiseVar4Detector and measurementNoiseVar4Tracker . These parameters are expected to be tuned or optimized based on the detector\u2019s and the tracker\u2019s characteristics for better measurement fusion. The usage of the state estimator in the NvDeepSORT tracker slightly differs from that for the aforementioned generic use case in that it is basically a Regular KF , yet with a couple of differences as per the original paper and the implementation (Check the references in NvDeepSORT Tracker section): Use of the aspect ratio a and the height h (instead of w and h ) to estimate the bbox size The process and measurement noises that are proportional to the bounding box height (instead of constant values) To allow these differences, the state estimator module in the NvMultiObjectTracker library has a set of additional config parameters: useAspectRatio to enable the use of a (instead of w ) noiseWeightVar4Loc and noiseWeightVar4Vel as the proportion coefficients for the measurement and velocity noise, respectively Note that if these two parameters are set, the fixed process noise and measurement noise parameters for the generic use cases will be ignored.", "keywords": []}, {"id": 3058, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#sub-batching-alpha", "display_name": "Sub-batching (Alpha)", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "sub-batching-alpha", "priority": -1, "content": "The Gst-nvtracker plugin works in the batch processing mode by default. In this mode, the input frame batch is passed to and processed by a single instance of low-level tracker library. The advantage of batch processing mode is to allow GPUs to work on bigger amount of data at once, potentially increasing the GPU occupancy during execution and reducing the CUDA kernel launch overhead. Depending on the use cases, however, a potential issue is that there is a possibility that GPU could be idling (also referred to as GPU bubble) in some compute stages in the tracker unless the end-to-end operation within the module is carried out solely on the GPU. This is indeed the case if some of the compute modules in the tracker runs on CPU. If there are other components in the DeepStream pipeline that uses GPU (e.g., GPU-based inference in PGIE and SGIE), such CPU blocks in tracker can be hidden behind them, not affecting the overall throughput of the pipeline. The newly-introduced Sub-batching feature allows the plugin to split the input frame batch into multiple sub-batches (for example, a four-stream pipeline can use two sub-batches in the tracker plugin, each of which takes care of two streams). Each sub-batch is assigned to a separate instance of low-level tracker library, where the input to the corresponding sub-batch is processed separately. Each instance of low-level tracker libraries runs on a dedicated thread running independently, allowing parallel processing of sub-batches and minimizing the GPU idling due to CPU compute blocks, which eventually results in higher resource utilization. Because sub-batching assigns separate low-level tracker library instances to different sub-batches, it allows the user to configure each individual sub-batch differently with different low-level tracker library configuration files. This can be utilized in multiple ways like setting varied compute backends across sub-batches, using varied tracking algorithms across sub-batches or modifying any other configuration that is supported in low-level tracker configuration file. More detailed example use-cases are discussed in Setup and Usage of Sub-batching (Alpha) section.", "keywords": []}, {"id": 3059, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#target-management-and-error-handling", "display_name": "Target Management and Error Handling", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "target-management-and-error-handling", "priority": -1, "content": "Although a new object is detected by the detector (i.e., a detector object), there is a possibility that this may be a false positive. To suppress such noise in detection, the NvMultiObjectTracker tracker library employs a technique called Late Activation , where a newly detected object is examined for a period of time and activated for long-term tracking only if it survives such a period. To be more specific, whenever a new object is detected, a new tracker is created to track the object, but the target is initially put into the Tentative mode, which is a probationary period, whose length is defined by probationAge under TargetManagement section of the config file. During this probationary period, the tracker output will not be reported to the downstream, since the target is not validated yet; however, those unreported tracker output data (i.e., the past-frame data ) are stored within the low-level tracker for later report. The same target may be detected for the next frame; however, there could be false negative by the detector (i.e., missed detection), resulting in a unsuccessful data association to the target. The NvMultiObjectTracker library employs another technique called Shadow Tracking , where a target is still being tracked in the background for a period of time even when the target is not associated with a detector object. Whenever a target is not associated with a detector object for a given time frame, an internal variable of the target called shadowTrackingAge is incremented. Once the target is associated with a detector object, then shadowTrackingAge will be reset to zero. If the target is in the Tentative mode and the shadowTrackingAge reaches earlyTerminationAge specified in the config file, the target will be terminated prematurely (which is referred to as Early Termination ). If the target is not terminated during the Tentative mode and successfully assocciated with a detector object, the target is activated and put into the Active mode, starting to report the tracker outputs to the downstream. If the past-frame data is enabled, the tracked data during the Tentative mode will be reported as well, since they were not reported yet. Once a target is activated (i.e., in Active mode), if the target is not associated for a given time frame (or the tracker confidence gets lower than a threshold), it will be put into the Inactive mode, and its shadowTrackingAge will be incremented, yet still be tracked in the background. However, the target will be terminated if the shadowTrackingAge exceeds maxShadowTrackingAge . The state transitions of a target tracker are summarized in the following diagram: The NvMultiObjectTracker library can generate a unique ID to some extent. If enabled by setting useUniqueID: 1 , each video stream will be assigned a 32-bit long random number during the initialization stage. All the targets created from the same video stream will have the same upper 32-bit of the uint64_t -type target ID set by the per-stream random number. In the meantime, the lower 32-bit of the target ID starts from 0. The randomly generated upper 32-bit number allows the target IDs from a particular video stream to increment from a random position in the possible ID space. If disabled (i.e., useUniqueID: 0 , which is the default value), both the upper and lower 32-bit will start from 0, resulting in the target ID to be incremented from 0 for every run. Note that the incrementation of the lower 32-bit of the target ID is done across the whole video streams in the same NvMultiObjectTracker library instantiation. Thus, even if the unique ID generation is disabled, the tracker IDs will be unique for the same pipeline run. If the unique ID generation is disabled, and if there are three objects for Stream 1 and two objects for Stream 2, for example, the target IDs will be assigned from 0 to 4 (instead of 0 to 2 for Stream 1 and 0 to 1 for Stream 2) as long as the two streams are being processed by the same library instantiation. preserveStreamUpdateOrder controls whether to use single or multiple threads to update targets. If it is enabled, new IDs are generated sequentially following input stream ID order in each batch using a single thread, i.e. the objects for Stream 1 and 2 will have IDs from 0 to 2 and 3 to 4 respectively. By default, this option is disabled so target management is done with multi-threads to enable better performance but the ID order is not preserved. If the user needs consistent IDs over multiple runs for the same video source, please set preserveStreamUpdateOrder: 1 and batched-push-timeout=-1 in deepstream-app config. The NvMultiObjectTracker library pre-allocates all the GPU memories during initialization based on: The number of streams to be processed The maximum number of objects to be tracked per stream (denoted as maxTargetsPerStream ) Thus, the CPU/GPU memory usage by the NvMultiObjectTracker library is almost linearly proportional to the total number of objects being tracked, which is (number of video streams) \u00d7 (maxTargetsPerStream) , except the scratch memory space used by dependent libraries (such as cuFFT\u2122, TensorRT\u2122, etc.). Thanks to the pre-allocation of all the necessary memory, the NvMultiObjectTracker library is not expected to have memory growth during long-term run even when the number of objects increases over time. Once the number of objects being tracked reaches the configured maximum value (i.e., maxTargetsPerStream ), any new objects will be discarded until some of the existing targets are terminated. Note that the number of objects being tracked includes the targets that are being tracked in the shadow tracking mode. Therefore, NVIDIA recommends that users set maxTargetsPerStream large enough to accommodate the maximum number of objects of interest that may appear in a frame, as well as the objects that may have been tracked from the past frames in the shadow tracking mode. The minDetectorConfidence property under BaseConfig section in a low-level tracker config file sets the confidence level below which the detector objects are filtered out.", "keywords": []}, {"id": 3060, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#target-re-association", "display_name": "Target Re-Association", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "target-re-association", "priority": -1, "content": "The target re-association algorithm enhances the long-term robustness of multi-object tracking by jointly using the Re-ID and spatio-temporal (i.e., motion) features. It addresses one of the major tracking failure cases that occurs in the situation where objects undergo partial- or full-occlusions in a gradual or abrupt manner. During this course of action, the detector at PGIE module may capture only some part of the objects (due to partial visibility), resulting in ill-sized, ill-centered boxes on the target. Later, the target cannot be associated with the object appearing again due to the size and location prediction errors, potentially causing tracking failures and ID switches. Such a re-association problem can typically be handled as a post-processing; however, for real-time analytics applications, this is often expected to be handled seamlessly as a part of the real-time multi-object tracking. The target re-association takes advantage of the Late Activation and Shadow Tracking in target management module. It tries to associate the newly-appeared targets with previously lost targets based on motion and Re-ID similarity in a seamless, real-time manner by the following steps: Tracklet Prediction : Whenever an existing target is not associated with a detector object for a prolonged period (same as probationAge ), it is considered that the target is lost. While the visual tracker module keeps track of the target in the shadow tracking mode, a length of the predicted tracklet (configured by trajectoryProjectionLength ) is generated using some of the recently matched tracklet points (whose length is set by prepLength4TrajectoryProjection ) and stored into an internal database until it is matched again with a detector object or re-associated with another target. Re-ID Feature Extraction : Before a target is lost, the Re-ID network extracts its Re-ID feature with the frame interval of reidExtractionInterval and stores them in the feature gallery. These features will be used to identify target re-appearance in the tracklet matching stage. Target ID Acquisition : When a new target is instantiated, its validity is examined for a few frames (i.e., probationAge ) and a target ID is assigned only if validated (i.e., Late Activation), after which the target state report starts. During the target ID acquisition, the new target is examined if it matches with one of the predicted tracklets from the existing targets in the internal database where the aforementioned predicted tracklets are stored. If matched, it would mean that the new target is actually the re-appearance of a disappeared target in the past. Then, the new target is re-associated with the existing target and its tracklet is fused into that as well. Otherwise, a new target ID is assigned. Tracklet Matching : During the tracklet matching process in the previous step, the valid candidate tracklets are queried from the database based on the feasible time window configured by maxTrackletMatchingTimeSearchRange . For the new target and each candidate, both the motion and Re-ID similarity are taken into account for tracklet matching. The motion similarity is the average IOU along the tracklet with various criteria including the minimum average IOU score (i.e., minTrackletMatchingScore ), maximum angular difference in motion (i.e., maxAngle4TrackletMatching ), minimum speed similarity (i.e., minSpeedSimilarity4TrackletMatching ), and minimum bbox size similarity (i.e., minBboxSizeSimilarity4TrackletMatching ) computed by a Dynamic Time Warping (DTW)-like algorithm. The Re-ID similarity is the cosine distance between the new target\u2019s Re-ID feature and its nearest neighbor in the candidate\u2019s feature gallery. The total similarity score is the weighted sum of both metrics: totalScore=w_1*IOU+w_2*reidSimilarity where w_i is the weight for each metric set in config file. Users can also set a minimum threshold for each similarity and the total score. Tracklet Fusion : Once two tracklets are associated, they are fused together to generate one smooth tracklet based on the matching status with detector and the confidence at each point. config_tracker_NvDCF_accuracy.yml provides an example to enable this feature. Since Re-ID is computationally expensive, users may choose to increase reidExtractionInterval to improve performance or set the parameters like below (i.e., disabling Re-ID feature extraction) to use motion-only target re-association without Re-ID. TrajectoryManagement: useUniqueID: 0 # Use 64-bit long Unique ID when assignining tracker ID. Default is [true] enableReAssoc: 1 # Enable Re-Assoc minMatchingScore4Overall: 0 # min matching score for overall minTrackletMatchingScore: 0.5644 # min tracklet similarity score for re-assoc matchingScoreWeight4TrackletSimilarity: 1.0 # weight for tracklet similarity score minTrajectoryLength4Projection: 36 # min trajectory length required to make projected trajectory prepLength4TrajectoryProjection: 50 # the length of the trajectory during which the state estimator is updated to make projections trajectoryProjectionLength: 94 # the length of the projected trajectory maxAngle4TrackletMatching: 106 # max angle difference for tracklet matching [degree] minSpeedSimilarity4TrackletMatching: 0.0967 # min speed similarity for tracklet matching minBboxSizeSimilarity4TrackletMatching: 0.5577 # min bbox size similarity for tracklet matching maxTrackletMatchingTimeSearchRange: 20 # the search space in time for max tracklet similarity trajectoryProjectionProcessNoiseScale: 0.0100 # trajectory projector&#x27;s process noise scale w.r.t. state estimator trajectoryProjectionMeasurementNoiseScale: 100 # trajectory projector&#x27;s measurement noise scale w.r.t. state estimator trackletSpacialSearchRegionScale: 0.2598 # the search region scale for peer tracklet ReID: reidType: 0 # The type of reid among { DUMMY=0, NvDEEPSORT=1, Reid based reassoc=2, both NvDEEPSORT and reid based reassoc=3} Target re-association can be effective only when the state estimator is enabled, otherwise the tracklet prediction will not be made properly. The parameters provided above is tuned for PeopleNet v2.6.2, and it may not work as expected for other types of detectors.", "keywords": []}, {"id": 3061, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#terminated-track-list", "display_name": "Terminated Track List", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "terminated-track-list", "priority": -1, "content": "Whenever a target is terminated, the full target trajectory data can be exported to the metadata as part of the miscellaneous data, which is populated in NvDsTargetMiscDataBatch data structure. This data not only informs of the termination event of a target, but also can be useful for a downstream module that performs trajectory-based analysis for each object. The terminated track list can be saved in a file in either deepstream-app or within the low-level tracker library: (Option 1) Saving output in deepstream-app : Add outputTerminatedTracks: 1 in tracker config TargetManagement section Add terminated-track-output-dir=&lt;dir name&gt; in deepstream-app config\u2019s application group properties create the folder &lt;dir name&gt; Run deepstream-app to save the terminated track history into text files in &lt;dir name&gt; Data format is defined below. frame number object unique id class id blank blank bbox left bbox top bbox right bbox bottom blank blank blank blank blank blank blank confidence tracker state visibility unsigned int long unsigned int unsigned int int float float float float float float float float float float float float float int float A file will be created for each frame in each stream. Sample data is like: 0 7 2 0 0.0 1535.194092 94.266541 1603.132812 301.653625 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.000000 2 1.000000 1 7 2 0 0.0 1535.938232 94.234810 1603.121338 301.769501 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.982758 2 1.000000 ... (Option 2) Saving output directly from low level tracker: Add outputTerminatedTracks: 1 in tracker config TargetManagement section Add terminatedTrackFilename: &lt;file name prefix&gt; in tracker config TargetManagement section. For example, set terminatedTrackFilename: track_dump and the saved file names will be track_dump_0.txt , track_dump_1.txt , etc. Run deepstream-app to save the terminated track information directly from the low-level tracker library Data format is defined below. The foot location, and convex hull data are only useful if SV3DT output is enabled. frame number(starting from 1) object unique id bbox left bbox top bbox right bbox bottom confidence Foot World Position X Foot World Position Y blank class id tracker state visibility Foot Image Position X Foot Image Position Y ConvexHull Points (optional) unsigned int long unsigned int int int int int float float float int unsigned int int float float float int separated by vertical bar A file will be created for each stream. Sample data is like: # SV3DT output disabled 31,48,558,104,31,74,0.949,-1.000,-1.000,-1,0,0.994,-1,-1 32,48,558,104,31,74,0.951,-1.000,-1.000,-1,0,0.995,-1,-1 ... # SV3DT output enabled 31,48,558,104,31,74,0.949,1254.535,2962.867,-1,0,0.994,581,176,-15|-34|-14|-35|-13|-35|-10|-36|-6|-36|-3|-36|0|-36|1|-36|2|-35|16|35|15|35|13|36|9|37|6|37|3|37|0|37|0|36 32,48,558,104,31,74,0.951,1255.602,2968.294,-1,0,0.995,581,176,-14|-34|-14|-35|-13|-35|-10|-35|-6|-36|-3|-36|0|-36|1|-36|2|-35|15|35|15|35|13|36|9|37|6|37|3|37|0|37|0|36 ...", "keywords": []}, {"id": 3062, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#the-3x4-camera-projection-matrix", "display_name": "The 3x4 Camera Projection Matrix", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "the-3x4-camera-projection-matrix", "priority": -1, "content": "The 3x4 Camera Projection Matrix is also called as simply the camera matrix, which is a 3x4 matrix that converts a 3D world point to a 2D point on camera image plane based on a pinhole camera model like shown in the figure below: Pinhole Camera Model. Source: OpenCV Doc and License More detailed and general information about the camera matrix can be found in various sources that deal with the computer vision geometries and camera calibration, including OpenCV\u2019s documentation on Camera Calibration . For projectionMatrix_3x4 in a camera model file (e.g., camInfo-01.yml ), the principal point (i.e., (Cx, Cy) ) in the camera matrix is assumed to be at (0, 0) as image coordinates. But, the optical center (i.e., (Cx, Cy) ) is located at the image center (i.e., (img_width/2, img_height/2) ). Thus, to move the origin to the left-top of the camera image (i.e., the pixel coordinates), SV3DT internally adds (img_width/2, img_height/2) after the transformation using the camera matrix provided in projectionMatrix_3x4 . In case that the 3x4 camera projection matrix already accounts for such translation of the principal point, users can provide the camera matrix in projectionMatrix_3x4_w2p instead. This assumes that the 3x4 camera projection matrix transforms a 3D world point directly into an actual pixel point whose origin is at the left-top corner of the image, so it does not require any further translation of the principal point.", "keywords": []}, {"id": 3063, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#tracker-accuracy-tuning", "display_name": "Tracker Accuracy Tuning", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "tracker-accuracy-tuning", "priority": -1, "content": "Tracker sample pipelines demonstrated in above section include lots of detector and tracker parameters optimized for people tracking. When users deploy such pipelines for other scenarios, such as traffic, animals, etc., a pain point is how to find the optimal parameters with the highest accuracy KPI for each use case. Manual parameter tuning requires in-depth knowledge on the tracker algorithm and how each parameter would affect the functionality. Given the large number of parameters, the complexity of such process would increase exponentially. Starting from DeepStream 7.0, a new tool PipeTuner is released to allow automatic accuracy tuning. It efficiently explores the (potentially very high-dimensional) parameter space and automatically finds the optimal parameters for the pipelines, which yields the highest KPI on the dataset. Base on their use case, users can tune the tracker on public multi-object tracking datasets, such as MOT Challenge , KITTI , or create their own dataset with sample videos and ground truth (bounding box and object ID). Users can select common tracking accuracy metrics including HOTA , MOTA and IDF1 as the KPI. Visit Accuracy Tuning Tools on how to setup PipeTuner and start DeepStream tracker accuracy tuning.", "keywords": []}, {"id": 3064, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#trafficcamnet-nvdcf", "display_name": "TrafficCamNet + NvDCF", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "trafficcamnet-nvdcf", "priority": -1, "content": "This pipeline performs more accurate vehicle tracking. For the output visualization, a deepstream-app pipeline is first constructed with the following components: Detector : TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvDCF with configuration as below. No vehicle Re-ID models are included in DeepStream so far, so the user needs to follow Customize Re-ID Model to setup a vehicle Re-ID model and change ReID section in tracker config. The detector and tracker config files: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/trafficcamnet/trafficcamnet_int8.txt labelfile-path=../../models/trafficcamnet/labels.txt tlt-encoded-model=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.etlt tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 uff-input-blob-name=input_1 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=4 interval=0 gie-unique-id=1 output-blob-names=output_cov/Sigmoid;output_bbox/BiasAdd ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=0 [class-attrs-all] pre-cluster-threshold=0.3034 nms-iou-threshold=0.5002 minBoxes=3 dbscan-min-score=1.2998 eps=0.1508 detected-min-w=20 detected-min-h=20 %YAML:1.0 BaseConfig: minDetectorConfidence: 0.0382 TargetManagement: enableBboxUnClipping: 0 preserveStreamUpdateOrder: 0 maxTargetsPerStream: 150 minIouDiff4NewTarget: 0.1356 minTrackerConfidence: 0.2136 probationAge: 1 maxShadowTrackingAge: 49 earlyTerminationAge: 1 TrajectoryManagement: useUniqueID: 0 enableReAssoc: 1 minMatchingScore4Overall: 0.0324 minTrackletMatchingScore: 0.2979 minMatchingScore4ReidSimilarity: 0.4329 matchingScoreWeight4TrackletSimilarity: 0.5117 matchingScoreWeight4ReidSimilarity: 0.8356 minTrajectoryLength4Projection: 14 prepLength4TrajectoryProjection: 50 trajectoryProjectionLength: 116 maxAngle4TrackletMatching: 180 minSpeedSimilarity4TrackletMatching: 0 minBboxSizeSimilarity4TrackletMatching: 0.2154 maxTrackletMatchingTimeSearchRange: 16 trajectoryProjectionProcessNoiseScale: 0.0100 trajectoryProjectionMeasurementNoiseScale: 100 trackletSpacialSearchRegionScale: 0.0742 reidExtractionInterval: 2 enableVanishingTrackletReconstruction: 0 minInclusionRatio4DuplicateTrackletRemoval: 0.5705 minIou4DuplicateTrackletRemoval: 0.5260 minMatchRatio4ValidTrackletDetermination: 0.4385 minVisibility4VanishingTrackletReconstruction: 0.3485 visibilityThreshold4VanishingTrackletDetection: 0.5817 DataAssociator: dataAssociatorType: 0 associationMatcherType: 1 checkClassMatch: 1 minMatchingScore4Overall: 0.1103 minMatchingScore4SizeSimilarity: 0.0392 minMatchingScore4Iou: 0.0980 minMatchingScore4VisualSimilarity: 0.3234 matchingScoreWeight4VisualSimilarity: 0.4223 matchingScoreWeight4SizeSimilarity: 0.8416 matchingScoreWeight4Iou: 0.6517 tentativeDetectorConfidence: 0.0198 minMatchingScore4TentativeIou: 0.1844 StateEstimator: stateEstimatorType: 1 processNoiseVar4Loc: 374.6508 processNoiseVar4Size: 3364.1350 processNoiseVar4Vel: 3.6082 measurementNoiseVar4Detector: 164.4517 measurementNoiseVar4Tracker: 3439.5683 VisualTracker: visualTrackerType: 1 useColorNames: 1 useHog: 1 featureImgSizeLevel: 4 featureFocusOffsetFactor_y: 0.0652 filterLr: 0.0993 filterChannelWeightsLr: 0.0549 gaussianSigma: 0.9047 ReID: # need customization reidType: 2 batchSize: 100 workspaceSize: 1000 reidFeatureSize: 128 reidHistorySize: 148 inferDims: [128, 64, 3] networkMode: 0 inputOrder: 1 colorFormat: 0 offsets: [0.0, 0.0, 0.0] netScaleFactor: 1.0000 keepAspc: 1 # onnxFile: customize_onnx_path Below is a side-by-side comparison of TrafficCamNet with different trackers on a challenging scene with lots of occlusions. From the top-left corner in the clockwise direction are detection only, NvSORT, NvDeepSORT, and NvDCF results. NvDCF has the highest tracking accuracy and robustness to occlusion.", "keywords": []}, {"id": 3065, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#trafficcamnet-nvdeepsort", "display_name": "TrafficCamNet + NvDeepSORT", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "trafficcamnet-nvdeepsort", "priority": -1, "content": "This pipeline enables vehicle Re-ID capability during tracking. Such a deepstream-app pipeline is constructed with the following components: Detector : TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvDeepSORT with configuration as below. No vehicle Re-ID models are included in DeepStream so far, so the user needs to follow Customize Re-ID Model to setup a vehicle Re-ID model and change ReID section in tracker config. The detector and tracker config files: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned_int8.txt labelfile-path=../../models/trafficcamnet/labels.txt onnx-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.onnx tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=4 interval=0 gie-unique-id=1 ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=0 [class-attrs-all] pre-cluster-threshold=0.1654 nms-iou-threshold=0.7614 minBoxes=3 dbscan-min-score=2.4240 eps=0.3615 detected-min-w=20 detected-min-h=20 %YAML:1.0 BaseConfig: minDetectorConfidence: 0.0451 TargetManagement: preserveStreamUpdateOrder: 0 maxTargetsPerStream: 150 minIouDiff4NewTarget: 0.0602 minTrackerConfidence: 0.7312 probationAge: 9 maxShadowTrackingAge: 59 earlyTerminationAge: 1 TrajectoryManagement: useUniqueID: 0 DataAssociator: dataAssociatorType: 0 associationMatcherType: 1 checkClassMatch: 1 thresholdMahalanobis: 34.3052 minMatchingScore4Overall: 0.0231 minMatchingScore4SizeSimilarity: 0.3104 minMatchingScore4Iou: 0.3280 minMatchingScore4ReidSimilarity: 0.6805 matchingScoreWeight4SizeSimilarity: 0.7103 matchingScoreWeight4Iou: 0.5429 matchingScoreWeight4ReidSimilarity: 0.6408 tentativeDetectorConfidence: 0.0483 minMatchingScore4TentativeIou: 0.5093 StateEstimator: stateEstimatorType: 2 noiseWeightVar4Loc: 0.0739 noiseWeightVar4Vel: 0.0097 useAspectRatio: 1 ReID: # need customization reidType: 1 batchSize: 100 workspaceSize: 1000 reidFeatureSize: 128 reidHistorySize: 100 inferDims: [128, 64, 3] networkMode: 0 inputOrder: 1 colorFormat: 0 offsets: [0.0, 0.0, 0.0] netScaleFactor: 1.0000 keepAspc: 1 # custom Re-ID model path", "keywords": []}, {"id": 3066, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#trafficcamnet-nvsort", "display_name": "TrafficCamNet + NvSORT", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "trafficcamnet-nvsort", "priority": -1, "content": "This pipeline performs high performance vehicle tracking with reasonable accuracy. Such a deepstream-app pipeline is constructed with the following components: Detector : TrafficCamNet v1.0.3 (w/ ResNet-18 as backbone) Post-processing algorithm for object detection: Hybrid clustering (i.e., DBSCAN + NMS) Tracker : NvSORT with configuration as below The detector and tracker config files: [property] ## model-specific params. The paths will be different if the user sets up in different directory. int8-calib-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned_int8.txt labelfile-path=../../models/trafficcamnet/labels.txt onnx-file=../../models/trafficcamnet/resnet18_trafficcamnet_pruned.onnx tlt-model-key=tlt_encode gpu-id=0 net-scale-factor=0.00392156862745098 input-dims=3;544;960 process-mode=1 model-color-format=0 ## 0=FP32, 1=INT8, 2=FP16 mode network-mode=1 num-detected-classes=4 interval=0 gie-unique-id=1 ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode=3 maintain-aspect-ratio=0 [class-attrs-all] pre-cluster-threshold=0.2327 nms-iou-threshold=0.1760 minBoxes=2 dbscan-min-score=0.7062 eps=0.4807 detected-min-w=20 detected-min-h=20 %YAML:1.0 BaseConfig: minDetectorConfidence: 0.0415 TargetManagement: enableBboxUnClipping: 0 maxTargetsPerStream: 300 minIouDiff4NewTarget: 0.6974 minTrackerConfidence: 0.8049 probationAge: 5 maxShadowTrackingAge: 42 earlyTerminationAge: 1 TrajectoryManagement: useUniqueID: 0 DataAssociator: dataAssociatorType: 0 associationMatcherType: 1 checkClassMatch: 1 minMatchingScore4Overall: 0.2042 minMatchingScore4SizeSimilarity: 0.2607 minMatchingScore4Iou: 0.3708 matchingScoreWeight4SizeSimilarity: 0.2639 matchingScoreWeight4Iou: 0.4384 tentativeDetectorConfidence: 0.1054 minMatchingScore4TentativeIou: 0.4953 usePrediction4Assoc: 1 StateEstimator: stateEstimatorType: 2 noiseWeightVar4Loc: 0.0853 noiseWeightVar4Vel: 0.0061 useAspectRatio: 1", "keywords": []}, {"id": 3067, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#unified-tracker-architecture-for-composable-multi-object-tracker", "display_name": "Unified Tracker Architecture for Composable Multi-Object Tracker", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "unified-tracker-architecture-for-composable-multi-object-tracker", "priority": -1, "content": "In NvMultiObjectTracker low-level tracker library, different types of multi-object trackers share common modules when it comes to basic functionalities (e.g., data association, target management, state estimation, etc.), while differing in other core functionalities (e.g., visual tracking for NvDCF and deep association metric for NvDeepSORT). The NvMultiObjectTracker library employs a unified architecture to allow the composition of a multi-object tracker through configuration by enabling only the modules required for a particular object tracker. The IOU tracker, for example, requires a minimum set of modules that consist of data association and target management modules. On top of that, NvSORT adds a state estimator for more accurate motion estimation &amp; prediction, and NvDeepSORT further introduces a deep Re-ID network to integrate appearance information into data association. Instead of the deep neural network-based Re-ID features in NvDeepSORT, NvDCF employs a Discriminative Correlation Filter (DCF)-based visual tracking module that uses conventional feature descriptors for more efficient tracking. However, NvDCF can still allow the use of Re-ID module for target re-association for longer-term robustness. The table below summarizes what modules are used to compose each object tracker, showing what modules are shared across different object trackers and how each object tracker differs in module composition: Tracker Type State Estimator Target Management Visual Tracker Target Re-Association Data Association Metric Spatio- temporal Re-ID Proximity &amp; Size Visual Similarity Re-ID IOU O O NvSORT O O O NvDeepSORT O O O O NvDCF O O O O O O O In the following sections, we will first discuss the general work flow of the NvMultiObjectTracker library and its core modules, and then each type of object trackers in more details with explanations on the config params in each module.", "keywords": []}, {"id": 3068, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#use-case-1", "display_name": "Use-case 1", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "use-case-1", "priority": -1, "content": "This use-case illustrates an application with a batch size of 4 (i.e., 4 streams). The batch is split into 3 sub-batches: the first sub-batch of size 2 and the next two sub-batches of size 1 each. The first sub-batch uses NvDCF tracker, the second sub-batch uses NvSORT tracker, and the third sub-batch uses IOU tracker, respectively. To achieve this, modify the [tracker] section in source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt configuration file that comes with DeepStream package as shown below : [tracker] enable=1 tracker-width=960 tracker-height=544 ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so ll-config-file=config_tracker_NvDCF_accuracy.yml;config_tracker_NvSORT.yml;config_tracker_IOU.yml sub-batches=0,1;2;3 In this example, sub-batches can also be configured using option 2 i.e. sub-batches=2:1:1 . Refer Gst Properties for details.", "keywords": []}, {"id": 3069, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#use-case-2", "display_name": "Use-case 2", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "use-case-2", "priority": -1, "content": "This use-case illustrates an application with a batch size of 4, where the batch is split into 2 sub-batches each of size 2: the first sub-batch uses NvDCF tracker with setting visualTrackerType: 1 (i.e., existing DCF module). The second sub-batch uses NvDCF tracker with visualTrackerType: 2 and vpiBackend4DcfTracker: 2 (i.e. NvDCF_VPI tracker with PVA backend). Please note that, since this use-case configures PVA backend, it will run only on Jetson platforms. Steps are : Create a copy of config_tracker_NvDCF_accuracy.yml and name it as config_tracker_NvDCF_accuracy_PVA.yml In config_tracker_NvDCF_accuracy_PVA.yml modify the VisualTracker: section as follows : VisualTracker: visualTrackerType: 2 # the type of visual tracker among { DUMMY=0, NvDCF=1, NvDCF_VPI=2 } vpiBackend4DcfTracker: 2 # the type of compute backend among {CUDA=1, PVA=2} .... Then modify the [tracker] section in source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt as follows : [tracker] enable=1 tracker-width=960 tracker-height=544 ll-lib-file=/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so ll-config-file=config_tracker_NvDCF_accuracy.yml;config_tracker_NvDCF_accuracy_PVA.yml sub-batches=0,1;2,3 In this example, sub-batches can also be configured using option 2 i.e. sub-batches=2:2 . Refer Gst Properties for details. For further details on implementation of sub-batches feature, please refer to a writeup at the end of nvtracker_proc.cpp in nvtracker plugin\u2019s source code. The most optimal sub-batches configuration for a pipeline depends on multiple factors like elements in the pipeline, configuration of each element, hardware configuration etc. Increasing the number of sub-batches parallelizes the processing of streams in a batch. But it also adds an overhead. Hence, the number of sub-batches to configure needs to be determined experimentally by comparing GPU/PVA utilization and performance across various sub-batches configurations. A thumb rule is to start with a single batch and keep splitting it into sub-batches until an optimal performance point is reached.", "keywords": []}, {"id": 3070, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#vehicle-tracking", "display_name": "Vehicle Tracking", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "vehicle-tracking", "priority": -1, "content": "To perform tracking of vehicle and other types of targets (such as pedestrians, bicycles and road signs), a NVIDIA\u00ae pre-trained detector model is available in NGC: TrafficCamNet : A newer model based on ResNet-18 backbone with higher detection accuracy on NVIDIA NGC . The following samples demonstrate using TrafficCamNet and various trackers with different detection intervals for performance and accuracy tradeoff.", "keywords": []}, {"id": 3071, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#visual-tracking", "display_name": "Visual Tracking", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "visual-tracking", "priority": -1, "content": "For each tracked target, NvDCF tracker defines a search region around its predicted location in the next frame large enough for the same target to be detected in the search region. The location of a target on a new video frame is predicted by using the state estimator module. The searchRegionPaddingScale property determines the size of the search region as a multiple of the diagonal of the target\u2019s bounding box. The size of the search region would be determined as: SearchRegion_{width}=w+searchRegionPaddingScale*\\sqrt{w*h} SearchRegion_{height}=h+searchRegionPaddingScale*\\sqrt{w*h} , where w and h are the width and height of the target\u2019s bounding box, respectively. Once the search region is defined for each target at its predicted location, the image patches from each of the search regions are cropped and scaled to a predefined feature image size, from which the visual features are extracted. The featureImgSizeLevel property defines the size of the feature image, and its range is from 1 to 5. Each level between 1 and 5 corresponds to 12x12, 18x18, 24x24, 30x30, and 36x36, respectively, for each feature channel. A lower value of featureImgSizeLevel causes NvDCF to use a smaller feature size, increasing GPU performance potentially yet at the cost of accuracy and robustness. Consider the relationship between featureImgSizeLevel and searchRegionPaddingScale when configuring the parameters. If searchRegionPaddingScale is increased while featureImgSizeLevel is fixed, the number of pixels corresponding to the target itself in the feature images will be effectively decreased. For each cropped image patch, the visual appearance features such as ColorNames and/or Histogram-of-Oriented-Gradient (HOG) are extracted. The type of visual features to be used can be configured by setting useColorNames and/or useHog . The HOG features consist of 18 channels based on the number of bins for different orientations, while The ColorNames features have 10 channels. If both features are used (by setting useColorNames: 1 and useHog: 1 ), the total number of channels would then be 28. Therefore, if one uses both HOG and ColorNames with featureImgSizeLevel: 5 , the dimension of visual features that represents a target would be 28x48x48. The more channels of visual features are used, the higher the accuracy would be, but would increase the computational complexity and reduce the performance. The NvDCF tracker uses NVIDIA\u2019s VPI\u2122 library for extracting those visual features. The correlation filters are generated with an attention window (using a Hanning window) applied at the center of the target bbox . Users are allowed to move the center of the attention window in the vertical direction. For example, featureFocusOffsetFactor_y: -0.2 would result in the center of the attention window to be at y=-0.2 in the feature map, where the relative range of the height is [-0.5, 0.5] . Consider that typical surveillance or CCTV cameras are mounted at a moderately high position to monitor a wide area of the environment, say, a retail store or a traffic intersection. From those vantage points, more occlusions can occur at the lower part of the body of persons or vehicles by other persons or vehicles. Moving the attention window up a bit may improve the accuracy and robustness for those use cases. Once a correlation filter is generated for a target, typical DCF-based trackers usually employ an exponential moving average for temporal consistency when the optimal correlation filter is created and updated over consecutive frames. The learning rate for this moving average can be configured by filterLr and filterChannelWeightsLr for the correlation filters and their channel weights, respectively. The standard deviation for Gaussian for the desired response used when creating an optimal DCF filter can also be configured by gaussianSigma . Compute Backends Visual tracker module in NvDCF supports multiple compute backends: CUDA/GPU and PVA ( Programmable Vision Accelerator ). So, the users are allowed to use different compute backends depending on the particular use cases. PVA is an accelerator in Tegra SOC in NVIDIA\u2019s Jetson devices, which is specialized for image processing and computer vision algorithms with extremely low power consumption. When running DeepStream-based pipeline with tracker on Jetson, it is recommended to use the PVA-backend for DCF operations in NvDCF for better power efficiency. Since the GPU-based processing for DCF operations is offloaded onto PVA, therefore, more GPU resources are made available to the users for any downstream or custom processing that requires GPU-based processing. To employ PVA-backend, the visual tracker module leverages the APIs provided by NVIDIA\u2019s VPI\u2122 , which can be enabled by setting visualTrackerType: 2 (Alpha feature) and vpiBackend4DcfTracker: 2 # {CUDA=1, PVA=2} on Jetson platforms. VPI also has CUDA-backend mode, which can configured by setting vpiBackend4DcfTracker: 1 on any supported HW platforms (Jetson or dGPU platforms). The PVA-backend implementation of DCF operations by VPI\u2122 currently has the following limitations: The maximum number of objects that can be supported by a single instance of tracker library is 512. This translates to the following restrictions in DeepStream configuration: When sub-batching is not enabled, the total number of objects being tracked across all the streams (i.e., the number of streams in a batch * maxTargetsPerStream ) should be less than or equal to 512 When sub-batching is enabled, the total number of objects being tracked across all the streams in a sub-batch (i.e., the number of streams in a sub-batch * maxTargetsPerStream ) should be less than or equal to 512 If there are N sub-batches, the total number of objects that can be tracked in the pipeline is effectively N*512 . Supports only one combination of the these three configurations : useColorNames: 1 and useHog: 1 and featureImgSizeLevel: 3 Another limitation of the DCF APIs provided by VPI\u2122 is that, the max number of streams supported by a single library instance is 33. Hence, to run a DS application with higher batch size (&gt;33) using visualTrackerType: 2 , it is recommended to use Sub-batching feature in the tracker plugin such that each sub-batch is of size less than or equal to 33 streams.", "keywords": []}, {"id": 3072, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvtracker#workflow-and-core-modules-in-the-nvmultiobjecttracker-library", "display_name": "Workflow and Core Modules in The NvMultiObjectTracker Library", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "workflow-and-core-modules-in-the-nvmultiobjecttracker-library", "priority": -1, "content": "The input to a low-level tracker library consists of (1) a batch of video frames from a single or multiple streams and (2) a list of detector objects for each video frame. If the detection interval (i.e., interval in Primary GIE section) is set larger than 0, the input data to the low-level tracker would have the detector object data only when the inferencing for object detection is performed for a video frame batch (i.e., the inferenced frame batch). For the frame batches where the inference is skipped (i.e., the uninferenced frame batch), the input data would include only the video frames. A detector object refers to an object that is detected by the detector in PGIE module, which is provided to the multi-object tracker module as an input. A target refers to an object that is being tracked by the object tracker. An inferenced frame is a video frame where an inference is carried out for object detection. Since the inference interval can be configured in setting for PGIE and can be larger than zero, the frameNum of two consecutive inferenced frames may not be contiguous. For carrying out multi-object tracking operations with the given input data, below are the essential functionalities to be performed. Multithreading is deployed to optimize their performance on CPU. Data association between the detector objects from a new video frame and the existing targets for the same video stream Target management based on the data association results, including the target state update and the creation and termination of targets Depending on the tracker types, there could be some addition processing before data association. For example, NvDeepSORT extracts Re-ID features from all the detector objects and computes the similarity, while NvDCF performs the visual tracker based localization so the targets\u2019 predicted locations in a new frame can be used for data association. More details will be covered in each tracker\u2019s section.", "keywords": []}, {"id": 3073, "doc_id": 3073, "filename": "text/DS_plugin_gst-nvtracker.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvtracker", "display_name": "Gst-nvtracker", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvtracker", "anchor": "", "priority": -1, "content": "The Gst-nvtracker plugin allows the DS pipeline to use a low-level tracker library to track the detected objects over time persistently with unique IDs. It supports any low-level library that implements NvDsTracker API, including the reference implementations provided by the NvMultiObjectTracker library: IOU, NvSORT, NvDeepSORT and NvDCF trackers. As part of this API, the plugin queries the low-level library for capabilities and requirements concerning the input format, memory type, and additional feature support. Based on these queries, the plugin then converts the input frame buffers into the format requested by the low-level tracker library. For example, the NvDeepSORT and NvDCF trackers use NV12 or RGBA, while IOU and NvSORT requires no video frame buffers at all. Based on the queries, the Gst-nvtracker plugin constructs the input data to the low-level tracker library, which consists of video frames and detected objects across multiple streams that are fed to the low-level library in a single data structure (i.e, a frame batch) through a single API call. This API design allows all the input data from multiple streams in the low-level tracker library processed in a batched processing mode (similar to the batch mode in cuFFT\u2122 , cuBLAS\u2122 , etc.) for potentially more efficient execution especially when accelerated on GPU. There for, it is required that the low-level tracker supports batch processing when using NvMOT_Process API. The Gst-nvtracker plugin supports retrieval of the user-defined miscellaneous data from the low-level tracker library through NvMOT_RetrieveMiscData API, which includes useful object tracking information other than the default data for the current frame targets; for example, past-frame object data, targets in shadow tracking mode, full trajectory of terminated targets and re-identification features. More details on the types of miscellaneous data and what they means can be found in Miscellaneous Data Output section. The users are allowed to define other types of miscellaneous data in NvMOTTrackerMiscData . More details on all these tracker APIs is discussed in NvDsTracker API for Low-Level Tracker Library section. The plugin accepts NV12- or RGBA-formatted frame data from the upstream component and scales (and/or converts) the input buffer to a buffer in the tracker plugin based on the format required by the low-level library, with the frame resolution specified by tracker-width and tracker-height in the configuration file\u2019s [tracker] section. The path to the low-level tracker library is to be specified via ll-lib-file configuration option in the same section. The low-level library to be used may also require its own configuration file, which can be specified via ll-config-file option. If ll-config-file is not specified, the low-level tracker library may proceed with its default parameter values. The reference low-level tracker implementations provided by the NvMultiObjectTracker library support various types of multi-object tracking algorithms: IOU Tracker : The Intersection-Over-Union (IOU) tracker uses the IOU values among the detector\u2019s bounding boxes between the two consecutive frames to perform the association between them or assign a new target ID if no match found. This tracker includes a logic to handle false positives and false negatives from the object detector; however, this can be considered as the bare-minimum object tracker, which may serve as a baseline only. NvSORT : The NvSORT tracker is the NVIDIA\u00ae-enhanced Simple Online and Realtime Tracking (SORT) algorithm. Instead of a simple bipartite matching algorithm, NvSORT uses a cascaded data association based on bounding box (bbox) proximity for associating bboxes over consecutive frames and applies a Kalman filter to update the target states. It is computationally efficient since it does not involve any pixel data processing. NvDeepSORT : The NvDeepSORT tracker is the NVIDIA\u00ae-enhanced Online and Realtime Tracking with a Deep Association Metric (DeepSORT) algorithm, which uses the deep cosine metric learning with a Re-ID neural network for data association of multiple objects over frames. This implementation allows users to use any Re-ID network as long as it is supported by NVIDIA\u2019s TensorRT\u2122 framework. NvDeepSORT also uses a cascaded data association instead of a simple bipartite matching. The implementation is also optimized for efficient processing on GPU. NvDCF : The NvDCF tracker is an online multi-object tracker that employs a discriminative correlation filter for visual object tracking, which allows independent object tracking even when detection results are not available. It uses the combination of the correlation filter responses and bounding box proximity for data association. More details on each algorithm and its implementation details can be found in NvMultiObjectTracker : A Reference Low-Level Tracker Library section. The source code of the Gst-nvtracker plugin is provided as a part of DeepStream SDK package under sources/gst-plugins/gst-nvtracker/ when installed on a system This is to allow users to make direct changes in the plugin whenever needed for their custom applications and also to show the users as to how the low-level libraries are managed and how the metadata is handled in the plugin.", "keywords": []}, {"id": 3074, "doc_id": 3077, "filename": "text/DS_plugin_gst-nvurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvurisrcbin#gst-properties-to-configure-nvurisrcbin", "display_name": "3.1 Gst Properties to configure nvurisrcbin", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvurisrcbin", "anchor": "gst-properties-to-configure-nvurisrcbin", "priority": -1, "content": "Property Meaning Type and Range Example Notes num-extra-surfaces Set extra decoder surfaces; Number of surfaces in addition to minimum decode surfaces given by the decoder Integer, 1 to 4,294,967,295 num-extra-surfaces=1 (default) gpu-id Set GPU Device ID used by nvurisrcbin components like decoder (nvv4l2decoder) and nvvideoconvert Integer, 1 to 4,294,967,295 gpu-id=0 (default) cudadec-memtype Memory type for cuda decoder buffers, Memory type for CUDA decoder buffers. Represented internally by enum CudaDecMemType. 0 (memtype_device): Device 1 (memtype_pinned): Host Pinned 2 (memtype_unified): Unified Integer, 0, 1, or 2 cudadec-memtype=0 (default) drop-frame-interval Interval to drop the frames, e.g. a value of 5 means the decoder outputs every fifth frame, and others are dropped. Integer, 1 to 30 Default: 0, dGPU / Jetson dec-skip-frames Type of frames to skip during decoding. Represented internally by enum SkipFrame. 0 (decode_all): decode all frames 1 (decode_non_ref): skips non-ref frames (Applicable only on Jetson platform) 2 (decode_key): decode key frames Integer, 0, 1, or 2 skip-frames=0 Default: 0 ,dGPU / Jetson select-rtp-protocol Transport Protocol to use for RTP Enum RtpProtocol Default: 0, rtp-multi (0): rtp-multi - UDP + UDP Multicast + TCP (4): rtp-tcp - TCP Only select-rtp-protocol=0 (default) file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with \u2018 file:/ \u2019 boolean file-loop=false (default) rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0=disable timeout Integer, 1 to 4,294,967,295 rtsp-reconnect-interval=10 rtsp-reconnect-attempts Maximum number of times a reconnection is attempted. Setting it to -1 means reconnection will be attempted infinitely. Valid when type of source is 4 and rtsp-reconnect-interval-sec is a non-zero positive value. Integer, &gt;=-1 rtsp-reconnect-attempts=4 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Integer, 1 to 4,294,967,295 latency=100 (default) udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Integer, 1 to 4,294,967,295 udp-buffer-size=524288 (default) smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp (0):smart-rec-disable - Disable Smart Record (1):smart-rec-cloud - Trigger Smart Record through cloud messages only (2):smart-rec-multi - Trigger Smart Record through cloud and local events smart-record=0 (default) smart-rec-dir-path Path of directory to save the recorded file. string Absolute or relative path smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix string Absolute or relative path smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead Integer, 1 to 4,294,967,295 smart-rec-video-cache=0 (default) smart-rec-cache Size of cache in seconds, applies to both audio and video cache Integer, 1 to 4,294,967,295 smart-rec-cache=0 (default) smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp (0): smart-rec-mp4 - MP4 container (1): smart-rec-mkv - MKV container smart-rec-container=0 (default) smart-rec-mode Smart record mode (0):smart-rec-mode-av - Record audio and video if available (1):smart-rec-mode-video - Record video only if available (2):smart-rec-mode-audio - Record audio only if available smart-rec-mode=0 (default) smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Integer, 1 to 4,294,967,295 smart-rec-default-duration=20 (default) async-handling Boolean property so that will handle Asynchronous state changes boolean async-handling=true(default) disable-audio Disable audio path mode at init time boolean disable-audio=true(default) ipc-buffer-timestamp-copy Copy buffer timestamp for nvunixfdsrc plugin boolean ipc-buffer-timestamp-copy=false(default) ipc-connection-attempts Max number of attempts for connection (-1 = unlimited) Integer. Range: -1 - 2147483647 Default: -1 ipc-connection-attempts=-1(default) ipc-connection-interval connection interval between connection attempts in micro seconds Unsigned Integer64. Range: 0 - 18446744073709551615 ipc-connection-interval=1000000(default) ipc-socket-path The path to the control socket used to control the shared memory transport. This may be modified during the NULL-&gt;READY transition String ipc-socket-path=null(default) low-latency-mode Set low latency mode for bitstreams having I and IPPP frames on decoder boolean low-latency-mode=false(default) drop-on-latency Tells the jitterbuffer to never exceed the given latency in size boolean drop-on-latency=true(default) message-forward Forwards all children messages boolean message-forward=false(default)", "keywords": []}, {"id": 3075, "doc_id": 3077, "filename": "text/DS_plugin_gst-nvurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvurisrcbin#how-to-use-nvurisrcbin-in-a-pipeline", "display_name": "2. How to use nvurisrcbin in a pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvurisrcbin", "anchor": "how-to-use-nvurisrcbin-in-a-pipeline", "priority": -1, "content": "Below pipeline is a sample gstreamer pipeline which is configured to accept input source: gst-launch-1.0 nvurisrcbin \\ uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! \\ m.sink_0 nvstreammux name=m width=1280 height=720 batch-size=1 ! nvmultistreamtiler ! nveglglessink", "keywords": []}, {"id": 3076, "doc_id": 3077, "filename": "text/DS_plugin_gst-nvurisrcbin.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvurisrcbin#introduction", "display_name": "1. Introduction", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvurisrcbin", "anchor": "introduction", "priority": -1, "content": "This GstBin is a GStreamer source bin. This bin is a wrapper over uridecodebin with additional functionality of the file looping, rtsp reconnection and smart record. The bin allows users to create simple gstreamer pipelines for AI multimedia analytics. For more details on nvurisrcbin , please run gst-inspect-1.0 nvurisrcbin on a machine/docker container with DeepStream installed.", "keywords": []}, {"id": 3077, "doc_id": 3077, "filename": "text/DS_plugin_gst-nvurisrcbin.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvurisrcbin", "display_name": "Gst-nvurisrcbin", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvurisrcbin", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3078, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#decoder", "display_name": "Decoder", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "decoder", "priority": -1, "content": "The OSS Gst-nvvideo4linux2 plugin leverages the hardware decoding engines on Jetson and DGPU platforms by interfacing with libv4l2 plugins on those platforms. It supports H.264, H.265, AV1, JPEG and MJPEG formats. The plugin accepts an encoded bitstream and uses the NVDEC hardware engine to decode the bitstream. The decoded output can be NV12 or YUV444 format which depends on the encoded stream content. When you use the v4l2 decoder for decoding JPEG images, you must use the open source jpegparse plugin before the decoder to parse encoded JPEG images.", "keywords": []}, {"id": 3079, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#encoder", "display_name": "Encoder", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "encoder", "priority": -1, "content": "The OSS Gst-nvvideo4linux2 plugin leverages the hardware accelerated encoding engine available on Jetson and dGPU platforms by interfacing with libv4l2 plugins on those platforms. The plugin accepts RAW data in I420/NV12 or YUV444 format. It uses the NVENC hardware engine to encode RAW input. Encoded output is in elementary bitstream supported format. To set appropriate tuning-info-id and preset-id properties please refer to Nvidia Video Codec SDK Documentation at https://docs.nvidia.com/video-technologies/video-codec-sdk/11.1/nvenc-preset-migration-guide/index.html", "keywords": []}, {"id": 3080, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "features", "priority": -1, "content": "The following table summarizes the features of the Gst-nvvideo4linux2 decoder plugin. Feature Description Supports H.264 decode h264 encoded bitstream is decoded into 8bit NV12 Supports H.265 decode h265 encoded bitstream is decoded into 8/10/12 bit NV12 or 8/10/12 bit YUV444 depending on the stream content Supports JPEG/MJPEG decode \u2014 User-configurable CUDA memory type (Pinned/Device/Unified) for output buffers \u2014 10/12bit YUV444 format support is applicable only for x86/dGPU platforms. Also, for 12bit NV12 format, the output caps shows I420_12LE. But the data is handled as semiplanar 12 bit data. This is a workaround since gstreamer v1.16 does not have the particular caps for 12 bit NV12. Downstream component should process it considering as 12bit NV12 only.", "keywords": []}, {"id": 3081, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "gst-properties", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvvideo4linux2 decoder plugin. Property Meaning Type and Range Example/Notes Platforms capture-io-mode Capture I/O mode (matches src pad) (0): auto - GST_V4L2_IO_AUTO (2): mmap - GST_V4L2_IO_MMAP On dGPU: Enum \u201cGstNvV4l2IOMode\u201d On Jetson: Enum \u201cGstNvV4l2DecCaptureIOMode\u201d Default: 0 dGPU Jetson capture-buffer-dynamic-allocation Set to enable capture buffer dynamic allocation (0): cap_buf_dyn_alloc_disabled - Capture buffer dynamic allocation disabled (1): fw_cap_buf_dyn_alloc_enabled - Capture buffer dynamic allocation enabled for forward playback (2): rw_cap_buf_dyn_alloc_enabled - Capture buffer dynamic allocation enabled for reverse playback (3): fw_rw_cap_buf_dyn_alloc_enabled - Capture buffer dynamic allocation enabled for forward and reverse playback Enum \u201cCaptureBufferDynamicAllocationModes\u201d Default: 0 Jetson cudadec-memtype Memory type for CUDA decoder buffers. (0): memtype_device - Memory type Device (1): memtype_pinned - Memory type Host Pinned (2): memtype_unified - Memory type Unified Enum \u201cCudaDecMemType\u201d Default: 2 dGPU disable-dpb Set to disable DPB buffer for low latency Boolean Default: false Jetson drop-frame-interval Interval to drop the frames, e.g. a value of 5 means the decoder outputs every fifth frame, and others are dropped. Integer, 1 to 30 Default: 0 dGPU Jetson extract-sei-type5-data Set to extract and attach SEI type5 unregistered data on output buffer Boolean Default: false dGPU enable-error-check Set to enable error check Boolean Default: false Jetson enable-frame-type-reporting Set to enable frame type reporting Boolean Default: false Jetson enable-full-frame Whether or not the data is full framed Boolean Default: false Jetson enable-max-performance Set to enable max performance Boolean Default: false Jetson gpu-id Device ID of GPU to use for decoding. Integer Default:0 dGPU low-latency-mode Set low latency mode for bitstreams having I and IPPP frames with no B frames Boolean Default: false dGPU mjpeg Set to open MJPEG block Boolean Default: false Jetson num-extra-surfaces Number of surfaces in addition to min decode surfaces given by the V4L2 driver. Integer, 1 to 24 Default: 0 dGPU Jetson output-io-mode Output side I/O mode (matches sink pad) On dGPU: (0): auto - GST_V4L2_IO_AUTO (2): mmap - GST_V4L2_IO_MMAP (5): dmabuf-import - GST_V4L2_IO_DMABUF_IMPORT On Jetson: (0): auto - GST_V4L2_IO_AUTO (2): mmap - GST_V4L2_IO_MMAP (3): userptr - GST_V4L2_IO_USERPTR On dGPU: Enum \u201cGstNvV4l2IOMode\u201d On Jetson: Enum \u201cGstNvV4l2DecOutputIOMode\u201d Default: 0, \u201cauto\u201d dGPU Jetson sei-uuid Set 16 bytes UUID string for SEI Parsing, extract-sei-type5-data should be TRUE String Default: null dGPU skip-frames Type of frames to skip during decoding. 0 (decode_all): decode all frames 1 (decode_non_ref): skips non-ref frames (Applicable only on Jetson platform) 2 (decode_key): decode key frames Enum \u201cSkipFrame\u201d Default: 0 dGPU Jetson", "keywords": []}, {"id": 3082, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#id1", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "id1", "priority": -1, "content": "Inputs RAW input in I420/NV12 or YUV444 format 8 bit I420/NV12 and YUV444 raw formats 8/10 bit I420/NV12 and YUV444 raw formats Output Gst Buffer with encoded output in H264, H265 and AV1 format.", "keywords": []}, {"id": 3083, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#id2", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "id2", "priority": -1, "content": "The following table summarizes the features of the Gst-nvvideo4linux2 encoder plugin. Feature Description Supports H.264 encode 8 bit I420/NV12, 8bit YUV444 raw format can be encoded into h264 bitstream Supports H.265 encode 8/10 bit I420/NV12, 8/10 bit YUV444 raw format can be encoded into h265 bitstream 8/10bit YUV444 format support is applicable only for x86/dGPU platforms.", "keywords": []}, {"id": 3084, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#id3", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "id3", "priority": -1, "content": "The following table summarizes the Gst properties of the Gst-nvvideo4linux2 encoder plugin. Property Meaning Type and Range Example/Notes Platforms aq Enable spatial AQ and set its stength Unsigned Integer, 0-15 Default: 0, \u201cauto\u201d dGPU bit-packetization Whether or not Packet size is based upon Number Of bits Boolean Default: false Jetson bitrate Sets bitrate for encoding, in bits/seconds. Unsigned Integer Default: 4000000 dGPU Jetson capture-io-mode Capture I/O mode (matches src pad) (0): auto - GST_V4L2_IO_AUTO (2): mmap - GST_V4L2_IO_MMAP (5): dmabuf-import - GST_V4L2_IO_DMABUF_IMPORT Enum \u201cGstNvV4l2IOMode\u201d Default: 0, \u201cauto\u201d dGPU Jetson constqp Sets constant QP values for I:P:B frames String, 1 to 51 Default: null dGPU copy-meta Copies input metadata on output buffer Boolean Default: false dGPU copy-timestamp Enabling the flag allows to copy the timestamps from input to the capture stream. Boolean Default: false Jetson control-rate Sets rate control mode for v4l2 encoding (0): variable_bitrate - GST_V4L2_VIDENC_VARIABLE_BITRATE (1): constant_bitrate - GST_V4L2_VIDENC_CONSTANT_BITRATE (2): constantQP - GST_V4L2_VIDENC_CONSTANT_QP Enum \u201cGstV4l2VideoEncRateControlType\u201d Default: 1, \u201cconstant_bitrate\u201d dGPU Jetson cq Sets targetQuality (Constant Quality) level for VBR mode Integer, 0-51 Default: 0, \u201cauto\u201d dGPU disable-cabac Set Entropy Coding Type CAVLC(TRUE) or CABAC(FALSE) Boolean Default: false Jetson enable-lossless Enable lossless encoding for YUV444 Boolean Default: false Jetson EnableMVBufferMeta Enable Motion Vector Meta data for encoding Boolean Default: false Jetson EnableTwopassCBR Enable two pass CBR while encoding Boolean Default: false Jetson extended-colorformat Sets extended colorformat pixel values 0 to 255 in VUI Info Boolean Default: false dGPU force-idr Force an IDR frame Boolean Default: false dGPU force-intra Forces an INTRA frame Boolean Default: false dGPU gpu-id Device ID of GPU to used. Unsigned Integer Default:0 dGPU idrinterval Sets IDR Frame occurence frequency in encoded stream Unsigned Integer Default: 256 dGPU Jetson iframeinterval Sets encoding intra-frame occurrence frequency. Unsigned Integer Default: 30 dGPU Jetson initqp Set values of initQP in I:P:B order. This provides rough hint to encoder to influence the qp difference between I, P and B String Default: null dGPU insert-aud Insert H.264 Access Unit Delimiter(AUD) Boolean Default: false Jetson insert-sps-pps Insert H.264 SPS, PPS at every IDR frame Boolean Default: false Jetson insert-vui Insert H.264 VUI(Video Usability Information) in SPS Boolean Default: false Jetson intra-refresh Intra Refresh Parameters. Use string with unsigned integer values of Intra Refresh in enableIntraRefresh,intraRefreshPeriod,intraRefreshCnt in same order to set the property. e.g. 1,30,5 String Default: null dGPU maxbitrate Set maxbitrate for v4l2 encoder. This mode is specified by setting rateControlMode to VBR Unsigned Integer Default: 0 dGPU maxperf-enable Enable or Disable Max Performance mode Boolean Default: false Jetson MeasureEncoderLatency Enable Measure Encoder latency Per Frame Boolean Default: false Jetson num-B-Frames Number of B Frames between two reference frames (not recommended) Unsigned Integer, 0-2 Default: 0 Jetson num-Ref-Frames Number of Reference Frames for encoder Unsigned Integer, 0-8 Default: 1 Jetson output-io-mode Sets output side I/O mode (matches sink pad) (0): auto - GST_V4L2_IO_AUTO (2): mmap - GST_V4L2_IO_MMAP (5): dmabuf-import - GST_V4L2_IO_DMABUF_IMPORT Enum \u201cGstNvV4l2IOMode\u201d Default: 0, \u201cauto\u201d dGPU Jetson peak-bitrate Peak bitrate in variable control-rate. The value must be &gt;= bitrate (1.2*bitrate) is set by default (Default: 0) Unsigned Integer Default: 0 Jetson poc-type Set Picture Order Count type value Unsigned Integer, 0-2 Default: 1 Jetson preset-id Sets CUVID Preset ID for Encoder Unsigned Integer, 1 to 7 Default: 1 dGPU preset-level HW preset level for encoder. (0): DisablePreset - Disable HW-Preset (1): UltraFastPreset - UltraFastPreset for high perf (2): FastPreset - FastPreset (3): MediumPreset - MediumPreset (4): SlowPreset - SlowPreset Enum \u201cGstV4L2VideoEncHwPreset\u201d Default: 1, \u201cUltraFastPreset\u201d Jetson Profile H.264/H.265 encoder profile. For H.264: (0): Baseline - GST_V4L2_H264_VIDENC_BASELINE_PROFILE (2): Main - GST_V4L2_H264_VIDENC_MAIN_PROFILE (4): High - GST_V4L2_H264_VIDENC_HIGH_PROFILE (7): High444 - GST_V4L2_H264_VIDENC_HIGH_444_PREDICTIVE For H.265: (0): Main - GST_V4L2_H265_VIDENC_MAIN_PROFILE (1): Main10 - GST_V4L2_H265_VIDENC_MAIN10_PROFILE (3): FREXT - GST_V4L2_H265_VIDENC_FREXT_PROFILE Enum \u201cGstV4l2VideoEncProfileType\u201d For H.264: Default: 0 (Baseline) For H.265: Default: 0 (Main) dGPU Jetson Property Meaning Type and Range Example/Notes Platforms qp-range Sets quantization paramenter range for P, I and B frame String, 1 to 51 Default: null dGPU Jetson quant-b-frames Quantization parameter for B-frames (0xffffffff=component default), use with ratecontrol-enable = 0 and preset-level = 0 Unsigned Integer, 0 - 4294967295 Default: 4294967295 Jetson quant-i-frames Quantization parameter for I-frames (0xffffffff=component default), use with ratecontrol-enable = 0 Unsigned Integer, 0 - 4294967295 Default: 4294967295 Jetson quant-p-frames Quantization parameter for P-frames (0xffffffff=component default), use with ratecontrol-enable = 0 and preset-level = 0 Unsigned Integer, 0 - 4294967295 Default: 4294967295 Jetson ratecontrol-enable Enable or Disable rate control mode Boolean Default: true Jetson slice-header-spacing Slice Header Spacing number of macroblocks/bits in one packet Unsigned Integer64 Default: 0 Jetson SliceIntraRefreshInterval Set SliceIntraRefreshInterval Unsigned Integer Default: 0 Jetson temporalaq Set this to enable adaptive quantization (Temporal). Boolean Default: false dGPU tuning-info-id Sets Tuning Info Preset for encoder. (1): HighQualityPreset - Tuning Preset for High Quality (2): LowLatencyPreset - Tuning Preset for Low Latency (3): UltraLowLatencyPreset - Tuning Preset for Low Latency (4): LosslessPreset - Tuning Preset for Lossless Enum \u201cGstV4L2VideoEncTuingInfoPreset\u201d Default: 2 (LowLatencyPreset) dGPU vbvbufsize Set VBV buffer size in bits. Unsigned Integer Default: 0 (default value by encoder) dGPU vbvinit Set VBV initial delay in bits Unsigned Integer Default: 0 (default value by encoder) dGPU vbv-size virtual buffer size Unsigned Integer Default: 4000000 Jetson", "keywords": []}, {"id": 3085, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideo4linux2#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs An encoded bitstream. Supported formats are H.264, H.265, AV1, JPEG and MJPEG H264 encoded bitstream in 8bit 4:2:0 format. H265 encoded bitstream in 8/10/12 bit 4:2:0 and 8/10/12 bit 4:4:4 format. AV1 encoded bitstream in 8bit 4:2:0 format. Output H264 decoder outputs GstBuffer in 8bit semi-planar(NV12) 4:2:0 format. H265 decoder outputs GstBuffer in 8/10/12 bit semi-planar(NV12) 4:2:0 format, 8/10/12 bit planar(YUV444) 4:4:4 format. AV1 decoder outputs GstBuffer in 8bit semi-planar(NV12) 4:2:0 format.", "keywords": []}, {"id": 3086, "doc_id": 3086, "filename": "text/DS_plugin_gst-nvvideo4linux2.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvvideo4linux2", "display_name": "Gst-nvvideo4linux2", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvvideo4linux2", "anchor": "", "priority": -1, "content": "DeepStream extends the open source V4L2 codec plugins (here called Gst-v4l2 ) to support hardware-accelerated codecs.", "keywords": []}, {"id": 3087, "doc_id": 3090, "filename": "text/DS_plugin_gst-nvvideoconvert.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideoconvert#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideoconvert", "anchor": "features", "priority": -1, "content": "This plugin supports scaling and conversion for NVMM to NVMM, RAW to NVMM, and NVMM to RAW and RAW to RAW buffer type conversion. The plugin supports cropping of the input and output frames.", "keywords": []}, {"id": 3088, "doc_id": 3090, "filename": "text/DS_plugin_gst-nvvideoconvert.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideoconvert#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideoconvert", "anchor": "gst-properties", "priority": -1, "content": "The following table describes the Gst properties of the Gst-nvvideoconvert plugin. Property Meaning Type and Range Example Notes nvbuf-memory-type Type of memory to be allocated. For dGPU: 0 (nvbuf-mem-default): Default memory, cuda-device 1 (nvbuf-mem-cuda-pinned): Pinned/Host CUDA memory 2 (nvbuf-mem-cuda-device) Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For Jetson: 0 (nvbuf-mem-default): Default memory, surface array 1 (nvbuf-mem-cuda-pinned): Pinned/Host CUDA memory 2 (nvbuf-mem-cuda-device) Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory 4 (nvbuf-mem-surface-array): Surface array memory enum GstNvVidConvBufMemoryType src-crop Pixel location: left:top:width:height of the input image which will be cropped and transformed into the output buffer. If the crop location is out of bound the values will be clamped to image boundaries of the input image. This property will be applied to all the input images in the batch String src-crop=\u201d20:40:150:100\u201d dest-crop Pixel location: left:top:width:height is the location in the output image where the input image will be transformed to. If the crop location is out of bound the values will be clamped to image boundaries of the output image. This property will be applied to all the output images in the batch String dest-crop=\u201d20:40:150:100\u201d interpolation-method Interpolation method: 0: Nearest 1: Bilinear 2: Algo-1 (GPU\u2014Cubic, VIC\u20145 Tap) 3: Algo-2 (GPU\u2014Super, VIC\u201410 Tap) 4: Algo-3 (GPU\u2014LanzoS, VIC\u2014Smart) 5: Algo-4 (GPU\u2014Ignored, VIC\u2014Nicest) 6: Default (GPU\u2014Nearest, VIC\u2014Nearest) enum GstInterpolationMethod interpolation-method=1 Default value is 6. compute-hw Type of computing hardware: 0: Default (GPU for gDPU, VIC for Jetson) 1: GPU 2: VIC enum GstComputeHW compute-hw=0 Default value is 0. gpu-id Device ID of GPU to use for format conversion Integer, 0 to 4,294,967,295 gpu-id=0 output-buffers Number of Output Buffers for the buffer pool Unsigned integer, 1 to 4,294,967,295 output-buffers=4 bl-output Flag applicable only for Jetson to output Block linear NVMM buffer for NV12 format. This is ignored for dGPU, Software memory (output buffer) and formats other than NV12 Boolean. Default: false bl-output=1 flip-method Type of rotation method. This flag is applicable for Jetson and GPU. Flip method: 0: Identity (no rotation) 1: Rotate counter-clockwise 90 degrees 2: Rotate 180 degrees 3: Rotate clockwise 90 degrees 4: Rotate horizontally 5: Rotate across upper right/lower left diagonal 6: Rotate vertically 7: Rotate across upper left/lower right diagonal enum GstNvDsVideoFlipMethod flip-method=1 Default value is 0. allow-odd-crop Flag to allow the odd dimensions for source and destination crop rectangle Boolean allow-odd-crop=1 Default value is 1. contiguous-buffers Enable contiguous output buffers Boolean contiguous-buffers=1 Default value is 0. disable-passthrough Disable passthrough mode at init time Boolean disable-passthrough=1 Default value is 0. copy-hw Select hardware used for surface copies: 1: GPU 2: VIC flags: readable, writable, controllable enum GstNvCopyHWType copy-hw=2 Default value is 1.", "keywords": []}, {"id": 3089, "doc_id": 3090, "filename": "text/DS_plugin_gst-nvvideoconvert.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideoconvert#inputs-and-outputs", "display_name": "Inputs and Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideoconvert", "anchor": "inputs-and-outputs", "priority": -1, "content": "Inputs Gst Buffer batched buffer NvDsBatchMeta Format: (NVMM/RAW) dGPU - NV12, I420, P010_10LE, BGRx, RGBA, GRAY8, RGB, BGR, Y444, Y444_10LE, Y444_12LE, BGR10A2_LE, UYVP, I420_12LE, RGB10A2_LE, GRAY16_LE Jetson - NV12, I420, P010_10LE, BGRx, RGBA, GRAY8, RGB, BGR, BGR10A2_LE, UYVP, UYVY, YUY2, YVYU, Y42B, I420_12LE, GRAY16_LE Control parameters gpu-id (dGPU only) nvbuf-memory-type src-crop dst-crop interpolation-method compute-hw flip-method Output Gst Buffer NvDsBatchMeta Format: (NVMM/RAW) dGPU - NV12, I420, P010_10LE, BGRx, RGBA, GRAY8, RGB, BGR, Y444, Y444_10LE, Y444_12LE, BGR10A2_LE, UYVP, I420_12LE, RGB10A2_LE, GRAY16_LE Jetson - NV12, I420, P010_10LE, BGRx, RGBA, GRAY8, RGB, BGR, BGR10A2_LE, UYVP, UYVY, YUY2, YVYU, Y42B, I420_12LE, GRAY16_LE For 12bit NV12 format, the input/output caps shows I420_12LE. But the data is handled as semiplanar 12 bit data. This is a workaround since gstreamer v1.16 does not have the particular caps for 12 bit NV12. Downstream component should process it considering as 12bit NV12 only. Only NVMM memory support is added for I420_12LE, Y444_10LE and Y444_12LE formats.", "keywords": []}, {"id": 3090, "doc_id": 3090, "filename": "text/DS_plugin_gst-nvvideoconvert.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvvideoconvert", "display_name": "Gst-nvvideoconvert", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvvideoconvert", "anchor": "", "priority": -1, "content": "This plugin performs video color format conversion. It accepts NVMM memory as well as RAW (memory allocated using calloc() or malloc() ), and provides NVMM or RAW memory at the output.", "keywords": []}, {"id": 3091, "doc_id": 3094, "filename": "text/DS_plugin_gst-nvvideotestsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideotestsrc#gst-properties", "display_name": "Gst Properties", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideotestsrc", "anchor": "gst-properties", "priority": -1, "content": "The following tables describes the Gst properties of the Gst-nvvideotestsrc plugin. Property Meaning Type and Range Example notes animation-mode For animating patterns, the counter that controls the animation. Enum \u201cGstNvVideoTestSrcAnimationMode\u201d Default: 0, \u201cframes\u201d (0): frames - Frame count (1): wall-time - Wall clock time (2): running-time - Running time animation-mode=0 blocksize Size in bytes to read per buffer (-1 = default) Unsigned Integer. Range: 0 - 4294967295 Default: 4096 blocksize=4096 gpu-id ID of the GPU where the buffers are allocated Unsigned Integer. Range: 0 - 2147483647 Default: 0 gpu-id=0 num-buffers Number of buffers to output before sending EOS (-1 = unlimited) Integer. Range: -1 - 2147483647 Default: -1 num-buffers=300 pattern Type of test pattern to generate Enum \u201cGstNvVideoTestSrcPattern\u201d Default: 0, \u201csmpte\u201d (0): smpte - SMPTE color bars (1): mandelbrot - Mandelbrot set (2): gradient - Gradient pattern=1 memtype Type of the memory used for the allocated buffers Enum \u201cNvBufSurfaceMemType\u201d Default: 2, \u201cDevice CUDA memory\u201d (1): Host/Pinned CUDA memory - host (2): Device CUDA memory - device (3): Unified CUDA memory - unified memtype=2 do-timestamp Apply current stream time to buffers Boolean. Default: false do-timestamp=true is-live Whether to act as a live source. Introduces latency based on FPS setting on src caps Boolean. Default: false is-live=true location File location for raw video file input. When file location is not specified, pattern gets used. String. Default: NULL location=test.rgba file-loop Loop through the input file until num-buffers (if specified) or infinitely Boolean. Default: false file-loop=true max-jitter Maximum jitter (in milliseconds) that can be applied to each buffer. Only applicable when is-live=true. A random jitter ranging up to \u201cmax-jitter\u201d gets applied to each buffer. Integer, \u22650 Default: 0 max-jitter=100 fixed-jitter List of fixed jitter values (in milliseconds). The list will be looped through for the entire sequence. Only applicable when is-live=true. If \u201cfixed-jitter\u201d is specified \u201cmax-jitter\u201d(if specified) is ignored. Semicolon delimited integer array. all values \u22650. Default: \u201c\u201d fixed-jitter=30;40;100;0;0", "keywords": []}, {"id": 3092, "doc_id": 3094, "filename": "text/DS_plugin_gst-nvvideotestsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideotestsrc#how-to-test", "display_name": "How to test", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideotestsrc", "anchor": "how-to-test", "priority": -1, "content": "nvvideotestsrc is currently supported for X86 only. support with \u201cJetson + dGPU\u201d is not yet enabled. Run following reference gst-launch-1.0 pipeline on DGPU setup. Default SMPTE Pattern - 720p 60Hz gst-launch-1.0 nvvideotestsrc ! queue ! nveglglessink -e Mandelbrot Pattern - 1080p 60Hz gst-launch-1.0 nvvideotestsrc pattern=mandelbrot ! &#x27;video/x-raw(memory:NVMM), width=1920, height=1080, framerate=60/1&#x27; ! queue ! nveglglessink -e Gradient Pattern - 720p 60Hz gst-launch-1.0 gst-launch-1.0 nvvideotestsrc pattern=2 ! queue ! nveglglessink -e", "keywords": []}, {"id": 3093, "doc_id": 3094, "filename": "text/DS_plugin_gst-nvvideotestsrc.html", "domain_name": "page", "name": "text/DS_plugin_gst-nvvideotestsrc#outputs", "display_name": "Outputs", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_gst-nvvideotestsrc", "anchor": "outputs", "priority": -1, "content": "This section summarizes the outputs of the Gst-nvvideotestsrc plugin. Output Gst Buffer with a test pattern Video Format: NV12, I420, RGBA (NVMM) Control parameters gpu-id animation-mode memtype blocksize pattern", "keywords": []}, {"id": 3094, "doc_id": 3094, "filename": "text/DS_plugin_gst-nvvideotestsrc.html", "domain_name": "std", "name": "text/DS_plugin_gst-nvvideotestsrc", "display_name": "Gst-nvvideotestsrc", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_gst-nvvideotestsrc", "anchor": "", "priority": -1, "content": "The Gst-nvvideotestsrc plugin uses CUDA to generate video test data in a variety of formats and patterns that is written directly to GPU output buffers using the video/x-raw(memory:NVMM) data type. The plugin can also be used to input raw video and generate GPU buffers at the output. The plugin provides properties to introduce jitter in buffer latencies which can be used to simulate network conditions locally. The Gst-nvvideotestsrc plugin is currently only supported on X86.", "keywords": []}, {"id": 3095, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "page", "name": "text/DS_plugin_metadata#adding-custom-meta-in-gst-plugins-upstream-from-gst-nvstreammux", "display_name": "Adding Custom Meta in Gst Plugins Upstream from Gst-nvstreammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_metadata", "anchor": "adding-custom-meta-in-gst-plugins-upstream-from-gst-nvstreammux", "priority": -1, "content": "The DeepStream SDK creates batch level metadata in the Gst-nvstreammux plugin. It holds NvDsBatchMeta metadata in a hierarchy of batches, frames within batches, and objects within frames.", "keywords": []}, {"id": 3096, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "page", "name": "text/DS_plugin_metadata#adding-metadata-to-the-plugin-before-gst-nvstreammux", "display_name": "Adding metadata to the plugin before Gst-nvstreammux", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_metadata", "anchor": "adding-metadata-to-the-plugin-before-gst-nvstreammux", "priority": -1, "content": "This procedure introduces metadata to the DeepStream pipeline at a plugin before Gst-nvstreammux. Set the plugin\u2019s following members of the plugin\u2019s NvDsMeta structure: copy_func free_func meta_type gst_to_nvds_meta_transform_func gst_to_nvds_meta_release_func Attach the metadata by calling gst_buffer_add_nvds_meta() and set the meta_type in the NvDsMeta instance returned by gst_buffer_add_nvds_meta() . The Gst-nvstreammux plugin transforms the input gst-meta created in step 2 from the Gst Buffer into an NvDsUserMeta object associated with the corresponding NvDsFrameMeta object. It adds this object to the frame_user_data list. Search the frame_user_meta_list in the NvDsFrameMeta object for the meta_type that was set in step 2, and access the attached metadata. See the sample application source code in sources/apps/sample_apps/deepstream-gst-metadata-test/deepstream_gst_metadata.c for more details. If gst meta is not attached with gst_buffer_add_nvds_meta() , it is not transformed into DeepStream metadata. It is still available in the Gst Buffer.", "keywords": []}, {"id": 3097, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "page", "name": "text/DS_plugin_metadata#new-metadata-fields", "display_name": "New metadata fields", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_metadata", "anchor": "new-metadata-fields", "priority": -1, "content": "The NvDsObjectMeta structure from DeepStream 5.0 GA release has three bbox info and two confidence values: detector_bbox_info - Holds bounding box parameters of the object when detected by detector. tracker_bbox_info - Holds bounding box parameters of the object when processed by tracker. rect_params - Holds bounding box coordinates of the object processed by the last module that updates it in the pipeline. These bounding box coordinates are clipped so that they do not fall outside frame boundary. These bounding box parameters are used to overlay: confidence - Holds a confidence value for the object, set by the inference module. tracker_confidence - Holds a confidence value for the object set by NvDCF. Will be 1.0 in the case of the other trackers (e.g., IOU , NvSORT and NvDeepSORT ) that do not have visual tracking capability. As noted in the description above, the bbox coordinates from detector and tracker are stored separately in the newly introduced detector_bbox_info and tracker_bbox_info , respectively. The bbox info rect_params continues to hold the bbox info as in previous DeepStream versions, for backward compatibility. Note that rect_params will be deprecated in future release. Preexisting confidence parameter holds the detector confidence value, while a newly introduced tracker_confidence parameter will hold the tracker confidence value.", "keywords": []}, {"id": 3098, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "page", "name": "text/DS_plugin_metadata#nvdsbatchmeta-basic-metadata-structure", "display_name": "NvDsBatchMeta: Basic Metadata Structure", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_metadata", "anchor": "nvdsbatchmeta-basic-metadata-structure", "priority": -1, "content": "DeepStream uses an extensible standard structure for metadata. The basic metadata structure NvDsBatchMeta starts with batch level metadata, created inside the Gst-nvstreammux plugin. Subsidiary metadata structures hold frame, object, classifier, and label data. DeepStream also provides a mechanism for adding user-specific metadata at the batch, frame, or object level. DeepStream attaches metadata to a Gst Buffer by attaching an NvDsBatchMeta structure and setting GstNvDsMetaType.meta_type to NVDS_BATCH_GST_META in the Gst-nvstreammux plugin. When your application processes the Gst Buffer, it can iterate over the attached metadata to find NVDS_BATCH_GST_META. The function gst_buffer_get_nvds_batch_meta() extracts NvDsBatchMeta from the Gst Buffer. (See the declaration in sources/include/gstnvdsmeta.h. ) See the deepstream-test1 sample application for an example of this function\u2019s usage. For more details, see the DeepStream SDK API reference documentation in DeepStream API Guides .", "keywords": []}, {"id": 3099, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "page", "name": "text/DS_plugin_metadata#user-custom-metadata-addition-inside-nvdsbatchmeta", "display_name": "User/Custom Metadata Addition inside NvDsBatchMeta", "type": "section", "display_type": "Page section", "docname": "text/DS_plugin_metadata", "anchor": "user-custom-metadata-addition-inside-nvdsbatchmeta", "priority": -1, "content": "To attach user-specific metadata at the batch, frame, or object level within NvDsBatchMeta , you must acquire an instance of NvDsUserMeta from the user meta pool by calling nvds_acquire_user_meta_from_pool() . (See sources/includes/nvdsmeta.h for details.) Then you must initialize NvDsUserMeta . The members you must set are user_meta_data , meta_type , copy_func , and release_func . For more details, see the sample application source code in sources/apps/sample_apps/deepstream-user-metadata-test/deepstream_user_metadata_app.c .", "keywords": []}, {"id": 3100, "doc_id": 3100, "filename": "text/DS_plugin_metadata.html", "domain_name": "std", "name": "text/DS_plugin_metadata", "display_name": "MetaData in the DeepStream SDK", "type": "doc", "display_type": "Page", "docname": "text/DS_plugin_metadata", "anchor": "", "priority": -1, "content": "Gst Buffer is the basic unit of data transfer in GStreamer. Each Gst Buffer has associated metadata. The DeepStream SDK attaches the DeepStream metadata object, NvDsBatchMeta, described in the following sections. To read more about Gst Buffer, refer to GStreamer documentation .", "keywords": []}, {"id": 3101, "doc_id": 3105, "filename": "text/DS_postprocessing_plugin.html", "domain_name": "page", "name": "text/DS_postprocessing_plugin#custom-parsing-functions", "display_name": "Custom Parsing functions", "type": "section", "display_type": "Page section", "docname": "text/DS_postprocessing_plugin", "anchor": "custom-parsing-functions", "priority": -1, "content": "This section mentions the parsing functions present in postprocess library for available network architectures. Custom Parsing Function Description NvDsPostProcessParseCustomResnet Parsing Resnet 10 model packaged in DeepStream NvDsPostProcessParseCustomTfSSD Tensorflow/Onnx SSD detector NvDsPostProcessParseCustomNMSTLT Parsing TAO Toolkit Open Architecture Models SSD, FRCNN, DSSD, RetinaNet NvDsPostProcessParseCustomBatchedNMSTLT Parsing of TAO Toolkit Open Architecture Models Yolo V3, Yolo V4 NvDsPostProcessParseCustomMrcnnTLTV2 Parsing of TAO Toolkit Open Architecture Model MaskRCNN NvDsPostProcessParseCustomFasterRCNN Parsing of Faster R-CNN Network NvDsPostProcessClassiferParseCustomSoftmax Parsing Resnet 18 vehicle type classifier model packaged in DeepStream NvDsPostProcessParseCustomSSD Parsing of SSD Network NvDsPostProcessParseCustomYoloV3 Parsing of Yolo V3 Network NvDsPostProcessParseCustomYoloV3Tiny Parsing of Yolo V3 Tiny Network NvDsPostProcessParseCustomYoloV2 Parsing of Yolo V2 Network NvDsPostProcessParseCustomYoloV2Tiny Parsing of Yolo V2 Tiny Network", "keywords": []}, {"id": 3102, "doc_id": 3105, "filename": "text/DS_postprocessing_plugin.html", "domain_name": "page", "name": "text/DS_postprocessing_plugin#detector-models", "display_name": "Detector models", "type": "section", "display_type": "Page section", "docname": "text/DS_postprocessing_plugin", "anchor": "detector-models", "priority": -1, "content": "To use Yolo V3 detector, follow the prerequisite steps mentioned in /opt/nvidia/deepstream/deepstream/sources/objectDetector_Yolo/README . Check if the setup is configured correctly by running below test pipelines in following folder /opt/nvidia/deepstream/deepstream/sources/objectDetector_Yolo/ . #For dGPU gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_yoloV3.txt ! \\ nvvideoconvert ! nvdsosd ! nveglglessink sync=0 #For Jetson gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_yoloV3.txt ! \\ nvvideoconvert ! nvdsosd ! nv3dsink sync=0 To update the above pipeline to use the post processing plugin for parsing, the /opt/nvidia/deepstream/deepstream/sources/objectDetector_Yolo/config_infer_primary_yoloV3.txt file must be modified by: changing the network-type=0 to network-type=100 . By doing this, output post processing is disabled in nvinfer plugin. Set the output-tensor-meta=1 , nvinfer plugin then attaches the tensor meta to the input buffer. Store the modified file as config_infer_primary_yoloV3_modified.txt . The post processing plugin config file in YAML format has to be created as below. property: gpu-id: 0 #Set the GPU id process-mode: 1 # Set the mode as primary inference num-detected-classes: 80 # Change according the models output gie-unique-id: 1 # This should match the one set in inference config ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode: 2 # Set appropriate clustering algorithm network-type: 0 # Set the network type as detector labelfile-path: labels.txt # Set the path of labels wrt to this config file parse-bbox-func-name: NvDsPostProcessParseCustomYoloV3 # Set custom parsing function class-attrs-all: # Set as done in the original infer configuration nms-iou-threshold: 0.5 pre-cluster-threshold: 0.7 Save the above config as config_detector.yml . The following pipeline can be executed as given below. #For dGPU gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_yoloV3_modified.txt ! \\ nvdspostprocess postprocesslib-config-file=config_detector.yml \\ postprocesslib-name=/opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so ! nvvideoconvert ! nvdsosd ! nveglglessink sync=0 #For Jetson gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_yoloV3_modified.txt ! \\ nvdspostprocess postprocesslib-config-file=config_detector.yml \\ postprocesslib-name=/opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so ! nvvideoconvert ! nvdsosd ! \\ nv3dsink sync=0 The NvDsPostProcessParseCustomYoloV3 function is defined in /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvdspostprocess/postprocesslib_impl/post_processor_custom_impl.cpp Process similar to the above can be followed to demonstrate the usage of Faster RCNN network ( /opt/nvidia/deepstream/deepstream/sources/objectDetector_FasterRCNN/README ), with nvdspostprocess plugin with below config_detector.yml property: gpu-id: 0 #Set the GPU id process-mode: 1 # Set the mode as primary inference num-detected-classes: 21 # Change according the models output gie-unique-id: 1 # This should match the one set in inference config ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode: 2 # Set appropriate clustering algorithm network-type: 0 # Set the network type as detector labelfile-path: labels.txt # Set the path of labels wrt to this config file parse-bbox-func-name: NvDsPostProcessParseCustomFasterRCNN # Set custom parsing function FRCNN class-attrs-all: # Set as done in the original infer configuration topk: 20 nms-iou-threshold: 0.4 pre-cluster-threshold: 0.5 class-attrs-0: pre-cluster-threshold: 1.1 The pipeline for running the Faster RCNN network with modified nvinfer config and post process plugin is given below. #For dGPU gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_fasterRCNN_modified.txt ! \\ nvdspostprocess postprocesslib-config-file=config_detector.yml postprocesslib-name=/opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so ! \\ nvvideoconvert ! nvdsosd ! nveglglessink sync=0 #For Jetson gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path=config_infer_primary_fasterRCNN_modified.txt ! \\ nvdspostprocess postprocesslib-config-file=config_detector.yml postprocesslib-name=/opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so ! \\ nvvideoconvert ! nvdsosd ! nv3dsink sync=0", "keywords": []}, {"id": 3103, "doc_id": 3105, "filename": "text/DS_postprocessing_plugin.html", "domain_name": "page", "name": "text/DS_postprocessing_plugin#mask-rcnn-model", "display_name": "Mask RCNN Model", "type": "section", "display_type": "Page section", "docname": "text/DS_postprocessing_plugin", "anchor": "mask-rcnn-model", "priority": -1, "content": "To use the instance segmentation model follow the README in package /opt/nvidia/deepstream/deepstream/samples/configs/tao_pretrained_models/README.md to obtain TAO toolkit config files and PeopleSegNet model. Once setup is done, execute following pipeline to validate the model. cd /opt/nvidia/deepstream/deepstream/samples/configs/tao_pretrained_models gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinfer config-file-path= config_infer_primary_peopleSegNet.txt ! \\ nvvideoconvert ! nvdsosd display-mask=1 process-mode=0 ! nveglglessink sync=0 For correct operation ensure the Tensor-RT OSS plugin is compiled and replaced as mentioned in the TAO README. As mentioned in earlier sections update the nvinfer configuration file to disable post processing and enable attaching tensor output meta. This is done by changing the network-type=100 and output-tensor-meta=1 . Store the file by the name config_infer_primary_peopleSegNet_modified.txt . The config_mrcnn.yml can be created as given below. property: gpu-id: 0 process-mode: 1 # Process on full frame num-detected-classes: 2 #Total Detected classes gie-unique-id: 1 #Match with gie-unique-id of inference config ## 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering) cluster-mode: 4 # Disable clustering network-type: 3 # Network is instance segmentation labelfile-path: peopleSegNet_labels.txt parse-bbox-instance-mask-func-name: NvDsInferParseCustomMrcnnTLTV2 class-attrs-all: pre-cluster-threshold: 0.8 Following pipeline can be used for testing the nvdspostprocess plugin with MRCNN network, using the above configuration files. gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! \\ nvinfer config-file-path= config_infer_primary_peopleSegNet.txt ! \\ nvdspostprocess postprocesslib-name= /opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so \\ postprocesslib-config-file= config_mrcnn.yml ! nvvideoconvert ! nvdsosd display-mask=1 process-mode=0 ! nveglglessink sync=0", "keywords": []}, {"id": 3104, "doc_id": 3105, "filename": "text/DS_postprocessing_plugin.html", "domain_name": "page", "name": "text/DS_postprocessing_plugin#primary-classification-model", "display_name": "Primary Classification model", "type": "section", "display_type": "Page section", "docname": "text/DS_postprocessing_plugin", "anchor": "primary-classification-model", "priority": -1, "content": "The primary classification model is demonstrated using the DeepStream Triton Docker Containers on dGPU. Once the docker is running the model repo and classification video should be created. The script prepare_classification_test_video.sh mentioned below requires ffmpeg to be installed. Some of the low level codec libraries need to be re-installed along with ffmpeg. Use the following command to install/re-install ffmpeg: apt-get install --reinstall libflac8 libmp3lame0 libxvidcore4 ffmpeg Execute following commands to download the model repo and create a sample classification video. cd /opt/nvidia/deepstream/deepstream/samples ./prepare_ds_triton_model_repo.sh apt-get install --reinstall libflac8 libmp3lame0 libxvidcore4 ffmpeg ./prepare_classification_test_video.sh cd /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app-triton Check by running following sample classification pipeline gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/classification_test_video.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! \\ nvinferserver config-file-path=config_infer_primary_classifier_densenet_onnx.txt \\ ! nvvideoconvert ! nvdsosd ! nveglglessink sync=1 To use nveglglessink inside docker ensure xhost + done from the host, and set appropriate DISPLAY environment variable inside the docker. Now, update the config_infer_primary_classifier_densenet_onnx.txt to disable post processing and attaching tensor output meta in nvinferserver. This can be done by updating configuration file with following parameters infer_config { postprocess { other {} } } and output_control { output_tensor_meta : true } infer_config { unique_id: 5 gpu_ids: [0] max_batch_size: 1 backend { triton { model_name: &quot;densenet_onnx&quot; version: -1 model_repo { root: &quot;../../triton_model_repo&quot; strict_model_config: true tf_gpu_memory_fraction: 0.0 tf_disable_soft_placement: 0 } } } preprocess { network_format: IMAGE_FORMAT_RGB tensor_order: TENSOR_ORDER_LINEAR maintain_aspect_ratio: 0 frame_scaling_hw: FRAME_SCALING_HW_DEFAULT frame_scaling_filter: 1 normalize { scale_factor: 0.0078125 channel_offsets: [128, 128, 128] } } #Disable post processing in nvinferserver postprocess { other { } } extra { copy_input_to_host_buffers: false output_buffer_pool_size: 2 } } input_control { process_mode: PROCESS_MODE_FULL_FRAME interval: 0 } #Enable attaching output tensor meta in nvinferserver output_control { output_tensor_meta: true } Save the above config as config_infer_primary_classifier_densenet_onnx_modified.txt . Create a config_classifier.yml as given below. property: gpu-id: 0 network-type: 1 # Type of network i.e. classifier process-mode: 1 # Operate in primary mode i.e. operate on full frame classifier-threshold: 0.2 #Set classifier threshold gie-unique-id: 5 # Set the unique_id matching one in the inference classifier-type: ObjectClassifier # type of classifier labelfile-path: /opt/nvidia/deepstream/deepstream/samples/triton_model_repo/densenet_onnx/densenet_labels.txt #Path of the labels fine The following pipeline with nvdspostprocess plugin can now be executed to view the classification results gst-launch-1.0 filesrc location=/opt/nvidia/deepstream/deepstream/samples/streams/classification_test_video.mp4 ! decodebin ! \\ m.sink_0 nvstreammux name=m batch-size=1 width=1920 height=1080 ! nvinferserver \\ config-file-path=config_infer_primary_classifier_densenet_onnx_modified.txt ! \\ nvdspostprocess postprocesslib-config-file= config_classifier.yml postprocesslib-name= \\ /opt/nvidia/deepstream/deepstream/lib/libpostprocess_impl.so ! nvvideoconvert ! nvdsosd ! nveglglessink sync=1", "keywords": []}, {"id": 3105, "doc_id": 3105, "filename": "text/DS_postprocessing_plugin.html", "domain_name": "std", "name": "text/DS_postprocessing_plugin", "display_name": "Gst-nvdspostprocess in DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_postprocessing_plugin", "anchor": "", "priority": -1, "content": "The Gst-nvdspostprocess plugin is released in DeepStream 6.1. The plugin supports parsing of various inferencing models in DeepStream SDK. The plugin can perform parsing on the tensors of the output layers provided by the Gst-nvinfer and Gst-nvinferserver. The aim of this document is to provide guidance on how to use the Gst-nvdspostprocess plugin for various inference models. This document provides details about: The document is divided into four parts. Detector models such as Yolo V3 and Faster RCNN. Using classification model as Primary Classification model with Gst-nvinferserver Mask RCNN Model . Also provides a table for using various custom functions that can be used for parsing of output layers.", "keywords": []}, {"id": 3106, "doc_id": 3107, "filename": "text/DS_ref_app_audio.html", "domain_name": "page", "name": "text/DS_ref_app_audio#deepstream-audio-reference-application-architecture-and-sample-graphs", "display_name": "DeepStream Audio Reference Application Architecture and Sample Graphs", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_audio", "anchor": "deepstream-audio-reference-application-architecture-and-sample-graphs", "priority": -1, "content": "The image below shows the expected output: The image below shows sample graph that could be constructed for audio rendering: GStreamer pipeline demonstrating the above sample graph without nvinferaudio component: USE_NEW_NVSTREAMMUX=yes gst-launch-1.0 \\ uridecodebin uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sonyc_mixed_audio.wav name=source_0 ! queue ! audioconvert ! audioresample ! mux.sink_0 \\ uridecodebin uri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sonyc_mixed_audio.wav name=source_1 ! queue ! audioconvert ! audioresample ! mux.sink_1 \\ nvstreammux name=mux batch-size=2 ! \\ nvstreamdemux name=demux \\ demux.src_0 ! audioconvert ! audioresample ! alsasink async=false \\ demux.src_1 ! audioconvert ! audioresample ! alsasink async=false", "keywords": []}, {"id": 3107, "doc_id": 3107, "filename": "text/DS_ref_app_audio.html", "domain_name": "std", "name": "text/DS_ref_app_audio", "display_name": "DeepStream Reference Application - deepstream-audio app", "type": "doc", "display_type": "Page", "docname": "text/DS_ref_app_audio", "anchor": "", "priority": -1, "content": "Audio application builds on top of the deepstream-app reference application to demonstrate inference of audio data. deepstream-audio application is open sourced and packaged with DeepStream 6.4 as an alpha product. The AI model used to demonstrate audio inference is an ONNX model. The model file is available within the DeepStream 6.4 package at: /opt/nvidia/deepstream/deepstream/samples/models/SONYC_Audio_Classifier/sonyc_audio_classify.onnx Quick run instructions: $ cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-audio/configs $ deepstream-audio -c ds_audio_sonyc_test_config.txt", "keywords": []}, {"id": 3108, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#application-architecture", "display_name": "Application Architecture", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "application-architecture", "priority": -1, "content": "The image below shows the architecture of the NVIDIA \u00ae DeepStream reference application. The DeepStream reference application is a GStreamer based solution and consists of set of GStreamer plugins encapsulating low-level APIs to form a complete graph. The reference application has capability to accept input from various sources like camera, RTSP input, encoded file input, and additionally supports multi stream/source capability. The list of GStreamer plugins implemented by NVIDIA and provided as a part of DeepStream SDK include: The Stream Muxer plugin ( Gst-nvstreammux ) to form a batch of buffers from multiple input sources. The Preprocess plugin ( Gst-nvdspreprocess ) for preprocessing on the pre-defined ROIs for primary inferencing. The NVIDIA TensorRT\u2122 based plugin ( Gst-nvinfer ) for primary and secondary (attribute classification of primary objects) detection and classification respectively. The Multi-Object Tracker plugin ( Gst-nvtracker ) for object tracking with unique ID. The Multi Stream Tiler plugin ( Gst-nvmultistreamtiler ) for forming 2D array of frames. The Onscreen Display (OSD) plugin ( Gst-nvdsosd ) to draw shaded boxes, rectangles and text on the composited frame using the generated metadata. The Message Converter ( Gst-nvmsgconv ) and Message Broker ( Gst-nvmsgbroker ) plugins in combination to send analytics data to a server in the Cloud.", "keywords": []}, {"id": 3109, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#application-group", "display_name": "Application Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "application-group", "priority": -1, "content": "The application group properties are: Key Meaning Type and Value Example Platforms enable-perf-measurement Indicates whether the application performance measurement is enabled. Boolean enable-perf-measurement=1 dGPU, Jetson perf-measurement-interval-sec The interval, in seconds, at which the performance metrics are sampled and printed. Integer, &gt;0 perf-measurement-interval-sec=10 dGPU, Jetson gie-kitti-output-dir Pathname of an existing directory where the application stores primary detector output in a modified KITTI metadata format. String gie-kitti-output-dir=\u00ad/home/\u00adubuntu/\u00adkitti_data/ dGPU, Jetson kitti-track-output-dir Pathname of an existing directory where the application stores tracker output in a modified KITTI metadata format. String kitti-track-output-dir=\u00ad/home/\u00adubuntu/\u00adkitti_data_tracker/ dGPU, Jetson reid-track-output-dir Pathname of an existing directory where the application stores tracker\u2019s Re-ID feature output. Each line\u2019s first integer is object id, and the remaining floats are its feature vector. String reid-track-output-dir=\u00ad/home/\u00adubuntu/\u00adreid_data_tracker/ dGPU, Jetson terminated-track-output-dir Pathname of an existing directory where the application stores terminated tracker output in a modified KITTI metadata format. String kitti-track-output-dir=\u00ad/home/\u00adubuntu/\u00adterminated_data_tracker/ dGPU, Jetson shadow-track-output-dir Pathname of an existing directory where the application stores shadow track state output in a modified KITTI metadata format. String shadow-track-output-dir=\u00ad/home/\u00adubuntu/\u00adshadow_data_tracker/ dGPU, Jetson global-gpu-id Set Global GPU ID for all the componenents at once if needed Integer global-gpu-id=1 dGPU, Jetson", "keywords": []}, {"id": 3110, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#application-tuning-for-deepstream-sdk", "display_name": "Application Tuning for DeepStream SDK", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "application-tuning-for-deepstream-sdk", "priority": -1, "content": "This section provides application tuning tips for the DeepStream SDK using the following parameters in the configuration file.", "keywords": []}, {"id": 3111, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#configuration-groups", "display_name": "Configuration Groups", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "configuration-groups", "priority": -1, "content": "The application configuration is divided into groups of configurations for each component and application-specific component. The configuration groups are: Group Configuration Group Application Group Application configurations that are not related to a specific component. Tiled-display Group Tiled display in the application. Source Group Source properties. There can be multiple sources. The groups must be named as: [source0], [source1] \u2026 Source-list and source-attr-all Groups Source URI provided as a list. There can be multiple sources. The groups must be named as: [source-list] and [source-attr-all] Streammux Group Specify properties and modify behavior of the streammux component. Preprocess Group Specify properties and modify behavior of the preprocess component. Primary GIE and Secondary GIE Group Specify properties and modify behavior of the primary GIE. Specify properties and modify behavior of the secondary GIE. The groups must be named as: [secondary-gie0], [secondary-gie1] \u2026 Tracker Group Specify properties and modify behavior of the object tracker. Message Converter Group Specify properties and modify behavior of the message converter component. Message Consumer Group Specify properties and modify behavior of message consumer components. The pipeline can contain multiple message consumer components. Groups must be named as [message-consumer0], [message-consumer1] \u2026 OSD Group Specify properties and modify the on-screen display (OSD) component that overlays text and rectangles on the frame. Sink Group Specify properties and modify behavior of sink components that represent outputs such as displays and files for rendering, encoding, and file saving. The pipeline can contain multiple sinks. Groups must be named as: [sink0], [sink1] \u2026 Tests Group Diagnostics and debugging. This group is experimental. NvDs-analytics Group Specify nvdsanalytics plugin configuration file, and to add the plugin in the application", "keywords": []}, {"id": 3112, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#deepstream-best-practices", "display_name": "DeepStream best practices", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "deepstream-best-practices", "priority": -1, "content": "Here are few best practices to optimize DeepStream application to remove bottlenecks in your application: Set the batch size of streammux and primary detector to equal the number of input sources. These settings are under [streammux] and [primary-gie] group of the config file. This keeps the pipeline running at full capacity. Higher or lower batch size than number of input sources can sometimes add latency in the pipeline. Set the height and width of streammux to the input resolution. This is set under [streammux] group of the config file. This ensures that stream doesn\u2019t go through any unwanted image scaling. If you are streaming from live sources such as RTSP or from USB camera, set live-source=1 in [streammux] group of config file. This enables proper timestamping for live sources creating smoother playback Tiling and visual output can take up GPU resource. There are 3 things that you can disable to maximize throughput when you do not need to render the output on your screen. As an example, rendering is not required when you want to run inference on the edge and transmit just the metadata to the cloud for further processing. Disable OSD or on-screen display. OSD plugin is used for drawing bounding boxes and other artifacts and adding labels in the output frame. To disable OSD set enable=0 in the [osd] group of the config file. The tiler creates an NxM grid for displaying the output streams. To disable the tiled output, set enable=0 in the [tiled-display] group of the config file. Disable the output sink for rendering: choose fakesink , that is, type=1 in the [sink] group of the config file. All the performance benchmark in Performance section are ran with tiling, OSD and output sink disabled. If CPU/GPU utilization is low, then one of the possibilities is that the elements in the pipeline are getting starved for buffers. Then try increasing the number of buffers allocated by the decoder by setting the num-extra-surfaces property of the [source#] group in the application or the num-extra-surfaces property of Gst-nvv4l2decoder element. If you are running the application inside docker console and it delivers low FPS, set qos=0 in the configuration file\u2019s [sink0] group. The issue is caused by initial load. When qos set to 1, as the property\u2019s default value in the [sink0] group, decodebin starts dropping frames. If you want to optimize processing pipelines end to end latency you can use latency measurement method in DeepStream. To enable frame latency measurement, run this command on the console: $ export NVDS_ENABLE_LATENCY_MEASUREMENT=1 To enable latency for all plugins, run this command on the console: $ export NVDS_ENABLE_COMPONENT_LATENCY_MEASUREMENT=1 When measuring frame latency using DeepStream latency APIs if large frame latency numbers in the order of 10^12 or 1e12 are observed, modify the latency measurement code (call to nvds_measure_buffer_latency API) to ... guint num_sources_in_batch = nvds_measure_buffer_latency(buf, latency_info); if (num_sources_in_batch &gt; 0 &amp;&amp; latency_info[0].latency &gt; 1e6) { NvDsBatchMeta *batch_meta = gst_buffer_get_nvds_batch_meta (buf); batch_meta-&gt;batch_user_meta_list = g_list_reverse (batch_meta-&gt;batch_user_meta_list); num_sources_in_batch = nvds_measure_buffer_latency(buf, latency_info); } ...", "keywords": []}, {"id": 3113, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#expected-output-for-the-deepstream-reference-application-deepstream-app", "display_name": "Expected Output for the DeepStream Reference Application (deepstream-app)", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "expected-output-for-the-deepstream-reference-application-deepstream-app", "priority": -1, "content": "The image below shows the expected output with preprocess plugin disabled: The image below shows the expected output with preprocess plugin enabled (Green bboxes are pre-defined ROIs):", "keywords": []}, {"id": 3114, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#inference-throughput", "display_name": "Inference Throughput", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "inference-throughput", "priority": -1, "content": "Here are a few steps to help you increase channel density for your application: If you are using Jetson AGX Orin or Jetson Orin NX, you can use the DLA (Deep learning accelerator) for inferencing. This frees GPU for other models or more streams. With DeepStream, users can infer every other frame or every third frame and use a tracker to predict the location in the object. This can be done with a simple config file change. Users can use one of the 3 available trackers to track the object in the frame. In the inference config file, change the interval parameter under [property] . This is a skip interval, number of frames to skip between inference. Interval of 0 means infer every frames and interval of 1 means skip 1 frame and infer every other frame. This can effectively double your overall channel throughput by going from interval of 0 to 1. Choose lower precision such as FP16 or INT8 for inference. If you want to use FP16, no new model is required. This is a simple change in the DS. To change, update the network-mode option in the inference config file. If you want to run INT8, an INT8 calibration cache is required which contains the FP32 to INT8 quantization table. DeepStream app can also be configured to have cascaded neural network. First network does the detection followed by second network with does some classification on the detection. To enable secondary inference, enable the secondary-gie from the config file. Set the appropriate batch sizes. Batch size will depend on number of objects that are typically sent to the secondary inference from primary inference. You\u2019ll have to experiment to see what the appropriate batch size for their use case is. To reduce the number of inferences of the secondary classifier, the objects to infer on can be filtered by setting input-object-min-width , input-object-min-height , input-object-max-width , input-object-max-height , operate-on-gie-id , operate-on-class-ids appropriately.", "keywords": []}, {"id": 3115, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#jetson-optimization", "display_name": "Jetson optimization", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "jetson-optimization", "priority": -1, "content": "Ensure that Jetson clocks are set high. Run these commands to set Jetson clocks high. $ sudo nvpmodel -m &lt;mode&gt; --for MAX perf and power mode is 0 $ sudo jetson_clocks For NX: use mode as 2. On Jetson, use Gst-nvdrmvideosink instead of Gst-nv3dsink as nv3dsink requires GPU utilization.", "keywords": []}, {"id": 3116, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#message-consumer-group", "display_name": "Message Consumer Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "message-consumer-group", "priority": -1, "content": "Message consumer group properties are: Key Meaning Type and Value Example Platforms enable Enables or disables the message consumer. Boolean enable=1 dGPU, Jetson proto-lib Path to the library having protocol adapter implementation. String proto-lib=/opt/nvidia/deepstream/deepstream-4.0/lib/libnvds_kafka_proto.so dGPU, Jetson conn-str Connection string of the server. String conn-str=foo.bar.com;80 dGPU, Jetson config-file Path to the file having additional configurations for protocol adapter, String config-file=../cfg_kafka.txt dGPU, Jetson subscribe-topic-list List of topics to subscribe. String subscribe-topic-list=toipc1;topic2;topic3 dGPU, Jetson sensor-list-file File having mappings from sensor index to sensor name. String sensor-list-file=dstest5_msgconv_sample_config.txt dGPU, Jetson", "keywords": []}, {"id": 3117, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#message-converter-group", "display_name": "Message Converter Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "message-converter-group", "priority": -1, "content": "Message converter group properties are: Key Meaning Type and Value Example Platforms enable Enables or disables the message converter. Boolean enable=1 dGPU, Jetson msg-conv-config Pathname of the configuration file for the Gst-nvmsgconv element. String msg-conv-config=dstest5_msgconv_sample_config.txt dGPU, Jetson msg-conv-payload-type Type of payload. 0, PAYLOAD_DEEPSTREAM: Deepstream schema payload. 1, PAYLOAD_DEEPSTREAM_MINIMAL: Deepstream schema payload minimal. 256, PAYLOAD_RESERVED: Reserved type. 257, PAYLOAD_CUSTOM: Custom schema payload. Integer 0, 1, 256, or 257 msg-conv-payload-type=0 dGPU, Jetson msg-conv-msg2p-lib Absolute pathname of an optional custom payload generation library. This library implements the API defined by sources/libs/nvmsgconv/nvmsgconv.h. String msg-conv-msg2p-lib=/opt/nvidia/deepstream/deepstream-4.0/lib/libnvds_msgconv.so dGPU, Jetson msg-conv-comp-id comp-id Gst property of the gst-nvmsgconv element. This is the Id of the component that attaches the NvDsEventMsgMeta which must be processed by gst-nvmsgconv element. Integer, &gt;=0 msg-conv-comp-id=1 dGPU, Jetson debug-payload-dir Directory to dump payload String debug-payload-dir=&lt;absolute path&gt; Default is NULL dGPU Jetson multiple-payloads Generate multiple message payloads Boolean multiple-payloads=1 Default is 0 dGPU Jetson msg-conv-msg2p-new-api Generate payloads using Gst buffer frame/object metadata Boolean msg-conv-msg2p-new-api=1 Default is 0 dGPU Jetson msg-conv-frame-interval Frame interval at which payload is generated Integer, 1 to 4,294,967,295 msg-conv-frame-interval=25 Default is 30 dGPU Jetson msg-conv-dummy-payload By default payload is generated if NVDS_EVENT_MSG_META is attached to buffer. With this dummy payload can be generated if there is no NVDS_EVENT_MSG_META attached to buffer boolean msg-conv-dummy-payload=true Default is false dGPU Jetson", "keywords": []}, {"id": 3118, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#nvds-analytics-group", "display_name": "NvDs-analytics Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "nvds-analytics-group", "priority": -1, "content": "The [nvds-analytics] group is for adding nvds-analytics plugin in the pipeline. Key Meaning Type and Value Example Platforms enable Enables or disables the plugin. Boolean enable=1 dGPU, Jetson config-file Configuration file path for nvdsanalytics plugin String config-file=config_nvdsanalytics.txt dGPU, Jetson See the DeepStream Plugin Guide for plugin-specific configuration file specifications (for the Gst-nvdspreprocess , Gst-nvinfer , Gst-nvtracker , Gst-nvdewarper , Gst-nvmsgconv , Gst-nvmsgbroker and Gst-nvdsanalytics plugins).", "keywords": []}, {"id": 3119, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#osd-group", "display_name": "OSD Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "osd-group", "priority": -1, "content": "The OSD group specifies the properties and modifies the behavior of the OSD component, which overlays text and rectangles on the video frame. Key Meaning Type and Value Example Platforms enable Enables or disables the On-Screen Display (OSD). Boolean enable=1 dGPU, Jetson gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU border-width Border width of the bounding boxes drawn for objects, in pixels. Integer, \u22650 border-width=10 dGPU, Jetson border-color Border color of the bounding boxes drawn for objects. R;G;B;A Float, 0\u2264R,G,B,A\u22641 border-color=0;0;0.7;1 #Dark Blue dGPU, Jetson text-size Size of the text that describes the objects, in points. Integer, \u22650 text-size=16 dGPU, Jetson text-color The color of the text that describes the objects, in RGBA format. R;G;B;A Float, 0\u2264R,G,B,A\u22641 text-color=0;0;0.7;1 #Dark Blue dGPU, Jetson text-bg-color The background color of the text that describes the objects, in RGBA format. R;G;B;A Float, 0\u2264R,G,B,A\u22641 text-bg-color=0;0;0;0.5 #Semi-transparent black dGPU, Jetson clock-text-size The size of the clock time text, in points. Integer, &gt;0 clock-text-size=16 dGPU, Jetson clock-x-offset The horizontal offset of the clock time text, in pixels. Integer, &gt;0 clock-x-offset=100 dGPU, Jetson clock-y-offset The vertical offset of the clock time text, in pixels. Integer, &gt;0 clock-y-offset=100 dGPU, Jetson font Name of the font for text that describes the objects. String font=Purisa dGPU, Jetson Enter the shell command fc-list to display the names of available fonts. clock-color Color of the clock time text, in RGBA format. R;G;B;A Float, 0\u2264R,G,B,A\u22641 clock-color=1;0;0;1 #Red dGPU, Jetson nvbuf-memory-type Type of CUDA memory the element is to allocate for output buffers. 0 (nvbuf-mem-default): a platform-specific default 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory 2 (nvbuf-mem-cuda-device): Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For dGPU: All values are valid. For Jetson: Only 0 (zero) is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU process-mode NvOSD processing mode. 0: CPU 1: GPU Integer, 0, 1, or 2 process-mode=1 dGPU, Jetson display-text Indicate whether to display text Boolean display-text=1 dGPU, Jetson display-bbox Indicate whether to bounding box Boolean display-bbox=1 dGPU, Jetson display-mask Indicate whether to display instance mask Boolean display-mask=1 dGPU, Jetson", "keywords": []}, {"id": 3120, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#performance-optimization", "display_name": "Performance Optimization", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "performance-optimization", "priority": -1, "content": "This section covers various performance optimization steps that you can try for maximum performance.", "keywords": []}, {"id": 3121, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#preprocess-group", "display_name": "Preprocess Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "preprocess-group", "priority": -1, "content": "The [pre-process] group is for adding nvdspreprocess plugin in the pipeline. Supports preprocessing for only Primary GIE. Key Meaning Type and Value Example Platforms enable Enables or disables the plugin. Boolean enable=1 dGPU, Jetson config-file Configuration file path for nvdspreprocess plugin String config-file=config_preprocess.txt dGPU, Jetson", "keywords": []}, {"id": 3122, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#primary-gie-and-secondary-gie-group", "display_name": "Primary GIE and Secondary GIE Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "primary-gie-and-secondary-gie-group", "priority": -1, "content": "The DeepStream application supports multiple secondary GIEs. For each secondary GIE, a separate group with the name secondary-gie%d must be added to the configuration file. For example: [primary-gie] key1=value1 key2=value2 ... [secondary-gie1] key1=value1 key2=value2 ... The primary and secondary GIE configurations are as follows. For each configuration, the Valid for column indicates whether the configuration property is valid for the primary or secondary TensorRT model, or for both models. Key Meaning Type and Value Example Platforms/ GIEs* enable Indicates whether the primary GIE must be enabled. Boolean enable=1 dGPU, Jetson Both GIEs gie-unique-id Unique component ID to be assigned to the nvinfer instance. Used to identify metadata generated by the instance. Integer, &gt;0 gie-unique-id=2 Both gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU, Both GIEs model-engine-file Absolute pathname of the pre-generated serialized engine file for the mode. String model-engine-file=\u00ad../../models/\u00adPrimary_Detector/\u00adresnet18_trafficcamnet_pruned.onnx_b4_gpu0_int8.engine Both GIEs nvbuf-memory-type Type of CUDA memory element is to allocate for output buffers. 0 (nvbuf-mem-default): a platform-specific default 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory 2 (nvbuf-mem-cuda-device): Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For dGPU: All values are valid. For Jetson: Only 0 (zero) is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU, Jetson Primary GIE config-file Pathname of a configuration file which specifies properties for the Gst-nvinfer plugin. It may contain any of the properties described in this table except config-file itself. Properties must be defined in a group named [property]. For more details about parameters see \u201cGst-nvinfer File Configuration Specifications\u201d in the DeepStream 4.0 Plugin Manual. String config-file=\u00ac/home/-ubuntu/-config_infer_resnet.txt For complete examples, see the sample file samples/\u00acconfigs/-deepstream-app/-config_infer_resnet.txt or the deepstream-test2 sample application. dGPU, Jetson Both GIEs batch-size The number of frames(P.GIE)/objects(S.GIE) to be inferred together in a batch. Integer, &gt;0 Integer, &gt;0 batch-size=2 dGPU, Jetson Both GIEs interval Number of consecutive batches to skip for inference. Integer, &gt;0 Integer, &gt;0 interval=2 dGPU, Jetson Primary GIE bbox-border-color The color of the borders for the objects of a specific class ID, specified in RGBA format. The key must be of format bbox-border-color&lt;class-id&gt;. This property can be identified multiple times for multiple class IDs. If this property is not identified for the class ID, the borders are not drawn for objects of that class-id. R:G:B:A Float, 0\u2264R,G,B,A\u22641 bbox-border-color2= 1;0;0;1 (Red for class-id 2) dGPU, Jetson Both GIEs bbox-bg-color The color of the boxes drawn over objects of a specific class ID, in RGBA format. The key must be of format bbox-bg-color&lt;class-id&gt;. This property can be used multiple times for multiple class IDs. If it is not used for a class ID, the boxes are not drawn for objects of that class ID. R:G:B:A Float, 0\u2264R,G,B,A\u22641 bbox-bg-color3=-0;1;0;0.3 (Semi-transparent green for class-id 3) dGPU, Jetson Both GIEs operate-on-gie-id A unique ID of the GIE, on whose metadata (NvDsFrameMeta) this GIE is to operate. Integer, &gt;0 operate-on-gie-id=1 dGPU, Jetson Secondary GIE operate-on-class-ids Class IDs of the parent GIE on which this GIE must operate. The parent GIE is specified using operate-on-gie-id. Semicolon separated integer array operate-on-class-ids=1;2 (operate on objects with class IDs 1, 2 generated by parent GIE) dGPU, Jetson Secondary GIE infer-raw-output-dir Pathname of an existing directory in which to dump the raw inference buffer contents in a file. String infer-raw-output-dir=\u00ad/home/\u00adubuntu/\u00adinfer_raw_out dGPU, Jetson Both GIEs labelfile-path Pathname of the labelfile. String labelfile-path=../../models/Primary_Detector/labels.txt dGPU, Jetson Both GIEs plugin-type Plugin to use for inference. 0: nvinfer (TensorRT) 1: nvinferserver (Triton inference server) Integer, 0 or 1 plugin-type=1 dGPU, Jetson Both GIEs input-tensor-meta Use preprocessed input tensors attached as metadata by nvdspreprocess plugin instead of preprocessing inside the nvinfer. Integer, 0 or 1 input-tensor-meta=1 dGPU, Jetson, Primary GIE * The GIEs are the GPU Inference Engines.", "keywords": []}, {"id": 3123, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#reducing-spurious-detections", "display_name": "Reducing Spurious Detections", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "reducing-spurious-detections", "priority": -1, "content": "Configuration Parameter Description Use Case threshold Per-class-threshold of primary detector. Increasing the threshold restricts output to objects with higher detection confidence. \u2014 roi-top-offset roi-bottom-offset Per-class top/bottom region of interest (roi) offset. Restricts output to objects in a specified region of the frame. To reduce spurious detections seen on the dashboard of dashcams detected-min-w detected-min-h detected-max-w detected-max-h Per-class min/max object width/height for primary-detector Restricts output to objects of specified size. To reduce false detections, for example, a tree being detected as a person", "keywords": []}, {"id": 3124, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#reference-application-configuration", "display_name": "Reference Application Configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "reference-application-configuration", "priority": -1, "content": "The NVIDIA DeepStream SDK reference application uses one of the sample configuration files from the samples/configs/deepstream-app directory in the DeepStream package to: Enable or disable components Change the properties or behavior of components Customize other application configuration settings that are unrelated to the pipeline and its components The configuration file uses a key file format, based on the freedesktop specifications at: https://specifications.freedesktop.org/desktop-entry-spec/latest", "keywords": []}, {"id": 3125, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#sink-group", "display_name": "Sink Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "sink-group", "priority": -1, "content": "The sink group specifies the properties and modifies the behavior of the sink components for rendering, encoding, and file saving. Key Meaning Type and Value Example Platforms enable Enables or disables the sink. Boolean enable=1 dGPU, Jetson type Type of sink, to use. 1: Fakesink 2: EGL based windowed nveglglessink for dGPU and nv3dsink for Jetson 3: Encode + File Save (encoder + muxer + filesink) 4: Encode + RTSP streaming; Note: sync=1 for this type is not applicable; 5: nvdrmvideosink (Jetson only) 6: Message converter + Message broker Integer, 1, 2, 3, 4, 5 or 6 type=2 dGPU, Jetson sync Indicates how fast the stream is to be rendered. 0: As fast as possible 1: Synchronously Integer, 0 or 1 sync=1 dGPU, Jetson qos Indicates whether the sink is to generate Quality-of-Service events, which can lead to the pipeline dropping frames when pipeline FPS cannot keep up with the stream frame rate. Boolean qos=0 dGPU, Jetson source-id The ID of the source whose buffers this sink must use. The source ID is contained in the source group name. For example, for group [source1] source-id=1. Integer, \u22650 source-id=1 dGPU, Jetson gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU container Container to use for the file save. Only valid for type=3. 1: MP4 2: MKV Integer, 1 or 2 container=1 dGPU, Jetson codec The encoder to be used to save the file. 1: H.264 (hardware) 2: H.265 (hardware) Integer, 1 or 2 codec=1 dGPU, Jetson bitrate Bitrate to use for encoding, in bits per second. Valid for type=3 and 4. Integer, &gt;0 bitrate=4000000 dGPU, Jetson iframeinterval Encoding intra-frame occurrence frequency. Integer, 0\u2264iv\u2264MAX_INT iframeinterval=30 dGPU, Jetson output-file Pathname of the output encoded file. Only valid for type=3. String output-file=\u00ad/home/\u00adubuntu/\u00adoutput.mp4 dGPU, Jetson nvbuf-memory-type Type of CUDA memory the plugin is to allocate for output buffers. 0 (nvbuf-mem-default): a platform-specific default 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory 2 (nvbuf-mem-cuda-device): Device CUDA memory 3 (nvbuf-mem-cuda-unified): Unified CUDA memory For dGPU: All values are valid. For Jetson: Only 0 (zero) Is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU, Jetson rtsp-port Port for the RTSP streaming server; a valid unused port number. Valid for type=4. Integer rtsp-port=8554 dGPU, Jetson udp-port Port used internally by the streaming implementation - a valid unused port number. Valid for type=4. Integer udp-port=5400 dGPU, Jetson conn-id Connection index. Valid for nvdrmvideosink(type=5). Integer, &gt;=1 conn-id=0 Jetson width Width of the renderer in pixels. Integer, &gt;=1 width=1920 dGPU, Jetson height Height of the renderer in pixels. Integer, &gt;=1 height=1920 dGPU, Jetson offset-x Horizontal offset of the renderer window, in pixels. Integer, &gt;=1 offset-x=100 dGPU, Jetson offset-y Vertical offset of the renderer window, in pixels. Integer, &gt;=1 offset-y=100 dGPU, Jetson plane-id Plane on which video should be rendered. Valid for nvdrmvideosink(type=5). Integer, \u22650 plane-id=0 Jetson msg-conv-config Pathname of the configuration file for the Gst-nvmsgconv element (type=6). String msg-conv-config=dstest5_msgconv_sample_config.txt dGPU, Jetson msg-broker-proto-lib Path to the protocol adapter implementation used Gst-nvmsgbroker (type=6). String msg-broker-proto-lib= /opt/nvidia/deepstream/deepstream-5.0/lib/libnvds_amqp_proto.so dGPU, Jetson msg-broker-conn-str Connection string of the backend server (type=6). String msg-broker-conn-str=foo.bar.com;80;dsapp dGPU, Jetson topic Name of the message topic (type=6). String topic=test-ds4 dGPU, Jetson msg-conv-payload-type Type of payload. 0, PAYLOAD_DEEPSTREAM: DeepStream schema payload. 1, PAYLOAD_DEEPSTREAM_-MINIMAL: DeepStream schema payload minimal. 256, PAYLOAD_RESERVED: Reserved type. 257, PAYLOAD_CUSTOM: Custom schema payload (type=6). Integer 0, 1, 256, or 257 msg-conv-payload-type=0 dGPU, Jetson msg-broker-config Pathname of an optional configuration file for the Gst-nvmsgbroker element (type=6). String msg-broker-config=/home/ubuntu/cfg_amqp.txt dGPU, Jetson sleep-time Sleep time between consecutive do_work calls in milliseconds Integer &gt;= 0. For Azure, use value &gt;= 10 depending on IoT Hub service tier message rate limit. Warning: failure is likely with unreasonably high sleep times, e.g. 10000000 ms sleep-time=10 dGPU Jetson new-api use protocol adapter library api\u2019s directly or use new msgbroker library wrapper api\u2019s (type=6) Integer 0 : Use adapter api\u2019s directly 1 : msgbroker lib wrapper api\u2019s new-api = 0 dGPU, Jetson msg-conv-msg2p-lib Absolute pathname of an optional custom payload generation library. This library implements the API defined by sources/libs/nvmsgconv/\u00adnvmsgconv.h. Applicable only when msg-conv-payload-type=257, PAYLOAD_CUSTOM. (type=6) String msg-conv-msg2p-lib= /opt/nvidia/deepstream/deepstream-4.0/lib/libnvds_msgconv.so dGPU, Jetson msg-conv-comp-id comp-id Gst property of the nvmsgconv element; ID (gie-unique-id) of the primary/secondary-gie component from which metadata is to be processed. (type=6) Integer, &gt;=0 msg-conv-comp-id=1 dGPU, Jetson msg-broker-comp-id comp-id Gst property of the nvmsgbroker element; ID (gie-unique-id) of the primary/secondary gie component from which metadata is to be processed. (type=6) Integer, &gt;=0 msg-broker-comp-id=1 dGPU, Jetson debug-payload-dir Directory to dump payload (type=6) String debug-payload-dir=&lt;absolute path&gt; Default is NULL dGPU Jetson multiple-payloads Generate multiple message payloads (type=6) Boolean multiple-payloads=1 Default is 0 \u201cdGPU Jetson\u201d msg-conv-msg2p-new-api Generate payloads using Gst buffer frame/object metadata (type=6) Boolean msg-conv-msg2p-new-api=1 Default is 0 \u201cdGPU Jetson\u201d msg-conv-frame-interval Frame interval at which payload is generated (type=6) Integer, 1 to 4,294,967,295 msg-conv-frame-interval=25 Default is 30 dGPU Jetson disable-msgconv Only add a message broker component instead of a message converter + message broker. (type=6) Integer, disable-msgconv = 1 dGPU, Jetson enc-type Engine to use for encoder 0: NVENC hardware engine 1: CPU software encoder Integer, 0 or 1 enc-type=0 dGPU, Jetson profile (HW) Encoder profile for the codec V4L2 H264 encoder(HW): 0: Baseline 2: Main 4: High V4L2 H265 encoder(HW): 0: Main 1: Main10 Integer, valid values from the column beside profile=2 dGPU, Jetson udp-buffer-size UDP kernel buffer size (in bytes) for internal RTSP output pipeline. Integer, &gt;=0 udp-buffer-size=100000 dGPU, Jetson link-to-demux A boolean which enables or disables streaming a particular \u201csource-id\u201d alone to this sink. Please check the tiled-display group enable key for more information. Boolean link-to-demux=0 dGPU, Jetson", "keywords": []}, {"id": 3126, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#source-group", "display_name": "Source Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "source-group", "priority": -1, "content": "The source group specifies the source properties. The DeepStream application supports multiple simultaneous sources. For each source, a separate group with the group names such as source%d must be added to the configuration file. For example: [source0] key1=value1 key2=value2 ... [source1] key1=value1 key2=value2 ... The source group properties are: Key Meaning Type and Value Example Platforms enable Enables or disables the source. Boolean enable=1 dGPU, Jetson type Type of source; other properties of the source depend on this type. 1: Camera (V4L2) 2: URI 3: MultiURI 4: RTSP 5: Camera (CSI) (Jetson only) Integer, 1, 2, 3, 4, or 5 type=1 dGPU, Jetson uri URI to the encoded stream. The URI can be a file, an HTTP URI, or an RTSP live source. Valid when type=2 or 3. With MultiURI, the %d format specifier can also be used to specify multiple sources. The application iterates from 0 to num-sources\u22121 to generate the actual URIs. String uri=file:///home/ubuntu/source.mp4 uri=http://127.0.0.1/source.mp4 uri=rtsp://127.0.0.1/source1 uri=file:///home/ubuntu/source_%d.mp4 dGPU, Jetson num-sources Number of sources. Valid only when type=3. Integer, \u22650 num-sources=2 dGPU, Jetson intra-decode-enable Enables or disables intra-only decode. Boolean intra-decode-enable=1 dGPU, Jetson num-extra-surfaces Number of surfaces in addition to minimum decode surfaces given by the decoder. Can be used to manage the number of decoder output buffers in the pipeline. Integer, \u22650 and \u226424 num-extra-surfaces=5 dGPU, Jetson gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU camera-id Unique ID for the input source to be added to metadata. (Optional) Integer, \u22650 camera-id=2 dGPU, Jetson camera-width Width of frames to be requested from the camera, in pixels. Valid when type=1 or 5. Integer, &gt;0 camera-width=1920 dGPU, Jetson camera-height Height of frames to be requested from the camera, in pixels. Valid when type=1 or 5. Integer, &gt;0 camera-height=1080 dGPU, Jetson camera-fps-n Numerator part of a fraction specifying the frame rate requested by the camera, in frames/sec. Valid when type=1 or 5. Integer, &gt;0 camera-fps-n=30 dGPU, Jetson camera-fps-d Denominator part of a fraction specifying the frame rate requested from the camera, in frames/sec. Valid when type=1 or 5. Integer, &gt;0 camera-fps-d=1 dGPU, Jetson camera-v4l2-dev-node Number of the V4L2 device node. For example, /dev/video&lt;num&gt; for the open source V4L2 camera capture path. Valid when the type setting (type of source) is 1. Integer, &gt;0 camera-v4l2-dev-node=1 dGPU, Jetson latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Integer, \u22650 latency=200 dGPU, Jetson camera-csi-sensor-id Sensor ID of the camera module. Valid when the type (type of source) is 5. Integer, \u22650 camera-csi-sensor-id=1 Jetson drop-frame-interval Interval to drop frames. For example, 5 means decoder outputs every fifth frame; 0 means no frames are dropped. Integer, drop-frame-interval=5 dGPU, Jetson cudadec-memtype Type of CUDA memory element used to allocate for output buffers for source of type 2,3 or 4. Not applicable for CSI or USB camera source 0 (memtype_device): Device memory allocated with cudaMalloc(). 1 (memtype_pinned): host/pinned memory allocated with cudaMallocHost(). 2 (memtype_unified): Unified memory allocated with cudaMallocManaged(). Integer, 0, 1, or 2 cudadec-memtype=1 dGPU nvbuf-memory-type Type of CUDA memory the element is to allocate for output buffers of nvvideoconvert, useful for source of type 1. 0 (nvbuf-mem-default, a platform-specific default 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory. 2 (nvbuf-mem-cuda-device): Device CUDA memory. 3 (nvbuf-mem-cuda-unified): Unified CUDA memory. For dGPU: All values are valid. For Jetson: Only 0 (zero) is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU,Jetson select-rtp-protocol Transport Protocol to use for RTP. Valid when type (type of source) is 4. 0: UDP + UDP Multicast + TCP 4: TCP only Integer, 0 or 4 select-rtp-protocol=4 dGPU, Jetson rtsp-reconnect-interval-sec Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. Setting it to 0 will disable the reconnection. Valid when type (type of source) is 4. Integer, \u22650 rtsp-reconnect-interval-sec=60 dGPU, Jetson rtsp-reconnect-attempts Maximum number of times a reconnection is attempted. Setting it to -1 means reconnection will be attempted infinitely. Valid when type of source is 4 and rtsp-reconnect-interval-sec is a non-zero positive value. Integer, \u2265-1 rtsp-reconnect-attempts=2 smart-record Ways to trigger the smart record. 0: Disable 1: Only through cloud messages 2: Cloud message + Local events Integer, 0, 1 or 2 smart-record=1 dGPU, Jetson smart-rec-dir-path Path of directory to save the recorded file. By default, the current directory is used. String smart-rec-dir-path=/home/nvidia/ dGPU, Jetson smart-rec-file-prefix Prefix of file name for recorded video. By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix. String smart-rec-file-prefix=Cam1 dGPU, Jetson smart-rec-cache Size of smart record cache in seconds. Integer, \u22650 smart-rec-cache=20 dGPU, Jetson smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Integer, 0 or 1 smart-rec-container=0 dGPU, Jetson smart-rec-start-time Number of seconds earlier from now to start the recording. E.g. if t0 is the current time and N is the start time in seconds that means recording will start from t0 \u2013 N. Obviously for it to work the video cache size must be greater than the N. Integer, \u22650 smart-rec-start-time=5 dGPU, Jetson smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Integer, \u22650 smart-rec-default-duration=20 dGPU, Jetson smart-rec-duration Duration of recording in seconds. Integer, \u22650 smart-rec-duration=15 dGPU, Jetson smart-rec-interval This is the time interval in seconds for SR start / stop events generation. Integer, \u22650 smart-rec-interval=10 dGPU, Jetson udp-buffer-size UDP buffer size in bytes for RTSP sources. Integer, \u22650 udp-buffer-size=2000000 dGPU, Jetson video-format Output video format for the source. This value is set as the output format of the nvvideoconvert element for the source. String: NV12, I420, P010_10LE, BGRx, RGBA video-format=RGBA dGPU, Jetson", "keywords": []}, {"id": 3127, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#source-list-and-source-attr-all-groups", "display_name": "Source-list and source-attr-all Groups", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "source-list-and-source-attr-all-groups", "priority": -1, "content": "The source-list group allows users to provide an initial list of source URI to start streaming with. This group along with [source-attr-all] can replace the need for separate [source] groups for each stream. Also, DeepStream support (Alpha feature) dynamic sensor provisioning via REST API. For more details on this feature, please refer to the sample configuration file and deepstream reference application run command here . For example: [source-list] num-source-bins=2 list=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4 sgie-batch-size=8 ... [source-attr-all] enable=1 type=3 num-sources=1 gpu-id=0 cudadec-memtype=0 latency=100 rtsp-reconnect-interval-sec=0 ... Note : [source-list] now support REST Server with use-nvmultiurisrcbin=1 For example: [source-list] num-source-bins=2 list=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4 use-nvmultiurisrcbin=1 #sensor-id-list vector is one to one mapped with the uri-list #identifies each sensor by a unique ID sensor-id-list=UniqueSensorId1;UniqueSensorId2 #Optional sensor-name-list vector is one to one mapped with the uri-list sensor-name-list=UniqueSensorName1;UniqueSensorName2 max-batch-size=10 http-ip=localhost http-port=9000 #sgie batch size is number of sources * fair fraction of number of objects detected per frame per source #the fair fraction of number of object detected is assumed to be 4 sgie-batch-size=40 [source-attr-all] enable=1 type=3 num-sources=1 gpu-id=0 cudadec-memtype=0 latency=100 rtsp-reconnect-interval-sec=0 The [source-list] group properties are: Key Meaning Type and Value Example Platforms enable Enables or disables the source. Boolean enable=1 dGPU, Jetson num-source-bins The total number of source URI\u2019s provided with the key list Integer num-source-bins=2 dGPU, Jetson sgie-batch-size sgie batch size is number of sources * fair fraction of number of objects detected per frame per source the fair fraction of number of object detected is assumed to be 4 Integer sgie-batch-size=8 dGPU, Jetson list The list of URI\u2019s separated by semi-colon \u2018;\u2019 String list=rtsp://ip-address:port/stream1;rtsp://ip-address:port/stream2 dGPU, Jetson sensor-id-list (Alpha Feature) Applicable only when use-nvmultiurisrcbin=1. The list of unique Identifiers identifying each stream separated by semi-colon \u2018;\u2019 String sensor-id-list=UniqueSensorId1;UniqueSensorId2 dGPU sensor-name-list (Alpha Feature) Applicable only when use-nvmultiurisrcbin=1. The Optional list of sensor names identifying each stream separated by semi-colon \u2018;\u2019 String sensor-name-list=SensorName1;SensorName2 dGPU use-nvmultiurisrcbin (Alpha Feature) Boolean if set enable the use of nvmultiurisrcbin with REST API support for dynamic sensor provisioning Boolean use-nvmultiurisrcbin=0(default) dGPU max-batch-size (Alpha Feature) Applicable only when use-nvmultiurisrcbin=1. Sets the maximum number of sensors that can be streamed using this instance of DeepStream Integer max-batch-size=10 dGPU http-ip (Alpha Feature) Applicable only when use-nvmultiurisrcbin=1. The HTTP Endpoint IP address to use String http-ip=localhost (default) dGPU http-port (Alpha Feature) Applicable only when use-nvmultiurisrcbin=1. The HTTP Endpoint port number to use. Note: User may pass empty string to disable REST API server String http-ip=9001 (default) dGPU The [source-attr-all] group support all properties except uri from the Source Group . A sample config file can be found at /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test5/configs/test5_config_file_nvmultiurisrcbin_src_list_attr_all.txt .", "keywords": []}, {"id": 3128, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#streammux-group", "display_name": "Streammux Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "streammux-group", "priority": -1, "content": "The [streammux] group specifies and modifies properties of the Gst-nvstreammux plugin. Key Meaning Type and Value Example Platforms gpu-id GPU element is to use in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU live-source Informs the muxer that sources are live. Boolean live-source=0 dGPU, Jetson buffer-pool-size Number of buffers in Muxer output buffer pool. Integer, &gt;0 buffer-pool-size=4 dGPU, Jetson batch-size Muxer batch size. Integer, &gt;0 batch-size=4 dGPU, Jetson batched-push-timeout Timeout in microseconds after to push the batch after the first buffer is available, even if the complete batch is not formed. Integer, \u2265\u22121 batched-push-timeout=40000 dGPU, Jetson width Muxer output width in pixels. Integer, &gt;0 width=1280 dGPU, Jetson height Muxer output height in pixels. Integer, &gt;0 height=720 dGPU, Jetson enable-padding Indicates whether to maintain source aspect ratio when scaling by adding black bands. Boolean enable-padding=0 dGPU, Jetson nvbuf-memory-type Type of CUDA memory the element is to allocate for output buffers. 0 (nvbuf-mem-default, a platform-specific default 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory. 2 (nvbuf-mem-cuda-device): Device CUDA memory. 3 (nvbuf-mem-cuda-unified): Unified CUDA memory. For dGPU: All values are valid. For Jetson: Only 0 (zero) is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU attach-sys-ts-as-ntp For live sources, the muxed buffer shall have associated NvDsFrameMeta-&gt;ntp_timestamp set to system time or the server\u2019s NTP time when streaming RTSP. If set to 1, system timestamp will be attached as ntp timestamp. If set to 0, ntp timestamp from rtspsrc, if available, will be attached. Boolean attach-sys-ts-as-ntp=0 dGPU, Jetson config-file-path This key is valid only for the new streammux. Please refer the plugin manual section \u201cNew Gst-nvstreammux\u201d for more information. Absolute or relative (to DS config-file location) path of mux configuration file. String config-file-path=config_mux_source30.txt dGPU, Jetson sync-inputs Time synchronize input frames before batching them. Boolean sync-inputs=0 (default) dGPU, Jetson max-latency Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds). Integer, \u22650 max-latency=0 (default) dGPU, Jetson drop-pipeline-eos Boolean property to control EOS propagation downstream from nvstreammux when all the sink pads are at EOS. (Experimental) Boolean drop-pipeline-eos=0(default) dGPU/Jetson", "keywords": []}, {"id": 3129, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#tests-group", "display_name": "Tests Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "tests-group", "priority": -1, "content": "The tests group is for diagnostics and debugging. Key Meaning Type and Value Example Platforms file-loop Indicates whether input files should be looped infinitely. Boolean file-loop=1 dGPU, Jetson", "keywords": []}, {"id": 3130, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#tiled-display-group", "display_name": "Tiled-display Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "tiled-display-group", "priority": -1, "content": "The tiled-display group properties are: Key Meaning Type and Value Example Platforms enable Indicates whether tiled display is enabled. When user sets enable=2, first [sink] group with the key: link-to-demux=1 shall be linked to demuxer\u2019s src_[source_id] pad where source_id is the key set in the corresponding [sink] group. Integer, 0 = disabled, 1 = tiler-enabled 2 = tiler-and-parallel-demux-to-sink-enabled enable=1 dGPU, Jetson rows Number of rows in the tiled 2D array. Integer, &gt;0 rows=5 dGPU, Jetson columns Number of columns in the tiled 2D array. Integer, &gt;0 columns=6 dGPU, Jetson width Width of the tiled 2D array, in pixels. Integer, &gt;0 width=1280 dGPU, Jetson height Height of the tiled 2D array, in pixels. Integer, &gt;0 height=720 dGPU, Jetson gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=0 dGPU nvbuf-memory-type Type of memory the element is to allocate for output buffers. 0 (nvbuf-mem-default): a platform-specific default type 1 (nvbuf-mem-cuda-pinned): pinned/host CUDA memory 2 (nvbuf-mem-cuda-device): device CUDA memory 3 (nvbuf-mem-cuda-unified): unified CUDA memory For dGPU: All values are valid. For Jetson: Only 0 (zero) is valid. Integer, 0, 1, 2, or 3 nvbuf-memory-type=3 dGPU, Jetson compute-hw Compute Scaling HW to use. Applicable only for Jetson. dGPU systems uses GPU by default. 0 (Default): Default, GPU for Tesla, VIC for Jetson 1 (GPU): GPU 2 (VIC): VIC Integer: 0-2 compute-hw=1 Jetson square-seq-grid Enable automatic square tiling according to number of sources. The tiles are placed sequentially on the grid with empty tiles at the end Boolean square-seq-grid=1 dGPU, Jetson", "keywords": []}, {"id": 3131, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#tracker-group", "display_name": "Tracker Group", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "tracker-group", "priority": -1, "content": "The tracker group properties include the following, and more details can be found in Gst Properties : Key Meaning Type and Value Example Platforms enable Enables or disables the tracker. Boolean enable=1 dGPU, Jetson tracker-width Frame width at which the tracker will operate, in pixels. (To be a multiple of 32 when tracker config visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0) Integer, \u22650 tracker-width=960 dGPU, Jetson tracker-height Frame height at which the tracker will operate, in pixels. (To be a multiple of 32 when tracker config visualTrackerType: 1 or reidType is non-zero with useVPICropScaler: 0) Integer, \u22650 tracker-height=544 dGPU, Jetson gpu-id GPU to be used by the element in case of multiple GPUs. Integer, \u22650 gpu-id=1 dGPU ll-config-file Configuration file for the low-level library if needed. (Alpha feature) A list of configuration files can be specified when the property sub-batches is configured. String ll-config-file=iou_config.txt dGPU, Jetson ll-lib-file Pathname for the low-level tracker implementation library. String ll-lib-file=/usr/-local/deepstream/libnvds_mot_iou.so dGPU, Jetson tracking-surface-type Set surface stream type for tracking. (default value is 0) Integer, \u22650 tracking-surface-type=0 dGPU, Jetson display-tracking-id Enables tracking id display. Boolean display-tracking-id=1 dGPU, Jetson tracking-id-reset-mode Allow force-reset of tracking ID based on pipeline event. Once tracking ID reset is enabled and such event happens, the lower 32-bit of the tracking ID will be reset to 0 0: Not reset tracking ID when stream reset or EOS event happens 1: Terminate all existing trackers and assign new IDs for a stream when the stream reset happens (i.e., GST_NVEVENT_STREAM_RESET) 2: Let tracking ID start from 0 after receiving EOS event (i.e., GST_NVEVENT_STREAM_EOS) (Note: Only the lower 32-bit of tracking ID to start from 0) 3: Enable both option 1 and 2 Integer, 0 to 3 tracking-id-reset-mode=0 dGPU, Jetson input-tensor-meta Use the tensor-meta from Gst-nvdspreprocess if available for tensor-meta-gie-id Boolean input-tensor-meta=1 dGPU, Jetson tensor-meta-gie-id Tensor Meta GIE ID to be used, property valid only if input-tensor-meta is TRUE Unsigned Integer, \u22650 tensor-meta-gie-id=5 dGPU, Jetson sub-batches (Alpha feature) Configures splitting of a batch of frames in sub-batches Semicolon delimited integer array. Must include all values from 0 to (batch-size -1) where batch-size is configured in [streammux] . sub-batches=0,1;2,3 In this example, a batch size of 4 is split into two sub-batches where the first sub-batch consists of source ids 0 &amp; 1 and second sub-batch consists of source ids 2 &amp; 3 dGPU, Jetson sub-batch-err-recovery-trial-cnt (Alpha feature) Configure the number of times the plugin can try to recover when the low level tracker in a sub-batch returns with a fatal error. To recover from the error, the plugin reinitializes the low level tracker library. Integer,\u2265-1 where, -1 corresponds to infinite trials sub-batch-err-recovery-trial-cnt=3 dGPU, Jetson user-meta-pool-size The size of tracker miscellaneous data buffer pool Unsigned Integer, &gt;0 user-meta-pool-size=32 dGPU, Jetson", "keywords": []}, {"id": 3132, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "page", "name": "text/DS_ref_app_deepstream#triton", "display_name": "Triton", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_deepstream", "anchor": "triton", "priority": -1, "content": "If you are using Triton with DeepStream, tune tf_gpu_memory_fraction values for TensorFlow GPU memory usage per process - suggested range [0.2, 0.6]. Too large value can cause Out-of-memory and too small may cause low perf. Enable TensorRT optimization when using TensorFlow or ONNX with Triton. Update Triton config file to enable TensorFlow/ONNX TensorRT online optimization. This will take several minutes during initialization each time. Alternatively, you can generate TF-TRT graphdef/savedmodel models offline.", "keywords": []}, {"id": 3133, "doc_id": 3133, "filename": "text/DS_ref_app_deepstream.html", "domain_name": "std", "name": "text/DS_ref_app_deepstream", "display_name": "DeepStream Reference Application - deepstream-app", "type": "doc", "display_type": "Page", "docname": "text/DS_ref_app_deepstream", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3134, "doc_id": 3137, "filename": "text/DS_ref_app_github.html", "domain_name": "page", "name": "text/DS_ref_app_github#ai-models-with-deepstream", "display_name": "AI models with DeepStream", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_github", "anchor": "ai-models-with-deepstream", "priority": -1, "content": "TAO model deployment in DeepStream", "keywords": []}, {"id": 3135, "doc_id": 3137, "filename": "text/DS_ref_app_github.html", "domain_name": "page", "name": "text/DS_ref_app_github#deepstream-features-sample", "display_name": "DeepStream features sample", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_github", "anchor": "deepstream-features-sample", "priority": -1, "content": "Runtime source addition/removal with DeepStream Anomaly detection using NV Optical Flow using DeepStream Single View 3D Tracking with DeepStream Custom Post-processing for SSD model in Python DeepStream app (Python) Save image metadata from DeepStream pipeline (Python) Generate RTSP output from the RTSP source with inferencing result (Python)", "keywords": []}, {"id": 3136, "doc_id": 3137, "filename": "text/DS_ref_app_github.html", "domain_name": "page", "name": "text/DS_ref_app_github#use-case-applications", "display_name": "Use case applications", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_github", "anchor": "use-case-applications", "priority": -1, "content": "DeepStream License Plate detection and recognition DeepStream parallel multiple models", "keywords": []}, {"id": 3137, "doc_id": 3137, "filename": "text/DS_ref_app_github.html", "domain_name": "std", "name": "text/DS_ref_app_github", "display_name": "DeepStream Reference Application on GitHub", "type": "doc", "display_type": "Page", "docname": "text/DS_ref_app_github", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3138, "doc_id": 3140, "filename": "text/DS_ref_app_nmos.html", "domain_name": "page", "name": "text/DS_ref_app_nmos#application-architecture", "display_name": "Application Architecture", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_nmos", "anchor": "application-architecture", "priority": -1, "content": "The image below shows the architecture of the NVIDIA \u00ae DeepStream NMOS reference application. This application demonstrates how to create any DeepStream app as an NMOS Node. It uses a library ( NvDsNmos ) which provides the APIs to create, destroy and internally manage the NMOS Node. The NMOS Node can automatically discover and register with an NMOS Registry on the network using the AMWA IS-04 Registration API. It also shows how to create various Video and Audio pipelines, run them simultaneously and reconfigure them based on NMOS events such as AMWA IS-05 Connection API requests from an NMOS Controller. This application has three modes of operations: As NMOS Receiver (Default) In this mode, application provides NMOS Receivers that can be used to configure UDP sources to receive SMPTE ST 2110-20/-30 streams. Received (Video / Audio) streams are rendered to local Video / Audio sinks after some processing (Object detection and Bounding box overlay in case of Video). As NMOS Sender In this mode, application provides NMOS Senders that can be used to configure UDP sinks to transmit SMPTE ST 2110-20/-30 streams. Transmitted streams are created from videotestsrc and audiotestsrc . As Both NMOS Receiver and Sender In this mode, application provides NMOS Receivers to configure UDP sources and after processing the data transmits streams from UDP sinks which are configured by NMOS Senders.", "keywords": []}, {"id": 3139, "doc_id": 3140, "filename": "text/DS_ref_app_nmos.html", "domain_name": "page", "name": "text/DS_ref_app_nmos#using-easy-nmos-for-nmos-registry-and-controller", "display_name": "Using Easy-NMOS for NMOS Registry and Controller", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_nmos", "anchor": "using-easy-nmos-for-nmos-registry-and-controller", "priority": -1, "content": "This application requires AMWA IS-05 Connection API requests for its operation. These events are generated by an NMOS Controller. Easy-NMOS is a simple and easy way to set up an NMOS Controller and Registry. Follow the instructions below to set up the NMOS Registry and run the NMOS Controller. These instructions expect that docker and docker compose are already installed. If not then refer steps provided here - https://docs.docker.com/engine/install/ and https://docs.docker.com/compose/install/ . Or follow the quick instructions here - rhastie/easy-nmos Clone the git repository as follows: git clone https://github.com/rhastie/easy-nmos.git Modify the docker-compose.yml to replace the values of \u201cipv4_address\u201d fields of each container accordingly. Start the docker containers as follows: docker-compose up Once setup is complete, the NMOS Controller should be running on following address. http://nmos-registry.local/admin Refer to rhastie/easy-nmos for detailed instructions for setup. Refer to https://www.amwa.tv/easy-nmos-videos for a tutorial on Easy-NMOS. Refer to https://specs.amwa.tv/nmos/ for details about the NMOS specifications.", "keywords": []}, {"id": 3140, "doc_id": 3140, "filename": "text/DS_ref_app_nmos.html", "domain_name": "std", "name": "text/DS_ref_app_nmos", "display_name": "DeepStream Reference Application - deepstream-nmos app", "type": "doc", "display_type": "Page", "docname": "text/DS_ref_app_nmos", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3141, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#iot-protocols-supported-and-cloud-configuration", "display_name": "IoT Protocols supported and cloud configuration", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "iot-protocols-supported-and-cloud-configuration", "priority": -1, "content": "Details on the IoT Protocols (like KAFKA, Azure, AMQP, etc.,) supported by nvmsgbroker plugin is listed in the DeepStream Plugin guide. DeepStream Public documentation may be referred to setup IoT hubs/servers/brokers specific to the protocol in use. [sink] group keys associated with type=6 for nvmsgconv and nvmsgbroker configuration are discussed in the Configuration Groups .", "keywords": []}, {"id": 3142, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#message-consumer", "display_name": "Message consumer", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "message-consumer", "priority": -1, "content": "deepstream-test5-app can be configured to work as message consumer for cloud messages. After parsing the received message, based on the content of the message specific action(s) can be triggered. For example, NvDsSrcParentBin* , which holds the smart record context, is passed as an argument in start_cloud_to_device_messaging() which is used to trigger start/stop of smart record. By default, event-based recording has been implemented to demonstrate the usage of message consumer. User need to implement the custom logic to work on other types of received messages. See deepstream_c2d_msg* files for more details about implementation. To subscribe to cloud messages, configure the [message-consumer] group(s) accordingly.", "keywords": []}, {"id": 3143, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#ota-model-update", "display_name": "OTA model update", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "ota-model-update", "priority": -1, "content": "Test5 app can update the models in the running pipeline on-the-fly. For this, the app provides the command line option -o . If test5 app is launched with -o (ota_override_file) option, any change to that file is monitored and based on the change in that file, running pipeline is updated with the new models on-the-fly.", "keywords": []}, {"id": 3144, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#sensor-provisioning-support-over-rest-api-runtime-sensor-add-remove-capability", "display_name": "Sensor Provisioning Support over REST API (Runtime sensor add/remove capability)", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "sensor-provisioning-support-over-rest-api-runtime-sensor-add-remove-capability", "priority": -1, "content": "By enabling the use of nvmultiurisrcbin, deepstream-(test5-)app can support runtime sensor ADD/REMOVE capability. More information on nvmultiurisrcbin can be found here . Sample command to run deepstream-test5-app with nvmultiurisrcbin: cd /opt/nvidia/deepstream/deepstream/sources/apps/sample_apps/deepstream-test5/configs deepstream-test5-app -c test5_config_file_nvmultiurisrcbin_src_list_attr_all.txt The config file passed in the above command uses [source-list] config group with config key use-nvmultiurisrcbin=1 to employ nvmultiurisrcbin. App starts with 2 X sources Able to add/remove streams using the curl command REST API commands documented in Section REST API payload definitions and sample curl commands for reference . By default the nvstreammux config key drop-pipeline-eos is set, allowing the app to always be alive. This means the application will not quit even after the last stream EOS. This allows the running REST Server to provision additional sensors. By default stream name is not observed in FPS logs. In source-list group, set stream-name-display=1 to view stream names along with source-id. By default on stream addition the tiler will not reutilize the empty tiles. Set square-seq-grid=1 to always follow a square grid and empty tiles will be reused if a new source is added.", "keywords": []}, {"id": 3145, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#smart-record-event-based-recording", "display_name": "Smart Record - Event based recording", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "smart-record-event-based-recording", "priority": -1, "content": "Test5 application can be configured to record the original video feed based on the event received from the server. In this way, instead of saving data all the time, this feature allows to record only event of interests. Refer to the DeepStream plugin manual and gst-nvdssr.h ``header file for more details about smart record. Event based recording can be enabled by setting ``smart-record under [sourceX] group. Currently test5 app only supports source type = 4 (RTSP). Similar approach can be used for other types of sources as well. There are two ways in which smart record events can be triggered: Through cloud messages. To trigger smart record through cloud messages, Test5 app should be configured to work as a message consumer. This can be done by configuring [message-consumerX] group(s) accordingly. After configuring the message consumer, smart record should be enabled on the source(s) on which event-based recording is desired. This can be done as follows: smart-record=1 Following minimum Json message is expected to trigger the start / stop of smart record. { command: string // &lt;start-recording / stop-recording&gt; start: string // &quot;2020-05-18T20:02:00.051Z&quot; end: string // &quot;2020-05-18T20:02:02.851Z&quot;, sensor: { id: string } } Through local events. Set smart-record=2 , this will enable smart record through cloud messages as well as local events. To demonstrate the event-based recording through local events, application by default triggers start / stop events every ten seconds. This interval and other parameters are configurable.", "keywords": []}, {"id": 3146, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "page", "name": "text/DS_ref_app_test5#using-the-ota-functionality", "display_name": "Using the OTA functionality", "type": "section", "display_type": "Page section", "docname": "text/DS_ref_app_test5", "anchor": "using-the-ota-functionality", "priority": -1, "content": "Perform the following to use the OTA functionality: Run deepstream-test5-app with -o &lt;ota_override_file&gt; option While DS application is running, update the &lt;ota_override_file&gt; with new model details and save it File content changes gets detected by deepstream-test5-app and then it starts model-update process. Currently only model-update feature is supported as a part of OTA functionality. Assumption for On-The-Fly model updates : New model must have same network parameter configuration as of previous model (e.g. network resolution, network architecture, number of classes) Engine file or cache file of new model to be provided by developer Updated values for other primary gie configuration parameters like group-threshold , bbox color , gpu-id , nvbuf-memory-type , etc., if provided in the override file, will not have any effect after model switch. Secondary gie model-update is not validated, only primary model-update is validated. No frame drop / frames without inference should be observed during on-the-fly model update process In case of model update failure, error message will be printed on the console and pipeline should continue to run with older model configuration config-file parameter is needed to suppress the config file parsing error prints, values from this config file are not used during model switch process", "keywords": []}, {"id": 3147, "doc_id": 3147, "filename": "text/DS_ref_app_test5.html", "domain_name": "std", "name": "text/DS_ref_app_test5", "display_name": "DeepStream Reference Application - deepstream-test5 app", "type": "doc", "display_type": "Page", "docname": "text/DS_ref_app_test5", "anchor": "", "priority": -1, "content": "Test5 application, in addition to regular inference pipeline, supports the following features: Sending the messages to back end server. Working as consumer to receive messages from the back-end server. Triggering event-based recording based on the messages received from the server. OTA model update. Sensor Provisioning Support over REST API", "keywords": []}, {"id": 3148, "doc_id": 3150, "filename": "text/DS_sample_configs_streams.html", "domain_name": "page", "name": "text/DS_sample_configs_streams#contents-of-the-package", "display_name": "Contents of the package", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_configs_streams", "anchor": "contents-of-the-package", "priority": -1, "content": "This section provides information about included sample configs and streams. samples: Directory containing sample configuration files, streams, and models to run the sample applications. samples/configs/deepstream-app: Configuration files for the reference application The following table provides information about configuration files for the reference application in samples/configs/deepstream-app directory. Configuration File Description Platform source30_1080p_dec_infer-resnet_tiled_display_int8.txt Demonstrates 30 stream decodes with primary inferencing For dGPU and Jetson AGX Orin platforms only. source30_1080p_dec_infer-resnet_tiled_display_int8.yml YAML based config file to demonstrate 30 stream decode with primary inferencingFor dGPU and Jetson AGX Orin platforms only. For dGPU and Jetson AGX Orin platforms only. source4_1080p_dec_infer-resnet_tiled_display_int8.txt Demonstrates four stream decodes with primary inferencing, object tracking, and two different secondary classifiers For dGPU and Jetson AGX Orin platforms only. source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yml YAML based config file to demonstrate four stream decode with primary inferencing, object tracking, and two different secondary classifiers For dGPU and Jetson AGX Orin platforms only. source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8_gpu1.txt Demonstrates four stream decodes with primary inferencing, object tracking, and two different secondary classifiers on GPU 1 (for systems that have multiple GPU cards) For dGPU platforms only config_infer_primary.txt Configures a nvinfer element as primary detector For dGPU and Jetson config_infer_primary.yml YAML based config file to configure a nvinfer element as primary detector For dGPU and Jetson config_infer_secondary_vehiclemake.txt, config_infer_secondary_vehicletypes.txt Configure a nvinfer element as secondary classifier For dGPU and Jetson config_infer_secondary_vehiclemake.yml, config_infer_secondary_vehicletypes.yml YAML based config file to configure a nvinfer element as secondary classifier For dGPU and Jetson config_tracker_IOU.yml Config file for IOU tracker For dGPU and Jetson config_tracker_NvSORT.yml Config file for NvSORT tracker For dGPU and Jetson config_tracker_NvDeepSORT.yml Config file for NvDeepSORT tracker For dGPU and Jetson config_tracker_NvDCF_accuracy.yml Config file for NvDCF tracker for higher accuracy For dGPU and Jetson config_tracker_NvDCF_max_perf.yml Config file for NvDCF tracker for max perf mode For dGPU and Jetson config_tracker_NvDCF_perf.yml Config file for NvDCF tracker for perf mode For dGPU and Jetson config_preprocess.txt Config file for using preprocess in PGIE mode For dGPU and Jetson config_preprocess_sgie.txt Config file for using preprocess in SGIE mode For dGPU and Jetson source4_1080p_dec_preprocess_infer-resnet_preprocess_sgie_tiled_display_int8.txt Demonstrates four stream decodes with preprocess plugin in PGIE mode followed by primary inferencing, preprocess plugin in SGIE mode, and two different secondary classifiers For dGPU and Jetson AGX Orin platforms only. source30_1080p_dec_preprocess_infer-resnet_tiled_display_int8.txt Demonstrates 30 stream decodes with preprocess plugin in PGIE mode followed by primary inferencing For dGPU and Jetson AGX Orin platforms only. sources_30.csv CSV file for 30 sources required in source30_1080p_dec_infer-resnet_tiled_display_int8.yml For dGPU and Jetson AGX Orin platforms only. sources_4.csv CSV file for 30 sources required in source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.yml For dGPU and Jetson AGX Orin platforms only. source1_usb_dec_infer_resnet_int8.txt Demonstrates one USB camera as input For dGPU and Jetson source1_csi_dec_infer_resnet_int8.txt Demonstrates one CSI camera as input For Jetson only source2_csi_usb_dec_infer_resnet_int8.txt Demonstrates one CSI camera and one USB camera as inputs For Jetson only source6_csi_dec_infer_resnet_int8.txt Demonstrates six CSI cameras as inputs For Jetson only source2_1080p_dec_infer-resnet_demux_int8.txt Demonstrates demux mode for two sources For dGPU and Jetson config_mux_source4.txt, config_mux_source30.txt Sample nvstreammux (new) config files. For more details see Section Mux Config Properties For dGPU and Jetson samples/configs/deepstream-app-triton: Configuration files for the reference application for inferencing using Triton Inference Server. The following table provides information about configuration files for the reference application in samples/configs/deepstream-app-triton directory. Configuration File Description source30_1080p_dec_infer-resnet_tiled_display_int8.txt 30 Decode + Infer source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt 4 Decode + Infer + SGIE + Tracker source1_primary_classifier.txt Single source + full frame classification source1_1080p_dec_infer_peoplesemsegnet_shuffle.txt Single source + semantic segmentation source1_primary_detector_peoplenet_transformer.txt Single source + full frame classification source1_primary_detector.txt Single source + object detection using ssd Other classification models can be used by changing the ds-triton nvinferserver config file in the [*-gie] group of application config file. Configuration files for ds-triton nvinferserver element in configs/deepstream-app-triton/ . The following table provides information about configuration files for the reference application in samples/configs/deepstream-app-triton directory. Configuration File Description config_infer_plan_engine_primary.txt Primary Object Detector config_infer_secondary_plan_engine_vehiclemake.txt Secondary Vehicle Make Classifier config_infer_secondary_plan_engine_vehicletypes.txt Secondary Vehicle Type Classifier config_infer_primary_classifier_densenet_onnx.txt DenseNet-121 v1.2 classifier config_infer_primary_classifier_inception_graphdef_postprocessInTriton.txt TensorFlow Inception v3 classifier - Post processing in Triton config_infer_primary_classifier_inception_graphdef_postprocessInDS.txt TensorFlow Inception v3 classifier - Post processing in DeepStream config_infer_primary_detector_ssd_inception_v2_coco_2018_01_28.txt TensorFlow SSD Inception V2 Object Detector config_infer_primary_classifier_mobilenet_v1_graphdef.txt TensorFlow Mobilenet V1 classifier config_infer_primary_detector_ssd_mobilenet_v1_coco_2018_01_28.txt TensorFlow Mobilenet V1 Object Detector samples/configs/deepstream-app-triton-grpc: Configuration files for the reference application for inferencing using Triton Inference Server gRPC The following table provides information about configuration files for the reference application using Triton Inference Server gRPC in samples/configs/deepstream-app-triton-grpc directory. Configuration File Description source30_1080p_dec_infer-resnet_tiled_display_int8.txt 30 Decode + Infer source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt 4 Decode + Infer + SGIE + Tracker Configuration files for ds-triton nvinferserver element in configs/deepstream-app-triton-grpc/ . The following table provides information about configuration files for the reference application using Triton Inference Server nvinferserver in samples/configs/deepstream-app-triton-grpc directory. Configuration File Description config_infer_plan_engine_primary.txt Primary Object Detector config_infer_secondary_plan_engine_vehiclemake.txt Secondary Vehicle Make Classifier config_infer_secondary_plan_engine_vehicletypes.txt Secondary Vehicle Type Classifier NVIDIA TAO Toolkit pretrained Models: samples/configs/tao_pretrained_models: Contains README.md to obtain configs and models for TAO toolkit. samples: Directory containing sample configuration files, models, and streams to run the sample applications. samples/streams: The following streams are provided with the DeepStream SDK: Streams Type of Stream sample_1080p_h264.mp4 H264 containerized stream sample_1080p_h265.mp4 H265 containerized stream sample_720p.h264 H264 elementary stream sample_720p.jpg JPEG image sample_720p_mjpeg.mp4 MJPEG containerized stream sample_720p.mp4 Containerized stream sample_cam5.mp4 H264 containerized stream (360D camera stream) sample_cam6.mp4 H264 containerized stream (360D camera stream) sample_industrial.jpg JPEG image yoga.jpg Image for perspective projection in Dewarper yoga.mp4 Containerized stream sample_qHD.mp4 Used for MaskRCNN sample_qHD.h264 H264 elementary stream sample_push.mov H264 containerized stream sample_ride_bike.mov H264 containerized stream sample_run.mov H264 containerized stream sample_walk.mov H264 containerized stream fisheye_dist.mp4 Containerized stream sonyc_mixed_audio.wav Audio bitstream sample_office.mp4 Containerized stream pointcloud Contains input files for lidar application samples/models: The following sample models are provided with the SDK: DeepStream Reference application Model Model Type No. of Classes Resolution Primary Detector Resnet18 4 960 \u00d7 544 Secondary Vehicle Make Classifier Resnet18 20 224 \u00d7 224 Secondary Vehicle Type Classifier Resnet18 6 224 \u00d7 224 Segmentation example Model Model Type No. of Classes Resolution Industrial Resnet18 + UNet 1 512 x 512 Semantic Resnet18 + UNet 4 512 x 512 Instance Resnet50 + Maskrcnn 2 1344 x 832", "keywords": []}, {"id": 3149, "doc_id": 3150, "filename": "text/DS_sample_configs_streams.html", "domain_name": "page", "name": "text/DS_sample_configs_streams#scripts-included-along-with-package", "display_name": "Scripts included along with package", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_configs_streams", "anchor": "scripts-included-along-with-package", "priority": -1, "content": "The script prepare_classification_test_video.sh mentioned below requires ffmpeg to be installed. Some of the low level codec libraries need to be re-installed along with ffmpeg. Use the following command to install/re-install ffmpeg: apt-get install --reinstall libflac8 libmp3lame0 libxvidcore4 ffmpeg The following scripts are included along with the sample applications package: samples/ prepare_classification_test_video.sh: Downloads Imagenet test images and creates a video out of it to test with Classification models like TensorFlow Inception, ONNX DenseNet etc. samples/ prepare_ds_triton_model_repo.sh: Prepare the Model repository for Triton Inference Server Creates engine files for Caffe and UFF based models provided as part of SDK. Downloads Model files for ONNX DenseNet , SSD Inception V2 Coco, Inception v3. For additional information on the above models, refer to: ONNX DenseNet - onnx/models SSD Inception V2 Coco - tensorflow/models Inception V3 - tensorflow/models samples/ prepare_ds_triton_tao_model_repo.sh: Prepare the Model repository for Triton Tao Inference Server Downloads Model files for Peoplenet Transformer, Peoplesemsegnet Shuffle, Facenet. Create engine files for downloaded models. uninstall.sh: Used to clean up previous DS installation.", "keywords": []}, {"id": 3150, "doc_id": 3150, "filename": "text/DS_sample_configs_streams.html", "domain_name": "std", "name": "text/DS_sample_configs_streams", "display_name": "Sample Configurations and Streams", "type": "doc", "display_type": "Page", "docname": "text/DS_sample_configs_streams", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3151, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#accessing-nvbufsurface-memory-in-opencv", "display_name": "Accessing NvBufSurface memory in OpenCV", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "accessing-nvbufsurface-memory-in-opencv", "priority": -1, "content": "CUDA and CPU memory in NvBufSurface can be accessed through cv::cuda::GpuMat and cv::Mat interface of OpenCV respectively. In that case, NvBufSurface can work with any computer vision algorithm implemented in OpenCV. Following code snippet shows how to access and use CUDA memory of NvBufSurface in OpenCV. cv::cuda::GpuMat gpuMat; const int aDstOrder[] = {2,0,1,3}; unsigned int index = 0; // Index of the buffer in the batch. unsigned int width, height; // set width and height of buffer NvBufSurface *input_buf; // Pointer to input NvBufSurface gpuMat = cv::cuda::GpuMat(height, width, CV_8UC4, (void *)input_buf-&gt;surfaceList[index].dataPtr); OR gpuMat = cv::cuda::GpuMat(height, width, CV_8UC4, (void *) input_buf-&gt;surfaceList[index].dataPtr, input_buf-&gt;surfaceList[index].pitch); cv::cuda::swapChannels(gpuMat, aDstOrder); On Jetson platform, if memory of NvBufSurface is of type NVBUF_MEM_SURFACE_ARRAY you should convert it to CUDA through CUDA-EGL interop before accessing it in OpenCV. Refer to sources/gst-plugins/gst-dsexample/gstdsexample.cpp to access the NvBufSurface memory in OpenCV matrix ( cv::Mat ). Below steps are required: Create EGL image from NvBufSurface using NvBufSurfaceMapEglImage() Register EGL image in cuda using cuGraphicsEGLRegisterImage() Map EGL frame using cuGraphicsResourceGetMappedEglFrame() to get cuda pointer Refer to gst_nvinfer_allocator_alloc in file /opt/nvidia/deepstream/deepstream/sources/gst-plugins/gst-nvinfer/gstnvinfer_allocator.cpp for more details.", "keywords": []}, {"id": 3152, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#adding-nvtx-apis-for-sample-plugin", "display_name": "Adding NVTX APIs for sample plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "adding-nvtx-apis-for-sample-plugin", "priority": -1, "content": "Like other DeepStreamSDK GStreamer plugins, NVTX APIs can be added in a custom plugin as well. More information on these APIs can be found in https://docs.nvidia.com/gameworks/content/gameworkslibrary/nvtx/nvidia_tools_extension_library_nvtx.htm . Follow the steps below to add NVTX APIs for custom plugin: Include nvtx3/nvToolsExt.h header in the source code of plugin. To measure range, two APIs are commonly used: nvtxRangePushA (context) - Point at which profiling starts for this component / plugin. nvtxRangePop () - Point at which profiling stops for this component / plugin. Make sure the markers are placed such that the core functions of the plugin are performed between the above two APIs. This will give an accurate idea of latency. Run NSight for the custom plugin to obtain information for the tasks run between these two markers.", "keywords": []}, {"id": 3153, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#description-of-the-sample-plugin-gst-dsexample", "display_name": "Description of the Sample Plugin: gst-dsexample", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "description-of-the-sample-plugin-gst-dsexample", "priority": -1, "content": "The GStreamer example plugin ( gst-dsexample ) demonstrates the following: Processing the entire frame, with downscaling / color conversion if required. Processing objects detected by the Primary Detector, specifically, cropping these objects from the frame and then processing the crops. In-place modification of the buffer frame contents using OpenCV Two versions of the plugin are included. Refer to the plugin\u2019s Makefile and README to switch between them Simple (gstdsexample.cpp) - Sequential pre-processing and processing Optimized (gstdsexample_optimized.cpp) - Parallel batch pre-processing and processing This release includes a simple static library dsexample_lib that demonstrates the interface between custom libraries and this Gstreamer plugin. The library generates simple labels of the form Obj_label . The library implements these functions: DsExampleCtxInit \u2014 Initializes the custom library DsExampleCtxDeinit \u2014 De-initializes the custom library DsExampleProcess \u2013 Process on an input frame The GStreamer plugin itself is a standard in-place transform plugin. Because it does not generate new buffers but only adds / updates existing metadata, the plugin implements an in-place transform. Some of the code is standard GStreamer plugin boilerplate (e.g. plugin_init , class_init , instance_init ). Other functions of interest are as follows:", "keywords": []}, {"id": 3154, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#enabling-and-configuring-the-sample-plugin", "display_name": "Enabling and configuring the sample plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "enabling-and-configuring-the-sample-plugin", "priority": -1, "content": "The pre-compiled deepstream-app binary already has the functionality to parse the configuration and add the sample element to the pipeline. To enable and configure the plugin, add the following section to an existing configuration file (for example, source4_720p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt ): [ds-example] enable=1 processing-width=640 processing-height=480 full-frame=0 blur-objects=0 unique-id=15", "keywords": []}, {"id": 3155, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#gstbasetransfrom-class-functions", "display_name": "GstBaseTransfrom Class Functions", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "gstbasetransfrom-class-functions", "priority": -1, "content": "start \u2014 Acquires resources, allocate memory, initialize example library. stop \u2014 De-initializes the example library and frees up resources and memory. set_caps \u2014 Gets the capabilities of the video (i.e. resolution, color format, framerate) that flow through this element. Allocations/initializations that depend on input video format can be done here. transform_ip \u2014 Implemented in the simple version. Called when the plugin receives a buffer from upstream element. Finds the metadata of the primary detector. Use get_converted_mat to pre-process frame/object crop to get the required buffer for pushing to library. Push the data to the example library. Pop the example library output. Attach/update metadata using attach_metadata_full_frame or attach_metadata_object . Alternatively, modify frame contents in-place to blur objects using blur_objects . submit_input_buffer \u2014 Implemented in the optimized version. Called when the plugin receives a buffer from upstream element. Works in parallel with gst_dsexample_output_loop to improve performance. Finds the metadata of the primary detector. Create a batch of frames/objects to pre-process. Pre-process the batches and push the pre-processed output to the processing thread. Pre-process on the next batch while the processing thread works on an older batch.", "keywords": []}, {"id": 3156, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#implementing-custom-logic-within-the-sample-plugin", "display_name": "Implementing Custom Logic Within the Sample Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "implementing-custom-logic-within-the-sample-plugin", "priority": -1, "content": "To implement custom logic within the plugin, replace the following function calls list below with corresponding functions of any other custom library. DsExampleCtxInit DsExampleCtxDeinit DsExampleProcess blur_objects Depending on the input requirements of the library, get_converted_mat may also require modification.", "keywords": []}, {"id": 3157, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#other-supporting-functions", "display_name": "Other supporting functions", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "other-supporting-functions", "priority": -1, "content": "get_converted_mat \u2014 Scales, converts, or crops the input buffer, either the full frame or the object based on its co-ordinates in primary detector metadata. attach_metadata_full_frame \u2014 Shows how the plugin can attach its own metadata for objects detected by the plugin. attach_metadata_object \u2014 Shows how the plugin can update labels for objects detected by primary detector. blur_objects \u2014 Modify buffer frame contents in-place to blur objects using OpenCV GaussianBlur. When running on dGPU make sure that input memory type to plugin is NVBUF_MEM_CUDA_UNIFIED . gst_dsexample_output_loop \u2014 Works in parallel with submit_input_buffer to improve performance. Wait for pre-processing of a batch to finish Process on the batch using dsexample_lib APIs Attach the output using one of attach_metadata\\_* functions On Jetson devices, custom GStreamer plugins must export the environment variable DS_NEW_BUFAPI and set its value to 1. See gst_dsexample_class_init() for an example in a plugin ( Gst-dsexample ).", "keywords": []}, {"id": 3158, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "page", "name": "text/DS_sample_custom_gstream#using-the-sample-plugin-in-a-custom-application-pipeline", "display_name": "Using the sample plugin in a custom application/pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_sample_custom_gstream", "anchor": "using-the-sample-plugin-in-a-custom-application-pipeline", "priority": -1, "content": "The sample plugin can be used in a gst-launch pipeline. The pipeline can also be constructed in a custom application. To construct a pipeline for running the plugin in full frame mode Construct a pipeline for running the plugin in full frame mode with the following command. For Jetson: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvvideoconvert ! dsexample full-frame=1 &lt;other-properties&gt; ! nvdsosd ! nv3dsink For Tesla: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvvideoconvert ! dsexample full-frame=1 &lt;other-properties&gt; ! nvdsosd ! nveglglessink To construct a pipeline for running the plugin to process on objects detected by the primary model Construct a pipeline for running the plugin to process on objects detected by the primary model with the following command. For Jetson: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvinfer config-file-path= &lt;primary-detector-config&gt; ! nvvideoconvert ! dsexample full-frame=0 &lt;other-properties&gt; ! nvdsosd ! nv3dsink For Tesla: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvinfer config-file-path= &lt;primary-detector-config&gt; ! nvvideoconvert ! dsexample full-frame=0 &lt;other-properties&gt; ! nvdsosd ! nveglglessink To construct a pipeline for running the plugin to blur objects detected by the primary model Construct a pipeline for running the plugin to blur objects detected by the primary model with the following command: For Jetson: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvinfer config-file-path= &lt;primary-detector-config&gt; ! nvvideoconvert ! &#x27;video/x-raw(memory:NVMM), format=RGBA&#x27; ! dsexample full-frame=0 blur-objects=1 ! nvdsosd ! nv3dsink For Tesla: $ gst-launch-1.0 filesrc location= &lt;mp4-file&gt; ! qtdemux ! h264parse ! nvv4l2decoder ! m.sink_0 nvstreammux name=m batch-size=1 width=1280 height=720 ! nvinfer config-file-path= &lt;primary-detector-config&gt; ! nvvideoconvert nvbuf-memory-type= nvbuf-mem-cuda-unified ! &#x27;video/x-raw(memory:NVMM), format=RGBA&#x27; ! dsexample full-frame=0 blur-objects=1 ! nvdsosd ! nveglglessink", "keywords": []}, {"id": 3159, "doc_id": 3159, "filename": "text/DS_sample_custom_gstream.html", "domain_name": "std", "name": "text/DS_sample_custom_gstream", "display_name": "Implementing a Custom GStreamer Plugin with OpenCV Integration Example", "type": "doc", "display_type": "Page", "docname": "text/DS_sample_custom_gstream", "anchor": "", "priority": -1, "content": "The DeepStream SDK supports a mechanism to add third party or custom algorithms within the reference application by modifying the example plugin ( gst-dsexample ). The sources for the plugin are in sources/gst-plugins/gst-dsexample directory in the SDK. This plugin was written for GStreamer 1.14.1 but is compatible with newer versions of GStreamer. This plugin derives from the GstBaseTransform class: https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-libs/html/GstBaseTransform.html To enable OpenCV functionalities, compile dsexample plugin with flag WITH_OPENCV=1 in the plugin Makefile.", "keywords": []}, {"id": 3160, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#buffer", "display_name": "Buffer", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "buffer", "priority": -1, "content": "The Buffer object serves as a wrapper for the data segments flowing through the pipeline. For a read only buffer, you can invoke the read method to access the data in read-only mode, employing a customized callable object for data processing. Similarly, for a read-write buffer, the process is analogous, with the added capability of modifying the data within the buffer. // example of a video buffer observer interface class SampleBufferObserver : public BufferProbe::IBufferObserver { public: virtual probeReturn handleBuffer(BufferProbe&amp; probe, const Buffer&amp; buffer) { // cast of a general buffer to a video buffer allows to tread the data in proper video format VideoBuffer video_buffer = buffer; video_buffer.read([byte](const void* data, size_t size) -&gt; size_t { const unsigned char* p_byte = (const unsigned char*) data; for (auto p = p_byte; p &lt; p_byte + size; p++) { // take a peek on the data } return size; }); } };", "keywords": []}, {"id": 3161, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#bufferprobe", "display_name": "BufferProbe", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "bufferprobe", "priority": -1, "content": "Application developers can employ a buffer probe to retrieve the output buffer generated within the pipeline. Various interfaces can be implemented based on the specific requirements of the probe, offering flexibility for different purposes. Interface name Method description IBufferObserver handleBuffer access each processed buffer in read only mode IBufferOperator handleBuffer access each processed buffer in read write mode IBatchMetadataObserver handleMetadata access the batch metadata in read only mode IBatchMetadataOperator handleMetadata access the batch metadata in read write mode", "keywords": []}, {"id": 3162, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#cameraconfig", "display_name": "CameraConfig", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "cameraconfig", "priority": -1, "content": "CameraConfig is a convenience tool to load camera configurations from a YAML file, allowing users to create a list of multiple camera sources (V4L2/CSI). A sample camera config looks as follows: camera-list: - camera-type: &quot;CSI&quot; camera-csi-sensor-id: 0 camera-width: 1280 camera-height: 720 camera-fps-n: 30 camera-fps-d: 1 - camera-type: &quot;V4L2&quot; camera-v4l2-dev-node: 2 camera-width: 640 camera-height: 480 camera-fps-n: 30 camera-fps-d: 1 There is only one section in the YAML file: camera-list which defines the camera source and its configuration: camera-list: each item defines camera-type, camera-width, camera-height, camera-fps-n, camera-fps-d, for CSI camera source: camera-csi-sensor-id and for V4L2 camera source: camera-v4l2-dev-node.", "keywords": []}, {"id": 3163, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#commonfactory-and-custom-objects", "display_name": "CommonFactory and custom Objects", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "commonfactory-and-custom-objects", "priority": -1, "content": "Application developers can utilize custom objects to access the processing results of specific Deepstream Elements tailored to their unique needs. These custom objects can be instantiated directly through the \u2018new\u2019 keyword if they are defined within the application code. Alternatively, if implemented through a plugin, they can be created through the common factory interface. Custom objects can be incorporated into the pipeline using the \u2018attach\u2019 method, requiring the name of the element to which they should be attached. Upon attachment, the designated element will assume control of the lifecycle of the custom object. The following is a list of currently supported custom objects:", "keywords": []}, {"id": 3164, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#datafeeder", "display_name": "DataFeeder", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "datafeeder", "priority": -1, "content": "The DataFeeder signal handler is specifically designed for attachment to an Element instance to capture data request related signals, such as \u201cneed-data\u201d and \u201cenough-data\u201d signals from an \u201cappsrc.\u201d By using DataFeeder, application developers gain the ability to seamlessly inject data directly into the target Element during runtime.", "keywords": []}, {"id": 3165, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#datareceiver", "display_name": "DataReceiver", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "datareceiver", "priority": -1, "content": "The DataReceiver signal handler is specifically for attachment to an Element instance to capture data ready related signals, such as \u201cnew-sample\u201d signal from an \u201cappsink.\u201d By using DataFeeder, By using DataReceiver, application developers can receive the processed data from the target Element during runtime.", "keywords": []}, {"id": 3166, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#elements-and-plugins", "display_name": "Elements and Plugins", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "elements-and-plugins", "priority": -1, "content": "The Deepstream SDK introduces Element as the fundamental functional block accessible through various plugins. Each type of element offers specific capabilities, including encoding, decoding, pre-processing, post-processing, AI inference, and Object Tracking. When integrated into a pipeline, an element initiates the processing of media buffers flowing through the pipeline, generating metadata or messages as a result. Elements are highly configurable, supporting customization through key-value pairs or an external configuration file. This flexibility enables them to adapt to diverse task requirements. The output of an element, comprising data buffers, metadata, and messages, can be seamlessly captured by downstream counterparts for continuous processing. Alternatively, it can be retrieved by the application for external processing through customized objects. An element can be instantiated using its predefined type name within the Deepstream SDK: Element streammux(&quot;nvstreammux&quot;, &quot;mux&quot;).set(&quot;batch-size&quot;, 1, &quot;width&quot;, 1280, &quot;height&quot;, 720); A more practical approach supports instantiating and configuring an element through the higher-level Pipeline API: pipeline.add(&quot;nvstreammux&quot;, &quot;mux&quot;, &quot;batch-size&quot;, 1, &quot;width&quot;, 1280, &quot;height&quot;, 720); To properly direct the flow of media, elements need to be sequentially linked within the Pipeline. In most cases, a straightforward linking operation can be achieved using a simple link method, with the names of each Element instance specified in order. However, in certain scenarios, additional information may be required to facilitate the linking process. This complexity can arise from variations in how Elements handle inputs and outputs. pipeline.add(&quot;nvurisrcbin&quot;, &quot;src&quot;).add(&quot;nvvideoconvert&quot;, &quot;converter&quot;); // only the video output of the media source should be linked to the video converter // &quot;vsrc_%u&quot; specify the video output of a nvuirsrcbin instance (refer to the plugin documentation) pipeline.link({&quot;src&quot;, &quot;converter&quot;}, {&quot;vsrc_%u&quot;, &quot;&quot;});", "keywords": []}, {"id": 3167, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#getting-started-with-service-maker-c-apis", "display_name": "Getting Started with Service Maker C++ APIs", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "getting-started-with-service-maker-c-apis", "priority": -1, "content": "Before starting on the actual application, we need to create a text file with name \u2018CMakeLists.txt\u2019 for building our application later: cmake_minimum_required(VERSION 3.16) project(Sample) find_package(nvds_service_maker REQUIRED PATHS /opt/nvidia/deepstream/deepstream/service-maker/cmake) add_executable(my-deepstream-app my_deepstream_app.cpp) target_link_libraries(my-deepstream-app PRIVATE nvds_service_maker) Now we can create a sample deepstream app (my_deepstream_app.cpp) with a pipeline to perform object detection from a incoming video stream: #include &quot;pipeline.hpp&quot; #include &lt;iostream&gt; using namespace deepstream; #define CONFIG_FILE_PATH &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; int main(int argc, char *argv[]) { try { Pipeline pipeline(&quot;sample-pipeline&quot;); pipeline.add(&quot;nvurisrcbin&quot;, &quot;src&quot;, &quot;uri&quot;, argv[1]) .add(&quot;nvstreammux&quot;, &quot;mux&quot;, &quot;batch-size&quot;, 1, &quot;width&quot;, 1280, &quot;height&quot;, 720) .add(&quot;nvinferbin&quot;, &quot;infer&quot;, &quot;config-file-path&quot;, CONFIG_FILE_PATH) .add(&quot;nvosdbin&quot;, &quot;osd&quot;) .add(&quot;nveglglessink&quot;, &quot;sink&quot;) .link({&quot;src&quot;, &quot;mux&quot;}, {&quot;&quot;, &quot;sink_%u&quot;}).link(&quot;mux&quot;,&quot;infer&quot;, &quot;osd&quot;, &quot;sink&quot;); pipeline.start().wait(); } catch (const std::exception &amp;e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return -1; } return 0; } In order to build the application, we should use the CMake to create build environment: $ mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make Once the build is complete, we can run the application to start the object detection pipeline: $ ./my-deepstream-app file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.mp4 Currently, despite the pipeline running, we aren\u2019t obtaining object information from the application. To access this data, we need to create a buffer probe that iterates through the metadata generated by the nvinfer plugin. A sample metadata probe can be implemented as follows: class ObjectCounter : public BufferProbe::IBatchMetadataObserver { public: ObjectCounter() {} virtual ~ObjectCounter() {} virtual probeReturn handleData(BufferProbe&amp; probe, const BatchMetadata&amp; data) { data.iterate([](const FrameMetadata&amp; frame_data) { auto vehicle_count = 0; frame_data.iterate([&amp;](const ObjectMetadata&amp; object_data) { auto class_id = object_data.classId(); if (class_id == 0) { vehicle_count++; } }); std::cout &lt;&lt; &quot;Object Counter: &quot; &lt;&lt; &quot; Pad Idx = &quot; &lt;&lt; frame_data.padIndex() &lt;&lt; &quot; Frame Number = &quot; &lt;&lt; frame_data.frameNum() &lt;&lt; &quot; Vehicle Count = &quot; &lt;&lt; vehicle_count &lt;&lt; std::endl; }); return probeReturn::Probe_Ok; } }; By attaching the buffer probe into the inference plugin within the existing pipeline before starting it, we\u2019ll get the vehicle count information from each frame of the video stream: pipeline.attach(&quot;infer&quot;, new BufferProbe(&quot;counter&quot;, new ObjectCounter)); Rebuild the application and run it again, vehicle count will be printed out. ...... Object Counter: Pad Idx = 0 Frame Number = 132 Vehicle Count = 7 Object Counter: Pad Idx = 0 Frame Number = 133 Vehicle Count = 8 Object Counter: Pad Idx = 0 Frame Number = 134 Vehicle Count = 7 Object Counter: Pad Idx = 0 Frame Number = 135 Vehicle Count = 8 Object Counter: Pad Idx = 0 Frame Number = 136 Vehicle Count = 9 Object Counter: Pad Idx = 0 Frame Number = 137 Vehicle Count = 7 Object Counter: Pad Idx = 0 Frame Number = 138 Vehicle Count = 9 Object Counter: Pad Idx = 0 Frame Number = 139 Vehicle Count = 9 Object Counter: Pad Idx = 0 Frame Number = 140 Vehicle Count = 9 Object Counter: Pad Idx = 0 Frame Number = 141 Vehicle Count = 11 .....", "keywords": []}, {"id": 3168, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#guideline-for-fine-tuning-a-pipeline-through-configuration-file", "display_name": "Guideline for Fine-tuning a Pipeline through Configuration File", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "guideline-for-fine-tuning-a-pipeline-through-configuration-file", "priority": -1, "content": "The YAML configuration file also offers users a straightforward option to finely tune the pipeline, enabling them to optimize performance effortlessly. Users can always start with a pipeline design from the blueprint with appropriate nodes and edges, tailored precisely to suit the specific objectives of their projects. Before proceeding, it\u2019s essential to address the following parameters: batch-size: this is a important property that could affects the performance. It specifies the total number of frames for streammux to create a batch, it must equal to the maximum streams expected to be fed into the pipeline. It is an inherent parameter of \u201cstreammux\u201d, while in the case of \u201cnvmultiurisrcbin\u201d, \u201cmax-batch-size\u201d should be set instead. batched-push-timeout: this is another property for \u201cstreammux\u201d or \u201cnvmultiurisrcbin\u201d. It determines how long streammux will wait until all the frames are collected, given the batch-size. Change in batched-push-timeout affects the framerates, especially when the input is live source, e.g RTSP. buffer-pool-size: this property defines the number of buffer pool used by streammux. In scenarios where the processing latency is prolonged to the extent that the buffer pool depletes before a buffer is returned, adjustments to certain properties may be necessary. Nonetheless, it\u2019s imperative to ensure that these adjustments do not surpass a limit of 16. In the majority of cases, performance degradation stems from hardware bottlenecks, which may arise from the CPU, GPU, or other components. To identify bottlenecks, users can modify the type of potentially problematic nodes to \u201cidentity,\u201d effectively disabling them, and then retest the performance iteratively until the actual bottleneck is pinpointed. Another factor contributing to performance degradation occurs when the pipeline lacks full parallelization, often resulting from irregular overloading of certain nodes. In such instances, inserting a queue before the problematic node can provide a solution. Additionally, unnecessary scaling can lead to wasteful computation. Therefore, it\u2019s beneficial to carefully consider the processing dimensions for each node. Ensuring that the processing dimension aligns with either the input/output dimension or model dimension can effectively minimize scaling.", "keywords": []}, {"id": 3169, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#id1", "display_name": "Prepare and Activate", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "id1", "priority": -1, "content": "Transition: From idle to paused, then to running. Process: By executing pipeline.prepare() followed by pipeline.activate(), the pipeline transitions through a paused state before becoming fully operational. This sequence allows for any necessary setup or configuration prior to execution.", "keywords": []}, {"id": 3170, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#metadata", "display_name": "Metadata", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "metadata", "priority": -1, "content": "In addition to the output data from an element, users may have a keen interest in the metadata generated by the element. This becomes particularly relevant in AI inference pipelines, where inference results are commonly conveyed in metadata format. The following is a list of currently supported metadata objects: Metadata class Description MetaData base class of all the metadata BatchMetaData metadata created through nvstreammux, acting as the root of all the other metadata and supporting iterating FrameMetaData and DisplayMetadata through the batch FrameMetaData metadata associated with a specific video frame, iterable within the BatchMetaData UserMetaData user defined metadata ObjectMetadata metadata that describes a detected object, iterable with the FrameMetaData. ClassifierMetadata metadata that contains the classification information of an object, iterable within the ObjectMetadata. DisplayMetadata metadata that describes the display properties, being used by the nvdsosd to draw various shapes and text on a video frame, iterable with the FrameMetaData. EventMessageUserMetadata a specific user metadata for generating an event message, once appended to the FrameMetaData, it will be consumed by downstream message converter. More details about Deepstream Metadata can be found here .", "keywords": []}, {"id": 3171, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#migrating-traditional-deepstream-apps-to-service-maker", "display_name": "Migrating Traditional Deepstream Apps to Service Maker", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "migrating-traditional-deepstream-apps-to-service-maker", "priority": -1, "content": "For users who have been integrating Deepstream applications into their solutions for an extended period, migrating to the new Service Maker APIs requires minimal effort. Traditional Deepstream applications rely on configuration files for pipeline customization and parameter setup. The Service Maker APIs follow a similar approach, offering a configuration specification with slight differences: Global Parameters In the traditional Deepstream applications, all the global parameters need to be defined under a specific section named \u2018applications\u2019: [application] enable-perf-measurement=1 perf-measurement-interval-sec=5 gie-kitti-output-dir=/tmp With Service Maker APIs, some of the parameters are expected to be added as command line argument. For example, the test5 app built from the Service Maker can change the performance measurement interval through a command line argument: perf-measurement-interval-sec 5 As for others which are not truly \u2018global\u2019, they can be set as a propertie of the corrsponding modules. For example, the \u2018gie-kitti-output-dir\u2019 is actually a property of the \u2018kitti_dump_probe\u2019 plugin built with the Service Maker, thus it can be set under the \u2018Properties\u2019 of the \u2018kitti_dump_probe\u2019 instance within the pipeline. - type: kitti_dump_probe.kitti_dump_probe name: kitti_dump properties: kitti-dir: &#x27;/tmp&#x27; Pipeline customization In contrast to the traditional Deepstream application, Service Maker adopts a graph-based YAML definition to represent a pipeline structure, providing users with maximum flexibility for customization. The predefined sections in the traditional configuration, such as \u2018primary-gie\u2019, \u2018secondary-gie\u2019, \u2018tracker\u2019, \u2018tiled-display\u2019, and \u2018osd\u2019, can all be configured through the properties of each independent element within the Service Maker YAML definition. Source and Batching In traditional Deepstream applications, source management involves a combination of \u2018sourceX\u2019, \u2018streammux\u2019, \u2018source-list\u2019, and \u2018source-attr-all\u2019 in the configuration file. Service Maker simplifies this by separating the source management into a standalone source configuration file. In this file, source information, including \u2018list\u2019, \u2018sensor-name-list\u2019, and \u2018sensor-id-list\u2019, is placed within the \u2018source-list\u2019 section. Meanwhile, pipeline customization, such as specifying the source type and properties, is handled in the \u2018source-config\u2019 section. Sink management Compared to the traditional Deepstream application, Service Maker offers support for a wider range of arbitrary sink options. These include existing types such as \u2018Fakesink\u2019, \u2018Display\u2019, \u2018File\u2019, \u2018UDP\u2019, and \u2018MsgConvBroker\u2019. Each of these sinks must be defined within the graph pipeline specification, which includes all necessary element nodes and the edges between them. This approach provides greater flexibility in configuring sinks for the pipeline.", "keywords": []}, {"id": 3172, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#pipeline", "display_name": "Pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "pipeline", "priority": -1, "content": "A pipeline serves as the foundation of Deepstream-based AI streaming applications. Media streams flow through interconnected functional blocks within a pipeline, processed via buffers widths metadata. A pipeline and the elements within it autonomously manage states and data flow, reducing the need for external intervention by application developers. A functional pipeline requires appropriate elements from Deepstream plugins to be added, configured and linked correctly. This can be seamlessly achieved using Pipeline APIs in a fluent manner: Pipeline pipeline(&quot;sample&quot;); // nvstreammux is the factory name in Deepstream to create a streammuxer Element // mux is the name of the Element instance // multiple key value pairs can be appended to configure the added Element pipeline.add(&quot;nvstreammux&quot;, &quot;mux&quot;, &quot;batch-size&quot;, 1, &quot;width&quot;, 1280, &quot;height&quot;, 720); For elements that have single static input and output, links can be established in a very straightforward manner: pipeline.link(&quot;mux&quot;, &quot;infer&quot;, &quot;osd&quot;, &quot;sink&quot;); However, if an element supports dynamic or multiple input/output, extra information is required to establish the link: // link the Element named &quot;src&quot; to the one named &quot;mux&quot; // given the input of a nvstreammux is dynamic, we must specify the input name &quot;sink_%u&quot; (refer to the plugin documentation) pipelin.link({&quot;src&quot;, &quot;mux&quot;}, {&quot;&quot;, &quot;sink_%u&quot;}); Pipeline construction can also be achieved through a declarative YAML configuration file, significantly reducing coding efforts in application development. The above pipeline can be defined as follows in YAML configuration. deepstream: nodes: - type: nvurisrcbin name: src - type: nvstreammux name: mux properties: batch-size: 1 width: 1280 height: 720 - type: nvinferbin name: infer properties: config-file-path: /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml - type: nvosdbin name: osd - type: nveglglessink name: sink edges: src: mux mux: infer infer: osd osd: sink And with the YAML configuration being applied, the application source can be simplified a lot: #include &quot;pipeline.hpp&quot; #include &lt;iostream&gt; using namespace deepstream; int main(int argc, char *argv[]) { try { Pipeline pipeline(&quot;my-pipeline&quot;, &quot;config.yaml&quot;); pipeline[&quot;src&quot;].set(&quot;uri&quot;, argv[1]); pipeline.start().wait(); } catch (const std::exception &amp;e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return -1; } return 0; } The YAML configuration of a pipeline begins with a \u201cdeepstream\u201d keyword, and is composed of two sections: Node definition list under \u201cnodes\u201d: each item defines an instance to be added to the pipeline, with \u201ctype\u201d, \u201cname\u201d and \u201cproperties\u201d specified. The \u201ctype\u201d field corresponds to the element name defined in DS plugins, such as \u201cnvstreammux\u201d; \u201cname\u201d is a string to identify the instance within the pipeline and must be unique; \u201cproperties\u201d field initialize the supported properties for the instance. Link definition list under \u201cedge\u201d: each item defines one or more connections, where the key specifies the source and the value specifies the target(s). In the case that a source has more than one output, the output name should also be specified, such as \u201csource.vsrc_%u: mux\u201d.", "keywords": []}, {"id": 3173, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#pipeline-activate", "display_name": "Pipeline.activate()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "pipeline-activate", "priority": -1, "content": "After using pipeline.prepare(), pipeline.activate() transitions the pipeline\u2019s state from paused to playing in a new thread. This effectively starts the pipeline. In multi-pipeline scenarios, this allows all pipelines to begin execution concurrently.", "keywords": []}, {"id": 3174, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#pipeline-prepare", "display_name": "Pipeline.prepare()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "pipeline-prepare", "priority": -1, "content": "Unlike pipeline.start(), which transitions the pipeline\u2019s state to playing in a new thread, pipeline.prepare() sets the pipeline\u2019s state to paused within the same thread. This is particularly useful in multi-pipeline scenarios where each pipeline\u2019s state needs to be changed to paused sequentially.", "keywords": []}, {"id": 3175, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#pipeline-wait", "display_name": "Pipeline.wait()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "pipeline-wait", "priority": -1, "content": "This API is used to join the threads created by pipeline.activate(), ensuring that all threads complete their execution before proceeding. The Sample Test 5 Application demonstrates how to utilize these API calls effectively.", "keywords": []}, {"id": 3176, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#prepare-and-activate", "display_name": "Prepare and Activate", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "prepare-and-activate", "priority": -1, "content": "For specific use cases, we have introduced alternative APIs to manage pipeline execution:", "keywords": []}, {"id": 3177, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#sample-applications", "display_name": "Sample Applications", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "sample-applications", "priority": -1, "content": "Sample applications can be found from the Deepstream installation directory /opt/nvidia/deepstream/deepstream/service-maker/sources/apps , and with the following commands user can build them: $ cmake /opt/nvidia/deepstream/deepstream/service-maker/sources/apps/deepstream_test1_app &amp;&amp; make", "keywords": []}, {"id": 3178, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#signalemitter", "display_name": "SignalEmitter", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "signalemitter", "priority": -1, "content": "The signal emitter is another pivotal component in the signaling mechanism, responsible for emitting signals rather than handling them. When an element seeks to have certain activities driven by the external environment, it accepts signal emitters. In this mechanism, with a signal emitter attached to an Element instance that is configured to receive such signals, corresponding activity will be triggered on the Element instance when the emit method is invoked on the signal emitter object.", "keywords": []}, {"id": 3179, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#signalhandler", "display_name": "SignalHandler", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "signalhandler", "priority": -1, "content": "Signaling is a vital mechanism that facilitates interaction between elements within a running pipeline and the external world, notifying observers of specific events. An element can support a variety of signals, each uniquely registered during instantiation. The comprehensive details regarding signal support for an element can be found in the corresponding plugin manual. Application developers have the flexibility to enhance the functionality of their applications by attaching signal handlers to Element instances. Once attached, these handlers respond promptly to the emitted signals, allowing developers to implement custom logic in response to specific events.", "keywords": []}, {"id": 3180, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#sourceconfig", "display_name": "SourceConfig", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "sourceconfig", "priority": -1, "content": "SourceConfig is a convenience tool to load source configurations from a YAML file, allowing users append extra information to a source and create a list for multiple sources. A sample source config looks as follows source-list: - uri: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; sensor-id: UniqueSensorId1 sensor-name: UniqueSensorName1 - uri: &quot;file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4&quot; sensor-id: UniqueSensorId2 sensor-name: UniqueSensorName2 source-config: source-bin: &quot;nvmultiurisrcbin&quot; properties: ip-address: &quot;localhost&quot; port: 7000 batched-push-timeout: 33000 live-source: true width: 1920 height: 1080 file-loop: true max-batch-size: 16 There are 2 sections in the YAML file: source-list and source-config, each defines the inputs and the configurations of the source bin(s): source-list: each item defines the uri, sensor-id and sensor-name for a source source-config: defines the type of the source node and corresponding properties. The property specification under \u201cproperties\u201d MUST be consistent with the type of the source node. When the number of the streams fed into the pipeline is big and variable during runtime, separating the source config from the pipeline definition gives more clarity, however, it is always the developers\u2019 decision for the most suitable approach.", "keywords": []}, {"id": 3181, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#start", "display_name": "Start", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "start", "priority": -1, "content": "Transition: From idle to running. Process: Utilize the pipeline.start() API to initiate the pipeline, moving it from an idle state to actively running tasks.", "keywords": []}, {"id": 3182, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#state-transitions-in-service-maker-pipelines", "display_name": "State Transitions in Service Maker Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "state-transitions-in-service-maker-pipelines", "priority": -1, "content": "Managing state transitions in service pipelines is essential for ensuring efficient and orderly operations. Service maker facilitates synchronous state transitions, enabling smooth and predictable changes in the pipeline\u2019s status. Here\u2019s a clearer and more structured explanation of these transitions:", "keywords": []}, {"id": 3183, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#stop", "display_name": "Stop", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "stop", "priority": -1, "content": "Transition: Back to idle. Process: The pipeline.stop() API is used to return the pipeline to its idle state, effectively halting operations and resetting it for future tasks. These transitions are designed to manage workflow efficiently, allowing for both immediate execution and necessary preparatory phases.", "keywords": []}, {"id": 3184, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "page", "name": "text/DS_service_maker_cpp#wait", "display_name": "Wait", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_cpp", "anchor": "wait", "priority": -1, "content": "Purpose: Suspend the current thread until the pipeline completes its execution. Process: The pipeline.wait() function is required after both the start and prepare/activate sequences to ensure that the current thread pauses until the pipeline has finished processing.", "keywords": []}, {"id": 3185, "doc_id": 3185, "filename": "text/DS_service_maker_cpp.html", "domain_name": "std", "name": "text/DS_service_maker_cpp", "display_name": "Service Maker for C/C++ Developers", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_cpp", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3186, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#high-level-python-flow-api", "display_name": "2. High-Level Python Flow API", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "high-level-python-flow-api", "priority": -1, "content": "For Python developers, Deepstream Service Maker offers a high-level Flow API that enables application development in a more intuitive and \u201cpythonic\u201d style. The Flow API abstracts even more technical complexities, making it an ideal choice for those less familiar with the intricacies of the Deepstream SDK, or for those who want to quickly prototype and iterate on solutions. Key Benefits: Pythonic design principles ensure code readability and simplicity. Rapid application development with minimal boilerplate code. Simplified access to real-time multimedia processing and AI inference capabilities.", "keywords": []}, {"id": 3187, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#object-oriented-c-api", "display_name": "1. Object-Oriented C++ API", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "object-oriented-c-api", "priority": -1, "content": "The Object-Oriented C++ API provided by Deepstream Service Maker abstracts low-level details like GStreamer/GLib mechanics, object lifecycle management, and concurrency issues such as deadlocks. By handling these complexities internally, it allows developers to focus on core business logic, significantly reducing development overhead. Key Benefits: No need to manage low-level GStreamer/GLib APIs. Efficient object lifecycle management through automatic object reference to prevent common runtime memory leak. No risk of deadlocks through robust concurrency management", "keywords": []}, {"id": 3188, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#overview", "display_name": "Overview", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "overview", "priority": -1, "content": "Deepstream Service Maker provides a high-level abstraction layer on top of the NVIDIA Deepstream SDK, designed to simplify the development of real-time multimedia processing and AI inference applications. By flattening the learning curve, it dramatically reduces the time required for application development from days to hours. This framework offers both C++ and Python APIs, with a special focus on Python for developers who prefer a more accessible programming language. Deepstream Service Maker simplifies the complex task of building high-performance, real-time applications by abstracting away low-level operations and offering a robust, object-oriented and declarative approach.", "keywords": []}, {"id": 3189, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#python-pipeline-api", "display_name": "3. Python Pipeline API", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "python-pipeline-api", "priority": -1, "content": "The Python Pipeline API is a direct binding of the underlying C++ API, giving developers with knowledge of the Deepstream SDK the full power of its capabilities. This API is more suited for users looking to unlock advanced features of the SDK while retaining the flexibility and simplicity that Python offers. Key Benefits: Direct access to Deepstream SDK\u2019s full power via Python. Perfect for developers who need precise control over multimedia pipelines. Provides access to performance-critical features in an easier language syntax.", "keywords": []}, {"id": 3190, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#runtime-module-mechanism", "display_name": "4. Runtime Module Mechanism", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "runtime-module-mechanism", "priority": -1, "content": "Deepstream Service Maker supports custom plugins through a runtime module mechanism, which is fully compatible with standard Deepstream plugins. This feature enables developers to extend the platform\u2019s capabilities without losing compatibility with the core system while fully leveraging standard Deepstream plugins, providing flexibility for application-specific customizations. Key Benefits: Seamless integration of custom plugins. Compatibility with standard Deepstream plugins ensures maximum extensibility. Modular design allows easy updates and scalability.", "keywords": []}, {"id": 3191, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "page", "name": "text/DS_service_maker_intro#unified-error-handling-via-exceptions", "display_name": "5. Unified Error Handling via Exceptions", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_intro", "anchor": "unified-error-handling-via-exceptions", "priority": -1, "content": "Error handling is unified across the APIs through the use of exceptions. This simplifies error management, allowing developers to handle errors in a structured and predictable manner, reducing potential issues during runtime. Key Benefits: Simplified error management using exceptions. Predictable handling of errors for all API calls. Cleaner, more maintainable application code", "keywords": []}, {"id": 3192, "doc_id": 3192, "filename": "text/DS_service_maker_intro.html", "domain_name": "std", "name": "text/DS_service_maker_intro", "display_name": "What is Deepstream Service Maker", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_intro", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3193, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#framerate-measurement-plugin", "display_name": "Framerate Measurement Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "framerate-measurement-plugin", "priority": -1, "content": "The Framerate Measurement Plugin is a sample plugin that creates a framerate measurement probe which measures and prints the current frame rate. The registered name of the plugin is \u201cmeasure_fps_probe\u201d.", "keywords": []}, {"id": 3194, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#getting-started-with-your-factory-and-plugin", "display_name": "Getting Started with Your Factory and Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "getting-started-with-your-factory-and-plugin", "priority": -1, "content": "Prior to encapsulating a factory, it is essential to come up with a custom object that the factory will create. As an illustrative example, let\u2019s consider a simple latency measurement probe. By implementing the IBufferObserver interface for a BufferProbe, we tailor it to serve as a latency measurement tool for video frames: class MeasureLatency : public BufferProbe::IBufferObserver { public: virtual probeReturn handleBuffer(BufferProbe&amp; probe, const Buffer&amp; buffer) { auto latency_info = buffer.measureLatency(); for (auto&amp; latency : latency_info) { cout &lt;&lt; &quot;Source id = &quot; &lt;&lt; latency.source_id &lt;&lt; &quot; Frame_num = &quot; &lt;&lt; latency.frame_num &lt;&lt; &quot; Frame latency = &quot; &lt;&lt; latency.latency &lt;&lt; &quot; (ms)&quot; &lt;&lt; endl; } return probeReturn::Probe_Ok; } }; Next, you need to encapsulate a factory for this latency measurement probe within a plugin. To achieve this, we can employ macros in the plugin.h file to define both the factory and the plugin, respectively: DS_CUSTOM_PLUGIN_DEFINE(measure_latency_probe, &quot;Custom probe to add measure Latency&quot;, &quot;0.1&quot;, &quot;Proprietary&quot;) // define a factory that creates a BufferProbe instance with a MeasureLatency implementation DS_CUSTOM_FACTORY_DEFINE( &quot;measure_latency_probe&quot;, &quot;Latency measurement calculating custom probe factory&quot;, &quot;probe&quot;, &quot;this is a latency measurement custom probe factory&quot;, &quot;NVIDIA&quot;, BufferProbe, MeasureLatency ) To build the plugin, you need to create a straightforward CMakeLists.txt file with the following content: cmake_minimum_required(VERSION 3.16) project(Sample) find_package(nvds_c++ REQUIRED PATHS /opt/nvidia/deepstream/deepstream/service-maker/cmake) add_library(measure_latency_probe SHARED measure_latency_probe.cpp) target_link_libraries(measure_latency_probe PRIVATE nvds_service_maker nvds_service_maker_utils) $ mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make Upon successful completion of the plugin build process, you can seamlessly utilize our latency measurement-customized BufferProbe in any application: pipeline.attach(&quot;decoder&quot;, &quot;measurelatencyprobe&quot;, &quot;my probe&quot;, &quot;src&quot;)", "keywords": []}, {"id": 3195, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#incorporating-properties-to-a-plugin", "display_name": "Incorporating properties to a plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "incorporating-properties-to-a-plugin", "priority": -1, "content": "To further increase the versatility of factory reuse, we can introduce property specification for the objects from the factory. Macros for adding property specification to the factory can be utilized as follows: DS_CUSTOM_FACTORY_DEFINE_PARAMS_BEGIN(probe_param_spec) DS_CUSTOM_FACTORY_DEFINE_PARAM(source-id, integer, &quot;source-id&quot;, &quot;sourceid&quot;, 0) DS_CUSTOM_FACTORY_DEFINE_PARAMS_END Within the latency measurement implementation, the calculation of frame latency can be confined to a specified stream: class MeasureLatency : public BufferProbe::IBufferObserver { public: virtual probeReturn handleBuffer(BufferProbe&amp; probe, const Buffer&amp; buffer) { int id = 0; probe.getProperty(&quot;source-size&quot;, id); auto latency_info = buffer.measureLatency(); for (auto&amp; latency : latency_info) { if (latency.source_id == id) { cout &lt;&lt; &quot;Source id = &quot; &lt;&lt; latency.source_id &lt;&lt; &quot; Frame_num = &quot; &lt;&lt; latency.frame_num &lt;&lt; &quot; Frame latency = &quot; &lt;&lt; latency.latency &lt;&lt; &quot; (ms)&quot; &lt;&lt; endl; } } return probeReturn::Probe_Ok; } }; In the application, you would have the option to specify the precise source ID for latency measurement: pipeline.attach(&quot;decoder&quot;, &quot;measurelatencyprobe&quot;, &quot;my probe&quot;, &quot;src&quot;, &quot;source-id&quot;, 1)", "keywords": []}, {"id": 3196, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#kitti-dump-plugin", "display_name": "KITTI Dump Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "kitti-dump-plugin", "priority": -1, "content": "The KITTI Dump Plugin is a sample plugin that creates a buffer probe to dump the object metatdata there into a txt file in kitti format. The registered name of the plugin is \u201cktti_dump_probe\u201d. Following parameters are supported: kitti-dir: the path for saving kitti files (default: /tmp/kitti).", "keywords": []}, {"id": 3197, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#latency-measurement-plugin", "display_name": "Latency Measurement Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "latency-measurement-plugin", "priority": -1, "content": "The Latency Measurement Plugin is a sample plugin that creates a latency measurement probe which measures and prints the current frame latency. The registered name of the plugin is \u201cmeasure_latency_probe\u201d.", "keywords": []}, {"id": 3198, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#message-metadata-generator", "display_name": "Message Metadata Generator", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "message-metadata-generator", "priority": -1, "content": "The Message Metadata Generator is a sample plugin that creates a buffer probe to generate event message metadata. This metadata can be utilized by downstream nvmsgconv to create JSON payloads for transmission to message brokers like Kafka. Registered name of the plugin is \u201cadd_message_meta_probe\u201d.", "keywords": []}, {"id": 3199, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#plugin-search-path", "display_name": "Plugin Search Path", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "plugin-search-path", "priority": -1, "content": "By default the plugins will be searched from the installation path /opt/nvidia/deepstream/deepstream/service-maker/sources/modules . However, users can specify their path by defining them in the NVDS_MODULE_PATH environment variable, and multiple paths can be separated by \u201c:\u201d.", "keywords": []}, {"id": 3200, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#sample-plugins", "display_name": "Sample Plugins", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "sample-plugins", "priority": -1, "content": "Sample plugins can be found from the Deepstream installation directory /opt/nvidia/deepstream/deepstream/service-maker/sources/modules , and with the following commands user can build them: $ cmake /opt/nvidia/deepstream/deepstream/service-maker/sources/modules/sample_video_probe &amp;&amp; make", "keywords": []}, {"id": 3201, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#sample-signal-handler-plugin", "display_name": "Sample Signal Handler Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "sample-signal-handler-plugin", "priority": -1, "content": "This plugin creates a sample signal handlers that responds on the \u201cmodel-updated\u201d signal from nvinfer plugin. As a sample it prints out the message whenever the model is updated. The registered name of the plugin is \u201csample_signal_handler\u201d.", "keywords": []}, {"id": 3202, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#sample-video-feeder-plugin", "display_name": "Sample Video Feeder Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "sample-video-feeder-plugin", "priority": -1, "content": "This plugin creates a sample video feeder can be attached to an \u201cappsrc\u201d, thus injects raw video data to the pipeline from a file. The registered name of the plugin is \u201csample_video_feeder\u201d. The following parameters are supported for customizing the created buffer probe object: location: a string to specifies the file as the source of video data frame-width: width of the video frame frame-height: height of the video frame format: format of the video frame, which can be one among RGBA, I420 and NV12 use-gpu-memory: True for copying data into a GPU memory use-external-memory: True for allocating the memory outside the pipeline.", "keywords": []}, {"id": 3203, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#sample-video-probe-plugin", "display_name": "Sample Video Probe Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "sample-video-probe-plugin", "priority": -1, "content": "This plugin creates a sample video probe which constructs the display metadata for downstream osd plugin to show the object counter. The registered name of the plugin is \u201csample_video_probe\u201d. The following parameters are supported for customizing the created buffer probe object: font-size: an integer to specify the size of the font.", "keywords": []}, {"id": 3204, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#sample-video-receiver-plugin", "display_name": "Sample Video Receiver Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "sample-video-receiver-plugin", "priority": -1, "content": "This plugin creates a sample video receiver to demonstrate how to retrieve the buffer data from an \u201cappsink\u201d. The registered name of the plugin is \u201csample_video_receiver\u201d.", "keywords": []}, {"id": 3205, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#smart-recording-action-plugin", "display_name": "Smart Recording Action Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "smart-recording-action-plugin", "priority": -1, "content": "This plugin creates a signal emitter object which can attach to \u201cnvurisrcbin\u201d to trigger smart record and pause it. As a sample plugin it interacts with a remote Kafka server and controls the smart recording based on the messages received from the Kafka server. The registered name of the plugin is \u201csmart_recording_action\u201d. The following parameters are supported for customizing the created buffer probe object: proto-lib: the path to the shared library that implements the device/cloud communication protocol conn-str: string for the connection in the format of \u2018ip;port\u2019 proto-config-file: path to the config file of the communication protocol msgconv-config-file: message converter config file path topic-list: list of topics to subscribe", "keywords": []}, {"id": 3206, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "page", "name": "text/DS_service_maker_plugin#smart-recording-signal-plugin", "display_name": "Smart Recording Signal Plugin", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_plugin", "anchor": "smart-recording-signal-plugin", "priority": -1, "content": "This plugin creates a sample smart recording signal handler which responds on \u201csr-done\u201d signal from \u201cnvurisrcbin\u201d with a brief print. The registered name of the plugin is \u201csmart_recording_signal\u201d.", "keywords": []}, {"id": 3207, "doc_id": 3207, "filename": "text/DS_service_maker_plugin.html", "domain_name": "std", "name": "text/DS_service_maker_plugin", "display_name": "What is a Deepstream Service Maker Plugin", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_plugin", "anchor": "", "priority": -1, "content": "A plugin encapsulates a specialized factory, enabling the creation of user-implemented custom objects through a standardized factory API. Users have the flexibility to define a factory in a plugin with descriptive metadata, including name, version, descriptions, and more, for their custom objects. By loading the plugin, any application gains the ability to create instances of the custom object through the common factory API and facilitates the seamless reuse of user-defined custom objects (e.g., object counter, latency measurement, etc) across multiple applications.", "keywords": []}, {"id": 3208, "doc_id": 3209, "filename": "text/DS_service_maker_python.html", "domain_name": "page", "name": "text/DS_service_maker_python#python-service-maker-installation", "display_name": "Python Service Maker Installation", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python", "anchor": "python-service-maker-installation", "priority": -1, "content": "In order to use Deepstream Service Maker Python APIs, users just need to have Deepstream SDK installed on their host( DS Installation Guide ) or use it inside DeepStream SDK docker( DS Docker Container ). Service Maker python package is pre-installed globally in \u201c/usr/local/lib/python3.10/dist-packages/pyservicemaker\u201d Quick Start Guide Introduction to Flow APIs FlowAPI Sample Applications Reference Table Introduction to Pipeline APIs PipelineAPI Sample Applications Reference Table Advanced Features Migrating Traditional Deepstream Apps to Service Maker Apps in Python", "keywords": []}, {"id": 3209, "doc_id": 3209, "filename": "text/DS_service_maker_python.html", "domain_name": "std", "name": "text/DS_service_maker_python", "display_name": "Service Maker for Python Developers(alpha)", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_python", "anchor": "", "priority": -1, "content": "Deepstream Service Maker offers a Python package tailored for python developers, providing essential bindings for Pipeline APIs alongside the high-level Flow APIs. Flow APIs are specifically for beginners to quickly create common media processing / AI inference applications without requiring any Deepstream knowledge, and Pipeline APIs can be used by advanced developers to further customize their application.", "keywords": []}, {"id": 3210, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#common-factory", "display_name": "Common Factory", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "common-factory", "priority": -1, "content": "Service maker python binding supports creating custom object directly from a service maker plugin. from pyservicemaker import CommonFactory # create a smart recording controller instance from &quot;smart_recording_action&quot; and name it &quot;sr_controller&quot; CommonFactory.create(&quot;smart_recording_action&quot;, &quot;sr_controller&quot;) The feature usage has been demonstrated in service-maker/sources/apps/python/pipeline_api/deepstream_test5_app application.", "keywords": []}, {"id": 3211, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#engine-file-monitor", "display_name": "Engine File Monitor", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "engine-file-monitor", "priority": -1, "content": "The EngineFileMonitor is defined in \u2018utils\u2019 submodule and can be used to monitor a model engine file, whenever it is updated the inference will restart without disrupting the whole pipeline. The feature usage has been demonstrated in service-maker/sources/apps/python/pipeline_api/deepstream_test5_app application.", "keywords": []}, {"id": 3212, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#handling-buffers", "display_name": "Handling Buffers", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "handling-buffers", "priority": -1, "content": "A Buffer object in Service Maker represents a batch of data along with corresponding metadata. It provides two properties, batch_size and batch_meta, for developers to access the data and metadata of a batch. Buffer objects are commonly passed either through BufferOperator or BufferRetriever interfaces, both of which are designed to be implemented within the application to handle the data from buffers within the pipeline. One difference is BufferOperator interface is required by a Probe and BufferRetriever by a Receiver. While it is technically possible to copy and process buffers within a probe, that\u2019s generally not recommended. Probes are primarily intended for inspection purposes, and performing time-consuming tasks within them should be avoided. This is because probes are typically executed within the critical path of the pipeline, and any delays introduced by extensive processing could increase the overall latency. The other difference is BufferOperator only allows in-place operation on the Buffer data, and the result will be passed downstream and used by other nodes within the same pipeline, however, BufferRetriever is supposed to consume the buffer at the end of the pipeline. Below is a sample implementation of BufferOperator for skipping frames. If the handle_buffer returns \u2018False\u2019, the current buffer will be dropped. from pyservicemaker import BufferOperator, Probe class FrameSkipper(BufferOperator): def __init__(self): super().__init__() self._frames = 0 def handle_buffer(self, buffer): self._frames += 1 return (self._frames%2) != 0 Once we try applying the frame skipper to above sample application as follows, we\u2019ll notice the downstream elements only get one frame in two. pipeline.attach(&quot;mux&quot;, Probe(&quot;probe&quot;, FrameSkipper())) For performing heavy operations on buffers, the preferred approach is to use BufferRetriever. By replacing the \u2018nveglglessink\u2019 with \u2018appsink\u2019 in the above sample and attaching a Receiver with a BufferRetriever implementation, we can access buffer in its \u2018consume\u2019 method. The most convenient way to access buffer data is to extract it into a tensor - a dlpack-compatible class designed to facilitate interoperability with other Python deep learning frameworks. from pyservicemaker import BufferRetriever, Receiver class MyBufferRetriever(BufferRetriever): def consume(self, buffer): # extract the data from the first buffer in a batch tensor = buffer.extract(0) pipeline.attach(&quot;sink&quot;, Receiver(&quot;receiver&quot;, MyBufferRetriever(queue)), tips=&quot;new-sample&quot;) A Service Maker Tensor object can by casted to corresponding tensors in any dlpack-compatible frameworks, e.g. pytorch: from pyservicemaker import BufferRetriever, Receiver import torch class MyBufferRetriever(BufferRetriever): def consume(self, buffer): tensor = buffer.extract(0) torch_tensor = torch.utils.dlpack.from_dlpack(tensor.clone()) If developers want to preserve the tensor data for later use, they must use clone() method to duplicate the tensor, as the BufferRetriever is at the end of the pipeline and the buffer will be released after consume() returns. A buffer object can be created via a tensor as well. This approach is commonly used in the implementation of BufferProvider, which works with the Feeder class and \u2018appsrc\u2019 to inject data into the pipeline. Below sample demonstrates how to load a pytorch RGB tensor and inject it into the pipeline. from pyservicemaker import BufferProvider, ColorFormat, as_tensor import torch class MyBufferProvider(BufferProvider): def generate(self, size): torch_tensor = torch.load(&#x27;tensor_data.pt&#x27;) ds_tensor = as_tensor(torch_tensor, &quot;HWC&quot;) return ds_tensor.wrap(ColorFormat.RGB) By replacing the \u2018urisrcbin\u2019 with \u2018appsrc\u2019 in the original sample code, MyBufferProvider can be incorporated into the pipeline: pipeline.add(&quot;appsrc&quot;, &quot;src&quot;, {&quot;caps&quot;: f&quot;video/x-raw(memory:NVMM), format=RGB, width={width}, height={height}, framerate=30/1&quot;, &quot;do-timestamp&quot;: True}) Moreover, a buffer can be created via a python byte list too, for example, mono pictures in black are generated from below code: from pyservicemaker import BufferProvider, Buffer class MyBufferProvider(BufferProvider): def generate(self, size): data = [0]*(320*240*3) return Buffer(data)", "keywords": []}, {"id": 3213, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#id1", "display_name": "Prepare and Activate", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "id1", "priority": -1, "content": "Transition: From idle to paused, then to running. Process: By executing pipeline.prepare() followed by pipeline.activate(), the pipeline transitions through a paused state before becoming fully operational. This sequence allows for any necessary setup or configuration prior to execution.", "keywords": []}, {"id": 3214, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#leveraging-metadata", "display_name": "Leveraging Metadata", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "leveraging-metadata", "priority": -1, "content": "Metadata provides additional information about a buffer in Deepstream Service Maker. A BatchMetadata object, which can be retrieved from a buffer, serves as the root for all other metadata objects. Batch metadata manages a metadata pool and provides methods for initializing a variety of metadata objects. The BatchMetadata object contains metadata for a batch of frames within a buffer. It carries the batching information such as size of the batch, number of frames in the batch, and also provides access to a list of FrameMetadata objects through its frame_items attribute. The FrameMetadata objects encapsulate metadata for individual frames in the buffer batch. These frames can originate from different input streams. Through FrameMetadata, developers can access various pieces of information, including dimensions, timestamps, frame number, etc. Moreover, frame metadata carries other metadata on the frame level, including ObjectMetadata, DisplayMetadata and various user metadata. The ObjectMetadata objects carry the results of object detection. These metadata objects are typically created by an object detection model within the \u2018nvinfer\u2019 plugin. The ObjectMetadata can then be utilized by the \u2018osd (On-Screen Display)\u2019 plugin for graphical representation. By leveraging ObjectMetadata, developers can visualize detected objects on the frame. When using customized models, developers can create their own ObjectMetadata from the model output for visualization. The TensorOutputUserMetadata is a customized user metadata that carries the output of an inference model. When the output-tensor-meta property in the nvinfer plugin is set to True, TensorOutputUserMetadata objects will be attached to the frame metadata. This allows developers to have direct access to the output tensors of a model. By using TensorOutputUserMetadata, developers can directly work with the inference results, enabling advanced processing and analysis of model outputs. The EventMessageUserMetadata is another type of user metadata that transforms object detection information into message objects. These message metadata are utilized by the nvmsgconv plugin to post messages to various IoT servers. By employing EventMessageUserMetadata, developers can facilitate the communication of detection events to external systems, enhancing the integration of Deepstream Service Maker with IoT infrastructures. For the details of metadata structure in Deepstream, users should refer to the document .", "keywords": []}, {"id": 3215, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#mediaextractor", "display_name": "MediaExtractor", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "mediaextractor", "priority": -1, "content": "MediaExtractor is a convenient class provided in utils module for extracting video frames from multiple media source. Each media source is defined by a MediaChunk object with \u2018source\u2019, \u2018start_pts\u2019 and \u2018duration\u2019. MediaExtractor is a callable and must be constructed with a list of input MediaChunk, once invoked it returns a list of Queue object from which decoded frames of each media chunk can be retrieved. From the decoded video frame, developers can access the data from its tensor attribute and timestamp from its \u2018timestamp\u2019 attribute. Below code snippet shows how to retrieve frames from media sources and is only applicable for x86 system: from pyservicemaker import BufferProvider, Buffer, Flow, Pipeline, ColorFormat from pyservicemaker.utils import MediaExtractor, MediaChunk from concurrent.futures import ThreadPoolExecutor import queue VIDEO_FILE = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.mp4&quot; N_CHUNKS = 8 class MyBufferProvider(BufferProvider): def __init__(self, queue, width, height): print(&quot;MyBufferProvider&quot;) super().__init__() self._queue = queue self.format = &quot;RGB&quot; self.width = width self.height = height self.framerate = 30 self.device = &#x27;gpu&#x27; self.frames = 0 def generate(self, size): try: frame = self._queue.get(timeout=2) self.frames += 1 return frame.tensor.wrap(ColorFormat.RGB) except queue.Empty: print(&quot;Buffer empty&quot;) return Buffer() chunks = [MediaChunk(f) for f in [VIDEO_FILE]*N_CHUNKS] qs = MediaExtractor(chunks=chunks, batch_size=N_CHUNKS)() with ThreadPoolExecutor(max_workers=N_CHUNKS) as exe: exe.map(lambda q: Flow(Pipeline(&quot;renderer&quot;)).inject([MyBufferProvider(q, 1280, 720)]).render(sync=False)(), qs)", "keywords": []}, {"id": 3216, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#mediainfo", "display_name": "MediaInfo", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "mediainfo", "priority": -1, "content": "MediaInfo object can be used to retrieve the information of a media source. from pyservicemaker import utils mediainfo = utils.MediaInfo.discover(&quot;sample.mp4&quot;)", "keywords": []}, {"id": 3217, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#osd", "display_name": "OSD", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "osd", "priority": -1, "content": "Service maker provides a submodule \u2018osd\u2019 for advanced display control with basic graphical gadgets. Text: a formatted string Rect: a colorful rectangle Line: straight line Arrow: arrows Circle: circles EventHandler: a pre-built class to respond on mouse events The feature usage has been demonstrated in service-maker/sources/apps/python/flow_api/deepstream_test1_app application.", "keywords": []}, {"id": 3218, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#performance-monitor", "display_name": "Performance Monitor", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "performance-monitor", "priority": -1, "content": "The PerfMonitor is defined in \u2018utils\u2019 submodule and can be used to monitor the framerate in realtime. Before a PerfMonitor takes effect, it must be applied on a specific node within the pipeline. When used with \u2018nvmultiurisrcbin\u2019, new source needs be registered with PerfMonitor using \u2018add_stream\u2019, and after a source is removed, \u2018remove_stream\u2019 of PerfMonitor must be called accordingly. The feature usage has been demonstrated in service-maker/sources/apps/python/pipeline_api/deepstream_test5_app application.", "keywords": []}, {"id": 3219, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#pipeline-activate", "display_name": "Pipeline.activate()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "pipeline-activate", "priority": -1, "content": "After using pipeline.prepare(), pipeline.activate() transitions the pipeline\u2019s state from paused to playing in a new thread. This effectively starts the pipeline. In multi-pipeline scenarios, this allows all pipelines to begin execution concurrently.", "keywords": []}, {"id": 3220, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#pipeline-messages", "display_name": "Pipeline Messages", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "pipeline-messages", "priority": -1, "content": "While the pipeline is running, various messages are generated to inform the application about its status. Service Maker supports the \u2018on_message\u2019 parameter in the \u2018start\u2019 method, providing developers with an opportunity to inspect and respond to the messages they\u2019re interested in. The on_message callable takes two parameters: the current pipeline and the message received. Service maker offers the bindings for two most important messages: StateTransitionMessage indicates a state transition within the pipeline: name description old_state the last state of the transition new_state the current state of the transition origin name of node triggering the message DynamicSourceMessage indicates source is added or removed via REST APIs. The message could be generated in case \u2018nvmultiurisrcbin\u2019 is used. name description source_added add or removal source_id index of the source sensor_id unique string identifying the sensor sensor_name a meaningful name of the sensor uri URI of the sensor The feature usage has been demonstrated in service-maker/sources/apps/python/pipeline_api/deepstream_test5_app application.", "keywords": []}, {"id": 3221, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#pipeline-prepare", "display_name": "Pipeline.prepare()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "pipeline-prepare", "priority": -1, "content": "Unlike pipeline.start(), which transitions the pipeline\u2019s state to playing in a new thread, pipeline.prepare() sets the pipeline\u2019s state to paused within the same thread. This is particularly useful in multi-pipeline scenarios where each pipeline\u2019s state needs to be changed to paused sequentially.", "keywords": []}, {"id": 3222, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#pipeline-wait", "display_name": "Pipeline.wait()", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "pipeline-wait", "priority": -1, "content": "This API is used to join the threads created by pipeline.activate(), ensuring that all threads complete their execution before proceeding. The Sample Test 5 Application demonstrates how to utilize these API calls effectively.", "keywords": []}, {"id": 3223, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#prepare-and-activate", "display_name": "Prepare and Activate", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "prepare-and-activate", "priority": -1, "content": "For specific use cases, we have introduced alternative APIs to manage pipeline execution:", "keywords": []}, {"id": 3224, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#start", "display_name": "Start", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "start", "priority": -1, "content": "Transition: From idle to running. Process: Utilize the pipeline.start() API to initiate the pipeline, moving it from an idle state to actively running tasks.", "keywords": []}, {"id": 3225, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#state-transitions-in-service-maker-pipelines", "display_name": "State Transitions in Service Maker Pipelines", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "state-transitions-in-service-maker-pipelines", "priority": -1, "content": "Managing state transitions in service pipelines is essential for ensuring efficient and orderly operations. Service maker facilitates synchronous state transitions, enabling smooth and predictable changes in the pipeline\u2019s status. Here\u2019s a clearer and more structured explanation of these transitions:", "keywords": []}, {"id": 3226, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#stop", "display_name": "Stop", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "stop", "priority": -1, "content": "Transition: Back to idle. Process: The pipeline.stop() API is used to return the pipeline to its idle state, effectively halting operations and resetting it for future tasks. These transitions are designed to manage workflow efficiently, allowing for both immediate execution and necessary preparatory phases.", "keywords": []}, {"id": 3227, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "page", "name": "text/DS_service_maker_python_advanced_features#wait", "display_name": "Wait", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "wait", "priority": -1, "content": "Purpose: Suspend the current thread until the pipeline completes its execution. Process: The pipeline.wait() function is required after both the start and prepare/activate sequences to ensure that the current thread pauses until the pipeline has finished processing.", "keywords": []}, {"id": 3228, "doc_id": 3228, "filename": "text/DS_service_maker_python_advanced_features.html", "domain_name": "std", "name": "text/DS_service_maker_python_advanced_features", "display_name": "Advanced Features", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_python_advanced_features", "anchor": "", "priority": -1, "content": "The pyservicemaker provides advanced APIs/utilities for developers to unlock the full potential of DeepStream SDK.", "keywords": []}, {"id": 3229, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#attach", "display_name": "Attach", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "attach", "priority": -1, "content": "The \u2018attach\u2019 method attach a Probe to the current flow. Two parameters required: name description what can be a Probe object or name of the probe in a shared library name the instance name if probe is from shared library", "keywords": []}, {"id": 3230, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#batch", "display_name": "Batch", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "batch", "priority": -1, "content": "The \u2018batch\u2019 method appends a batching operation to the current flow to combine all the streams to a single batched one. This operation takes \u2018batch_size\u2019, \u2018width\u2019, and \u2018height\u2019 as parameters. If these parameters are not given, the operation sets the batch size to the number of streams and the width x height to 1920 x 1080 by default. uri_list = [&quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;]*4 # playback all the source in a tiled display Flow(Pipeline(&quot;playback&quot;)).capture(uri_list).batch().render()()", "keywords": []}, {"id": 3231, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#batched-capture", "display_name": "Batched Capture", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "batched-capture", "priority": -1, "content": "The \u2018batch_capture\u2019 method appends a operation to capture to an empty flow and batches the inputs. The operation takes either a list of URIs or a source config file as input and forming a batched stream thereafter. uri_list = [&quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;]*4 # playback 4 mp4 videos at the same time Flow(Pipeline(&quot;playback&quot;)).batch_capture(uri_list).render()()", "keywords": []}, {"id": 3232, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#capture", "display_name": "Capture", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "capture", "priority": -1, "content": "The \u2018capture\u2019 method appends a capture operation to an empty flow. This operation takes a list of URIs as input, from which multiple streams carrying decoded data will be created within the flow. # Flow for playback a mp4 video video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(Pipeline(&quot;playback&quot;)).capture([video_file]).render()()", "keywords": []}, {"id": 3233, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#decode", "display_name": "Decode", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "decode", "priority": -1, "content": "The \u2018decode\u2019 method appends a decoding operation to the current flow. The operation adds a decoder to each upstream. It is very useful in the case that the data is injected via buffer providers. class JpegBufferProvider(BufferProvider): def __init__(self, file_path:str): super().__init__() self._file_path = file_path self.format = &quot;JPEG&quot; self.width = 1280 self.height = 720 self.framerate = 0 self.count = 0 self.expected = 255 def generate(self, size): data = [] with open(self._file_path, &quot;rb&quot;) as f: bytes = f.read() data = [int(b) for b in bytes] if self.count &lt; self.expected: self.count += 1 return Buffer() if self.count == self.expected else Buffer(data) # decode jpeg from a binary buffer jpeg_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.jpg&quot; Flow(Pipeline(&quot;test&quot;)).inject([JpegBufferProvider(jpeg_file)]).decode().render()()", "keywords": []}, {"id": 3234, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#encode", "display_name": "Encode", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "encode", "priority": -1, "content": "The \u2018encode\u2019 method appends a encoder to the current flow to encode the video data into a file or rtsp stream. The operations takes a destination URI prefixed with \u2018 file:// \u2019 or \u2018 rtsp:// \u2019. If the prefix is missing, \u2018 file:// \u2019 is implied. In the case of RTSP stream, a port number must appear in the URI. Moreover, optional parameters for encoding control are supported too. name description profile profile: 0 for baseline (default), 1 for constrainted baseline, 2 for main, 4 for high iframeinterval Encoding Intra Frame occurrence frequency, default 10 bitrate bitrate, default 2000000 # streaming a udp stream via rtsp pipeline = Pipeline(&quot;test&quot;) video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(pipeline).capture([video_file]).encode(&quot;output.mp4&quot;, sync=True)()", "keywords": []}, {"id": 3235, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#flowapi-sample-applications-reference-table", "display_name": "FlowAPI Sample Applications Reference Table", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "flowapi-sample-applications-reference-table", "priority": -1, "content": "Reference test application Path inside service-maker/sources directory Description Sample test application 1 apps/python/flow_api/deepstream_test1_app Sample of how to use flowAPI methods for a single H.264 stream inference: batch_capture -&gt; infer -&gt; render. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 2 apps/python/flow_api/deepstream_test2_app Sample of how to use flowAPI methods for a single H.264 stream cascaded inference: batch_capture -&gt; infer (primary detector) -&gt; track -&gt; infer (secondary classifier) -&gt; render. This app uses resnet18_trafficcamnet_pruned.onnx for detection and 2 classifier models (i.e., resnet18_vehiclemakenet_pruned.onnx, resnet18_vehicletypenet_pruned.onnx). Sample test application 3 apps/python/flow_api/deepstream_test3_app Builds on flow_api/deepstream_test1(sample test application 1) to demonstrate how to: Use multiple sources in the pipeline for inference. Extract the stream metadata, which contains useful information about the frames in the batched buffer. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 4 apps/python/flow_api/deepstream_test4_app Builds on flow_api/deepstream_test1 for a single H.264 stream inference to demonstrate how to use publish method to publish messages to a remote server and fork method to simultaneously render the output. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Inject and Retrieve Example apps/python/flow_api/deepstream_appsrc_test_app Demonstrates how to create a BufferRetriever for a retrieve method. The retrieve method with a customized BufferRetriever can be used to extract buffer data from the pipeline.", "keywords": []}, {"id": 3236, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#fork", "display_name": "Fork", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "fork", "priority": -1, "content": "The \u2018fork\u2019 method forks the current flow so that more than one flow can be appended. # Initiate a pipeline to read a mp4 file # transcode the video to both a local file and via rtsp # at the same time, do the playback pipeline = Pipeline(&quot;test&quot;) dest = &quot;rtsp://localhost:8554&quot; flow = Flow(pipeline).capture([&quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h265.mp4&quot;]).batch().fork() flow.encode(dest, sync=True) flow.encode(&quot;/tmp/sample.mp4&quot;) flow.render(sync=True) flow() The output RTSP stream can be received from \u201c rtsp://localhost:8554/ds-test \u201d", "keywords": []}, {"id": 3237, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#infer", "display_name": "Infer", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "infer", "priority": -1, "content": "The \u2018infer\u2019 method enables the inference in the current flow. The operation takes a \u2018config\u2019 parameter for the model configuration file. Optional standard nvinfer parameters can be added to override the values in the configuration file. pgie_config = &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; # object detection using resnet18 for 4 streams uri_list = [&quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;]*4 Flow(Pipeline(&quot;infer&quot;)).batch_capture(uri_list).infer(pgie_config).render()()", "keywords": []}, {"id": 3238, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#inject", "display_name": "Inject", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "inject", "priority": -1, "content": "The \u2018inject\u2019 method appends an injection operation to an empty flow. The operation takes a list of BufferProvider objects and creates multiple streams thereafter. In addition to overriding the \u2018generate\u2019 method to create buffers, BufferProvider objects must carry the following members to instruct the injection process: member name description width width of the video frames height height of the video frames format format: RGB/I420 framerate framerate of the video use_gpu boolean value to indicate if the data is in GPU memory from pyservicemaker import Pipeline, Flow, BufferProvider, Buffer class MyBufferProvider(BufferProvider): def __init__(self, width, height, device=&#x27;cpu&#x27;, framerate=30, format=&quot;RGB&quot;): super().__init__() self.width = width self.height = height self.format = format self.framerate = framerate self.device = device self.count = 0 self.expected = 255 def generate(self, size): data = [self.count]*(self.width*self.height*3) if self.count &lt; self.expected: self.count += 1 return Buffer() if self.count == self.expected else Buffer(data) p = MyBufferProvider(320, 240) # playback a mp4 video Flow(Pipeline(&quot;playback&quot;)).inject([p]).render()()", "keywords": []}, {"id": 3239, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#publish", "display_name": "Publish", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "publish", "priority": -1, "content": "The \u2018publish\u2019 method appends a procedure to the current flow for publishing events to the remote server. The operations takes the following parameters to set up the communication between the pipeline and the remote server. name description msg_broker_proto_lib The low level library used by the message broker msg_broker_conn_str The connect string for the server topic topic name msg_conv_config The message converter config for source information # publish the object data to a kafka server Flow(Pipeline(&quot;publish&quot;)).batch_capture( &quot;/opt/nvidia/deepstream/deepstream/service-maker/sources/apps/deepstream_test5_app/source_list_dynamic.yaml&quot; ).infer( &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; ).attach( what=&quot;add_message_meta_probe&quot;, name=&quot;message_generator&quot; ).publish( msg_broker_proto_lib=&quot;/opt/nvidia/deepstream/deepstream/lib/libnvds_kafka_proto.so&quot;, msg_broker_conn_str=&quot;qvs-ds-kafka.nvidia.com;9092&quot;, topic=&quot;test4app&quot;, )() Invocation of the method result in the end of a flow and no more operation can be appended.", "keywords": []}, {"id": 3240, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#render", "display_name": "Render", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "render", "priority": -1, "content": "The \u2018render\u2019 method appends a renderer to the current flow to display or discard the video. The operation takes a render mode to decide how to render the data, DISPLAY (default) and DISCARD are supported so far. Moreover, optional named arguments cover all the standard sink control parameters. Invocation of the method result in the end of a flow and no more operation can be appended. # discard the video frames video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(Pipeline(&quot;playback&quot;)).capture([video_file]).render(mode=RenderMode.DISCARD)()", "keywords": []}, {"id": 3241, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#retrieve", "display_name": "Retrieve", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "retrieve", "priority": -1, "content": "The \u2018retrieve\u2019 method appends a data retriever to the current flow. The operation takes a instance of BufferRetriever which implements the \u2018consume\u2019 method to access buffers. Invocation of the method result in the end of a flow and no more operation can be appended. # Read the decoded video buffers from a sample mp4 file from pyservicemaker import Pipeline, Flow, BufferRetriever class MyBufferRetriever(BufferRetriever): def __init__(self): super().__init__() self.frames = 0 def consume(self, buffer): tensor = buffer.extract(0) assert len(tensor.shape) == 3 self.frames += 1 return 1 video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(Pipeline(&quot;retrieve&quot;)).capture([video_file]).retrieve(MyBufferRetriever())()", "keywords": []}, {"id": 3242, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_flow_api#track", "display_name": "Track", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "track", "priority": -1, "content": "The \u2018track\u2019 method appends a tracker to the current flow for tracking the detected object. The operation must come after \u2018infer\u2019 for detection data. Standard nvtracker parameters must be appropriately set to make the tracker work correctly. pgie_config = &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; uri_list = [&quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot;]*4 # object detection and tracking using nvmultiobjecttracker for 4 streams Flow(Pipeline(&quot;tracker&quot;)).batch_capture(uri_list).infer(pgie_config).track( ll_config_file=&quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_tracker_NvDCF_perf.yml&quot;, ll_lib_file=&quot;/opt/nvidia/deepstream/deepstream/lib/libnvds_nvmultiobjecttracker.so&quot; ).render()()", "keywords": []}, {"id": 3243, "doc_id": 3243, "filename": "text/DS_service_maker_python_into_to_flow_api.html", "domain_name": "std", "name": "text/DS_service_maker_python_into_to_flow_api", "display_name": "Introduction to Flow APIs", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_python_into_to_flow_api", "anchor": "", "priority": -1, "content": "Flow APIs effectively abstract away the underlying pipeline details, allowing developers to focus solely on the goals of their specific tasks in a pythonic style. These high-level APIs emphasize \u201cwhat to do\u201d rather than \u201chow to do it,\u201d enabling developers to express their intentions in a more intuitive and concise manner. This abstraction simplifies the development process and improves code readability and maintainability. Besides the explicitly declared arguments, Flow APIs also allow veterans to override standard Deepstream Element properties through kwargs, and the only trick is all the \u2018-\u2019 in a property name must be replaced with \u2018_\u2019. For instance, users can specify the GPU they want to use when they create a flow for capturing: # Create a capture flow on gpu 1 flow = Flow(Pipeline(&#x27;caputure&#x27;)).capture([video_file], gpu_id=1) Within the service maker a wide range of common operations in the multimedia and deep learning fields are supported by Flow.", "keywords": []}, {"id": 3244, "doc_id": 3245, "filename": "text/DS_service_maker_python_into_to_pipeline_api.html", "domain_name": "page", "name": "text/DS_service_maker_python_into_to_pipeline_api#pipelineapi-sample-applications-reference-table", "display_name": "PipelineAPI Sample Applications Reference Table", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_into_to_pipeline_api", "anchor": "pipelineapi-sample-applications-reference-table", "priority": -1, "content": "Reference test application Path inside service-maker/sources directory Description Sample test application 1 apps/python/pipeline_api/deepstream_test1_app Sample of how to use DeepStream elements for a single H.264 stream inference using pipelineAPI: filesrc -&gt; decode -&gt; nvstreammux -&gt; nvinfer or nvinferserver (primary detector) -&gt; nvdsosd -&gt; renderer. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 2 apps/python/pipeline_api/deepstream_test2_app Sample of how to use DeepStream elements for a single H.264 stream cascaded inference using pipelineAPI: filesrc -&gt; decode -&gt; nvstreammux -&gt; nvinfer or nvinferserver (primary detector) -&gt; nvtracker -&gt; nvinfer or nvinferserver (secondary classifier) -&gt; nvdsosd -&gt; renderer. This app uses resnet18_trafficcamnet_pruned.onnx for detection and 2 classifier models (i.e., resnet18_vehiclemakenet_pruned.onnx, resnet18_vehicletypenet_pruned.onnx). Sample test application 3 apps/python/pipeline_api/deepstream_test3_app Builds on pipeline_api/deepstream_test1 (sample test application 1) to demonstrate how to: Use multiple sources in the pipeline for inference. Use a uridecodebin to accept any type of input (e.g. RTSP/File). Configure nvstreammux to generate a batch of frames and infer on it for better resource utilization. Extract the stream metadata, which contains useful information about the frames in the batched buffer. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 4 apps/python/pipeline_api/deepstream_test4_app Builds on pipeline_api/deepstream_test1 for a single H.264 stream inference: filesrc, decode, nvstreammux, nvinfer or nvinferserver, nvdsosd, renderer to demonstrate how to: Use the nvmsgconv and nvmsgbroker plugins in the pipeline. Create NVDS_META_EVENT_MSG type metadata and attach it to the buffer. Use NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and person. This app uses resnet18_trafficcamnet_pruned.onnx for detection. Sample test application 5 apps/python/pipeline_api/deepstream_test5_app Builds with pipelineAPI. Demonstrates: Use of nvmsgconv and nvmsgbroker plugins in the pipeline for multistream inference. How to configure nvmsgbroker plugin from the config file as a sink plugin (for KAFKA, Azure, etc.). How to work with a remote Kafaka server as producer and consumer. Leveraging nvmultiurisrcbin for dynamic source management This app uses resnet18_trafficcamnet_pruned.onnx for detection. Appsrc and Appsink example apps/python/pipeline_api/deepstream_appsrc_test_app Demonstrates how to create a BufferProvider for a Feeder class and how to create a BufferRetriever for a receiver class. A Feeder with customized BufferProvider can be used to inject user data to the DS pipeline and a receiver with a customized BufferRetriever can be used to extract buffer data from the pipeline. Kafka Custom Data example apps/python/pipeline_api/deepstream_kafka_test_app Sample of how to use DeepStream elements for a single H.264 stream inference and send custom inference data directly to a kafka server using pipelineAPI: filesrc -&gt; decode -&gt; nvstreammux -&gt; nvinfer or nvinferserver (primary detector) -&gt; nvdsosd -&gt; renderer. This app uses resnet18_trafficcamnet_pruned.onnx for detection.", "keywords": []}, {"id": 3245, "doc_id": 3245, "filename": "text/DS_service_maker_python_into_to_pipeline_api.html", "domain_name": "std", "name": "text/DS_service_maker_python_into_to_pipeline_api", "display_name": "Introduction to Pipeline APIs", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_python_into_to_pipeline_api", "anchor": "", "priority": -1, "content": "For developers already familiar with the DeepStream SDK, pyservicemaker offers Pipeline APIs that enable them to fully harness the capabilities of DeepStream. Creating a sample Deepstream application in Python using Pipeline APIs closely mirrors the process with C++ APIs, with the notable distinction that it doesn\u2019t require a Makefile or build process. from pyservicemaker import Pipeline import sys CONFIG_FILE_PATH = &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; if __name__ == &#x27;__main__&#x27;: pipeline = Pipeline(&quot;sample-pipeline&quot;) pipeline.add(&quot;nvurisrcbin&quot;, &quot;src&quot;, {&quot;uri&quot;: sys.argv[1]}) pipeline.add(&quot;nvstreammux&quot;, &quot;mux&quot;, {&quot;batch-size&quot;: 1, &quot;width&quot;: 1280, &quot;height&quot;: 720}) pipeline.add(&quot;nvinferbin&quot;, &quot;infer&quot;, {&quot;config-file-path&quot;: CONFIG_FILE_PATH}) pipeline.add(&quot;nvosdbin&quot;, &quot;osd&quot;).add(&quot;nveglglessink&quot;, &quot;sink&quot;) pipeline.link((&quot;src&quot;, &quot;mux&quot;), (&quot;&quot;, &quot;sink_%u&quot;)).link(&quot;mux&quot;, &quot;infer&quot;, &quot;osd&quot;, &quot;sink&quot;) pipeline.start().wait() A functional pipeline requires appropriate elements from Deepstream plugins to be added, configured and linked correctly. This can be seamlessly achieved using Pipeline APIs in a fluent manner: Pipeline pipeline(&quot;sample-pipeline&quot;) // nvstreammux is the factory name in Deepstream to create a streammuxer Element // mux is the name of the Element instance // multiple key value pairs can be appended to configure the added Element pipeline.add(&quot;nvstreammux&quot;, &quot;mux&quot;, &quot;batch-size&quot;, 1, &quot;width&quot;, 1280, &quot;height&quot;, 720) The \u2018add\u2019 method is used to incorporate all necessary element nodes into a pipeline instance. This method takes the element\u2019s registration name and node name as parameters, followed by a dictionary specifying the element\u2019s properties. The node name given to an element during addition can be used to refer to the element within the pipeline. For detailed insights into how each property affects the respective element, DS Plugin Overview serves as the primary and most comprehensive resource. Developers can also run gst-inspect-1.0 with element registration name to check its technical specification, e.g. after looking up the nvstreammux from the plugin manual, we know the element is for batching buffers from multiple input and it requires \u201cbatch-size\u201d, \u201cwidth\u201d and \u201cheight\u201d to be set. After the element nodes are added into the pipeline, the \u2018link\u2019 method accomplishes the construction of the streaming path. This method offers two variations: The simpler one accepts the names of all instances to be linked sequentially. pipeline.link(&quot;mux&quot;, &quot;infer&quot;, &quot;osd&quot;, &quot;sink&quot;) The more sophisticated one links two instances, utilizing two tuples to specify the source name and target name, along with the source and target pads to indicate the specific media streams. pipeline.link((&quot;src&quot;, &quot;mux&quot;), (&quot;&quot;, &quot;sink_%u&quot;)) The second \u2018link\u2019 method primarily addresses dynamic paths, such as those encountered with the \u2018nvstreammux\u2019 element. This element features a dynamic input and a template pad named \u201csink_%u,\u201d which requires the use of this method to establish the appropriate connections. To start the pipeline and wait until the stream reaches its end, the \u2018start\u2019 method and \u2018wait\u2019 method need to be called sequentially. pipeline.start().wait() Now let\u2019s save the code as sample_app.py and run the application from the console: $ python3 sample_app.py file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_720p.mp4 The inference is operating as expected with the provided model configuration. However, if we wish to inspect the results, additional steps are required by attaching a probe. A probe is a predefined class utilized to intercept the processed buffer and metadata. By providing it with a suitable implementation of BatchMetadataOperator, we can extract the object detection results from the metadata generated by \u2018nvinfer\u2019. Below is a sample implementation of a BatchMetadataOperator, which counts the objects and displays the numbers in the downstream \u2018osd\u2019 element. The \u2018handle_metadata\u2019 method is called within the pipeline on every buffer batch, with \u2018batch_meta\u2019 object wrapping the batch metadata. Developers can iterate through the \u2018batch_meta\u2019 object for frame metadata, then frame metadata for object metadata. In the sample code, handle_metadata inspects the object information for each frame within a batch, calculates the count for each class and appends a display metadata object containing a text label to the frame. Thus, the numbers get displayed in the video output. For more details about the metadata usage, refer to Leveraging Metadata . from pyservicemaker import BatchMetadataOperator, Probe, osd class ObjectCounterMarker(BatchMetadataOperator): def handle_metadata(self, batch_meta): for frame_meta in batch_meta.frame_items: vehcle_count = 0 person_count = 0 for object_meta in frame_meta.object_items: class_id = object_meta.class_id if class_id == 0: vehcle_count += 1 elif class_id == 2: person_count += 1 print(f&quot;Object Counter: Pad Idx={frame_meta.pad_index},&quot; f&quot;Frame Number={frame_meta.frame_number},&quot; f&quot;Vehicle Count={vehcle_count}, Person Count={person_count}&quot;) text = f&quot;Person={person_count},Vehicle={vehcle_count}&quot; display_meta = batch_meta.acquire_display_meta() label = osd.Text() label.display_text = text.encode(&#x27;ascii&#x27;) label.x_offset = 10 label.y_offset = 12 label.font.name = osd.FontFamily.Serif label.font.size = 12 label.font.color = osd.Color(1.0, 1.0, 1.0, 1.0) label.set_bg_color = True label.bg_color = osd.Color(0.0, 0.0, 0.0, 1.0) display_meta.add_text(label) frame_meta.append(display_meta) By attaching the above buffer probe into the inference plugin within the existing pipeline before starting it, we extract object count information from each frame of the video stream and display it both in the console output and as an overlay on the video: pipeline.attach(&quot;infer&quot;, Probe(&quot;counter&quot;, ObjectCounterMarker())) Now let\u2019s run the python application again and we\u2019ll see the object counts printed out: Object Counter: Pad Idx=0,Frame Number=0,Vehicle Count=12, Person Count=6 Object Counter: Pad Idx=0,Frame Number=1,Vehicle Count=15, Person Count=7 Object Counter: Pad Idx=0,Frame Number=2,Vehicle Count=13, Person Count=5 Object Counter: Pad Idx=0,Frame Number=3,Vehicle Count=12, Person Count=6 Object Counter: Pad Idx=0,Frame Number=4,Vehicle Count=15, Person Count=8 Object Counter: Pad Idx=0,Frame Number=5,Vehicle Count=15, Person Count=5 Object Counter: Pad Idx=0,Frame Number=6,Vehicle Count=11, Person Count=5 Object Counter: Pad Idx=0,Frame Number=7,Vehicle Count=13, Person Count=5 Object Counter: Pad Idx=0,Frame Number=8,Vehicle Count=19, Person Count=4 Object Counter: Pad Idx=0,Frame Number=9,Vehicle Count=15, Person Count=5 Object Counter: Pad Idx=0,Frame Number=10,Vehicle Count=13, Person Count=4 In addition to creating a Probe instance from Python code, the \u2018attach\u2019 method can also attach a probe from a shared library by specifying the module name. Below code attaches a pre-built probe for displaying the object information over \u2018osd\u2019: pipeline.attach(&quot;infer&quot;, &quot;sample_video_probe&quot;, &quot;my_probe&quot;) YAML configuration files for pipeline construction are supported, following the same specification as used by C++ APIs. Below is how the above pipeline can be defined in YAML configuration: deepstream: nodes: - type: nvurisrcbin name: src properties: uri: file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4 - type: nvstreammux name: mux properties: batch-size: 1 width: 1280 height: 720 - type: nvinferbin name: infer properties: config-file-path: /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml - type: nvosdbin name: osd - type: nveglglessink name: sink edges: src: mux mux: infer infer: osd osd: sink And with the YAML configuration being applied, the application source can be simplified to a single line: Pipeline(name=&quot;sample-pipeline&quot;, config_file=&quot;my_config.yaml&quot;).start().wait()", "keywords": []}, {"id": 3246, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#bufferprovider", "display_name": "BufferProvider", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "bufferprovider", "priority": -1, "content": "BufferProvider specifies an interface for developers to implement, so to generate buffers. The code snippet below demonstrates how to generate buffers from bytes with a sub-class of BufferProvider (For demonstration, the method generates grey pictures): from pyservicemaker import BufferProvider, Buffer class MyBufferProvider(BufferProvider): def __init__(self, width, height, device=&#x27;cpu&#x27;, framerate=30, format=&quot;RGB&quot;): super().__init__() self.width = width self.height = height self.format = format self.framerate = framerate self.device = device def generate(self, size): data = [128]*(self.width*self.height*3) return Buffer() if self.count == self.expected else Buffer(data) Extra information is recommended for the pipeline to better understand what the data in the buffer represents, such as format, width, height, etc. Developers can create an empty buffer without any argument, and injecting an empty buffer to the pipeline will end it. To inject buffers to pipeline, developers can use inject flow with their customized BufferProvider. The code snippet below shows how to inject video buffers into a pipeline and display it: Flow(Pipeline(&quot;playback&quot;)).inject([MyBufferProvider(640, 480)]).render()()", "keywords": []}, {"id": 3247, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#bufferretriever", "display_name": "BufferRetriever", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "bufferretriever", "priority": -1, "content": "BufferRetriever specifies a customizable interface for developers to consume the buffers. It must be used with the retrieve flow. The code snippet below shows how to get buffer data from the pipeline. # Read the decoded video buffers from a sample mp4 file from pyservicemaker import Pipeline, Flow, BufferRetriever class MyBufferRetriever(BufferRetriever): def consume(self, buffer): tensor = buffer.extract(0) return 1 To utilize the buffer data, developers must extract it into a tensor. If the data is batched, multiple tensors may be extracted, requiring the use of a batch ID. If there is no batching, 0 should always be passed to extract method. Sub class from BufferRetriever can be used together with the retrieve flow to get buffer from the pipeline: video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(Pipeline(&quot;retrieve&quot;)).capture([video_file]).retrieve(MyBufferRetriever())()", "keywords": []}, {"id": 3248, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#create-a-simple-video-player-application", "display_name": "Create a Simple Video Player Application", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "create-a-simple-video-player-application", "priority": -1, "content": "The code snippet below demonstrates how to create a simple flow to decode and display a video file. from pyservicemaker import Pipeline, Flow pipeline = Pipeline(&quot;playback&quot;) video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(pipeline).capture([video_file]).render()() Once the flow is complete, it can be invoked with \u2018()\u2019 because it is callable. This invocation keeps the pipeline running until the processing is finished. Additionally, developers can choose to call Pipeline.start() and Pipeline.wait(). The code snippet below is effectively equivalent to the above one. from pyservicemaker import Pipeline, Flow pipeline = Pipeline(&quot;playback&quot;) video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(pipeline).capture([video_file]).render() pipeline.start() pipeline.wait()", "keywords": []}, {"id": 3249, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#create-an-object-detection-application", "display_name": "Create an Object Detection Application", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "create-an-object-detection-application", "priority": -1, "content": "A more advanced pipeline for object detection built on top of Sample Video Player Application can be constructed using the infer method for inference as follows: from pyservicemaker import Pipeline, Flow pipeline = Pipeline(&quot;detector&quot;) infer_config = &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; Flow(pipeline).batch_capture([video_file]).infer(infer_config).render()() The application executes an object detection model based on ResNet18 on the captured video. The model\u2019s configuration is specified in the infer_config, and detected objects are automatically converted into bounding boxes, which are overlaid on the display.", "keywords": []}, {"id": 3250, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#customizing-object-detection-sample-application", "display_name": "Customizing Object Detection Sample Application", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "customizing-object-detection-sample-application", "priority": -1, "content": "In many use cases, developers require direct access to inference results for various analyses. To achieve this, the application can be enhanced by attaching a probe to the inference result (For deeper understanding of a probe, please refer to Handling Buffers ). This probe allows developers to define custom metadata operators that extract output tensors from the metadata associated with the output buffers. (For more details on metadata, please refer to Leveraging Metadata .) Below is the enhanced version of the above code snippet. from pyservicemaker import Pipeline, Flow, Probe, BatchMetadataOperator import torch class TensorOutput(BatchMetadataOperator): def handle_metadata(self, batch_meta): for frame_meta in batch_meta.frame_items: for user_meta in frame_meta.tensor_items: for n, tensor in user_meta.as_tensor_output().get_layers().items(): print(f&quot;tensor name: {n}&quot;) print(f&quot;tensor object: {tensor}&quot;) # operations on tensors: torch_tensor = torch.utils.dlpack.from_dlpack(tensor.clone()) pipeline = Pipeline(&quot;detector&quot;) infer_config = &quot;/opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app/config_infer_primary.yml&quot; video_file = &quot;/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4&quot; probe = Probe(&#x27;tensor_retriver&#x27;, TensorOutput()) Flow(pipeline).batch_capture([video_file]).infer(infer_config, output_tensor_meta=True).attach(probe).render()() The enhanced code retrieves inference result as tensors from user metadata associated with the output buffer from infer flow. This is done through a probe that utilizes a customized BatchMetadataOperator to extract and process the metadata.", "keywords": []}, {"id": 3251, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#getting-to-know-buffer-and-tensor", "display_name": "Getting to know Buffer and Tensor", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "getting-to-know-buffer-and-tensor", "priority": -1, "content": "In pyservicemaker, a Buffer represents a chunk of data that flows through the pipeline from one node to another. It contains the actual media data, such as a segment of audio or video, and is passed between nodes for processing or output. In some cases, developers would like to create their own buffers and inject it to the pipeline or consume the buffers from the pipeline. pyservicemaker provides two abstract classes for them to achieved such goals.", "keywords": []}, {"id": 3252, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#getting-to-know-pipeline-and-flow", "display_name": "Getting to know Pipeline and Flow", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "getting-to-know-pipeline-and-flow", "priority": -1, "content": "The first thing users need to know for using pyservicemaker is pipeline . A pipeline consists of various processing nodes linked together to process or manipulate data flows. Each node instance performs a specific function, such as capturing data, decoding, processing, or rendering it. These nodes are connected in a chain, creating a pipeline through which the data flows. A simple empty pipeline can be created with a given name as follows: from pyservicemaker import Pipeline pipeline = Pipeline(&quot;sample-pipeline&quot;) So far the pipeline can not do anything. To make it functional developers can define data flows for the pipeline by creating a flow for a pipeline. Flow APIs provide developers with the flexibility to append operations based on their specific goals subsequently. This approach allows for a modular and customizable workflow where operations can be added as needed. Every time a Flow method is called, it takes the intended output streams from the last flow and assume them as the inputs of current flow. Thus, the order of Flow methods determines how a flow works when the pipeline is started.", "keywords": []}, {"id": 3253, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "page", "name": "text/DS_service_maker_python_quick_start#tensor", "display_name": "Tensor", "type": "section", "display_type": "Page section", "docname": "text/DS_service_maker_python_quick_start", "anchor": "tensor", "priority": -1, "content": "Tensor is essentially a multidimensional array that is widely used in deep learning space. The pyservicemaker Tensor facilitates data handling on the GPU and offers seamless interoperability with other frameworks through its compatibility with DLPack. A common practice for re-using data from a pyservicemaker Tensor is to clone the tensor and pass it to a PyTorch Tensor. This ensures that the original data remains unchanged while enabling efficient integration with other frameworks for further processing. The code snippet below shows how to transform a pyservicemaker Tensor to a pytorch tensor torch_tensor = torch.utils.dlpack.from_dlpack(tensor.clone()) Similarly, developers also can create pyservicemaker Tensors from pytorch tensor, and then wrap it into a buffer. The code snippet below demonstrates how to generate buffers from pytorch tensors within a customized BufferProvider, which can be later used by inject flow. from pyservicemaker import BufferProvider, ColorFormat, as_tensor import torch class MyBufferProvider(BufferProvider): def generate(self, size): torch_tensor = torch.load(&#x27;tensor_data.pt&#x27;) ds_tensor = as_tensor(torch_tensor, &quot;HWC&quot;) return ds_tensor.wrap(ColorFormat.RGB)", "keywords": []}, {"id": 3254, "doc_id": 3254, "filename": "text/DS_service_maker_python_quick_start.html", "domain_name": "std", "name": "text/DS_service_maker_python_quick_start", "display_name": "Quick Start Guide", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_python_quick_start", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3255, "doc_id": 3255, "filename": "text/DS_service_maker_traditional_app_migration.html", "domain_name": "std", "name": "text/DS_service_maker_traditional_app_migration", "display_name": "Migrating Traditional Deepstream Apps to Service Maker Apps in Python", "type": "doc", "display_type": "Page", "docname": "text/DS_service_maker_traditional_app_migration", "anchor": "", "priority": -1, "content": "There are two options available for migrating traditional Deepstream applications to Python apps. One option involves using Pipeline APIs with configuration files, while the other option utilizes Flow APIs. Each approach offers its own advantages and can be chosen based on the specific requirements and preferences of the application developers. Guidelines for migrating Deepstream applications to Python apps using pipeline APIs remain consistent with those of Service Maker C++ APIs. Thus, this section will focus on how to migrate Deepstream Applications to Python apps using Flow APIs. Defining the Video source Service Maker uses a Source List YAML file to define inputs, including the source information and input configuration. Specification of source list file can be found in SourceConfig . Once we have a Source List file, we can create a batch capture flow with it: from pyservicemaker import Pipeline, Flow Flow(Pipeline(&quot;my-pipeline&quot;)).batch_capture(&quot;my_source_list.yaml&quot;) Pipeline Customization In Flow APIs, each predefined section for pipeline customization in the configuration file for a traditional Deepstream Application corresponds to its respective function: DS Configuration Flow API Name primary-gie infer secondary-gie infer tracker track Sink management Flow APIs have corresponding functions for each sink type supported in traditional Deepstream Application: DS Sink Type Flow API Name Fakesink render(mode=RenderMode.DISCARD) Display render(mode=RenderMode.DISPLAY) File encode(\u201c/tmp/sample.mp4\u201d) UDP encode(\u201cudp://localhost:5400\u201d) RTSP encode(\u201d rtsp://localhost:5400 \u201d) MsgConvBroker publish To enable multiple-sink, we can just call fork() to fork the current flow and append various sink functions with it (check the \u2018fork\u2019 function in previous sections).", "keywords": []}, {"id": 3256, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#after-removing-all-the-sources-from-the-pipeline-crash-is-seen-if-muxer-and-tiler-are-present-in-the-pipeline", "display_name": "After removing all the sources from the pipeline crash is seen if muxer and tiler are present in the pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "after-removing-all-the-sources-from-the-pipeline-crash-is-seen-if-muxer-and-tiler-are-present-in-the-pipeline", "priority": -1, "content": "This happens when muxer generates an empty batched buffer to clear the tiler output. To address this issue, install a probe on sink pad of tiler. Drop the buffer if batch_meta-&gt;num_frames_in_batch = 0, code snippet for reference below: static GstPadProbeReturn drop_empty_buffer (GstPad * pad, GstPadProbeInfo * info, gpointer user_data) { NvDsBatchMeta *batch_meta = gst_buffer_get_nvds_batch_meta(GST_BUFFER(info-&gt;data)); if (batch_meta &amp;&amp; batch_meta-&gt;num_frames_in_batch == 0) return GST_PAD_PROBE_DROP; return GST_PAD_PROBE_OK; } GstPad *sinkpad = gst_element_get_static_pad(tiler, &quot;sink&quot;); gst_pad_add_probe(sinkpad, GST_PAD_PROBE_TYPE_BUFFER, drop_empty_buffer, NULL, NULL); gst_object_unref(sinkpad)", "keywords": []}, {"id": 3257, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#application-fails-to-run-when-the-neural-network-is-changed", "display_name": "Application fails to run when the neural network is changed", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "application-fails-to-run-when-the-neural-network-is-changed", "priority": -1, "content": "Solution: Make sure that the network parameters are updated for the corresponding [GIE] group in the configuration file (e.g. source30_720p_dec_infer-resnet_tiled_display_int8.txt ). Also make sure that the Gst-nvinfer plugin\u2019s configuration file is updated accordingly. When the model is changed, make sure that the application is not using old engine files.", "keywords": []}, {"id": 3258, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#deepstream-plugins-failing-to-load-without-display-variable-set-when-launching-ds-dockers", "display_name": "DeepStream plugins failing to load without DISPLAY variable set when launching DS dockers", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "deepstream-plugins-failing-to-load-without-display-variable-set-when-launching-ds-dockers", "priority": -1, "content": "Solution: The error \u201cNo EGL Display; nvbufsurftransform: Could not get EGL display connection\u201d will be resolved if the user ensure to meet either of the below requirements. The below requirements shall be met before starting the docker using docker run command. When user expect to use Display window Set appropriate value for the DISPLAY variable and Execute the command: xhost + from the host terminal, to allow the docker to launch a display window. Example: $ export DISPLAY=:0 $ xhost + When user expect to not use a Display window unset the DISPLAY variable or launch the docker without exporting DISPLAY variable to its environment.", "keywords": []}, {"id": 3259, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#error-while-running-onnx-explicit-batch-dimension-networks", "display_name": "Error while running ONNX / Explicit batch dimension networks", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "error-while-running-onnx-explicit-batch-dimension-networks", "priority": -1, "content": "After upgrading TensorRT on Jetson, running with ONNX / Explicit batch dimension networks fails with the error \u201cNetwork has dynamic or shape inputs, but no optimization profile has been defined.\u201d Due to an ABI break in TensorRT 7.1.3.0 (part of Jetpack 4.4 - Jetpack 4.6), when moving to newer TensorRT versions, libnvds_infer.so needs to be recompiled from sources provided in the SDK. The sources along with the compilation instructions can be found in /opt/nvidia/deepstream/deepstream-6.4/sources/libs/nvdsinfer .", "keywords": []}, {"id": 3260, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#errors-occur-when-deepstream-app-fails-to-load-plugin-gst-nvinferserver", "display_name": "Errors occur when deepstream-app fails to load plugin Gst-nvinferserver", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "errors-occur-when-deepstream-app-fails-to-load-plugin-gst-nvinferserver", "priority": -1, "content": "For example: (deepstream-app:16632): GStreamer-WARNING **: 13:13:31.201: Failed to load plugin &#x27;/usr/lib/x86_64-linux-gnu/gstreamer-1.0/deepstream/libnvdsgst_inferserver.so&#x27;:  libtrtserver.so: cannot open shared object file: No such file or directory. This is a harmless warning indicating that the DeepStream\u2019s nvinferserver plugin cannot be used since \u201cTriton Inference Server\u201d is not installed. Solution 1: Ignore this message if users do not need Triton support. Otherwise see Solution 2, 3. Solution 2: Pull deepstream-triton docker image and start the container. Retry deepstream-app to launch triton models. Solution 3: For dGPU: Build Triton server library from source ( triton-inference-server/server ) and fix dynamic link problem manually. For Jetson: Refer /opt/nvidia/deepstream/deepstream/samples/configs/deepstream-app-triton/README for steps to install Triton on Jetson.", "keywords": []}, {"id": 3261, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#errors-occur-when-deepstream-app-is-run-with-a-number-of-streams-greater-than-100", "display_name": "Errors occur when deepstream-app is run with a number of streams greater than 100", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "errors-occur-when-deepstream-app-is-run-with-a-number-of-streams-greater-than-100", "priority": -1, "content": "For example: (deepstream-app:15751): GStreamer-CRITICAL **: 19:25:29.810: gst_poll_write_control: assertion &#x27;set != NULL&#x27; failed. Solution: Run this command on the console: `` ulimit -Sn 4096`` Then run the deepstream-app again.", "keywords": []}, {"id": 3262, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#flickering-bbox", "display_name": "Flickering Bbox", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "flickering-bbox", "priority": -1, "content": "In case the PGIE detection interval is set to zero (i.e., interval=0 in the ds-app config file), the bbox flickering may occur in the video output if the value for minTrackerConfidence is set too low. Try increasing the value for this parameter to mitigate the issue. In case the PGIE detection interval is set to be a non-zero value (i.e., interval &gt; 0 in the ds-app config file), it is expected that the tracker outputs are not reported on the uninferenced frames, although all the targets are being tracked in the background. Thus, it is an expected behavior that the real-time video display from OSD has the bbox flickering. To mitigate this issue, users can first enable the past-frame data configuration to retrieve the missed outputs and then add a custom module to combine the real-time metadata with the past-frame data. By doing so, users can combine the data in a proper order and can opt to visualize the combined data on the display with no flickering bbox issue.", "keywords": []}, {"id": 3263, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#frequent-tracking-id-changes-although-no-nearby-objects", "display_name": "Frequent tracking ID changes although no nearby objects", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "frequent-tracking-id-changes-although-no-nearby-objects", "priority": -1, "content": "This may occur because the tracker cannot detect the target from the correlation response map. It is recommended to start with lower minimum qualification for the target. First, set minTrackerConfidence with a relatively low value like 0.5 . Also, in case the state estimator is enabled, the prediction may not be accurate enough. Users may tune the state estimator parameters based on the expected motion dynamics, or disable during debugging.", "keywords": []}, {"id": 3264, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#frequent-tracking-id-switches-to-the-nearby-objects", "display_name": "Frequent tracking ID switches to the nearby objects", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "frequent-tracking-id-switches-to-the-nearby-objects", "priority": -1, "content": "Make the data association policy stricter by increasing the minimum qualifications such as: minMatchingScore4SizeSimilarity minMatchingScore4Iou minMatchingScore4VisualSimilarity", "keywords": []}, {"id": 3265, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#memory-usage-keeps-on-increasing-when-the-source-is-a-long-duration-containerized-files-e-g-mp4-mkv", "display_name": "Memory usage keeps on increasing when the source is a long duration containerized files(e.g. mp4, mkv)", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "memory-usage-keeps-on-increasing-when-the-source-is-a-long-duration-containerized-files-e-g-mp4-mkv", "priority": -1, "content": "A memory accumulation bug is present in GStreamer\u2019s Base Parse class which potentially affects all codec parsers provided by GStreamer. This bug is seen only with long duration seekable streams (mostly containerized files e.g. mp4). This does not affect live sources like RTSP. An issue has been filed on GStreamer\u2019s GitLab project https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/468 Solution: Apply the following temporary fix to the GStreamer sources and build the library. Check the exact Gstreamer version installed on the system. $ gst-inspect-1.0 --version gst-inspect-1.0 version 1.16.2 GStreamer 1.16.2 https://launchpad.net/distros/ubuntu/+source/gstreamer1.0 Clone the Gstreamer repo and checkout the tag corresponding to the installed version. $ git clone git@gitlab.freedesktop.org:gstreamer/gstreamer.git $ cd gstreamer $ git checkout 1.16.2 Make sure the build dependencies are installed. $ sudo apt install libbison-dev build-essential flex debhelper Run autogen.sh and configure script. $ ./autogen.sh \u2013noconfigure $ ./configure \u2013prefix=(pwd)/out # Don\u2019t want to overwrite system libs Save the following patch to a file. diff --git a/libs/gst/base/gstbaseparse.c b/libs/gst/base/gstbaseparse.c index 41adf130e..ffc662a45 100644 --- a/libs/gst/base/gstbaseparse.c +++ b/libs/gst/base/gstbaseparse.c @@ -1906,6 +1906,9 @@ gst_base_parse_add_index_entry (GstBaseParse * parse, guint64 offset, GST_LOG_OBJECT (parse, &quot;Adding key=%d index entry %&quot; GST_TIME_FORMAT &quot; @ offset 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, key, GST_TIME_ARGS (ts), offset); + if (!key) + goto exit; + if (G_LIKELY (!force)) { if (!parse-&gt;priv-&gt;upstream_seekable) { Apply the patch. $ cat patch.txt | patch -p1 Build the sources. make -j(nproc) &amp;&amp; make install 8. Backup the distribution provided library and copy the newly built library. Adjust the library name for version. For Jetson replace x86_64-linux-gnu with aarch64-linux-gnu. $ sudo cp /usr/lib/x86_64-linux-gnu/libgstbase-1.0.so.0.1602.0 ${HOME}/libgstbase-1.0.so.0.1602.0.backup $ sudo cp out/lib/libgstbase-1.0.so.0.1602.0 /usr/lib/x86_64-linux-gnu/", "keywords": []}, {"id": 3266, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#my-component-is-getting-registered-as-an-abstract-type", "display_name": "My component is getting registered as an abstract type.", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "my-component-is-getting-registered-as-an-abstract-type", "priority": -1, "content": "This usually happens because pure virtual methods inherited from the base class hierarchy have not been implemented. A quick way to find which pure virtual methods have not been implemented is to try to declare an object of the component class. Adding \u201cMyComponentType comp;\u201d anywhere after the class definition should throw compilation errors pointing to the missing implementations.", "keywords": []}, {"id": 3267, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#my-component-is-not-visible-in-the-composer-even-after-registering-the-extension-with-registry", "display_name": "My component is not visible in the composer even after registering the extension with registry", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "my-component-is-not-visible-in-the-composer-even-after-registering-the-extension-with-registry", "priority": -1, "content": "Run \u201cregistry extn info -n &lt;extn-name&gt;\u201d to check that component is part of the extension. If not, Check that a call to GXF_EXT_FACTORY_ADD() corresponding to the component has been added within the GXF_EXT_FACTORY code block of the extension Run \u201cregistry comp info -t &lt;comp-type&gt;\u201d to check if the component is being detected as an abstract type. If yes, component does not list abstract types since they cannot be instantiated. Check the solution to the next question.", "keywords": []}, {"id": 3268, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#nvdsbatchmeta-not-found-for-input-buffer-error-while-running-deepstream-pipeline", "display_name": "\u201cNvDsBatchMeta not found for input buffer\u201d error while running DeepStream pipeline", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "nvdsbatchmeta-not-found-for-input-buffer-error-while-running-deepstream-pipeline", "priority": -1, "content": "Solution: The Gst-nvstreammux plugin is not in the pipeline. Starting with DeepStream 4.0, Gst-nvstreammux is a required plugin. This is an example pipeline: Gst nvv4l2decoder --&gt; Gst nvstreammux --&gt; Gst nvinfer --&gt; Gst nvtracker --&gt; Gst nvmultistreamtiler --&gt; Gst nvvideoconvert --&gt; Gst nvosd --&gt; Gst nveglglessink", "keywords": []}, {"id": 3269, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#nvidia-driver-installation-issues", "display_name": "Nvidia driver installation issues", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "nvidia-driver-installation-issues", "priority": -1, "content": "Error: \u201cAn NVIDIA kernel module \u2018nvidia-drm\u2019 appears to already be loaded in your kernel. **** \u201d Solution: The Error suggest another version of NVIDIA driver is loaded. You may refer to the links below to uninstall previous driver versions. Uninstallation method differs based on the installation method (runfile or debian). Quick Links: 1. Handle Conflicting Installation Methods. 2. Pre Installation Actions", "keywords": []}, {"id": 3270, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#on-jetson-observing-error-gstnvarguscamerasrc-cpp-execute-751-no-cameras-available", "display_name": "On Jetson, observing error : gstnvarguscamerasrc.cpp, execute:751 No cameras available", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "on-jetson-observing-error-gstnvarguscamerasrc-cpp-execute-751-no-cameras-available", "priority": -1, "content": "In order to access CSI camera, you can use Jetson-IO tool to enable CSI camera sensor. For example on AGX, navigate to /opt/nvidia/jetson-io/ : -&gt; Run sudo python jetson-io.py and follow Wizard -&gt; Configure Jetson AGX Xavier CSI Connector -&gt; Configure for compatible hardware. -&gt; Choose the CSI camera module e.g. \u201cJetson Camera E3333 module\u201d -&gt; Save pin changes -&gt; Save and reboot to reconfigure pins For more details, refer to https://docs.nvidia.com/jetson/l4t/#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/hw_setup_jetson_io.html and section 2.3 and 3.0 of https://developer.nvidia.com/sites/default/files/akamai/embedded/jetson-linux-release-notes-r341-dp.pdf", "keywords": []}, {"id": 3271, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#on-jetson-observing-error-nvbufsurftransform-copy-cpp-failed-in-mem-copy-or-cugraphicseglregisterimage-failed-700", "display_name": "On Jetson, observing error : \u201cnvbufsurftransform_copy.cpp: Failed in mem copy\u201d or \u201ccuGraphicsEGLRegisterImage failed : 700\u201d", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "on-jetson-observing-error-nvbufsurftransform-copy-cpp-failed-in-mem-copy-or-cugraphicseglregisterimage-failed-700", "priority": -1, "content": "To avoid this error we can set \u201ccopy-hw\u201d property as \u201cVIC\u201d for nvvideoconvert while using \u201c\u201dnvbuf-mem-surface-array\u201d as memory type. Example pipeline to set \u201ccopy-hw\u201d property of nvvideoconvert to \u201cVIC\u201d: $ gst-launch-1.0 filesrc location=test_I420.yuv ! videoparse width=1280 height=720 format=2 framerate=30/1 ! nvvideoconvert copy-hw=2 ! &#x27;video/x-raw(memory:NVMM), format=(string)I420&#x27; ! nv3dsink sync=0 -e Refer to \u201cdeepstream-appsrc-test\u201d app available in Deepstream SDK, for usage of \u201ccopy-hw\u201d property from application. For more FAQs and troubleshooting, see https://forums.developer.nvidia.com/t/deepstream-sdk-faq/", "keywords": []}, {"id": 3272, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#seeing-gitches-choppy-video-due-to-potential-packet-drops-over-remote-viewing-of-rtsp-output-using-vlc", "display_name": "Seeing gitches / choppy video due to potential packet drops over remote viewing of RTSP output (using VLC)", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "seeing-gitches-choppy-video-due-to-potential-packet-drops-over-remote-viewing-of-rtsp-output-using-vlc", "priority": -1, "content": "VLC use UDP by default to stream the RTSP URL. UDP is lossy and cause quality issues on the rendered video. When viewing DeepStream RTSP sink output remotely, please force usage of TCP to avoid unnecessary packet drops. Example command to force TCP when using VLC: $ vlc --rtsp-tcp rtsp://path/to/stream", "keywords": []}, {"id": 3273, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#setup-re-id-model", "display_name": "Setup Re-ID model", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "setup-re-id-model", "priority": -1, "content": "Error \u201c!![ERROR] TAO model file does not exist\u201d when using config_tracker_NvDCF_accuracy.yml or config_tracker_NvDeepSORT.yml . tltEncodedModel: &quot;/opt/nvidia/deepstream/deepstream/samples/models/Tracker/resnet50_market1501.etlt&quot;&quot; does not exist. Solution: You need a Re-ID model to use these trackers. Follow steps in sources/tracker_ReID/README to setup the Re-ID model.", "keywords": []}, {"id": 3274, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#some-rgb-video-format-pipelines-worked-before-deepstream-6-1-onwards-on-jetson-but-don-t-work-now", "display_name": "Some RGB video format pipelines worked before DeepStream 6.1 onwards on Jetson but don\u2019t work now", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "some-rgb-video-format-pipelines-worked-before-deepstream-6-1-onwards-on-jetson-but-don-t-work-now", "priority": -1, "content": "The below pipeline used to work in previous releases before DeepStream 6.1 onwards and also works on dGPU, but fails on Jetson: gst-launch-1.0 -v videotestsrc ! &#x27;video/x-raw,format=RGB&#x27; ! videoconvert ! \\ nvvideoconvert nvbuf-memory-type=0 name=converter1 ! &#x27;video/x-raw(memory:NVMM),format=(string)NV12&#x27; ! \\ nvvideoconvert ! &#x27;video/x-raw&#x27; ! nveglglessink Setting pipeline to PAUSED ... Using winsys: x11 Pipeline is PREROLLING ... Got context from element &#x27;eglglessink0&#x27;: gst.egl.EGLDisplay=context, display=(GstEGLDisplay)NULL; /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstVideoConvert:videoconvert0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/Gstnvvideoconvert:converter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstEglGlesSink:eglglessink0.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:converter1.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstVideoConvert:videoconvert0.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive 0:00:00.282672495 716265 0xaaab033c7400 ERROR nvvideoconvert gstnvvideoconvert.c:3750:``gst_nvvideoconvert_transform: buffer transform failed`` ERROR: from element /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0: Internal data stream error. Additional debug info: gstbasesrc.c(3072): gst_base_src_loop (): /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0: streaming stopped, reason error (-5) ERROR: pipeline doesn&#x27;t want to preroll. Setting pipeline to NULL ... Freeing pipeline ... The support for RGB/BGR video formats was added in nvvideoconvert in DeepStream 6.1. Earlier RGB/BGR input wasn\u2019t accepted by nvvideoconvert, hence for above pipeline the (OSS) videoconvert converts RGB to a format which can be accepted by nvvideoconvert and hence it used to work. Now, post DeepStream 6.1 the (OSS) videoconvert plugin goes in passthrough mode, and the default compute hardware for Jetson is VIC which doesn\u2019t support RGB input. To allow RGB input and output to work with nvvideoconvert set compute-hw=GPU property on the plugin as given below. gst-launch-1.0 -v videotestsrc ! &#x27;video/x-raw,format=RGB&#x27; ! videoconvert ! \\ nvvideoconvert compute-hw=GPU nvbuf-memory-type=0 name=converter1 ! &#x27;video/x-raw(memory:NVMM),format=(string)NV12&#x27; ! \\ nvvideoconvert ! &#x27;video/x-raw&#x27; ! nveglglessink Setting pipeline to PAUSED ... Using winsys: x11 Pipeline is PREROLLING ... Got context from element &#x27;eglglessink0&#x27;: gst.egl.EGLDisplay=context, display=(GstEGLDisplay)NULL; /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstVideoConvert:videoconvert0.GstPad:src: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/Gstnvvideoconvert:converter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:src: caps = video/x-raw, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter2.GstPad:src: caps = video/x-raw, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstEglGlesSink:eglglessink0.GstPad:sink: caps = video/x-raw, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter2.GstPad:sink: caps = video/x-raw, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)NV12, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:converter1.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstVideoConvert:videoconvert0.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:sink: caps = video/x-raw, format=(string)RGB, width=(int)320, height=(int)240, framerate=(fraction)30/1, multiview-mode=(string)mono, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClock", "keywords": []}, {"id": 3275, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#stale-frames-observed-on-rtsp-output", "display_name": "Stale frames observed on RTSP output", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "stale-frames-observed-on-rtsp-output", "priority": -1, "content": "If stale frames are observed on the RTSP output, then update rtsp-port and udp-port parameter( at RTSP sink) inside the config file which is being used to run deepstream applications. Update rtsp-port to other port number. For ex: rtsp-port=8660 Update udp-port to other port number. For ex: udp-port=5500", "keywords": []}, {"id": 3276, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#tensorflow-models-are-running-into-oom-out-of-memory-problem", "display_name": "Tensorflow models are running into OOM (Out-Of-Memory) problem", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "tensorflow-models-are-running-into-oom-out-of-memory-problem", "priority": -1, "content": "This problem may manifest as other errors like CUDA_ERROR_OUT_OF_MEMORY , core dump , application get killed once GPU memory is set up by Tensorflow component. Solution: Tune parameter tf_gpu_memory_fraction in config file (e.g. config_infer_primary_detector_ssd_inception_v2_coco_2018_01_28.txt ) to a proper value. For more details, see: samples/configs/deepstream-app-triton/README .", "keywords": []}, {"id": 3277, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#the-deepstream-application-is-running-slowly", "display_name": "The DeepStream application is running slowly", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "the-deepstream-application-is-running-slowly", "priority": -1, "content": "Solution 1: One of the plugins in the pipeline may be running slowly. You can measure the latency of each plugin in the pipeline to determine if one of them is slow. To enable frame latency measurement, run this command on the console: $ export NVDS_ENABLE_LATENCY_MEASUREMENT=1 To enable latency for all plugins, run this command on the console: $ export NVDS_ENABLE_COMPONENT_LATENCY_MEASUREMENT=1 Solution 2: (dGPU only) Ensure that your GPU card is in the PCI slot with the highest bus width. Solution 3: In the configuration file\u2019s [streammux] group, set batched-push-timeout to 1/max_fps . Solution 4: In the configuration file\u2019s [streammux] group, set width and height to the stream\u2019s resolution. Solution 5: For RTSP streaming input, in the configuration file\u2019s [streammux] group, set live-source=1 . Also make sure that all [sink#] groups have the sync property set to 0. Solution 6: If secondary inferencing is enabled, try to increase batch-size in the the configuration file\u2019s [secondary-gie#] group in case the number of objects to be inferred is greater than the batch-size setting. Solution 7: On Jetson, use Gst-nvdrmvideosink instead of Gst-nv3dsink as nv3dsink requires GPU utilization. Solution 8: If the GPU is the performance bottleneck, try increasing the interval at which the primary detector infers on input frames. You can do this by modifying the interval property of [primary-gie] group in the application configuration, or the interval property of the Gst-nvinfer configuration file. Solution 9: If the elements in the pipeline are getting starved for buffers (you can check if CPU/GPU utilization is low), increase the number of buffers allocated by the decoder by setting the num-extra-surfaces property of the [source#] group in the application or the num-extra-surfaces property of Gst-nvv4l2decoder element. Solution 10: If you are running the application inside docker/on-console and it delivers low FPS, set qos=0 in the configuration file\u2019s [sink0] group. The issue is caused by initial load. With qos set to 1 as the property\u2019s default value in the [sink0] group, decodebin starts dropping frames. Solution 11: For RTSP streaming input, if the input has high jitter the GStreamer rtpjitterbuffer element might drop packets which are late. Increase the latency property of rtspsrc , for deepstream-app set latency in [source*] group. Alternatively, if using RTSP type source (type=4) with deepstream-app , turn off drop-on-latency in deepstream_source_bin.c . These steps may add cumulative delay in frames reaching the renderer and memory accumulation in the rtpjitterbuffer if the pipeline is not fast enough. Solution 12: On Jetson in the configuration file of gst-nvinfer set scaling-compute-hw = 1 if gpu usage is not 100%. Solution 13: On dgpu set cudadec-memtype=0 property on Gst-nvv4l2decoder plugin to select device memory output.", "keywords": []}, {"id": 3278, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#the-deepstream-application-is-running-slowly-jetson-only", "display_name": "The DeepStream application is running slowly (Jetson only)", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "the-deepstream-application-is-running-slowly-jetson-only", "priority": -1, "content": "Solution: Ensure that Jetson clocks are set high. Run these commands to set Jetson clocks high. $ sudo nvpmodel -m 0 --for MAX perf and power $ sudo jetson_clocks", "keywords": []}, {"id": 3279, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#the-deepstream-reference-application-fails-to-launch-or-any-plugin-fails-to-load", "display_name": "The DeepStream reference application fails to launch, or any plugin fails to load", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "the-deepstream-reference-application-fails-to-launch-or-any-plugin-fails-to-load", "priority": -1, "content": "Solution: Try clearing the GStreamer cache by running the command: $ rm -rf ${HOME}/.cache/gstreamer-1.0 Also run this command if there is an issue with loading any of the plugins. Warnings or errors for failing plugins are displayed on the terminal. $ gst-inspect-1.0 Then run this command to find missing dependencies: $ ldd &lt;plugin&gt;.so where &lt;plugin&gt; is the name of the plugin that failed to load.", "keywords": []}, {"id": 3280, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#uyvp-video-format-pipeline-doesn-t-work-on-jetson", "display_name": "UYVP video format pipeline doesn\u2019t work on Jetson", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "uyvp-video-format-pipeline-doesn-t-work-on-jetson", "priority": -1, "content": "The below pipeline for UYVP video format doesn\u2019t work for Jetson: gst-launch-1.0 videotestsrc ! &#x27;video/x-raw,format=UYVP,width=1920,height=1080,depth=10,framerate=(fraction)50/1&#x27; ! nvvideoconvert ! \\ &#x27;video/x-raw(memory:NVMM),width=960,height=540,format=UYVP&#x27; ! nvvideoconvert ! nv3dsink -v Setting pipeline to PAUSED ... Using winsys: x11 Pipeline is PREROLLING ...; /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)I420, block-linear=(boolean)false /GstPipeline:pipeline0/GstNv3dSink:nv3dsink0.GstPad:src: caps = video/x-raw, width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)RGBA, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0.GstPad:sink: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:sink: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive nvbufsurface: invalid colorFormat 69 nvbufsurface: Error in allocating buffer Error(-1) in buffer allocation ** (gst-launch-1.0:723645): CRITICAL **: 17:18:46.766: gst_nvds_buffer_pool_alloc_buffer: assertion &#x27;mem&#x27; failed ERROR: from element /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0: failed to activate bufferpool Additional debug info: gstbasetransform.c(1678): default_prepare_output_buffer (): /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0: failed to activate bufferpool ERROR: pipeline doesn&#x27;t want to preroll. Setting pipeline to NULL ... Freeing pipeline ... The default memory allocator (nvbuf-mem-surface-array) on Jetson doesn\u2019t support allocation for UYVP, so currently the allocation is only supported through nvbuf-mem-cuda-device on Jetson. As VIC doesn\u2019t support transformation on Cuda memory hence, GPU can be used to do the required transformation. So, the above pipeline can be modified to run on Jetson. gst-launch-1.0 videotestsrc ! &#x27;video/x-raw,format=UYVP,width=1920,height=1080,depth=10,framerate=(fraction)50/1&#x27; ! \\ nvvideoconvert nvbuf-memory-type=nvbuf-mem-cuda-device compute-hw=GPU ! \\ &#x27;video/x-raw(memory:NVMM),width=960,height=540,format=UYVP&#x27; ! nvvideoconvert compute-hw=GPU ! nv3dsink -v Setting pipeline to PAUSED ... Using winsys: x11 Pipeline is PREROLLING ... /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstCapsFilter:capsfilter0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstQueue:queue0.GstPad:sink: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstQueue:queue0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/GstQueue:queue0.GstPad:src: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)I420, block-linear=(boolean)false /GstPipeline:pipeline0/GstQueue:queue1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)I420, block-linear=(boolean)false /GstPipeline:pipeline0/GstQueue:queue1.GstPad:src: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)I420, block-linear=(boolean)false /GstPipeline:pipeline0/GstNv3dSink:nv3dsink0.GstPad:sink: caps = video/x-raw, width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)RGBA, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/GstCapsFilter:capsfilter1.GstPad:sink: caps = video/x-raw(memory:NVMM), width=(int)960, height=(int)540, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive, format=(string)UYVP, block-linear=(boolean)false /GstPipeline:pipeline0/Gstnvvideoconvert:nvvideoconvert0.GstPad:sink: caps = video/x-raw, format=(string)UYVP, width=(int)1920, height=(int)1080, framerate=(fraction)50/1, multiview-mode=(string)mono, depth=(int)10, pixel-aspect-ratio=(fraction)1/1, interlace-mode=(string)progressive Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClock The original pipeline would work as is on dGPU, but need to modify it to remove nvegltransform element.", "keywords": []}, {"id": 3281, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#warning-message-gstnvtracker-unable-to-acquire-a-user-meta-buffer", "display_name": "Warning message gstnvtracker: Unable to acquire a user meta buffer", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "warning-message-gstnvtracker-unable-to-acquire-a-user-meta-buffer", "priority": -1, "content": "Tracker uses a buffer pool for miscellaneous data memory management, whose size can be set with user-meta-pool-size . When the latency for downstream plugins to release the buffers is too long, the buffer pool may be empty so tracker will skip reporting the miscellaneous data for next batch and print this message. Users can increase the pool size from default 32 to larger values like 64.", "keywords": []}, {"id": 3282, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#when-executing-a-graph-the-execution-ends-immediately-with-the-warning-no-system-specified-nothing-to-do", "display_name": "When executing a graph, the execution ends immediately with the warning \u201cNo system specified. Nothing to do\u201d", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "when-executing-a-graph-the-execution-ends-immediately-with-the-warning-no-system-specified-nothing-to-do", "priority": -1, "content": "Check that NvDsScheduler component is part of the graph.", "keywords": []}, {"id": 3283, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "page", "name": "text/DS_troubleshooting#you-are-migrating-from-deepstream-6-0-to-deepstream-7-1", "display_name": "You are migrating from DeepStream 6.0 to DeepStream 7.1", "type": "section", "display_type": "Page section", "docname": "text/DS_troubleshooting", "anchor": "you-are-migrating-from-deepstream-6-0-to-deepstream-7-1", "priority": -1, "content": "Solution: You must clean up the DeepStream 6.0 libraries and binaries. Use one of these commands to clean up: For dGPU: For example to remove DeepStream 6.0 : Open the uninstall.sh file in /opt/nvidia/deepstream/deepstream/ Set PREV_DS_VER as 6.0 Run the script as sudo ./uninstall.sh For Jetson: Flash the target device with the latest release of JetPack.", "keywords": []}, {"id": 3284, "doc_id": 3284, "filename": "text/DS_troubleshooting.html", "domain_name": "std", "name": "text/DS_troubleshooting", "display_name": "Troubleshooting", "type": "doc", "display_type": "Page", "docname": "text/DS_troubleshooting", "anchor": "", "priority": -1, "content": "If you run into to trouble while using DeepStream, consider the following solutions. if you don\u2019t find answers below, post your questions on DeepStream developer forum .", "keywords": []}, {"id": 3285, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#cuda-engine-creation-for-custom-models", "display_name": "CUDA Engine Creation for Custom Models", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "cuda-engine-creation-for-custom-models", "priority": -1, "content": "DeepStream supports creating TensorRT CUDA engines for models which are not in Caffe, UFF, or ONNX format, or which must be created from TensorRT Layer APIs. The objectDetector_YoloV3 sample application shows an example of the implementation. When using a single custom library for multiple nvinfer plugin instances in a pipeline, each instance can have its own implementation of engine-create-func-name and this can be specified in the configuration file. An example would be back-to-back detector pipeline with different types of yolo models.", "keywords": []}, {"id": 3286, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#custom-model-implementation-interface", "display_name": "Custom Model Implementation Interface", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "custom-model-implementation-interface", "priority": -1, "content": "nvinfer supports interfaces for these purposes: Custom bounding box parsing for custom neural network detectors and classifiers IPlugin implementation for layers not natively supported by NVIDIA\u00ae TensorRT\u2122 Initializing non-image input layers in cases where the network has more than one input layer Creating a CUDA engine using TensorRT Layer APIs instead of model parsing APIs. Read more about TensorRT docs here: https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html IModelParser interface to parse the model and fill the layers in an INetworkDefinition All the interface implementations for the models must go into a single independent shared library. nvinfer dynamically loads the library with dlopen() , looks for implemented interfaces with dlsym() , and calls the interfaces as required. For more information about the interface, refer to the header file nvdsinfer_custom_impl.h .", "keywords": []}, {"id": 3287, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#custom-output-parsing", "display_name": "Custom Output Parsing", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "custom-output-parsing", "priority": -1, "content": "For detectors, you must write a library that can parse the bounding box coordinates and the object class from the output layers. For classifiers, the library must parse the object attributes from the output layers. For example, in segmentation models, the library must parse the bounding box, object class and the mask from the output layers. You can find example code and makefile in the source directory in sources/libs/nvdsinfer_customparser . The generated library path and the function name must be specified with the configuration parameters as mentioned in the section Custom Model. The README file in sources/libs/nvdsinfer_customparser has an example of how to use this custom parser. Following output parsers are supported in the current release: MaskRCNN SSD YoloV3 / YoloV3Tiny / YoloV2 / YoloV2Tiny DetectNet", "keywords": []}, {"id": 3288, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#during-deserialization", "display_name": "During Deserialization", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "during-deserialization", "priority": -1, "content": "If deserializing the models requires an instance of NvInfer1::IPluginFactory , the custom library must also implement NvDsInferPluginFactoryRuntimeGet() and optionally NvDsInferPluginFactoryRuntimeDestroy() . During deserialization, Gst-nvinfer calls the library\u2019s NvDsInferPluginFactoryRuntimeGet() function to get the IPluginFactory instance, then calls NvDsInferPluginFactoryRuntimeDestroy to destroy the instance if it finds that function during Gst-nvinfer deinitialization. The FasterRCNN sample provided with the SDK provides an example of using the IPluginV2+nvcaffeparser1::IPluginFactoryV2 interface with DeepStream. This sample has been adapted from TensorRT. It also provides an example of using the legacy IPlugin + nvcaffeparser1::IPluginFactory + Gst-nvinfer 1::IPluginFactory interface for backward compatibility.", "keywords": []}, {"id": 3289, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#for-caffe-files", "display_name": "For Caffe Files", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "for-caffe-files", "priority": -1, "content": "During parsing and building of a Caffe network, Gst-nvinfer looks for NvDsInferPluginFactoryCaffeGet . If found, it calls the function to get the IPluginFactory instance. Depending on the type of IPluginFactory returned, Gst-nvinfer sets the factory using one of the ICaffeParser interface\u2019s methods setPluginFactory() , setPluginFactoryExt() , or setPluginFactoryV2() . After the network has been built and serialized, Gst-nvinfer looks for NvDsInferPluginFactoryCaffeDestroy and calls it to destroy the IPluginFactory instance.", "keywords": []}, {"id": 3290, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#for-uff-files", "display_name": "For Uff Files", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "for-uff-files", "priority": -1, "content": "During parsing and building of a Caffe network, Gst-nvinfer looks for NvDsInferPluginFactoryUffGet . If found, it calls the function to get the IPluginFactory instance. Depending on the type of IPluginFactory returned, Gst-nvinfer sets the factory using one of the IUffParser inteface\u2019s methods setPluginFactory() or setPluginFactoryExt() . After the network has been built and serialized, Gst-nvinfer looks for NvDsInferPluginFactoryUffDestroy and calls it to destroy the IPluginFactory instance.", "keywords": []}, {"id": 3291, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#how-to-use-iplugincreator", "display_name": "How to Use IPluginCreator", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "how-to-use-iplugincreator", "priority": -1, "content": "To use the new IPluginCreator interface you must implement the interface in an independent custom library. This library must be passed to the Gst-nvinfer plugin through its configuration file by specifying the library\u2019s pathname with the custom-lib-path key. Gst-nvinfer opens the library with dlopen() , which causes the plugin to be registered with TensorRT. There is no further direct interaction between the custom library and Gst-nvinfer. TensorRT calls the custom plugin functions as required. The SSD sample provided with the SDK provides an example of using the IPluginV2 and IPluginCreator interface. This sample has been adapted from TensorRT.", "keywords": []}, {"id": 3292, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#how-to-use-ipluginfactory", "display_name": "How to Use IPluginFactory", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "how-to-use-ipluginfactory", "priority": -1, "content": "To use the IPluginFactory interface, you must implement the interface in an independent custom library. Pass this library to the Gst-nvinfer plugin through the plugin\u2019s configuration file by specifying the library\u2019s pathname in the custom-lib-path key. The custom library must implement the applicable functions: NvDsInferPluginFactoryCaffeGet NvDsInferPluginFactoryCaffeDestroy NvDsInferPluginFactoryUffGet NvDsInferPluginFactoryUffDestroy NvDsInferPluginFactoryRuntimeGet NvDsInferPluginFactoryRuntimeDestroy These structures are defined in nvdsinfer_custom_impl.h . The function definitions must be named as in the header file. Gst-nvinfer opens the custom library with dlopen() and looks for the names.", "keywords": []}, {"id": 3293, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#imodelparser-interface-for-custom-model-parsing", "display_name": "IModelParser Interface for Custom Model Parsing", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "imodelparser-interface-for-custom-model-parsing", "priority": -1, "content": "This is an alternative to the \u201cCUDA Engine Creation\u201d interface for parsing and filling a TensorRT network (INetworkDefinition). The objectDetector_YoloV3 sample application shows an example of the implementation.", "keywords": []}, {"id": 3294, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#input-layer-initialization", "display_name": "Input Layer Initialization", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "input-layer-initialization", "priority": -1, "content": "DeepStream supports initializing non-image input layers for networks having more than one input layer. The layers are initialized only once before the first inference call. The objectDetector_FasterRCNN sample application shows an example of an implementation.", "keywords": []}, {"id": 3295, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "page", "name": "text/DS_using_custom_model#iplugin-implementation", "display_name": "IPlugin Implementation", "type": "section", "display_type": "Page section", "docname": "text/DS_using_custom_model", "anchor": "iplugin-implementation", "priority": -1, "content": "DeepStream supports networks containing layers not supported by TensorRT but supported through implementations of the IPlugin interface. The objectDetector_SSD , objectDetector_FasterRCNN , and objectDetector_YoloV3 sample applications show examples of IPlugin implementations. DeepStream supports NVIDIA\u00ae TensorRT\u2122 plugins for custom layers. The Gst-nvinfer plugin now has support for the IPluginV2 and IPluginCreator interface, introduced in TensorRT 5.0. For caffemodels and for backward compatibility with existing plugins, it also supports the following interfaces: nvinfer1::IPluginFactory nvuffparser::IPluginFactory nvuffparser::IPluginFactoryExt nvcaffeparser1::IPluginFactory nvcaffeparser1::IPluginFactoryExt nvcaffeparser1::IPluginFactoryV2 See the TensorRT documentation for details on new and deprecated plugin interfaces.", "keywords": []}, {"id": 3296, "doc_id": 3296, "filename": "text/DS_using_custom_model.html", "domain_name": "std", "name": "text/DS_using_custom_model", "display_name": "Using a Custom Model with DeepStream", "type": "doc", "display_type": "Page", "docname": "text/DS_using_custom_model", "anchor": "", "priority": -1, "content": "The NVIDIA\u00ae DeepStream SDK on NVIDIA\u00ae Tesla\u00ae or NVIDIA\u00ae Jetson platforms can be customized to support custom neural networks for object detection and classification. You can create your own model. You must specify the applicable configuration parameters in the [property] group of the nvinfer configuration file (for example, config_infer_primary.txt ). The configuration parameters that you must specify include: model-file (Caffe model) proto-file (Caffe model) onnx-file (ONNX models) model-engine-file, if already generated int8-calib-file for INT8 mode mean-file, if required offsets, if required maintain-aspect-ratio, if required parse-bbox-func-name (detectors only) parse-classifier-func-name (classifiers only) custom-lib-path network-type model-color-format process-mode engine-create-func-name infer-dims (UFF models)", "keywords": []}, {"id": 3297, "doc_id": 3298, "filename": "text/DeepStream_Main_Feedback_Form.html", "domain_name": "page", "name": "text/DeepStream_Main_Feedback_Form#request-documentation-fix", "display_name": "Request Documentation Fix", "type": "section", "display_type": "Page section", "docname": "text/DeepStream_Main_Feedback_Form", "anchor": "request-documentation-fix", "priority": -1, "content": "We apologize you found an error in our documentation and thank you in advance for helping us correct it. Below is a form which you can use to pinpoint the problem for us so corrections happen quickly.", "keywords": []}, {"id": 3298, "doc_id": 3298, "filename": "text/DeepStream_Main_Feedback_Form.html", "domain_name": "std", "name": "text/DeepStream_Main_Feedback_Form", "display_name": "Feedback form", "type": "doc", "display_type": "Page", "docname": "text/DeepStream_Main_Feedback_Form", "anchor": "", "priority": -1, "content": "", "keywords": []}, {"id": 3299, "doc_id": 3299, "filename": "text/Extensionmanual_toc.html", "domain_name": "std", "name": "text/Extensionmanual_toc", "display_name": "Extensions", "type": "doc", "display_type": "Page", "docname": "text/Extensionmanual_toc", "anchor": "", "priority": -1, "content": "CudaExtension Components nvidia::gxf::CudaStream nvidia::gxf::CudaStreamId nvidia::gxf::CudaEvent nvidia::gxf::CudaStreamPool nvidia::gxf::CudaStreamSync nvidia::gxf::CudaAllocator nvidia::gxf::StreamOrderedAllocator GXF Stream Sync Signaler Waiter GxfStreamExtension Components nvidia::gxf::GxfStreamSync GXF Stream Sync Workflow At the Signaler codelet At the Waiter Codelet Example Yaml file StandardExtension Interfaces nvidia::gxf::Codelet nvidia::gxf::Clock nvidia::gxf::System nvidia::gxf::Queue nvidia::gxf::Router nvidia::gxf::Transmitter nvidia::gxf::Receiver nvidia::gxf::Scheduler nvidia::gxf::SchedulingTerm nvidia::gxf::Allocator nvidia::gxf::Monitor nvidia::gxf::IPCServer nvidia::gxf::IPCClient nvidia::gxf::ResourceBase nvidia::gxf::Controller Components nvidia::gxf::RealtimeClock nvidia::gxf::ManualClock nvidia::gxf::SyntheticClock nvidia::gxf::SystemGroup nvidia::gxf::MessageRouter nvidia::gxf::NetworkRouter nvidia::gxf::RouterGroup nvidia::gxf::DoubleBufferTransmitter nvidia::gxf::DoubleBufferReceiver nvidia::gxf::Connection nvidia::gxf::PeriodicSchedulingTerm nvidia::gxf::CountSchedulingTerm nvidia::gxf::TargetTimeSchedulingTerm nvidia::gxf::DownstreamReceptiveSchedulingTerm nvidia::gxf::MessageAvailableSchedulingTerm nvidia::gxf::MultiMessageAvailableSchedulingTerm nvidia::gxf::ExpiringMessageAvailableSchedulingTerm nvidia::gxf::BooleanSchedulingTerm nvidia::gxf::BTSchedulingTerm nvidia::gxf::AsynchronousSchedulingTerm nvidia::gxf::MessageAvailableFrequencyThrottler nvidia::gxf::MemoryAvailableSchedulingTerm nvidia::gxf::GraphWorker nvidia::gxf::GraphDriver nvidia::gxf::GreedyScheduler nvidia::gxf::MultiThreadScheduler nvidia::gxf::EpochScheduler nvidia::gxf::EventBasedScheduler nvidia::gxf::BlockMemoryPool nvidia::gxf::UnboundedAllocator nvidia::gxf::ThreadPool nvidia::gxf::GPUDevice nvidia::gxf::CPUThread nvidia::gxf::Forward nvidia::gxf::Topic nvidia::gxf::Tensor nvidia::gxf::Timestamp nvidia::gxf::MultiSourceTimestamp nvidia::gxf::Metric nvidia::gxf::JobStatistics nvidia::gxf::Broadcast nvidia::gxf::Gather nvidia::gxf::TensorCopier nvidia::gxf::TimedThrottler nvidia::gxf::Vault nvidia::gxf::Subgraph nvidia::gxf::EndOfStream nvidia::gxf::Synchronization signed char unsigned char short int short unsigned int int unsigned int long int long unsigned int float double bool Python Bindings Clock Receiver Transmitter PrimitiveType Shape MemoryStorageType Tensor Allocator Python Codelets General Concepts Implenting a Python Codelet Implementing Class Adding Python Codelet to the Graph Accessing Parameters Accessing other Components NetworkExtension Interfaces nvidia::gxf::TcpCodelet Components nvidia::gxf::ClockSyncPrimary nvidia::gxf::ClockSyncSecondary nvidia::gxf::TcpClient nvidia::gxf::TcpServer NvTritonExt Components nvidia::triton::TritonServer nvidia::triton::TritonInferencerInterface nvidia::triton::TritonInferencerImpl nvidia::triton::TritonInferenceRequest nvidia::triton::TritonInferenceResponse nvidia::triton::TritonOptions nvidia::triton::TritonRequestReceptiveSchedulingTerm SerializationExtension Interfaces nvidia::gxf::ComponentSerializer Components nvidia::gxf::EntityRecorder nvidia::gxf::EntityReplayer nvidia::gxf::StdComponentSerializer MultimediaExtension Components nvidia::gxf::AudioBuffer nvidia::gxf::VideoBuffer VideoEncoderExtension Components nvidia::gxf::VideoEncoderRequest nvidia::gxf::VideoEncoderResponse nvidia::gxf::VideoEncoderContext VideoDecoderExtension Components nvidia::gxf::VideoDecoderRequest nvidia::gxf::VideoDecoderResponse nvidia::gxf::VideoDecoderContext Behavior Trees General Concept Behavior Tree Codelets Constant Behavior Parallel Behavior Repeat Behavior Selector Behavior Sequence Behavior Switch Behavior Timer Behavior UCX Extension Description Requirements Components UcxContext UcxTransmitter UcxReceiver UcxComponentSerializer UcxEntitySerializer UcxSerializationBuffer Example HttpExtension Interfaces nvidia::gxf::HttpClient Components nvidia::gxf::HttpServer nvidia::gxf::HttpIPCClient nvidia::gxf::CppRestHttpClient GrpcExtension Interfaces Components nvidia::gxf::GrpcServer nvidia::gxf::GrpcClient TensorRTExtension Components nvidia::gxf::TensorRtInference NvDs3dProcessingExt Components nvidia::deepstream::NvDs3dSrc nvidia::deepstream::NvDs3dSink nvidia::deepstream::NvDs3dFilter nvidia::deepstream::NvDs3dDataDepthInfoLogger nvidia::deepstream::NvDs3dDataColorInfoLogger nvidia::deepstream::NvDs3dDataPointCloudInfoLogger NvDsActionRecognitionExt Components nvidia::deepstream::NvDsActionRecognition2D nvidia::deepstream::NvDsActionRecognition3D NvDsAnalyticsExt Components nvidia::deepstream::NvDsAnalytics NvDsBaseExt Interfaces nvidia::deepstream::INvDsKeyboardInput Components nvidia::deepstream::NvDsStaticOutput nvidia::deepstream::NvDsDynamicOutput nvidia::deepstream::NvDsOnRequestOutput nvidia::deepstream::NvDsStaticInput nvidia::deepstream::NvDsOnRequestInput nvidia::deepstream::NvDsMultiOutput nvidia::deepstream::NvDsProbeConnector nvidia::deepstream::NvDsProbe nvidia::deepstream::NvDsConnection nvidia::deepstream::NvDsMultiSrcConnection nvidia::deepstream::NvDsKeyboardInput nvidia::deepstream::NvDsScheduler nvidia::deepstream::NvDsToGxfBridge nvidia::deepstream::NvGxfToDsBridge nvidia::deepstream::NvDsGxfObjectDataTranslator nvidia::deepstream::NvDsGxfAudioClassificationDataTranslator nvidia::deepstream::NvDsGxfOpticalFlowDataTranslator nvidia::deepstream::NvDsGxfSegmentationDataTranslator nvidia::deepstream::NvDsGxfInferTensorDataTranslator nvidia::deepstream::NvDsQueue nvidia::deepstream::NvDsTee nvidia::deepstream::NvDsBufferSync NvDsCloudMsgExt Components nvidia::deepstream::NvDsMessage nvidia::deepstream::NvDsMsgRelayTransmitter nvidia::deepstream::NvDsMsgRelayReceiver nvidia::deepstream::NvDsMsgBrokerC2DReceiver nvidia::deepstream::NvDsMsgBrokerD2CTransmitter nvidia::deepstream::NvDsMsgRelay nvidia::deepstream::NvDsMsgBroker nvidia::deepstream::NvDsMsgConverter nvidia::deepstream::NvDsMsgConvBroker NvDsConverterExt Components nvidia::deepstream::NvDsVideoConvert nvidia::deepstream::AudioConvert nvidia::deepstream::AudioResample NvDsDewarperExt Components nvidia::deepstream::NvDsAisleFilter nvidia::deepstream::NvDsBBoxFilter nvidia::deepstream::NvDsDewarper nvidia::deepstream::NvDsSpotChangeSignal nvidia::deepstream::NvDsSpot NvDsInferenceExt Components nvidia::deepstream::NvDsModelUpdatedSignal nvidia::deepstream::NvDsInferVideoPropertyController nvidia::deepstream::NvDsInferVideo nvidia::deepstream::NvDsAsr nvidia::deepstream::NvDsInferAudio nvidia::deepstream::NvDsPreProcess NvDsInferenceUtilsExt Components nvidia::deepstream::NvDsKittiDump nvidia::deepstream::NvDsFpsMeasurement nvidia::deepstream::NvDsLatencyMeasurement nvidia::deepstream::NvDsAudioClassificationPrint nvidia::deepstream::NvDsPerClassObjectCounting nvidia::deepstream::NvDsModelEngineWatchOTFTrigger nvidia::deepstream::NvDsRoiClassificationResultParse nvidia::deepstream::NvDsMetaDeserialize nvidia::deepstream::NvDsMetaSerialize NvDsInterfaceExt Interfaces nvidia::deepstream::INvDsElement nvidia::deepstream::INvDsIO nvidia::deepstream::INvDsInput nvidia::deepstream::INvDsOutput nvidia::deepstream::INvDsProbe nvidia::deepstream::INvDsConnection nvidia::deepstream::INvDsComponent nvidia::deepstream::INvDsInPlaceDataHandler nvidia::deepstream::INvDsAction nvidia::deepstream::INvDsSignal nvidia::deepstream::INvDsPropertyController nvidia::deepstream::INvDsAudioTemplatePluginConfigComponent nvidia::deepstream::INvDsVideoTemplatePluginConfigComponent nvidia::deepstream::INvDsInferModelConfigComponent nvidia::deepstream::INvDsGxfDataTranslator Components nvidia::deepstream::NvBufSurfaceHandle nvidia::deepstream::NvBufAudioHandle nvidia::deepstream::NvDsBatchMetaHandle nvidia::deepstream::GstBufferHandle NvDsMuxDemuxExt Components nvidia::deepstream::NvDsStreamDemux nvidia::deepstream::NvDsStreamMux nvidia::deepstream::NvDsStreamDemuxNew nvidia::deepstream::NvDsStreamMuxNew NvDsOpticalFlowExt Components nvidia::deepstream::NvDsOpticalFlow nvidia::deepstream::NvDsOpticalFlowVisual NvDsOutputSinkExt Components nvidia::deepstream::NvDsFakeSink nvidia::deepstream::NvDsFileOut nvidia::deepstream::NvDsVideoRendererPropertyController nvidia::deepstream::NvDsVideoRenderer nvidia::deepstream::NvDsRtspOut nvidia::deepstream::XvImageSink nvidia::deepstream::AlsaAudioRenderer NvDsSampleExt Components nvidia::deepstream::NvDsSampleProbeMessageMetaCreation nvidia::deepstream::NvDsSampleSourceManipulator nvidia::deepstream::NvDsSampleVideoTemplateLib nvidia::deepstream::NvDsSampleAudioTemplateLib nvidia::deepstream::NvDsSampleC2DSmartRecordTrigger nvidia::deepstream::NvDsSampleD2C_SRMsgGenerator NvDsSampleModelsExt Components nvidia::deepstream::NvDsResnet10_4ClassDetectorModel nvidia::deepstream::NvDsSecondaryCarColorClassifierModel nvidia::deepstream::NvDsSecondaryCarMakeClassifierModel nvidia::deepstream::NvDsSecondaryVehicleTypeClassifierModel nvidia::deepstream::NvDsSonyCAudioClassifierModel nvidia::deepstream::NvDsCarDetector360dModel NvDsSourceExt Components nvidia::deepstream::NvDsSourceInfoLoader nvidia::deepstream::NvDsStartSrAction nvidia::deepstream::NvDsStopSrAction nvidia::deepstream::NvDsSrDoneSignal nvidia::deepstream::NvDsSingleSrcInput nvidia::deepstream::NvDsSourceManipulationAction nvidia::deepstream::NvDsMultiSourceSmartRecordAction nvidia::deepstream::NvDsMultiSrcInput nvidia::deepstream::NvDsMultiSrcWarpedInput nvidia::deepstream::NvDsRecordAction nvidia::deepstream::NvDsMultiSrcInputWithRecord nvidia::deepstream::NvDsCameraSrcInput nvidia::deepstream::VideoTestSrc nvidia::deepstream::AudioTestSrc nvidia::deepstream::AlsaAudioInput NvDsTemplateExt Components nvidia::deepstream::NvDsAudioTemplate nvidia::deepstream::NvDsVideoTemplate NvDsTrackerExt Components nvidia::deepstream::NvDsTracker NvDsTranscodeExt Components nvidia::deepstream::NvDsJpegDecoder nvidia::deepstream::NvDsVideoDecoder nvidia::deepstream::NvDsH264Encoder nvidia::deepstream::NvDsH265Encoder NvDsTritonExt Components nvidia::deepstream::NvDsTriton NvDsUcxExt Components nvidia::deepstream::NvDsUcxClientSink nvidia::deepstream::NvDsUcxClientSrc nvidia::deepstream::NvDsUcxServerSink nvidia::deepstream::NvDsUcxServerSrc NvDsUdpExt Components nvidia::deepstream::NvDsUdpSink nvidia::deepstream::NvDsUdpSrc NvDsVisualizationExt Components nvidia::deepstream::NvDsOSDPropertyController nvidia::deepstream::NvDsOSD nvidia::deepstream::NvDsTiler nvidia::deepstream::NvDsSegVisual nvidia::deepstream::NvDsBlender nvidia::deepstream::NvDsTilerEventHandler", "keywords": []}, {"id": 3300, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#codelet-to-deepstream-bridge-nvgxftodsbridge", "display_name": "Codelet to DeepStream Bridge - NvGxfToDsBridge", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "codelet-to-deepstream-bridge-nvgxftodsbridge", "priority": -1, "content": "The NvDsToGxfBridge component is responsible for receiving data from upstream Codelet component, translating it to DeepStream data structures and pushing it to the underlying DeepStream pipeline. It acts as a source component in the DeepStream portion of the graph. Another DeepStream INvDsElement based component must be linked via its out I/O. NvGxfToDsBridge has two receiver handle parameters to receive the data:", "keywords": []}, {"id": 3301, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#correlating-message-entities-receieved-on-frame-rx-and-data-rx", "display_name": "Correlating message entities receieved on frame-rx and data-rx", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "correlating-message-entities-receieved-on-frame-rx-and-data-rx", "priority": -1, "content": "As message entities can be received asynchronously on the two receiver components, the NvGxfToDsBridge component uses acqtime in the native Timestamp component for correlating the two messages. Thus it is mandatory that these messages contain the Timestamp component.", "keywords": []}, {"id": 3302, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#data-rx", "display_name": "data-rx", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "data-rx", "priority": -1, "content": "Receiver for other data. Like the frame data, the message entities pushed on this transmitter will contain data for a single frame. The bridge component uses translator components to translate this data. It calls the translate_gxf_to_ds method of all INvDsGxfDataTranslator based components added to the same entity. It passes the incoming data message entity along with the output DeepStream buffer and metadata structure. The individual translator components translate only those data components in the incoming data message which they understand and update the output DeepStream data structures. Based on the use case, any combination of translators can be added to the bridge entity. It is optional to link Receiver component to data-rx NvGxfToDsBridge pushes data to the DeepStream pipeline as soon as it is received.", "keywords": []}, {"id": 3303, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#data-tx", "display_name": "data-tx", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "data-tx", "priority": -1, "content": "Transmitter for other data. Same as frame data, the message entities pushed on this transmitter will contain data for a single frame. As mentioned earlier, the bridge component uses translator components to translate this data. It calls the translate_ds_to_gxf method of all INvDsGxfDataTranslator based components added to the same entity. It passes the DeepStream buffer and metadata structure along with the output message entity to which all translators must add data components. Based on the use case, any combination of translators can be added to the bridge entity. The contents of the message entity pushed on this transmitter are: Component Name Component Type / Details \u2026 Data components added by translators source-id uint64_t. Same as in frame message entity, useful to corelate frame and data message entities frame-num uint64_t. Same as in frame message entity, useful to corelate frame and data message entities timestamp nvidia::gxf::Timestamp . Timestamp component. It is optional to link Transmitter components to either of the parameters. NvDsToGxfBridge uses the AsynchronousSchedulingTerm for executing the bridge entity as soon as data is available from the DeepStream pipeline.", "keywords": []}, {"id": 3304, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#deepstream-to-codelet-bridge-nvdstogxfbridge", "display_name": "DeepStream to Codelet Bridge - NvDsToGxfBridge", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "deepstream-to-codelet-bridge-nvdstogxfbridge", "priority": -1, "content": "The NvDsToGxfBridge component is responsible for pulling data out of the underlying pipeline, translating it to native data components used by Codelets and pushing it to the downstream Codelet components. It acts as a sink component in the DeepStream portion of the graph. Another DeepStream INvDsElement based component must be linked via it\u2019s in I/O. NvDsToGxfBridge has two transmitter handle parameters which is used to push data:", "keywords": []}, {"id": 3305, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#frame-rx", "display_name": "frame-rx", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "frame-rx", "priority": -1, "content": "Receiver for frame data and related metadata. The bridge component uses zero-copy concept for frame data; frame data is not copied, only representing data structures translated. See the table for frame-tx in the previous section on details of the message entity contents that can be consumed by the bridge. The component can receive nvidia:gxf::EndOfStream messages from upstream Codelet components and push the corresponding events in the DeepStream pipeline. It is mandatory to link Receiver component to frame-rx .", "keywords": []}, {"id": 3306, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#frame-tx", "display_name": "frame-tx", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "frame-tx", "priority": -1, "content": "Transmitter for translated frame data and related metadata. The bridge supports consuming DeepStream\u2019s batched buffer but only translates and pushes a single frame from the batch at a time. The output message entities generated by the NvDsToGxfBridge component will contain data for a single frame, but the bridge will generate N such messages for a single batched DeepStream buffer of size N before moving to the next buffer. The bridge component uses zero-copy concept for frame data; frame data is not copied, only representing data structures translated. The contents of the message entity pushed on this transmitter are: Component Name Component Type / Details Frame nvidia::gxf::VideoBuffer or nvidia::gxf::AudioBuffer or nvidia::gxf::Tensor , depending on type of buffer (video/audio/raw) being translated source-id uint64_t. Unique identifier for the source of the frame in case of a multi-source graph frame-num uint64_t. A sequential number for frame originating from the same source (Video only) pts uint64_t. A 0-offset based timestamp for the frame assigned by the GStreamer pipeline ntp uint64_t. An NTP based timestamp for when the frame was created at the source. See https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_NTP_Timestamp.html for more details. source-frame-width uint64_t. Width of the frame at the source, useful in case the frame has undergone any transformations in the pipeline (Video only) source-frame-height uint64_t. Height of the frame at the source, useful in case the frame has undergone any transformations in the pipeline (Video only) surface-type uint64_t. Surface type of the subframe in a dewarped frame. (Applicable only to dewarped images) surface-index uint64_t. Surface index of the subframe in a dewarped frame. (Applicable only to dewarped images) timestamp nvidia::gxf::Timestamp . Timestamp component. The component informs downstream components about the end-of-Stream by pushing an nvidia::gxf::EndOfStream data component on the frame-tx transmitter. This contains the source-id of the corresponding source, if one among multiple sources reaches EoS. The source-id can also be -1 for complete pipeline EoS.", "keywords": []}, {"id": 3307, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#nvdsgxfaudioclassificationdatatranslator", "display_name": "NvDsGxfAudioClassificationDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "nvdsgxfaudioclassificationdatatranslator", "priority": -1, "content": "Translates DS audio classification data structure ( NvDsAudioFrameMeta/NvDsClassifierMeta ) to Codelet data structure and vice versa. The data components produced or consumed by this translator are: Component Name Component Type / Details audio-classification-&lt;cid&gt; nvidia::gxf::Tensor , shape - (M, 1) , data type - uint64_t . Indexes for the output classes for the current audio frame audio-classification-confidence-&lt;cid&gt; nvidia::gxf::Tensor , shape - (M, 1) , data type - float . Classification probability for the output classes for the current audio frame audio-classification-label-&lt;cid&gt; nvidia::gxf::Tensor , shape - (M, L) , data type - uint8_t . String labels for the output classes for the current audio frame cid - Component ID that generated the meta data M - Number of types of classification supported by the component. &gt; 1 for multi-label classification models L - Maximum length of string label", "keywords": []}, {"id": 3308, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#nvdsgxfinfertensordatatranslator", "display_name": "NvDsGxfInferTensorDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "nvdsgxfinfertensordatatranslator", "priority": -1, "content": "Translates DS infer tensor data structure( NvDsInferTensorMeta ) to Codelet data structure and vice versa. The data components produced or consumed by this translator are: Component Name Component Type / Details infer-tensor-frame-&lt;layer-name&gt; nvidia::gxf::Tensor . Contains data for frame-level raw inference output for layer with name layer name. Shape and data type depends on the model layer shape and data type infer-tensor-object-&lt;layer-name&gt; nvidia::gxf::Tensor . Contains data for object-level raw inference output for layer with name layer name. Shape and data type depends on the model layer shape and data type, shape has an additional highest order dimension of N (number of objects in the frame.", "keywords": []}, {"id": 3309, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#nvdsgxfobjectdatatranslator", "display_name": "NvDsGxfObjectDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "nvdsgxfobjectdatatranslator", "priority": -1, "content": "Translates DS object data structure ( NvDsObjectMeta ) to Codelet data structure and vice versa. The data components produced or consumed by this translator are: Component Name Component Type / Details bbox nvidia::gxf::Tensor , shape - (N, 4) , data type - float . Bounding box co-ordinates for all objects in the frame class-id nvidia::gxf::Tensor , shape - (N, 1) , data type - uint64_t . Class ids for all objects in the frame confidence nvidia::gxf::Tensor , shape - (N, 1) , data type - float . Detection confidence for all objects in the frame. object-id nvidia::gxf::Tensor , shape - (N, 1) , data type - int64_t . Object tracking ids for all objects in the frame. -1 for untracked objects tracker-confidence nvidia::gxf::Tensor , shape - (N, 1) , data type - float . Tracking confidence for all objects in the frame. object-label nvidia::gxf::Tensor , shape - (N, L) , data type - uint8_t . String labels for all objects in the frame. detector-bbox nvidia::gxf::Tensor , shape - (N, 4) , data type - float . Original bounding box co-ordinates generated by detector tracker-bbox nvidia::gxf::Tensor , shape - (N, 4) , data type - float . Original bounding box co-ordinates generated by tracker classification-&lt;cid&gt; nvidia::gxf::Tensor , shape - (N, M, 1) , data type - uint64_t . Indexes for the output classes for all objects in the frame classification-confidence-&lt;cid&gt; nvidia::gxf::Tensor , shape - (N, M, 1) , data type - float . Classification probability for the output classes for all objects in the frame classification-label-&lt;cid&gt; nvidia::gxf::Tensor , shape - (N, M, L) , data type - uint8_t . String labels for the output classes for all objects in the frame instance-segmentation nvidia::gxf::Tensor , shape - (N, rows, cols) , data type - float . Raw instance segmentation outputs for all objects in the frame instance-segmentation-valid nvidia::gxf::Tensor , shape - (N, 1) , data type - uint8_t . Boolean indicating if the instance segmentation mask is valid for the object N - Number of objects in the frame cid - Component ID that generated the meta data M - Number of types of classification supported by the component. &gt; 1 for multi-label classification models L - Maximum length of string label", "keywords": []}, {"id": 3310, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#nvdsgxfopticalflowdatatranslator", "display_name": "NvDsGxfOpticalFlowDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "nvdsgxfopticalflowdatatranslator", "priority": -1, "content": "Translates DS optical flow data structure ( NvDsOpticalFlowMeta ) to Codelet data structure and vice versa. The data components produced or consumed by this translator are: Component Name Component Type / Details motion-vectors nvidia::gxf::Tensor , shape - (rows, columns, 2) . data type - int16_t . contains motion vectors for x and y directions.", "keywords": []}, {"id": 3311, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#nvdsgxfsegmentationdatatranslator", "display_name": "NvDsGxfSegmentationDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "nvdsgxfsegmentationdatatranslator", "priority": -1, "content": "Translates DS segmentation data structure ( NvDsInferSegmentationMeta ) to Codelet data structure and vice versa. The data components produced or consumed by this translator are: Component Name Component Type / Details seg-class-map nvidia::gxf::Tensor , shape - (rows, columns) , data type - int32 . Per-pixel map of class-ids with highest classification probability for that pixel seg-class-probability-matrix nvidia::gxf::Tensor , shape - (rows, columns, classes) , data type - float . Raw segmentation output containing classification probabilities for all pixels for all classes", "keywords": []}, {"id": 3312, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#pts-handling", "display_name": "PTS handling", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "pts-handling", "priority": -1, "content": "It is necessary to assign a proper PTS (Presentation timestamp) to the GStreamer buffers being pushed to the DeepStream pipeline. The NvGxfToDsBridge component uses the following order of preference for assigning the PTS: pts data component if it is part of the message entity received on frame-rx converting native Timestamp component to the GStreamer PTS if it is part of the message entity received on frame-rx Using the current running system time when the message was received to calculate the PTS.", "keywords": []}, {"id": 3313, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#standard-translators", "display_name": "Standard Translators", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "standard-translators", "priority": -1, "content": "DeepStream extensions provide a set of translators for commonly used data types:", "keywords": []}, {"id": 3314, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "page", "name": "text/ExtensionsManual/DSBridge#translators-the-invdsgxfdatatranslator-interface", "display_name": "Translators - The INvDsGxfDataTranslator interface", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/DSBridge", "anchor": "translators-the-invdsgxfdatatranslator-interface", "priority": -1, "content": "The INvDsGxfDataTranslator interface is used as a base class for components that can translate between DeepStream Data Structures for Metadata representation ( NvDsBatchMeta ) and corresponding data components ( nvidia::gxf::Tensor and primitive data types like uint64_t` and `int64_t ). The interface provides the following virtual methods. Concrete implementations must implement these methods. Methods Details gxf_result_t translate_ds_to_gxf( GstBuffer *buffer, NvDsBatchMeta *batch_meta, int frame_idx, nvidia::gxf::Entity message, nvidia::gxf::Handle&lt;nvidia::gxf::Allocator&gt; allocator, nvidia::gxf::MemoryStorageType storage_type) Implementations must translate the input data represented by GstBuffer and NvDsBatchMeta for a single frame having index frame_idx . The translated output data components must be added to the message entity. The supplied Allocator and MemoryStorageType can be used to allocate memory required by the output data components. gxf_result_t translate_gxf_to_ds(nvidia::gxf::Entity message, GstBuffer *buffer, NvDsBatchMeta *batch_meta, int frame_idx) Implementations must translate the input data represented by data components part of the message entity. The translated DeepStream data must be added to the supplied GstBuffer and/or NvDsBatchMeta for the frame having index frame_idx . Implementations must define a clear specification of the type of data components handled, so other components can code against these specifications and consume or produce data based on it. The specification must include the name of the component in the message entity and the component type. In addition if the component type is nvidia::gxf::Tensor , the shape of the tensor, the data type of the tensor contents and storage type of the backing memory must be specified. For example, when translating from DeepStream to Codelet, the NvDsObjectDataTranslator component adds a nvidia::gxf::Tensor component in the output message entity with name bbox , shape (N, 4) where N is the number of objects in the frame, data type of float and storage type of gxf::MemoryStorageType::kSystem . Similarly when translating from Codelet to DeepStream, the NvDsObjectDataTranslator component looks for a bbox named component in the input message entity with data type float and shape of (N, 4) .", "keywords": []}, {"id": 3315, "doc_id": 3315, "filename": "text/ExtensionsManual/DSBridge.html", "domain_name": "std", "name": "text/ExtensionsManual/DSBridge", "display_name": "DeepStream to Codelet Bridge", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/DSBridge", "anchor": "", "priority": -1, "content": "DeepStream extensions provide a few components for interoperability between GStreamer plugin extensions and Codelets. These components called as \u201cbridge\u201d components are responsible for pulling data out of underlying DeepStream GStreamer pipeline and translating the DeepStream data structures representing buffer and metadata into the Codelet data components and vice versa. The bridge components do the task of translating the buffer data between DeepStream and Codelet themselves. For translating other data, the bridge components make use of helper components called \u201ctranslators\u201d that are derived from the INvDsGxfDataTranslator interface. DeepStream extensions provide some translators as listed later for some of the commonly used data structures. You can implement custom data translators from the interface for custom data types without needing changes in any core DeepStream components. You may choose the types of data that must be translated and add the corresponding translator components to the same entity as the bridge component. No explicit links to the bridge component are required. The bridge components are Codelet based components. They require a standard scheduler like GreedyScheduler or MultithreadedScheduler in addition to the NvDsScheduler to be part of the graph. The bridge component execution can be controlled by adding standard scheduling terms to the same entity as the bridge.", "keywords": []}, {"id": 3316, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "id1", "priority": -1, "content": "config-file Custom 3d data renderer configuration file path Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3317, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "id2", "priority": -1, "content": "config-file Custom filter configuration file path Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3318, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "id3", "priority": -1, "content": "dump-file-path File to dump depth information buffer to Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE probe-connector Handle to a nvidia::deepstream::NvDsProbeConnector component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3319, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "id4", "priority": -1, "content": "dump-file-path File to dump color information buffer to Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE probe-connector Handle to a nvidia::deepstream::NvDsProbeConnector component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3320, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "id5", "priority": -1, "content": "dump-file-path File to dump point cloud information buffer to Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE probe-connector Handle to a nvidia::deepstream::NvDsProbeConnector component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3321, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3ddatacolorinfologger", "display_name": "nvidia::deepstream::NvDs3dDataColorInfoLogger", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3ddatacolorinfologger", "priority": -1, "content": "Log color information from 3D data flowing the pipeline Component ID: ca795272-d853-45ad-bb2f-7f3e25b63243 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3322, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3ddatadepthinfologger", "display_name": "nvidia::deepstream::NvDs3dDataDepthInfoLogger", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3ddatadepthinfologger", "priority": -1, "content": "Log depth information from 3D data flowing the pipeline Component ID: 067a4c05-f3e3-41f2-978d-aca497f488fd Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3323, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3ddatapointcloudinfologger", "display_name": "nvidia::deepstream::NvDs3dDataPointCloudInfoLogger", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3ddatapointcloudinfologger", "priority": -1, "content": "Log point cloud information from 3D data flowing the pipeline Component ID: 3c9da518-1fbe-47fa-8fb6-1d9d19800d16 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3324, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3dfilter", "display_name": "nvidia::deepstream::NvDs3dFilter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3dfilter", "priority": -1, "content": "Component for loading and 3D data processing using custom libraries. For more information refer to https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvds3dfilter.html Component ID: ff52ea59-3bb8-3820-b217-4c4cd969f79e Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3325, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3dsink", "display_name": "nvidia::deepstream::NvDs3dSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3dsink", "priority": -1, "content": "Component for rendering 3D data using custom libraries. Acts as a sink element. Component ID: 1ff189fc-071c-42eb-813e-9f1874795a0c Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3326, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#nvidia-deepstream-nvds3dsrc", "display_name": "nvidia::deepstream::NvDs3dSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "nvidia-deepstream-nvds3dsrc", "priority": -1, "content": "Component for loading 3D data using custom libraries. Acts as a source element. Component ID: 865933da-3ea3-4dc6-b8c6-afc3d38a3e9d Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3327, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDs3dProcessingExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "parameters", "priority": -1, "content": "config-file Custom 3d data loader configuration file path Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3328, "doc_id": 3328, "filename": "text/ExtensionsManual/NvDs3dProcessingExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDs3dProcessingExt", "display_name": "NvDs3dProcessingExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDs3dProcessingExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream extension for 3-dimensional data capture, process and rendering UUID: ecded987-983c-4fcd-af14-7f961b059c8e Version: 0.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3329, "doc_id": 3333, "filename": "text/ExtensionsManual/NvDsActionRecognitionExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsActionRecognitionExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsActionRecognitionExt", "anchor": "id1", "priority": -1, "content": "model-engine-file Path to the model engine file. Absolute or relative to the extension directoy. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 2 classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0", "keywords": []}, {"id": 3330, "doc_id": 3333, "filename": "text/ExtensionsManual/NvDsActionRecognitionExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsActionRecognitionExt#nvidia-deepstream-nvdsactionrecognition2d", "display_name": "nvidia::deepstream::NvDsActionRecognition2D", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsActionRecognitionExt", "anchor": "nvidia-deepstream-nvdsactionrecognition2d", "priority": -1, "content": "Configuration for NVIDIA TAO 2D Action Recognition model.Recognizes actions Push, Fall, Walk, Run, Ride Bike. For more information: https://ngc.nvidia.com/catalog/models/nvidia:tao:actionrecognitionnet Model files must be downloaded and extracted to /opt/nvidia/deepstream/deepstream/samples/models/tao_pretrained_models/actionRecognition Component ID: deca38c1-5fcd-40f6-9c2a-95f4d83524ca Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3331, "doc_id": 3333, "filename": "text/ExtensionsManual/NvDsActionRecognitionExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsActionRecognitionExt#nvidia-deepstream-nvdsactionrecognition3d", "display_name": "nvidia::deepstream::NvDsActionRecognition3D", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsActionRecognitionExt", "anchor": "nvidia-deepstream-nvdsactionrecognition3d", "priority": -1, "content": "Configuration for NVIDIA TAO 3D Action Recognition model.Recognizes actions Push, Fall, Walk, Run, Ride Bike. For more information: https://ngc.nvidia.com/catalog/models/nvidia:tao:actionrecognitionnet Model files must be downloaded and extracted to /opt/nvidia/deepstream/deepstream/samples/models/tao_pretrained_models/actionRecognition Component ID: 0ed5a99d-5445-4eeb-823b-3f6a2f77305e Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3332, "doc_id": 3333, "filename": "text/ExtensionsManual/NvDsActionRecognitionExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsActionRecognitionExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsActionRecognitionExt", "anchor": "parameters", "priority": -1, "content": "model-engine-file Path to the model engine file. Absolute or relative to the extension directoy. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 2 classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0", "keywords": []}, {"id": 3333, "doc_id": 3333, "filename": "text/ExtensionsManual/NvDsActionRecognitionExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsActionRecognitionExt", "display_name": "NvDsActionRecognitionExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsActionRecognitionExt", "anchor": "", "priority": -1, "content": "Components for using the NVIDIA TAO Toolkit Action Recognition models UUID: b7259b47-6df1-4774-b55f-ccd71e692c44 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3334, "doc_id": 3336, "filename": "text/ExtensionsManual/NvDsAnalyticsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsAnalyticsExt#nvidia-deepstream-nvdsanalytics", "display_name": "nvidia::deepstream::NvDsAnalytics", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsAnalyticsExt", "anchor": "nvidia-deepstream-nvdsanalytics", "priority": -1, "content": "Process analytics algorithm on objects. Refer to nvdsanalytics plugin Component ID: 684a5fe9-f265-3520-b621-455749501c69 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3335, "doc_id": 3336, "filename": "text/ExtensionsManual/NvDsAnalyticsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsAnalyticsExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsAnalyticsExt", "anchor": "parameters", "priority": -1, "content": "config-file DsAnalytics Config File. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE enable Enable DsAnalytics plugin, or set in passthrough mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True unique-id Unique ID for the element. Can be used to identify output of the element. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 17 video-in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats are video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats are video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3336, "doc_id": 3336, "filename": "text/ExtensionsManual/NvDsAnalyticsExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsAnalyticsExt", "display_name": "NvDsAnalyticsExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsAnalyticsExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream Extension for metadata analytics. UUID: 0aee1c83-fad2-4bba-a25a-b253a8289f13 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3337, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id1", "priority": -1, "content": "source Handle to a source I/O - derived from INvDsOutput . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsOutput source-request-pad-name Pad name to use when requesting a pad from NvDsOnRequestOutput . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING target Handle to a target I/O - derived from INvDsInput . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsInput target-request-pad-name Pad name to use when requesting a pad from NvDsOnRequestInput . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 3338, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id2", "priority": -1, "content": "source Handle to an NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput target Handle to an NvDsOnRequestInput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput", "keywords": []}, {"id": 3339, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id3", "priority": -1, "content": "allocator Handle to a allocator component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Allocator data-storage-type Memory storage type for data components: 0 - kSystem, 1 - kHost Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 data-tx Handle to a Transmitter component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter frame-tx Handle to a Transmitter component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Transmitter in Handle to a NvDsStaticInput component. Supported formats - audio, video Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput measure-perf Enable bridge performance meaurement Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False scheduling-term Handle to a AsynchronousSchedulingTerm component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::AsynchronousSchedulingTerm sync Wether to retreive frames from Gst pipeline synchronously based on frame PTS Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False", "keywords": []}, {"id": 3340, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id4", "priority": -1, "content": "caps GStreamer capabilies to set on the underlying source element. Required when frame data received is not raw audio or video. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING data-rx Handle to a Receiver component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver data-timeout Time in nanoseconds to wait for data message to arrive after frame message is received. -1 to wait indefinitely. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 frame-rx Handle to a Receiver component Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::gxf::Receiver measure-perf Enable bridge performance meaurement Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False out Handle to a NvDsStaticOutput component. Supported formats - audio, video Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput sys-mem-mode When component receives audio/video frames with memory storage, select between translation to (0) - Nv Buffer format, (1) - Pure Gst buffer Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 3341, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id5", "priority": -1, "content": "flush-on-eos Discard all data in the queue when an EOS event is received. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports all formats. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput leaky Determines where the queue leaks, if at all. Valid values: 0: no 1: upstream 2: downstream Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 max-size-buffers Maximum number of buffers in the queue (0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 200 max-size-bytes Maximum amount of data in the queue (bytes, 0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 10485760 max-size-time Maximum amount of data in the queue (in ns, 0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1000000000 min-threshold-buffers Minimum number of buffers in the queue to allow reading (0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 min-threshold-bytes Minimum amount of data in the queue to allow reading (bytes, 0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 min-threshold-time Minimum amount of data in the queue to allow reading (in ns, 0=disable). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput silent Used to silence queue signals. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False", "keywords": []}, {"id": 3342, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id6", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id6", "priority": -1, "content": "allow-not-linked Return GST_FLOW_OK even if there are no source pads or they are all unlinked. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False has-chain Checks if the element can operate in push mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput out-%u Handle to an nvidia::deepstream::NvDsOnRequestOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestOutput pull-mode Behavior of tee in pull mode. Valid values: 0: never 1: single Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 silent Cancels the production of last_message events. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True", "keywords": []}, {"id": 3343, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#id7", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "id7", "priority": -1, "content": "in-%u Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput sync-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3344, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-invdskeyboardinput", "display_name": "nvidia::deepstream::INvDsKeyboardInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-invdskeyboardinput", "priority": -1, "content": "Interface for the keyboard input component. Component ID: 8ab63073-251f-49ba-a48e-fe7f602eec94 Base Type: nvidia::gxf::Component Defined in: nvdsbase/nvds_keyboard_input.hpp", "keywords": []}, {"id": 3345, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsbuffersync", "display_name": "nvidia::deepstream::NvDsBufferSync", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsbuffersync", "priority": -1, "content": "Ensures that processing by upstream components on buffers received on src pad has finished. This is useful in cases where a buffer is provided to multiple elements simultaneously using an element like tee and it must be ensured that the elements have finished processing before pushing it downstream. Component ID: bdb17955-2fb5-3481-9ee3-722d9cffca61 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3346, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsconnection", "display_name": "nvidia::deepstream::NvDsConnection", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsconnection", "priority": -1, "content": "Component that connects two INvDsElement based components. Component ID: f51eee4e-6176-4df7-bc38-aa352df3cbb9 Base Type: nvidia::deepstream::INvDsConnection", "keywords": []}, {"id": 3347, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsdynamicoutput", "display_name": "nvidia::deepstream::NvDsDynamicOutput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsdynamicoutput", "priority": -1, "content": "I/O component for an output that is made dynamically available at runtime by an INvDsElement component. Component ID: cbdcefb0-f6c0-43d6-908b-89ca7fb67d74 Base Type: nvidia::deepstream::INvDsOutput Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3348, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsgxfaudioclassificationdatatranslator", "display_name": "nvidia::deepstream::NvDsGxfAudioClassificationDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsgxfaudioclassificationdatatranslator", "priority": -1, "content": "Translate DS audio classification data structure to GXF data structure and vice versa. Component ID: f7cb57b9-e05f-42c4-bb44-1a2bc6bda6cc Base Type: nvidia::deepstream::INvDsGxfDataTranslator", "keywords": []}, {"id": 3349, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsgxfinfertensordatatranslator", "display_name": "nvidia::deepstream::NvDsGxfInferTensorDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsgxfinfertensordatatranslator", "priority": -1, "content": "Translate DS infer tensor data structure to GXF data structure and vice versa. Component ID: 682a30d1-6fed-4b2a-b97e-b0416f49cf8c Base Type: nvidia::deepstream::INvDsGxfDataTranslator", "keywords": []}, {"id": 3350, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsgxfobjectdatatranslator", "display_name": "nvidia::deepstream::NvDsGxfObjectDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsgxfobjectdatatranslator", "priority": -1, "content": "Translate DS object data structure to GXF data structure and vice versa. Component ID: 2dc0e9d6-722f-4856-872c-2386442eda46 Base Type: nvidia::deepstream::INvDsGxfDataTranslator", "keywords": []}, {"id": 3351, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsgxfopticalflowdatatranslator", "display_name": "nvidia::deepstream::NvDsGxfOpticalFlowDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsgxfopticalflowdatatranslator", "priority": -1, "content": "Translate DS optical flow data structure to GXF data structure and vice versa. Component ID: 35567c7d-a376-42b8-8562-efc2ea85de3d Base Type: nvidia::deepstream::INvDsGxfDataTranslator", "keywords": []}, {"id": 3352, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsgxfsegmentationdatatranslator", "display_name": "nvidia::deepstream::NvDsGxfSegmentationDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsgxfsegmentationdatatranslator", "priority": -1, "content": "Translate DS segmentation data structure to GXF data structure and vice versa. Component ID: bd69f3eb-dc18-46e6-800c-c4c33c85b541 Base Type: nvidia::deepstream::INvDsGxfDataTranslator", "keywords": []}, {"id": 3353, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdskeyboardinput", "display_name": "nvidia::deepstream::NvDsKeyboardInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdskeyboardinput", "priority": -1, "content": "Keyboard input component. Helper component to share keyboard/stdin input between various components. Returns an fd to read input from. Component ID: 266b08bd-bcee-415b-bd99-8f85543d3efc Base Type: nvidia::deepstream::INvDsKeyboardInput", "keywords": []}, {"id": 3354, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsmultioutput", "display_name": "nvidia::deepstream::NvDsMultiOutput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsmultioutput", "priority": -1, "content": "I/O component for an INvDsElement component output that generates data from multiple sources. Component ID: 46365da3-a2c5-472e-9eba-ccf8c9d6d3b5 Base Type: nvidia::deepstream::INvDsIO Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3355, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsmultisrcconnection", "display_name": "nvidia::deepstream::NvDsMultiSrcConnection", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsmultisrcconnection", "priority": -1, "content": "Component that connects INvDsElement based components, that generate output from multiple sources to another aggregator component. Component ID: 4ce04fde-c27a-44a1-b786-63161fb80f74 Base Type: nvidia::deepstream::INvDsConnection", "keywords": []}, {"id": 3356, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsonrequestinput", "display_name": "nvidia::deepstream::NvDsOnRequestInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsonrequestinput", "priority": -1, "content": "I/O component for an input that an INvDsElement component accepts on request. Component ID: fdf605c3-44f3-49cf-a570-3fb53dfe8cee Base Type: nvidia::deepstream::INvDsInput Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3357, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsonrequestoutput", "display_name": "nvidia::deepstream::NvDsOnRequestOutput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsonrequestoutput", "priority": -1, "content": "I/O component for an output that must be requested from an INvDsElement component. Component ID: bb06615e-34c9-4288-8928-5d18a8c796be Base Type: nvidia::deepstream::INvDsOutput Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3358, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsprobe", "display_name": "nvidia::deepstream::NvDsProbe", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsprobe", "priority": -1, "content": "Component for probing an I/O for monitoring and in-place manipulation of data flowing through the I/O. Component ID: 27fb497d-9fba-45c3-a793-ebc3dd7f058f Base Type: nvidia::deepstream::INvDsProbe", "keywords": []}, {"id": 3359, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsprobeconnector", "display_name": "nvidia::deepstream::NvDsProbeConnector", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsprobeconnector", "priority": -1, "content": "Connector component between NvDsProbe and a component implementing the INvDsInPlaceDataHandler interface. Component ID: 2d9c7aad-df5a-4634-a297-4045bdc41370 Base Type: nvidia::gxf::Component Defined in: nvdsbase/nvds_probe_connector.hpp", "keywords": []}, {"id": 3360, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsqueue", "display_name": "nvidia::deepstream::NvDsQueue", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsqueue", "priority": -1, "content": "Simple data queue. Moves the processing of the downstream component to a separate thread. Component ID: 87ad1e4f-1a37-39d0-88f3-6a07adce663a Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3361, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsscheduler", "display_name": "nvidia::deepstream::NvDsScheduler", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsscheduler", "priority": -1, "content": "The DeepStream scheduler responsible for constructing the graph(pipeline) and managing its state and scheduling DeepStream components Component ID: 74f24521-e347-42ce-853b-e429f3d07cb3 Base Type: nvidia::gxf::System", "keywords": []}, {"id": 3362, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsstaticinput", "display_name": "nvidia::deepstream::NvDsStaticInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsstaticinput", "priority": -1, "content": "I/O component for a static (always available) input of an INvDsElement component. Component ID: 9fd570ad-ff14-4621-b661-c1f77ccdef18 Base Type: nvidia::deepstream::INvDsInput Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3363, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdsstaticoutput", "display_name": "nvidia::deepstream::NvDsStaticOutput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdsstaticoutput", "priority": -1, "content": "I/O component for a static (always available) output of an INvDsElement component. Component ID: 58a8c362-bf1d-4bdf-8139-61aa21a44644 Base Type: nvidia::deepstream::INvDsOutput Defined in: nvdsbase/nvds_io.hpp", "keywords": []}, {"id": 3364, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdstee", "display_name": "nvidia::deepstream::NvDsTee", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdstee", "priority": -1, "content": "1-to-N pipe fitting. Component ID: 57c50fad-14af-3e03-bfdc-d60485da7d4e Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3365, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvdstogxfbridge", "display_name": "nvidia::deepstream::NvDsToGxfBridge", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvdstogxfbridge", "priority": -1, "content": "Bridge component that extracts data from the DeepStream pipeline and translates it to GXF data structures. Component ID: e63a7542-862d-443f-b0d5-106f1d16e4b3 Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 3366, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#nvidia-deepstream-nvgxftodsbridge", "display_name": "nvidia::deepstream::NvGxfToDsBridge", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "nvidia-deepstream-nvgxftodsbridge", "priority": -1, "content": "Bridge component that translates GXF data structures to DeepStream buffers and metadata and pushed them to the DeepStream pipeline. Component ID: e9945862-1686-4464-a211-b873f1f8365f Base Type: nvidia::gxf::Codelet", "keywords": []}, {"id": 3367, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsBaseExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "parameters", "priority": -1, "content": "io Handle to a INvDsIO component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsIO probe-connector Handle to a NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3368, "doc_id": 3368, "filename": "text/ExtensionsManual/NvDsBaseExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsBaseExt", "display_name": "NvDsBaseExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsBaseExt", "anchor": "", "priority": -1, "content": "Basic components required to build a DeepStream graph. UUID: 56d7e3ec-62c6-4652-bcc8-4f1c3b00df03 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3369, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "id1", "priority": -1, "content": "cfg-file Path of a configuration file to be passed to the message protocol adapter. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE conn-str Connection string of backend message broker server (e.g. foo.bar.com;80;dsapp1). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING debug Debug flag to print message contents as string. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False proto-lib Path of the message protocol adaptor library implementing the NvDsMsgAPI interface. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE rx Handle to the helper component NvDsMsgRelayReceiver for getting messages pushed by other components. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayReceiver", "keywords": []}, {"id": 3370, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "id2", "priority": -1, "content": "source Handle to an NvDsMsgRelayTransmitter component which will transmit the messages. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayTransmitter target Handle to an NvDsMsgRelayReceiver component which will transmit the messages. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayReceiver", "keywords": []}, {"id": 3371, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "id3", "priority": -1, "content": "async Go asynchronously to PAUSED . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True blocksize Size in bytes to pull per buffer (0 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4096 comp-id By default this element operates on all NvDsPayload type meta. It may be restricted to a specific NvDsPayload meta by this component id. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 config Name of configuration file with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE conn-str connection string of backend server (e.g. foo.bar.com;80;dsapp1). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING enable-last-sample Enable the last-sample property. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput max-bitrate The maximum bits per second to render (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 max-lateness Maximum number of nanoseconds that a buffer can be late by, before it is dropped (-1 unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 new-api Use new libnvds_msgbroker API. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False proto-lib Name of protocol adaptor library with absolute path. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE qos Generate Quality-of-Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False render-delay Additional render delay of the sink in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True throttle-time The time to keep between rendered buffers (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 topic Name of the message topic. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: ts-offset Timestamp offset in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3372, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "id4", "priority": -1, "content": "comp-id By default this element operates on all NvDsEventMsgMeta . It may be restricted to a specific NvDsEventMsgMeta meta by this component id. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 config Name of configuration file with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE debug-payload-dir Absolute path of the directory to dump payloads for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE frame-interval Frame interval at which payload is generated Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 30 in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput msg2p-lib Name of payload generation library with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE msg2p-newapi Use new API which supports publishing multiple payloads using NvDsFrameMeta Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False multiple-payloads Use API which supports receiving multiple payloads from converter lib. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput payload-type Type of payload to be generated. Valid values: 0: PAYLOAD_DEEPSTREAM 1: PAYLOAD_DEEPSTREAM_MINIMAL 256: PAYLOAD_RESERVED 257: PAYLOAD_CUSTOM Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3373, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "id5", "priority": -1, "content": "debug-payload-dir Absolute path of the directory to dump payloads for debugging. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE disable-msgconv Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput msg-broker-comp-id By default this element operates on all NvDsPayload meta. It may be restricted to a specific NvDsPayload meta by this component id. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 msg-broker-config Name of configuration file with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE msg-broker-conn-str connection string of backend server (e.g. foo.bar.com;80;dsapp1). Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING msg-broker-proto-lib Name of protocol adaptor library with absolute path. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE msg-conv-comp-id By default this element operates on all NvDsEventMsgMeta meta. It may be restricted to a specific NvDsEventMsgMeta meta by this component id. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 msg-conv-config Name of configuration file with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE msg-conv-msg2p-lib Name of payload generation library with absolute path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE msg-conv-payload-type Type of payload to be generated. Valid values: 0: PAYLOAD_DEEPSTREAM 1: PAYLOAD_DEEPSTREAM_MINIMAL 256: PAYLOAD_RESERVED 257: PAYLOAD_CUSTOM Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 multiple-payloads Use API which supports receiving multiple payloads from converter lib. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False new-api Use new libnvds_msgbroker API. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True topic Name of the message topic. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 3374, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmessage", "display_name": "nvidia::deepstream::NvDsMessage", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmessage", "priority": -1, "content": "Data component for a cloud message. Consists of the topic for the message and a buffer containing the message contents. Component ID: 45d73bc1-7ffb-43af-b11f-c3202fde0902 Base Type: Defined in: nvdscloudmsg/nvds_message.hpp", "keywords": []}, {"id": 3375, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgbroker", "display_name": "nvidia::deepstream::NvDsMsgBroker", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgbroker", "priority": -1, "content": "Sends payload metadata to the remote server. Refer to nvmsgbroker plugin Component ID: 9e7c325b-7368-39d4-ae5c-b9c245e1342c Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3376, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgbrokerc2dreceiver", "display_name": "nvidia::deepstream::NvDsMsgBrokerC2DReceiver", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgbrokerc2dreceiver", "priority": -1, "content": "Receive messages from cloud via a message broker for the user configured topics using a protocol library implementing the DeepStream messaging interface NvDsMsgApi . Refer to Messaging Interface Component ID: 88ff8361-8045-4457-b257-5f19db143409 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3377, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgbrokerd2ctransmitter", "display_name": "nvidia::deepstream::NvDsMsgBrokerD2CTransmitter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgbrokerd2ctransmitter", "priority": -1, "content": "Send messages to cloud via a message broker using a protocol library implementing the DeepStream messaging interface NvDsMsgApi . Refer to Messaging Interface Component ID: 585ad84e-b5af-4997-b3b3-d2e10d50a2b8 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3378, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgconvbroker", "display_name": "nvidia::deepstream::NvDsMsgConvBroker", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgconvbroker", "priority": -1, "content": "DeepStreamSDK Message Broker Sink Bin. Internal Pipeline: queue-&gt;nvmsgconv-&gt;nvmsgbroker Component ID: 76975c14-1e84-325f-867c-4a291ce310c1 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3379, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgconverter", "display_name": "nvidia::deepstream::NvDsMsgConverter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgconverter", "priority": -1, "content": "Transforms buffer meta to schema or payload meta. Refer to nvmsgconv plugin Component ID: 3e9033bc-e428-3358-bbb6-3455b2a492e8 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3380, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgrelay", "display_name": "nvidia::deepstream::NvDsMsgRelay", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgrelay", "priority": -1, "content": "Component to connect an NvDsMsgRelayTransmitter and an NvDsMsgRelayReceiver component. Component ID: 5a1ea6d3-20f6-4c4a-b480-1a26bd89ef60 Base Type: nvidia::deepstream::INvDsConnection", "keywords": []}, {"id": 3381, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgrelayreceiver", "display_name": "nvidia::deepstream::NvDsMsgRelayReceiver", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgrelayreceiver", "priority": -1, "content": "Helper component to receive message payloads from a transmitter component. This component does not handle the messages. Message consumer components use methods of this component to implement and set a callback for when messages are received. Component ID: 5c6861a2-706e-4311-b4e6-936846415ba3 Base Type: nvidia::deepstream::INvDsComponent Defined in: nvdscloudmsg/nvds_msg_relay_receiver.hpp", "keywords": []}, {"id": 3382, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#nvidia-deepstream-nvdsmsgrelaytransmitter", "display_name": "nvidia::deepstream::NvDsMsgRelayTransmitter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "nvidia-deepstream-nvdsmsgrelaytransmitter", "priority": -1, "content": "Helper component to transmit message payload to a receiver component. This component does not generate any messages. Message producer components use methods of this component to relay messages to consumer components. Component ID: 68568563-6464-41f6-912e-d25038a2c299 Base Type: nvidia::deepstream::INvDsComponent Defined in: nvdscloudmsg/nvds_msg_relay_transmitter.hpp", "keywords": []}, {"id": 3383, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsCloudMsgExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "parameters", "priority": -1, "content": "cfg-file Path of a configuration file to be passed to the message protocol adapter. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE conn-str Connection string of backend message broker server (e.g. foo.bar.com;80;dsapp1). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING debug Debug flag to print message contents as string. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False proto-lib Path of the message protocol adaptor library implementing the NvDsMsgAPI interface. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE topics List of topics that the component should subscribe to. Specified as a semi-colon separated list of strings, for example, topic1;topic2;topic3. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING tx Handle to the helper component NvDsMsgRelayTransmitter for pushing messages to other components. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayTransmitter", "keywords": []}, {"id": 3384, "doc_id": 3384, "filename": "text/ExtensionsManual/NvDsCloudMsgExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsCloudMsgExt", "display_name": "NvDsCloudMsgExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsCloudMsgExt", "anchor": "", "priority": -1, "content": "Components for cloud messaging UUID: d16b1366-dba2-47f6-95fc-b09b39f885de Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3385, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "id1", "priority": -1, "content": "audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput audio-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput dithering Selects between different dithering methods. Valid values: 0: none 1: rpdf 2: tpdf 3: tpdf-hf Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2 noise-shaping Selects between different noise shaping methods. Valid values: 0: none 1: error-feedback 2: simple 3: medium 4: high Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3386, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "id2", "priority": -1, "content": "audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput audio-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput quality Resample quality with 0 being the lowest and 10 being the best. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 4 resample-method What resample method to use Valid values: 0: nearest 1: linear 2: cubic 3: blackman-nuttall 4: kaiser Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 4 sinc-filter-auto-threshold Memory usage threshold to use if sinc filter mode is AUTO, given in bytes. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1048576 sinc-filter-interpolation interpolate the sinc filter table. Valid values: 0: none 1: linear 2: cubic Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2 sinc-filter-mode sinc filter table mode to use. Valid values: 0: interpolated 1: full 2: auto Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2", "keywords": []}, {"id": 3387, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#nvidia-deepstream-audioconvert", "display_name": "nvidia::deepstream::AudioConvert", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "nvidia-deepstream-audioconvert", "priority": -1, "content": "Convert audio to different formats. Gstreamer audioconvert element. Component ID: a9c7471a-9db7-3239-9acf-7ff1a29e250e Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3388, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#nvidia-deepstream-audioresample", "display_name": "nvidia::deepstream::AudioResample", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "nvidia-deepstream-audioresample", "priority": -1, "content": "Resamples audio. Component ID: 87739bfc-dc3c-34ca-a936-4a748506ede0 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3389, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#nvidia-deepstream-nvdsvideoconvert", "display_name": "nvidia::deepstream::NvDsVideoConvert", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "nvidia-deepstream-nvdsvideoconvert", "priority": -1, "content": "Convert and resize the video from one colorspace to another. Refer to nvvideoconvert plugin Component ID: 83b74e7f-6d42-3676-b4ea-7812d0a7c6ed Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3390, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsConverterExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "parameters", "priority": -1, "content": "bl-output Blocklinear output, applicable only for memory:NVMM NV12 format output buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False compute-hw Compute Scaling HW Valid values: 0: Default 1: GPU 2: VIC Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 dest-crop Pixel location left:top:width:height . Use string with values of crop location to set the property. e.g. 20:20:40:50. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: 0:0:0:0 flip-method video flip methods Valid values: 0: none 1: counterclockwise 2: rotate-180 3: clockwise 4: horizontal-flip 5: upper-right-diagonal 6: vertical-flip 7: upper-left-diagonal Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 interpolation-method Set interpolation methods. Valid values: 0: Nearest 1: Bilinear 2: Algo-1 3: Algo-2 4: Algo-3 5: Algo-4 6: Default Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 6 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 output-buffers number of output buffers Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 src-crop Pixel location left:top:width:height . Use string with values of crop location to set the property. e.g. 20:20:40:50. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: 0:0:0:0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR, RGB, BGR, UYVP) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR, RGB, BGR, UYVP) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3391, "doc_id": 3391, "filename": "text/ExtensionsManual/NvDsConverterExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsConverterExt", "display_name": "NvDsConverterExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsConverterExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream extension for converter components. UUID: 7fe1ae48-7bb3-49a8-98fb-142ba07eb273 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3392, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "id1", "priority": -1, "content": "aisle-calibration-file Aisle Camera Calibration File for vertical cylinder projection surfaces. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3393, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "id2", "priority": -1, "content": "config-file Dewarper Config File. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 interpolation-method Set interpolation methods. Valid values: 0: Nearest 1: Bilinear 2: Algo-1 3: Algo-2 4: Algo-3 5: Algo-4 6: Default Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 6 num-batch-buffers Number of Surfaces per output Buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 num-output-buffers Number of Output Buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 source-id Set Source / Camera ID. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR, RGB, BGR, UYVP) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3394, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "id3", "priority": -1, "content": "calibration-file Camera Calibration File for push broom projection surfaces. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE comp-id ID to identify the NvDsEventMsgMeta generated by this element. componentId in NvDsEventMsgMeta will be set to this number. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput max-spot-views-per-frame Set maximum number of spots views Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput spot-change-signal Handle to a NvDsSpotChangeSignal component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSpotChangeSignal wait-threshold Number of seconds to wait before sending the parking spot status change event. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 10", "keywords": []}, {"id": 3395, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#nvidia-deepstream-nvdsaislefilter", "display_name": "nvidia::deepstream::NvDsAisleFilter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "nvidia-deepstream-nvdsaislefilter", "priority": -1, "content": "Gstreamer nvaisle filter element. Component ID: 83cd694a-24e3-351b-a48b-d1ad71773f99 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3396, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#nvidia-deepstream-nvdsbboxfilter", "display_name": "nvidia::deepstream::NvDsBBoxFilter", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "nvidia-deepstream-nvdsbboxfilter", "priority": -1, "content": "Gstreamer NV BBOX Filter Element to filter class objects for given surface for 360d use case. Component ID: 46470fa0-c087-3c36-887e-b0ea069b0b94 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3397, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#nvidia-deepstream-nvdsdewarper", "display_name": "nvidia::deepstream::NvDsDewarper", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "nvidia-deepstream-nvdsdewarper", "priority": -1, "content": "DeepStreamSDK NvDewarper Bin. Internal Pipeline: queue-&gt;nvvidconv-&gt;queue-&gt;nvdewarper . Refer to nvdewarper plugin Component ID: de1ba1d0-fa68-3c22-bec7-6cf9c04f0d6b Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3398, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#nvidia-deepstream-nvdsspot", "display_name": "nvidia::deepstream::NvDsSpot", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "nvidia-deepstream-nvdsspot", "priority": -1, "content": "Gstreamer Element to determine occupied or empty status of parking car for 360d use case. Component ID: e53f132c-6c11-39ed-a82c-ad175dc5c2d9 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3399, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#nvidia-deepstream-nvdsspotchangesignal", "display_name": "nvidia::deepstream::NvDsSpotChangeSignal", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "nvidia-deepstream-nvdsspotchangesignal", "priority": -1, "content": "Signals a change in the occupancy status of a parking spot. This is a connector component. This component must be linked to \u2018 NvDsSpot \u2019 which emits the signal and another component which will handle the signal callback. Component ID: 63fdcd89-1c6d-367a-aae7-492ec6035120 Base Type: nvidia::deepstream::INvDsSignal Defined in: nvdsdewarper/nvdsdewarper_signals.hpp", "keywords": []}, {"id": 3400, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsDewarperExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "parameters", "priority": -1, "content": "aisle-calibration-file Aisle Camera Calibration File. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE comp-id ID to identify the NvDsEventMsgMeta generated by this element. componentId in NvDsEventMsgMeta will be set to this number. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3401, "doc_id": 3401, "filename": "text/ExtensionsManual/NvDsDewarperExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsDewarperExt", "display_name": "NvDsDewarperExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsDewarperExt", "anchor": "", "priority": -1, "content": "Components for 360d applications. UUID: 1c7c145e-a631-4748-953a-bf3e7f92305d Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3402, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "id1", "priority": -1, "content": "audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput audio-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput config-file Set config file path for algo ctx in custom lib. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE create-speech-ctx-func Symbol name to create algo ctx in custom lib. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: creat_asr_ctx customlib-name Set custom library Name to be used. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE Default: libnvds_speech_riva.so", "keywords": []}, {"id": 3403, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "id2", "priority": -1, "content": "audio-framesize Frame size to use for transform. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 audio-hopsize Hop size to use for transform. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S16LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput audio-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S16LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput audio-transform Transform name and parameters. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING batch-size Maximum batch size for inference. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 classifier-type Type of classifier of this instance of nvinfer . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING config-file-path Path to the configuration file for this instance of nvinfer . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE gpu-id Set GPU Device ID Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 infer-model-config Handle to a INvDsInferModelConfigComponent component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsInferModelConfigComponent model-engine-file Absolute path to the pre-generated serialized engine file for the model. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE output-tensor-meta Attach inference tensor outputs as buffer metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False raw-output-file-write Write raw inference output to file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False unique-id Unique ID for the element. Can be used to identify output of the element. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 15", "keywords": []}, {"id": 3404, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "id3", "priority": -1, "content": "unique-id Unique ID for the element. Can be used to identify output of the element Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 15 enable Enable gst-nvdspreprocess plugin, or set in passthrough mode Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True gpu-id Set GPU Device ID Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 config-file Preprocess Config File Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE video-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA, I420) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput video-in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA, I420) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3405, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdsasr", "display_name": "nvidia::deepstream::NvDsAsr", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdsasr", "priority": -1, "content": "Performs automatic speech recognition on input audio. Refer to nvdsasr plugin Component ID: f74d67fc-711e-364b-8a8b-e5a349304d15 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3406, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdsinferaudio", "display_name": "nvidia::deepstream::NvDsInferAudio", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdsinferaudio", "priority": -1, "content": "DeepStreamSDK Audio Inference plugin. Refer to nvinferaudio plugin Component ID: 582e8e1d-197c-32ce-a79e-3630785e9408 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3407, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdsinfervideo", "display_name": "nvidia::deepstream::NvDsInferVideo", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdsinfervideo", "priority": -1, "content": "DeepStreamSDK TensorRT Bin. Internal Pipeline: queue-&gt;nvvidconv-&gt;nvinfer . Component ID: 18e494e2-4c0e-3589-97be-06ece23a7692 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3408, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdsinfervideopropertycontroller", "display_name": "nvidia::deepstream::NvDsInferVideoPropertyController", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdsinfervideopropertycontroller", "priority": -1, "content": "Helper component to control properties of nvidia::deepstream::NvDsInferVideo . This is a connector component. It must be linked to two components: NvDsInferVideo component to control the properties, and another component which will set/get properties via the helper component APIs. Component ID: 6b5f8068-fb7d-301f-ad5a-55fbf81d1b6f Base Type: nvidia::deepstream::INvDsPropertyController Defined in: nvdsinference/nvdsinference_interfaces.hpp", "keywords": []}, {"id": 3409, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdsmodelupdatedsignal", "display_name": "nvidia::deepstream::NvDsModelUpdatedSignal", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdsmodelupdatedsignal", "priority": -1, "content": "Reports the on-the-fly model update status. This is a connector component. This component must be linked to \u2018NvDsInferVideo\u2019 which emits the signal and another component which will handle the signal callback. Component ID: 5b154229-a6ce-342c-8ca6-8f045316a912 Base Type: nvidia::deepstream::INvDsSignal Defined in: nvdsinference/nvdsinference_interfaces.hpp", "keywords": []}, {"id": 3410, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#nvidia-deepstream-nvdspreprocess", "display_name": "nvidia::deepstream::NvDsPreProcess", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "nvidia-deepstream-nvdspreprocess", "priority": -1, "content": "Preprocessing using custom algorithms for different streams. For more information refer to https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_plugin_gst-nvdspreprocess.html Component ID: 2abf4770-e210-3f41-abd6-0555b8ca107f Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3411, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "parameters", "priority": -1, "content": "batch-size Maximum batch size for inference. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 config-file-path Path to the configuration file for this instance of nvinfer . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE filter-out-class-ids Ignore metadata for objects of specified class ids Use string with values of class ids in ClassID (int) to set the property. e.g. 0;2;3. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 infer-model-config Handle to a INvDsInferModelConfigComponent component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsInferModelConfigComponent infer-on-class-ids Operate on objects with specified class ids Use string with values of class ids in ClassID (int) to set the property. e.g. 0:2:3. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING infer-on-gie-id Infer on metadata generated by GIE with this unique ID. Set to -1 to infer on all metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 input-tensor-meta Use preprocessed input tensors attached as metadata instead of preprocessing inside the plugin Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL interval Specifies number of consecutive batches to be skipped for inference. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 model-engine-file Absolute path to the pre-generated serialized engine file for the model. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE model-updated-signal Handle to a NvDsModelUpdatedSignal component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsModelUpdatedSignal output-instance-mask Instance mask expected in network output and attach it to metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False output-tensor-meta Attach inference tensor outputs as buffer metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False process-mode Infer processing mode. Valid values: 1: primary 2: secondary Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 property-controller Property Controller for NvDsInferVideo component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsInferVideoPropertyController raw-output-file-write Write raw inference output to file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False unique-id Unique ID for the element. Can be used to identify output of the element. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 15 video-in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3412, "doc_id": 3412, "filename": "text/ExtensionsManual/NvDsInferenceExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsInferenceExt", "display_name": "NvDsInferenceExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsInferenceExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStreamSDK Streaming Inference components. UUID: 0b02963e-c24e-4c13-ace0-c4cdf36c7c71 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3413, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id1", "priority": -1, "content": "enable Enable FPS measurement. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True interval Interval in seconds to print the FPS values. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 5 print-time Print the current time along with the FPS values. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3414, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id2", "priority": -1, "content": "enable Enable latency measurement. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3415, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id3", "priority": -1, "content": "probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3416, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id4", "priority": -1, "content": "overlay-count Whether to overlay the per class object count on the frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3417, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id5", "priority": -1, "content": "nvdsinfervideo-prop-controller Handle to an NvDsInferVideoPropertyController component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsInferVideoPropertyController watch-file Engine file to watch for updates and trigger on-the-fly model update. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE", "keywords": []}, {"id": 3418, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id6", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id6", "priority": -1, "content": "probe-connector Handle to a nvidia::deepstream::NvDsProbeConnector component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3419, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id7", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id7", "priority": -1, "content": "deserialize-lib Set de-serialization library Name to be used Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING video-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(ANY);audio(ANY) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput video-in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(ANY);audio(ANY) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3420, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#id8", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "id8", "priority": -1, "content": "serialize-lib Set serialization library Name to be used Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING video-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(ANY);audio(ANY) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput video-in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(ANY);audio(ANY) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3421, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsaudioclassificationprint", "display_name": "nvidia::deepstream::NvDsAudioClassificationPrint", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsaudioclassificationprint", "priority": -1, "content": "Sample probe to print audio classification labels. Component ID: 2071b190-5f0a-40fb-a420-5ead5da214a0 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3422, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsfpsmeasurement", "display_name": "nvidia::deepstream::NvDsFpsMeasurement", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsfpsmeasurement", "priority": -1, "content": "Measure per source FPS. Component ID: ec142ba4-724c-4332-aaaf-7e0746e98446 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3423, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdskittidump", "display_name": "nvidia::deepstream::NvDsKittiDump", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdskittidump", "priority": -1, "content": "Store list of objects in a frame to a file in a modified KITTI metadata format. Component ID: 495a66f2-d9ab-4c0a-a8d5-2c4fb3818a7c Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3424, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdslatencymeasurement", "display_name": "nvidia::deepstream::NvDsLatencyMeasurement", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdslatencymeasurement", "priority": -1, "content": "Measure overall pipeline and per component latency. Requires exporting environment variable NVDS_ENABLE_LATENCY_MEASUREMENT=1 . Additionally to for per-component latency export NVDS_ENABLE_COMPONENT_LATENCY_MEASUREMENT=1 . Component ID: 43d4a2b8-7892-4e10-ae5d-fc15cbb54cd5 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3425, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsmetadeserialize", "display_name": "nvidia::deepstream::NvDsMetaDeserialize", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsmetadeserialize", "priority": -1, "content": "Component to deserialize DeepStream metadata and attach to buffer Component ID: fd3771a8-e342-3ac2-a28b-ab92f25b58c9 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3426, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsmetaserialize", "display_name": "nvidia::deepstream::NvDsMetaSerialize", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsmetaserialize", "priority": -1, "content": "Component to serialize DeepStream metadata attached to a buffer Component ID: 9b9181cd-8b6d-3dac-bd7d-aac21fe993da Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3427, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsmodelenginewatchotftrigger", "display_name": "nvidia::deepstream::NvDsModelEngineWatchOTFTrigger", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsmodelenginewatchotftrigger", "priority": -1, "content": "Watch a model engine file for updates and trigger on-the-fly model update on a NvDsInferVideo component. Component ID: d64b11b7-97cf-4de4-a2ac-772da9295008 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3428, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsperclassobjectcounting", "display_name": "nvidia::deepstream::NvDsPerClassObjectCounting", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsperclassobjectcounting", "priority": -1, "content": "Count and print number of objects per class in the current batch. Component ID: 5dc37884-ea36-4bf2-810c-f7b7821090a5 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3429, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#nvidia-deepstream-nvdsroiclassificationresultparse", "display_name": "nvidia::deepstream::NvDsRoiClassificationResultParse", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "nvidia-deepstream-nvdsroiclassificationresultparse", "priority": -1, "content": "Parse classification results for an ROI and attach as OSD text Component ID: 86d9071a-bbe8-4c1a-a721-353cc83610b6 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3430, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "parameters", "priority": -1, "content": "output-dir Directory to write kitti data to. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3431, "doc_id": 3431, "filename": "text/ExtensionsManual/NvDsInferenceUtilsExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsInferenceUtilsExt", "display_name": "NvDsInferenceUtilsExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsInferenceUtilsExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStreamSDK Streaming Inference components. UUID: 27856a43-5ad4-4d8e-be36-0ec2cf9bbb58 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3432, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-gstbufferhandle", "display_name": "nvidia::deepstream::GstBufferHandle", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-gstbufferhandle", "priority": -1, "content": "A component which holds a single GstBuffer instance. Component ID: 0e82cbb4-3a5a-4d40-b490-9c096bf93258 Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3433, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsaction", "display_name": "nvidia::deepstream::INvDsAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsaction", "priority": -1, "content": "Interface for implementing an action component. Actions are triggers sent to elements to take associated action. Component ID: 371d1e46-b28f-42aa-829d-6fe4c7c81c51 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3434, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsaudiotemplatepluginconfigcomponent", "display_name": "nvidia::deepstream::INvDsAudioTemplatePluginConfigComponent", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsaudiotemplatepluginconfigcomponent", "priority": -1, "content": "Base type for describing a audio template plugin based component configuration. Component ID: 56a198dd-c262-44fb-b6e9-7bcfc670b84a Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3435, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdscomponent", "display_name": "nvidia::deepstream::INvDsComponent", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdscomponent", "priority": -1, "content": "Interface for implementing a custom DeepStream domain component. Component ID: 8d187c25-b7b5-4879-8a45-a16febe3bd89 Base Type: nvidia::gxf::Component Defined in: interfaces.hpp", "keywords": []}, {"id": 3436, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsconnection", "display_name": "nvidia::deepstream::INvDsConnection", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsconnection", "priority": -1, "content": "Interface for representing a connection between INvDsElement based components. Component ID: dcdbda55-80da-4a85-82fd-13c05989602a Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3437, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdselement", "display_name": "nvidia::deepstream::INvDsElement", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdselement", "priority": -1, "content": "Interface for GStreamer element based components. Component ID: 64f21ab3-ad97-4986-9a0e-a0d7571d64e4 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3438, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsgxfdatatranslator", "display_name": "nvidia::deepstream::INvDsGxfDataTranslator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsgxfdatatranslator", "priority": -1, "content": "Base type for components that can translate between DeepStream data structures and GXF data structures. Component ID: c02f4266-b517-4f65-ad87-46da8bb84504 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3439, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsinfermodelconfigcomponent", "display_name": "nvidia::deepstream::INvDsInferModelConfigComponent", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsinfermodelconfigcomponent", "priority": -1, "content": "Base type for describing a nvinfer model configuration. Component ID: 6027cf23-16f9-41ad-8a98-2ecf0c6ecd07 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3440, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsinplacedatahandler", "display_name": "nvidia::deepstream::INvDsInPlaceDataHandler", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsinplacedatahandler", "priority": -1, "content": "Interface for component handling callbacks from a probe. Component ID: c2a2cc07-ceb7-4e5f-b49a-0f0de584be6b Base Type: nvidia::deepstream::INvDsComponent Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3441, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsinput", "display_name": "nvidia::deepstream::INvDsInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsinput", "priority": -1, "content": "INvDsElement I/O interface for inputs. Component ID: c892a4ab-5344-4927-b1c3-86af5097b2c9 Base Type: nvidia::deepstream::INvDsIO Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3442, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsio", "display_name": "nvidia::deepstream::INvDsIO", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsio", "priority": -1, "content": "INvDsElement I/O(input/output) interface. Component ID: e1655a8e-5bc7-471d-a7cd-2756a5bfce91 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3443, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsoutput", "display_name": "nvidia::deepstream::INvDsOutput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsoutput", "priority": -1, "content": "INvDsElement I/O interface for outputs. Component ID: bc6daf3f-35f0-41cc-9022-e589b580b795 Base Type: nvidia::deepstream::INvDsIO Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3444, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsprobe", "display_name": "nvidia::deepstream::INvDsProbe", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsprobe", "priority": -1, "content": "DeepStream probe interface for monitoring and manipulation of data flowing through an I/O. Component ID: ac67b50b-5b28-46d6-9d3b-fc2f60697de6 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3445, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdspropertycontroller", "display_name": "nvidia::deepstream::INvDsPropertyController", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdspropertycontroller", "priority": -1, "content": "Interface for implementing a property controller from INvDsElement based components. Component ID: 118ac2fd-2baf-4e90-b9f3-98a534146d19 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3446, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdssignal", "display_name": "nvidia::deepstream::INvDsSignal", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdssignal", "priority": -1, "content": "Interface for implementing a signal component. Signals are callbacks from elements when associated events occur. Component ID: 8e49046e-ac94-4d3d-9eb0-530ccce1ad49 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3447, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-invdsvideotemplatepluginconfigcomponent", "display_name": "nvidia::deepstream::INvDsVideoTemplatePluginConfigComponent", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-invdsvideotemplatepluginconfigcomponent", "priority": -1, "content": "Base type for describing a video template plugin based component configuration. Component ID: 45cfc84a-efdb-47b4-bafc-0884121aeea7 Base Type: nvidia::gxf::Component Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3448, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-nvbufaudiohandle", "display_name": "nvidia::deepstream::NvBufAudioHandle", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-nvbufaudiohandle", "priority": -1, "content": "A component which holds a single NvBufAudio instance. Component ID: 7fb0686d-59e6-4ba1-b6f7-91119766e4eb Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3449, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-nvbufsurfacehandle", "display_name": "nvidia::deepstream::NvBufSurfaceHandle", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-nvbufsurfacehandle", "priority": -1, "content": "A component which holds a single NvBufSurface instance. Component ID: 22d06d65-f316-4e61-b4cf-40547b15f5f3 Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3450, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsInterfaceExt#nvidia-deepstream-nvdsbatchmetahandle", "display_name": "nvidia::deepstream::NvDsBatchMetaHandle", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "nvidia-deepstream-nvdsbatchmetahandle", "priority": -1, "content": "A component which holds a single NvDsBatchMeta instance. Component ID: 81ff6895-b744-4465-a089-0414e13c1c3c Defined in: nvdsinterface/interfaces.hpp", "keywords": []}, {"id": 3451, "doc_id": 3451, "filename": "text/ExtensionsManual/NvDsInterfaceExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsInterfaceExt", "display_name": "NvDsInterfaceExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsInterfaceExt", "anchor": "", "priority": -1, "content": "Interfaces and data components for DeepStream. UUID: f787f50d-9004-4e85-88b9-1ed1894257f2 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3452, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "id1", "priority": -1, "content": "attach-sys-ts If set to TRUE , system timestamp will be attached as ntp timestamp. If set to FALSE, ntp timestamp from rtspsrc , if available, will be attached. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True batch-size Maximum number of buffers in a batch. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 batched-push-timeout Timeout in microseconds to wait after the first buffer is available to push the batch even if the complete batch is not formed. Set to -1 to wait infinitely. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 40000 buffer-pool-size Maximum number of buffers in muxer\u2019s internal pool. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 compute-hw Compute Scaling HW. Valid values: 0: Default 1: GPU 2: VIC Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 enable-padding Maintain input aspect ratio when scaling by padding with black bands. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False frame-num-reset-on-eos Reset frame numbers to 0 for a source from which EOS is received (For debugging purpose only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 height Height of each frame in output batched buffer. This property MUST be set. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 interpolation-method Set interpolation methods. Valid values: 0: Nearest 1: Bilinear 2: Algo-1 3: Algo-2 4: Algo-3 5: Algo-4 6: Default Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 live-source Boolean property to inform muxer that sources are live. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False max-latency Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 num-surfaces-per-frame Max number of surfaces per frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 sync-inputs Boolean property to force synchronization of input frames. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False video-in-%u Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supported formats - video(NV12, RGBA, I420) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA, I420) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput width Width of each frame in output batched buffer. This property MUST be set. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 3453, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "id2", "priority": -1, "content": "in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA);audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput out-%u Handle to an nvidia::deepstream::NvDsOnRequestOutput component. Supported formats - video(NV12, RGBA);audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestOutput", "keywords": []}, {"id": 3454, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "id3", "priority": -1, "content": "attach-sys-ts If set to TRUE , system timestamp will be attached as ntp timestamp. If set to FALSE , ntp timestamp from rtspsrc , if available, will be attached. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True batch-size Maximum number of buffers in a batch Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 config-file-path Path to the configuration file for this instance of nvinfer . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE frame-num-reset-on-eos Reset frame numbers to 0 for a source from which EOS is received (For debugging purpose only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL in-%u Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supported formats - video(NV12, RGBA);audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput max-latency Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 num-surfaces-per-frame Number of Surfaces in a frame Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA);audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput sync-inputs Boolean property to force synchronization of input frames. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False", "keywords": []}, {"id": 3455, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#nvidia-deepstream-nvdsstreamdemux", "display_name": "nvidia::deepstream::NvDsStreamDemux", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "nvidia-deepstream-nvdsstreamdemux", "priority": -1, "content": "1-to-N pipes stream demultiplexing. Only one of legacy or new implementations can be included in a graph. Refer to nvstreamdemux plugin Component ID: 9458d06a-048d-3a0d-9c52-5666b374090e Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3456, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#nvidia-deepstream-nvdsstreamdemuxnew", "display_name": "nvidia::deepstream::NvDsStreamDemuxNew", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "nvidia-deepstream-nvdsstreamdemuxnew", "priority": -1, "content": "1-to-N pipes stream demultiplexing. New implementation. Supports audio. Only one of legacy or new implementations can be included in a graph. Component ID: 660c26a1-743f-4754-a016-bf1dc50638e9 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3457, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#nvidia-deepstream-nvdsstreammux", "display_name": "nvidia::deepstream::NvDsStreamMux", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "nvidia-deepstream-nvdsstreammux", "priority": -1, "content": "N-to-1 pipe stream multiplexing. Only one of legacy or new implementations can be included in a graph. Refer to nvstreammux plugin Component ID: 5112ed9a-11c5-3443-b017-f33ba8dc46f8 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3458, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#nvidia-deepstream-nvdsstreammuxnew", "display_name": "nvidia::deepstream::NvDsStreamMuxNew", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "nvidia-deepstream-nvdsstreammuxnew", "priority": -1, "content": "N-to-1 pipe stream multiplexing. New implementation. Supports audio. Only one of legacy or new implementations can be included in a graph. Refer to nvstreammux new plugin Component ID: ccf04e18-454b-4d41-9380-e9186fa5ed7c Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3459, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsMuxDemuxExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "parameters", "priority": -1, "content": "video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA, I420) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out-%u Handle to an nvidia::deepstream::NvDsOnRequestOutput component. Supported formats - video(NV12, RGBA, I420) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestOutput", "keywords": []}, {"id": 3460, "doc_id": 3460, "filename": "text/ExtensionsManual/NvDsMuxDemuxExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsMuxDemuxExt", "display_name": "NvDsMuxDemuxExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsMuxDemuxExt", "anchor": "", "priority": -1, "content": "NVIDIA Multistream mux/demux plugin. UUID: 89b8398c-5820-4051-835c-a91f2d49766b Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3461, "doc_id": 3465, "filename": "text/ExtensionsManual/NvDsOpticalFlowExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOpticalFlowExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOpticalFlowExt", "anchor": "id1", "priority": -1, "content": "gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3462, "doc_id": 3465, "filename": "text/ExtensionsManual/NvDsOpticalFlowExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOpticalFlowExt#nvidia-deepstream-nvdsopticalflow", "display_name": "nvidia::deepstream::NvDsOpticalFlow", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOpticalFlowExt", "anchor": "nvidia-deepstream-nvdsopticalflow", "priority": -1, "content": "Gstreamer NV Optical Flow Plugin. Refer to nvof plugin Component ID: 6666f63f-219c-347f-b5a6-b944e329dc10 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3463, "doc_id": 3465, "filename": "text/ExtensionsManual/NvDsOpticalFlowExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOpticalFlowExt#nvidia-deepstream-nvdsopticalflowvisual", "display_name": "nvidia::deepstream::NvDsOpticalFlowVisual", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOpticalFlowExt", "anchor": "nvidia-deepstream-nvdsopticalflowvisual", "priority": -1, "content": "Gstreamer NV Optical Flow Visualization Plugin. Refer to nvofvisual plugin Component ID: ab8b128c-98fe-3621-84f7-c8b26fa4736d Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3464, "doc_id": 3465, "filename": "text/ExtensionsManual/NvDsOpticalFlowExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOpticalFlowExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOpticalFlowExt", "anchor": "parameters", "priority": -1, "content": "dump-of-meta Dump Optical Flow Meta. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 grid-size Type of Grid Size. Valid values: 0: NVOF_GRID_SIZE_4x4 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 pool-size Size of optical flow memory pool. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 7 preset-level Type of Preset Levels. Valid values: 0: NV_OF_PERF_LEVEL_FAST 1: NV_OF_PERF_LEVEL_MEDIUM 2: NV_OF_PERF_LEVEL_SLOW Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 qos Handle Quality-of-Service events. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3465, "doc_id": 3465, "filename": "text/ExtensionsManual/NvDsOpticalFlowExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsOpticalFlowExt", "display_name": "NvDsOpticalFlowExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsOpticalFlowExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream OpticalFlow components. UUID: 814ef803-7b37-4a3d-8b95-5fc483824712 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3466, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "id1", "priority": -1, "content": "bitrate Encoding bitrate in bits/sec. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 codec Type of codec to use. Valid values: 1: h264 2: h265 3: mpeg4 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 container Type of container to use. Valid values: 1: mp4 2: mkv Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 enc-type Type of encoder to use. Valid values: 0: hw 1: sw Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 iframeinterval Encoding Intra Frame occurrence frequency (H/W encoder only). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 output-file Type of Video sink to use. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE profile Encoder profile to use. Valid values: 0: baseline 1: main 2: high 3: main10 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 qos Generate Quality - of - Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR, RGB, BGR, UYVP) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3467, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "id2", "priority": -1, "content": "color-range Sets color range only when set-mode=1 (Valid for nvdrmvideosink) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 conn-id Connection Index (Valid for nvdrmvideosink) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 height Renderer height. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 offset-x Renderer horizontal offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 offset-y Renderer vertical offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 plane-id Plane on which video should be rendered (Valid for nvdrmvideosink) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 prop-controller Property Controller for NvDsVideoRenderer component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsVideoRendererPropertyController qos Generate Quality - of - Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False set-mode Select default or mode of Video Stream (Valid for nvdrmvideosink) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-sink Type of Video sink to use. Valid values: 1: fake 2: egl 3: overlay Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2 width Renderer width. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3468, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "id3", "priority": -1, "content": "audio-in Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput bitrate Encoding bitrate in bits/sec. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 codec Type of codec to use. Valid values: 1: h264 2: h265 3: mpeg4 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 enc-type Type of encoder to use. Valid values: 0: hw 1: sw Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 iframeinterval Encoding Intra Frame occurrence frequency (H/W encoder only). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 30 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 output-file Type of Video sink to use. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE profile Encoder profile to use. Valid values: 0: baseline 1: main 2: high 3: main10 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 qos Generate Quality - of - Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False rtsp-port Port on which the RTSP server would listen. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 8554 sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True video-in Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, YUY2, UYVY, YVYU, Y42B) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput", "keywords": []}, {"id": 3469, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "id4", "priority": -1, "content": "async Go asynchronously to PAUSED . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True autopaint-colorkey Autofill overlay with colorkey . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True blocksize Size in bytes to pull per buffer (0 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4096 brightness The brightness of the video. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 colorkey Color to use for the overlay mask. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 526352 contrast The contrast of the video. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 device The number of the video adaptor. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: 0 display X Display name. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING double-buffer Double-buffer the output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False draw-borders Draw black borders to fill unused area in force-aspect-ratio mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True enable-last-sample Enable the last-sample property. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True force-aspect-ratio When enabled, scaling will respect original aspect ratio. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True handle-events When enabled, XEvents will be selected and handled. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True handle-expose When enabled, the current frame will always be drawn in response to X Expose events. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True hue The hue of the video. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput max-bitrate The maximum bits per second to render (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 5000000 pixel-aspect-ratio The pixel aspect ratio of the device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING processing-deadline Maximum processing deadline in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 15000000 qos Generate Quality-of-Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True render-delay Additional render delay of the sink in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 saturation The saturation of the video. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 show-preroll-frame Whether to render video frames during pre-roll. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True synchronous When enabled, runs the X display in synchronous mode. (unrelated to A/V sync, used only for debugging). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False throttle-time The time to keep between rendered buffers (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 ts-offset Timestamp offset in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3470, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "id5", "priority": -1, "content": "alignment-threshold Timestamp alignment threshold in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 40000000 async Go asynchronously to PAUSED. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE, ac3, eac3, dts) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput blocksize Size in bytes to pull per buffer (0 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4096 buffer-time Size of audio buffer in microseconds, this is the minimum latency that the sink reports. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 200000 can-activate-pull Allow pull-based scheduling. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False device ALSA device, as defined in an asound configuration file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: default discont-wait Window of time in nanoseconds to wait before creating a discontinuity. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1000000000 drift-tolerance Tolerance for clock drift in microseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 40000 enable-last-sample Enable the last-sample property. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False latency-time The minimum amount of data to write in each iteration in microseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 10000 max-bitrate The maximum bits per second to render (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 processing-deadline Maximum processing deadline in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 20000000 provide-clock Provide a clock to be used as the global pipeline clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True qos Generate Quality-of-Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False render-delay Additional render delay of the sink in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 slave-method Algorithm used to match the rate of the master clock. Valid values: 0: resample 1: skew 2: none 3: custom Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True throttle-time The time to keep between rendered buffers (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 ts-offset Timestamp offset in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3471, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-alsaaudiorenderer", "display_name": "nvidia::deepstream::AlsaAudioRenderer", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-alsaaudiorenderer", "priority": -1, "content": "Output to a sound card via ALSA. Component ID: c29cf282-989b-31d0-a347-c1a1f305627c Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3472, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-nvdsfakesink", "display_name": "nvidia::deepstream::NvDsFakeSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-nvdsfakesink", "priority": -1, "content": "Black hole for data. Component ID: 58271e37-3a3e-3fba-b083-d1a5f09a3686 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3473, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-nvdsfileout", "display_name": "nvidia::deepstream::NvDsFileOut", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-nvdsfileout", "priority": -1, "content": "DeepStreamSDK Video Sinks Bin. Internal Pipeline: queue-&gt;nvvideoconvert-&gt;encoder-&gt;codecparse-&gt;mux-&gt;filesink . Component ID: f6d82647-03d8-3d74-a17e-a3ee8f1eb9a3 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3474, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-nvdsrtspout", "display_name": "nvidia::deepstream::NvDsRtspOut", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-nvdsrtspout", "priority": -1, "content": "Nvidia DeepStreamSDK RTSP Sink Bin. Internal Pipeline: queue-&gt;nvvideoconvert-&gt;encoder-&gt;codecparse-&gt;rtppay-&gt;udpsink . Component ID: 938afedb-02e6-39de-a513-43da57f1ad09 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3475, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-nvdsvideorenderer", "display_name": "nvidia::deepstream::NvDsVideoRenderer", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-nvdsvideorenderer", "priority": -1, "content": "DeepStreamSDK Video Sinks Bin. Internal Pipeline: queue-&gt;nvvideoconvert-&gt;renderer . Component ID: 3370346e-c770-3de9-9adf-c7fdf0f25c0f Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3476, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-nvdsvideorendererpropertycontroller", "display_name": "nvidia::deepstream::NvDsVideoRendererPropertyController", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-nvdsvideorendererpropertycontroller", "priority": -1, "content": "Helper component to control properties of nvidia::deepstream::NvDsVideoRendererPropertyController . This is a connector component. It must be linked to two components - An NvDsVideoRendererPropertyController component to control properties and another component which will set/get properties via the helper component APIs. Component ID: 7df81ee0-72db-43f9-ba31-f51e9fe2c2d1 Base Type: nvidia::deepstream::INvDsPropertyController Defined in: @@@@@@@@@@", "keywords": []}, {"id": 3477, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#nvidia-deepstream-xvimagesink", "display_name": "nvidia::deepstream::XvImageSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "nvidia-deepstream-xvimagesink", "priority": -1, "content": "A Xv based videosink. Component ID: bce7ec3f-7c68-32bc-a45f-de6bdd570969 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3478, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsOutputSinkExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "parameters", "priority": -1, "content": "async Go asynchronously to PAUSED . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True blocksize Size in bytes to pull per buffer (0 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4096 can-activate-pull Can activate in pull mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False can-activate-push Can activate in push mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True drop-out-of-segment Drop and don\u2019t render / hand off out-of-segment buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True dump Dump buffer contents to stdout . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False enable-last-sample Enable the last-sample property. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True in Handle to an nvidia::deepstream::NvDsStaticInput component. Supports any format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput max-bitrate The maximum bits per second to render (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 num-buffers Number of buffers to accept going EOS. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 qos Generate Quality-of-Service events upstream. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False render-delay Additional render delay of the sink in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 signal-handoffs Send a signal before un-reffing the buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False silent Don\u2019t produce last_message events. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True state-error Generate a state change error. Valid values: 0: none 1: null-to-ready 2: ready-to-paused 3: paused-to-playing 4: playing-to-paused 5: paused-to-ready 6: ready-to-null Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 sync Sync on the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False throttle-time The time to keep between rendered buffers (0 = disabled). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 ts-offset Timestamp offset in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3479, "doc_id": 3479, "filename": "text/ExtensionsManual/NvDsOutputSinkExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsOutputSinkExt", "display_name": "NvDsOutputSinkExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsOutputSinkExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream sink and output related components. UUID: 3fc9ad87-03e7-47a8-bbfc-8501c3f7ff2f Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3480, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "id1", "priority": -1, "content": "interval-sec Interval in seconds at which the sources will be added/removed. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 10 max-num-sources Maximum number of sources to add to the NvDsMultiSrcInput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4 source-manip-action Handle to an nvidia::deepstream::NvDsSourceManipulationAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceManipulationAction uri URI to add. Same URI will be added multiple times. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 3481, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "id2", "priority": -1, "content": "scale-factor Video frame scaling factor Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 1.0", "keywords": []}, {"id": 3482, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "id3", "priority": -1, "content": "noise-factor Noise to add to the input audio. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 1.0", "keywords": []}, {"id": 3483, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "id4", "priority": -1, "content": "msg-rx Handle to a NvDsMsgRelayReceiver component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayReceiver msgconv-config Path to a NvDsMsgConv config file containing the sensor information. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE smart-record-action Handle to a NvDsMultiSourceSmartRecordAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiSourceSmartRecordAction smart-record-done-signal Handle to a NvDsSrDoneSignal component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSrDoneSignal", "keywords": []}, {"id": 3484, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "id5", "priority": -1, "content": "msg-tx Handle to a NvDsMsgRelayTransmitter component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMsgRelayTransmitter msgconv-config Path to a NvDsMsgConv config file containing the sensor information. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE topic Topic to send the messages on. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING", "keywords": []}, {"id": 3485, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssampleaudiotemplatelib", "display_name": "nvidia::deepstream::NvDsSampleAudioTemplateLib", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssampleaudiotemplatelib", "priority": -1, "content": "Sample component demonstrating usage of DeepStream\u2019s audio template plugin configuration component. The sample component adds noise to the input audio. Component ID: 69571eda-411a-4de6-8ca0-ad5bd2c29353 Base Type: nvidia::deepstream::INvDsAudioTemplatePluginConfigComponent", "keywords": []}, {"id": 3486, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssamplec2dsmartrecordtrigger", "display_name": "nvidia::deepstream::NvDsSampleC2DSmartRecordTrigger", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssamplec2dsmartrecordtrigger", "priority": -1, "content": "Sample component for demonstrating cloud to device(C2D) communication and handling C2D messages. This component triggers smart record start/stop action on the NvDsMultiUriSrcInput component. Expected JSON schema for the messages: { ....command:string, // &lt;start-recording / stop-recording&gt; ....start: string, // &quot;2020-05-18T20:02:00.051Z&quot; ....end: string, // &quot;2020-05-18T20:02:02.851Z&quot; ....sensor: { ........id: string // sensor name in msgconv config ....} } Component ID: 5f358981-6081-44c4-a1c0-017ac49a7215 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3487, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssampled2c-srmsggenerator", "display_name": "nvidia::deepstream::NvDsSampleD2C_SRMsgGenerator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssampled2c-srmsggenerator", "priority": -1, "content": "Sample component for demonstrating device to cloud(C2D). This component generates JSON messages which can be consumed by NvDsSampleC2DSmartRecordTrigger component to trigger smart record start/stop. Component ID: e6dcc34b-542b-4680-8d61-72a2cfc5e1de Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3488, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssampleprobemessagemetacreation", "display_name": "nvidia::deepstream::NvDsSampleProbeMessageMetaCreation", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssampleprobemessagemetacreation", "priority": -1, "content": "Sample probe handler demonstrating creation of NvDsEventMsgMeta for sending messages to cloud. * This is only a temporary implementation. * Component ID: 7995ee1f-8be0-40d4-a35f-b2679850b7b2 Base Type: nvidia::deepstream::INvDsInPlaceDataHandler", "keywords": []}, {"id": 3489, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssamplesourcemanipulator", "display_name": "nvidia::deepstream::NvDsSampleSourceManipulator", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssamplesourcemanipulator", "priority": -1, "content": "Sample component demonstrating adding/removing sources at runtime. Component ID: 717b2c43-2f10-4fe8-b961-65e408ece299 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3490, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#nvidia-deepstream-nvdssamplevideotemplatelib", "display_name": "nvidia::deepstream::NvDsSampleVideoTemplateLib", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "nvidia-deepstream-nvdssamplevideotemplatelib", "priority": -1, "content": "Sample component demonstrating usage of DeepStream\u2019s video template plugin configuration component. The sample component scales video frame. Component ID: 7a6e75f1-da4d-4819-8861-3ea49328ade7 Base Type: nvidia::deepstream::INvDsVideoTemplatePluginConfigComponent", "keywords": []}, {"id": 3491, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "parameters", "priority": -1, "content": "car-color-unique-id Unique ID of the NvDsInferVideo component configured for car color classification. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 car-make-unique-id Unique ID of the NvDsInferVideo component configured for car make classification. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 generate-dummy-data Generate dummy data to be attached as NvDsEventMsgMeta , if false or not set, uses metadata generated by the pipeline. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector vehicle-type-unique-id Unique ID of the NvDsInferVideo component configured for vehicle type classification. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 3492, "doc_id": 3492, "filename": "text/ExtensionsManual/NvDsSampleExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsSampleExt", "display_name": "NvDsSampleExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsSampleExt", "anchor": "", "priority": -1, "content": "Sample components for demonstrating usage of various DeepStream interfaces and components. UUID: 44a711e4-8519-4a68-81e8-be7ee4af3ff0 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3493, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "id1", "priority": -1, "content": "classifier-async-mode Enables inference on detected objects and asynchronous metadata attachments. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.51 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING input-object-max-height When used in secondary mode only on objects with this maximum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-max-width When used in secondary mode only on objects with this maximum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-min-height When used in secondary mode only on objects with this minimum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 input-object-min-width When used in secondary mode only on objects with this minimum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution. Valid values: 0: Platform default - GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-filter The filter to use for scaling frames / object crops to network resolution. Valid values: 0: Nearest 1: Bilinear 2: Cubic(GPU)/5-Tap(VIC) 3: Super(GPU)/10-Tap(VIC) 4: Lanzos(GPU)/Smart(VIC) 5: Nicest(VIC only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3494, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "id2", "priority": -1, "content": "classifier-async-mode Enables inference on detected objects and asynchronous metadata attachments. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.51 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING input-object-max-height When used in secondary mode only on objects with this maximum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-max-width When used in secondary mode only on objects with this maximum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-min-height When used in secondary mode only on objects with this minimum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 input-object-min-width When used in secondary mode only on objects with this minimum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution. Valid values: 0: Platform default - GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-filter The filter to use for scaling frames / object crops to network resolution. Valid values: 0: Nearest 1: Bilinear 2: Cubic(GPU)/5-Tap(VIC) 3: Super(GPU)/10-Tap(VIC) 4: Lanzos(GPU)/Smart(VIC) 5: Nicest(VIC only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3495, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "id3", "priority": -1, "content": "classifier-async-mode Enables inference on detected objects and asynchronous metadata attachments. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.51 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING input-object-max-height When used in secondary mode only on objects with this maximum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-max-width When used in secondary mode only on objects with this maximum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-min-height When used in secondary mode only on objects with this minimum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 input-object-min-width When used in secondary mode only on objects with this minimum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 128 model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution. Valid values: 0: Platform default - GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-filter The filter to use for scaling frames / object crops to network resolution. Valid values: 0: Nearest 1: Bilinear 2: Cubic(GPU)/5-Tap(VIC) 3: Super(GPU)/10-Tap(VIC) 4: Lanzos(GPU)/Smart(VIC) 5: Nicest(VIC only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3496, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "id4", "priority": -1, "content": "classifier-threshold Minimum threshold label probability. The classifier outputs the label having the highest probability if it is greater than this threshold Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3497, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "id5", "priority": -1, "content": "cluster-mode Object clustering mode to use. Valid values: 1: DBSCAN 2: NMS 3: DBSCAN + NMS (Hybrid) 4: No clustering Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 dbscan-min-score Minimum sum of confidence of all the neighbors in a cluster for it to be considered a valid cluster. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0 detected-max-h Maximum height in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1920 detected-max-w Maximum width in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1920 detected-min-h Minimum height in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 detected-min-w Minimum width in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False eps Epsilon values for DBSCAN clustering algorithm Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.9 infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING input-object-max-height When used in secondary mode only on objects with this maximum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-max-width When used in secondary mode only on objects with this maximum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-min-height When used in secondary mode only on objects with this minimum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 input-object-min-width When used in secondary mode only on objects with this minimum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 min-boxes Minimum number of points required to form a dense region for DBSCAN algorithm Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 3 model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 nms-iou-threshold Maximum IOU score between two proposals after which the proposal with the lower confidence will be rejected. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.5 post-cluster-threshold Detection threshold to be applied post clustering operation for all classes Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0 pre-cluster-threshold Detection threshold to be applied prior to clustering operation for all classes Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.5 roi-bottom-offset Offset of the RoI from the bottom of the frame. Only objects within the RoI are output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 roi-top-offset Offset of the RoI from the top of the frame. Only objects within the RoI are output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution. Valid values: 0: Platform default - GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-filter The filter to use for scaling frames / object crops to network resolution. Valid values: 0: Nearest 1: Bilinear 2: Cubic(GPU)/5-Tap(VIC) 3: Super(GPU)/10-Tap(VIC) 4: Lanzos(GPU)/Smart(VIC) 5: Nicest(VIC only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 topK Keep only top K objects with highest detection scores. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 20 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3498, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdscardetector360dmodel", "display_name": "nvidia::deepstream::NvDsCarDetector360dModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdscardetector360dmodel", "priority": -1, "content": "Car detector model for 360d use case. Contains the caffemodel and prototxt , labels file, INT8 calibration file and the nvinfer configuration file for the model. Component ID: 8e3defe9-faf4-4417-945f-4ceb3950ca20 Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3499, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdsresnet10-4classdetectormodel", "display_name": "nvidia::deepstream::NvDsResnet10_4ClassDetectorModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdsresnet10-4classdetectormodel", "priority": -1, "content": "4-class primary model detecting vehicles, persons, bicycles and roadsigns. Contains the caffemodel and prototxt , labels file, INT8 calibration file and the nvinfer configuration file for the model. Component ID: c2bed4f0-b9dd-43ab-b693-e0cbdd4f96e8 Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3500, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdssecondarycarcolorclassifiermodel", "display_name": "nvidia::deepstream::NvDsSecondaryCarColorClassifierModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdssecondarycarcolorclassifiermodel", "priority": -1, "content": "Secondary car color classification model. Contains the caffemodel and prototxt , labels file, INT8 calibration file, the mean ppm file and the nvinfer configuration file for the model. Component ID: f7a64e00-f01f-4eaf-8c94-d686c28b9e48 Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3501, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdssecondarycarmakeclassifiermodel", "display_name": "nvidia::deepstream::NvDsSecondaryCarMakeClassifierModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdssecondarycarmakeclassifiermodel", "priority": -1, "content": "Secondary car make classification model. Contains the caffemodel and prototxt , labels file, INT8 calibration file, the mean ppm file and the nvinfer configuration file for the model. Component ID: f10b9a8c-d8d4-4ed8-ad54-8d8dca2392b9 Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3502, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdssecondaryvehicletypeclassifiermodel", "display_name": "nvidia::deepstream::NvDsSecondaryVehicleTypeClassifierModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdssecondaryvehicletypeclassifiermodel", "priority": -1, "content": "Secondary vehicle type classification model. Contains the caffemodel and prototxt , labels file, INT8 calibration file, the mean ppm file and the nvinfer configuration file for the model. Component ID: 47728594-4a13-4460-a906-32c3ae52a61a Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3503, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#nvidia-deepstream-nvdssonycaudioclassifiermodel", "display_name": "nvidia::deepstream::NvDsSonyCAudioClassifierModel", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "nvidia-deepstream-nvdssonycaudioclassifiermodel", "priority": -1, "content": "Audio classifier trained on the SONYC urban noise database. Contains the onnx file, labels file and the nvinfer configuration file for the model. Component ID: d8d8f07e-3502-4124-ac4f-15f521cf2fb9 Base Type: nvidia::deepstream::INvDsInferModelConfigComponent", "keywords": []}, {"id": 3504, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSampleModelsExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "parameters", "priority": -1, "content": "cluster-mode Object clustering mode to use. Valid values: 1: DBSCAN 2: NMS 3: DBSCAN + NMS (Hybrid) 4: No clustering Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 2 dbscan-min-score Minimum sum of confidence of all the neighbors in a cluster for it to be considered a valid cluster. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0 detected-max-h Maximum height in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 detected-max-w Maximum width in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 detected-min-h Minimum height in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 detected-min-w Minimum width in pixels of detected objects to be output by the detector Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 enable-dla Enable DLA for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False eps Epsilon values for DBSCAN clustering algorithm Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.7 infer-dims Binding dimensions to set on the image input layer. Format - &lt;dim1&gt;;&lt;dim2&gt;;&lt;dim3&gt;\u2026 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING input-object-max-height When used in secondary mode only on objects with this maximum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-max-width When used in secondary mode only on objects with this maximum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 input-object-min-height When used in secondary mode only on objects with this minimum height Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 input-object-min-width When used in secondary mode only on objects with this minimum width Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 min-boxes Minimum number of points required to form a dense region for DBSCAN algorithm Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 3 model-engine-file Path to the model engine file. Absolute or relative to the extension directory. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE network-mode Data format to be used by inference. Valid values: 0: FP32 1: INT8 2: FP16 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 nms-iou-threshold Maximum IOU score between two proposals after which the proposal with the lower confidence will be rejected. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.5 post-cluster-threshold Detection threshold to be applied post clustering operation for all classes Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.0 pre-cluster-threshold Detection threshold to be applied prior to clustering operation for all classes Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.4 roi-bottom-offset Offset of the RoI from the bottom of the frame. Only objects within the RoI are output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 roi-top-offset Offset of the RoI from the top of the frame. Only objects within the RoI are output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-compute-hw Compute hardware to use for scaling frames / object crops to network resolution. Valid values: 0: Platform default - GPU (dGPU), VIC (Jetson) 1: GPU 2: VIC (Jetson only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 scaling-filter The filter to use for scaling frames / object crops to network resolution. Valid values: 0: Nearest 1: Bilinear 2: Cubic(GPU)/5-Tap(VIC) 3: Super(GPU)/10-Tap(VIC) 4: Lanzos(GPU)/Smart(VIC) 5: Nicest(VIC only) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 tensor-meta-pool-size Size of the output tensor meta pool Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 6 topK Keep only top K objects with highest detection scores. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 20 use-dla-core DLA Core to use for inferencing Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3505, "doc_id": 3505, "filename": "text/ExtensionsManual/NvDsSampleModelsExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsSampleModelsExt", "display_name": "NvDsSampleModelsExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsSampleModelsExt", "anchor": "", "priority": -1, "content": "Components for using the sample models provided as part of DeepStreamSDK. UUID: 909dc1ea-c654-44c1-97a3-0b8fec12141a Version: 1.7.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3506, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id1", "priority": -1, "content": "audio-out-%u Handle to an nvidia::deepstream::NvDsDynamicOutput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsDynamicOutput cudadec-memtype Set to specify memory type for CUDA decoder buffers. Valid values: 0: memtype_device 1: memtype_pinned 2: memtype_unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 dec-skip-frames Type of frames to skip during decoding. Valid values: 0: decode_all 1: decode_non_ref 2: decode_key Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 drop-frame-interval Interval to drop the frames,ex: value of 5 means every 5th frame will be given by decoder, rest all dropped. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with &#x27;file:/&#x27; . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 100 num-extra-surfaces Number of surfaces in addition to minimum decode surfaces given by the decoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0 = disable timeout. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 select-rtp-protocol Transport Protocol to use for RTP. Valid values: 0: rtp-multi 4: rtp-tcp Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 smart-rec-cache Size of cache in seconds, applies to both audio and video cache Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp . Valid values: 0: smart-rec-mp4 1: smart-rec-mkv Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 20 smart-rec-dir-path Path of directory to save the recorded file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: Smart_Record smart-rec-mode Smart record mode Valid values: 0: smart-rec-mode-av 1: smart-rec-mode-video 2: smart-rec-mode-audio Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp . Valid values: 0: smart-rec-disable 1: smart-rec-cloud 2: smart-rec-multi Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 source-id Unique ID for the input source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 sr-done-signal Handle to a NvDsSrDoneSignal component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSrDoneSignal start-sr-action Handle to a NvDsStartSrAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStartSrAction stop-sr-action Handle to a NvDsStopSrAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStopSrAction type Set the type of source. Use source-type-rtsp to use smart record features. Valid values: 0: auto 1: uri 2: rtsp Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 uri URI of the file or rtsp source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING video-out-%u Handle to an nvidia::deepstream::NvDsDynamicOutput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsDynamicOutput", "keywords": []}, {"id": 3507, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id2", "priority": -1, "content": "audio-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput cudadec-memtype Set to specify memory type for CUDA decoder buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 dec-skip-frames Type of frames to skip during decoding. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 drop-frame-interval Interval to drop the frames,ex: value of 5 means every 5th frame will be given by decoder, rest all dropped. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with file:/ . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-extra-surfaces Number of surfaces in addition to minimum decode surfaces given by the decoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 peer-pad-id-same-as-source-id Force the downstream element\u2019s request pad index to be same as the source-id of the source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0=disable timeout. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 select-rtp-protocol Transport Protocol to use for RTP Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-cache Size of cache in seconds, applies to both audio and video cache Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-rec-dir-path Path of directory to save the recorded file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING smart-rec-mode Smart record mode Valid values: 0: smart-rec-mode-av 1: smart-rec-mode-video 2: smart-rec-mode-audio Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-status Boolean indicating if SR is currently. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-record-action Handle to an nvidia::deepstream::NvDsMultiSourceSmartRecordAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiSourceSmartRecordAction smart-record-done-signal Handle to an nvidia::deepstream::NvDsSrDoneSignal component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSrDoneSignal source-id-list Semi-colon separated list of unique IDs for the input source. Should have 1-to-1 mapping with uri-list. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING source-info-loader Handle to an nvidia::deepstream::NvDsSourceInfoLoader component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceInfoLoader source-manip-action Handle to an nvidia::deepstream::NvDsSourceManipulationAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceManipulationAction type Set the type of source. Use source-type-rtsp to use smart record features. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 uri-list Semi-colon separated list of URIs, Overrides the uri parameter of GstDsNvUriSrcBin . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING video-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput", "keywords": []}, {"id": 3508, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id3", "priority": -1, "content": "audio-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput cudadec-memtype Set to specify memory type for CUDA decoder buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 dec-skip-frames Type of frames to skip during decoding. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 dewarper-config-file Dewarper Config File. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE drop-frame-interval Interval to drop the frames,ex: value of 5 means every 5th frame will be given by decoder, rest all dropped. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with file:/ . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 interpolation-method Set interpolation method for the dewarper . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-batch-buffers Number of Surfaces per output Buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-extra-surfaces Number of surfaces in addition to minimum decode surfaces given by the decoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-output-buffers Number of Output Buffers of the dewarper . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 peer-pad-id-same-as-source-id Force the downstream element\u2019s request pad index to be same as the source-id of the source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0=disable timeout. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 select-rtp-protocol Transport Protocol to use for RTP Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-cache Size of cache in seconds, applies to both audio and video cache. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-rec-dir-path Path of directory to save the recorded file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING smart-rec-mode Smart record mode Valid values: 0: smart-rec-mode-av 1: smart-rec-mode-video 2: smart-rec-mode-audio Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-status Boolean indicating if SR is currently. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-record-action Handle to an nvidia::deepstream::NvDsMultiSourceSmartRecordAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiSourceSmartRecordAction smart-record-done-signal Handle to a nvidia::deepstream::NvDsSrDoneSignal component Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSrDoneSignal source-id-list Semi-colon separated list of unique IDs for the input source. Should have 1-to-1 mapping with uri-list. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING source-info-loader Handle to an nvidia::deepstream::NvDsSourceInfoLoader component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceInfoLoader source-manip-action Handle to an nvidia::deepstream::NvDsSourceManipulationAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceManipulationAction type Set the type of source. Use source-type-rtsp to use smart record features. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 uri-list Semi-colon separated list of URIs. Overrides the uri parameter of GstDsNvUriSrcBin . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING video-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput", "keywords": []}, {"id": 3509, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id4", "priority": -1, "content": "audio-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput cudadec-memtype Set to specify memory type for CUDA decoder buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 dec-skip-frames Type of frames to skip during decoding. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 drop-frame-interval Interval to drop the frames,ex: value of 5 means every 5th frame will be given by decoder, rest all dropped. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 file-loop Loop file sources after EOS. Src type must be source-type-uri and uri starting with file:/ . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 latency Jitterbuffer size in milliseconds; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-extra-surfaces Number of surfaces in addition to minimum decode surfaces given by the decoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 peer-pad-id-same-as-source-id Force the downstream element\u2019s request pad index to be same as the source-id of the source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False pre-event-rec-time Pre-event record time. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 record-action Handle to a NvDsRecordAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsRecordAction record-mode Record Mode. 0 = no recording, 1 = video, 2 = snapshot. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 rtsp-reconnect-interval Timeout in seconds to wait since last data was received from an RTSP source before forcing a reconnection. 0=disable timeout. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 select-rtp-protocol Transport Protocol to use for RTP. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-cache Size of cache in seconds, applies to both audio and video cache Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 smart-rec-container Container format of recorded video. MP4 and MKV containers are supported. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-default-duration In case a Stop event is not generated. This parameter will ensure the recording is stopped after a predefined default duration. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-rec-dir-path Path of directory to save the recorded file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE smart-rec-file-prefix By default, Smart_Record is the prefix. For unique file names every source must be provided with a unique prefix. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING smart-rec-mode Smart record mode Valid values: 0: smart-rec-mode-av 1: smart-rec-mode-video 2: smart-rec-mode-audio Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 smart-rec-status Boolean indicating if SR is currently. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL smart-rec-video-cache Size of video cache in seconds. DEPRECATED: Use \u2018smart-rec-cache\u2019 instead. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 smart-record Enable Smart Record and choose the type of events to respond to. Sources must be of type source-type-rtsp . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 source-id-list Semi-colon separated list of unique IDs for the input source. Should have 1-to-1 mapping with uri-list. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING source-info-loader Handle to an nvidia::deepstream::NvDsSourceInfoLoader component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceInfoLoader source-manip-action Handle to an nvidia::deepstream::NvDsSourceManipulationAction component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsSourceManipulationAction type Set the type of source. Use source-type-rtsp to use smart record features. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 udp-buffer-size UDP Buffer Size in bytes; applicable only for RTSP streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 uri-list Semi-colon separated list of URIs. Overrides the uri parameter of GstDsNvUriSrcBin . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING video-%u-out Handle to an nvidia::deepstream::NvDsMultiOutput component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsMultiOutput", "keywords": []}, {"id": 3510, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id5", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id5", "priority": -1, "content": "framerate Frame rate to request from the source Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 30 gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 height Frame height to request from the source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 480 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 sensor-id Set the id of camera sensor to use. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 source-id Unique ID for the input source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 type Type of interface to use. Valid values: 0: v4l2 1: nvargus Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 v4l2-device V4L2 capture device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: /dev/video0 video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput width Frame width to request from the source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 640", "keywords": []}, {"id": 3511, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id6", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id6", "priority": -1, "content": "animation-mode For pattern=ball , which counter defines the position of the ball. Valid values: 0: frames 1: wall-time 2: running-time Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 background-color Background color to use (big-endian ARGB). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4278190080 blocksize Size in bytes to read per buffer (-1 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4096 do-timestamp Apply current stream time to buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False flip For pattern=ball , invert colors every second. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False foreground-color Foreground color to use (big-endian ARGB). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4294967295 horizontal-speed Scroll image number of pixels per frame (positive is scroll to the left). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 is-live Act as a live source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False k0 Zoneplate zero order phase, for generating plain fields or phase offsets. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kt Zoneplate 1st order t phase, for generating phase rotation as a function of time. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kt2 Zoneplate 2nd order t phase, t*t/256 cycles per picture. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kx Zoneplate 1st order x phase, for generating constant horizontal frequencies. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kx2 Zoneplate 2nd order x phase, normalized to kx2/256 cycles per horizontal pixel at width/2 from origin. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kxt Zoneplate x*t product phase, normalized to kxy/256 cycles per vertical pixel at width/2 from origin. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kxy Zoneplate  x*y product phase. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 ky Zoneplate 1st order y phase, for generating constant vertical frequencies. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 ky2 Zoneplate 2nd order y phase, normalized to ky2/256 cycles per vertical pixel at height/2 from origin. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 kyt Zoneplate  y*t product phase. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 motion For pattern=ball , determines the motion of the ball. Valid values: 0: wavy 1: sweep 2: hsweep Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 num-buffers Number of buffers to output before sending EOS (-1 = unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 pattern Type of test pattern to generate. Valid values: 0: smpte 1: snow 2: black 3: white 4: red 5: green 6: blue 7: checkers-1 8: checkers-2 9: checkers-4 10: checkers-8 11: circular 12: blink 13: smpte75 14: zone-plate 15: gamut 16: chroma-zone-plate 17: solid-color 18: ball 19: smpte100 20: bar 21: pinwheel 22: spokes 23: gradient 24: colors Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 timestamp-offset An offset added to timestamps set on buffers (in ns). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 typefind Run typefind before negotiating (deprecated, non-functional). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(I420, YV12, YUY2, UYVY, AYUV, VUYA, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, Y210, Y410, NV12, NV21, GRAY8, GRAY16_BE, GRAY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_10BE, I420_10LE, I422_10BE, I422_10LE, Y444_10BE, Y444_10LE, GBR, GBR_10BE, GBR_10LE, NV16, NV24, NV12_64Z32, A420_10BE, A420_10LE, A422_10BE, A422_10LE, A444_10BE, A444_10LE, NV61, P010_10BE, P010_10LE, IYU2, VYUY, GBRA, GBRA_10BE, GBRA_10LE, BGR10A2_LE, GBR_12BE, GBR_12LE, GBRA_12BE, GBRA_12LE, I420_12BE, I420_12LE, I422_12BE, I422_12LE, Y444_12BE, Y444_12LE, GRAY10_LE32, NV12_10LE32, NV16_10LE32, NV12_10LE40, bayer) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput xoffset Zoneplate 2nd order products x offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 yoffset Zoneplate 2nd order products y offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3512, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id7", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id7", "priority": -1, "content": "apply-tick-ramp Apply ramp to tick samples. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False audio-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE, S8, U8) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput blocksize Size in bytes to read per buffer (-1 = default). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4294967295 can-activate-pull Can activate in pull mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False can-activate-push Can activate in push mode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True do-timestamp Apply current stream time to buffers. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False freq Frequency of test signal. The sample rate needs to be at least 4 times higher. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 440.0 is-live Act as a live source. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False marker-tick-period Make every Nth tick a marker tick (= a tick with different volume). Only used if wave = ticks . 0 = no marker ticks. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 marker-tick-volume Volume of marker ticks. Only used if wave = ticks and marker-tick-period is set to a nonzero value. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 1.0 num-buffers Number of buffers to output before sending EOS (-1 = unlimited). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 samplesperbuffer Number of samples in each outgoing buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1024 sine-periods-per-tick Number of sine wave periods in one tick. Only used if wave = ticks . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 10 tick-interval Distance between start of current and start of next tick, in nanoseconds. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1000000000 timestamp-offset An offset added to timestamps set on buffers (in ns). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 typefind Run typefind before negotiating (deprecated, non-functional). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False volume Volume of test signal. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FLOAT64 Default: 0.8 wave Oscillator waveform. Valid values: 0: sine 1: square 2: saw 3: triangle 4: silence 5: white-noise 6: pink-noise 7: sine-table 8: ticks 9: gaussian-noise 10: red-noise 11: blue-noise 12: violet-noise Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0", "keywords": []}, {"id": 3513, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#id8", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "id8", "priority": -1, "content": "audio-out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput blocksize Size in bytes to read per buffer (-1 = default) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 buffer-time Size of audio buffer in microseconds. This is the maximum amount of data that is buffered in the device and the maximum latency that the source reports. This value might be ignored by the element if necessary; see \u201cactual-buffer-time\u201d Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 200000 device ALSA device, as defined in an asound configuration file Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: default do-timestamp Apply current stream time to buffers Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False latency-time The minimum amount of data to read in each iteration in microseconds. This is the minimum latency that the source reports. This value might be ignored by the element if necessary; see \u201cactual-latency-time\u201d Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 10000 num-buffers Number of buffers to output before sending EOS (-1 = unlimited) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 provide-clock Provide a clock to be used as the global pipeline clock Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True slave-method Algorithm used to match the rate of the masterclock Valid values: 0: resample 1: re-timestamp 2: skew 3: none Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2 typefind Run typefind before negotiating (deprecated, non-functional) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False", "keywords": []}, {"id": 3514, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-alsaaudioinput", "display_name": "nvidia::deepstream::AlsaAudioInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-alsaaudioinput", "priority": -1, "content": "Read from a sound card via ALSA Component ID: ee5f60b1-85a2-3d5b-bf3e-a1ce8b66dde9 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3515, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-audiotestsrc", "display_name": "nvidia::deepstream::AudioTestSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-audiotestsrc", "priority": -1, "content": "Creates audio test signals of given frequency and volume. Component ID: b8992fc1-c964-3c56-8441-df6dfd8dbc64 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3516, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdscamerasrcinput", "display_name": "nvidia::deepstream::NvDsCameraSrcInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdscamerasrcinput", "priority": -1, "content": "Nvidia DeepStreamSDK NvCameraSrc Bin. Component ID: 3ab02c2f-b2ef-3a55-85e1-f7aebb552393 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3517, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsmultisourcesmartrecordaction", "display_name": "nvidia::deepstream::NvDsMultiSourceSmartRecordAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsmultisourcesmartrecordaction", "priority": -1, "content": "Signals the NvDsMultiSrcInput component to start / stop smart recording on a particular source. This functionality is based on DeepStream Smart Record https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Smart_video.html Component ID: ab36e218-340e-47b6-b876-d8a17480aabb Base Type: nvidia::deepstream::INvDsAction Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3518, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsmultisrcinput", "display_name": "nvidia::deepstream::NvDsMultiSrcInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsmultisrcinput", "priority": -1, "content": "Multi-input source component. Takes a list of URIs as a parameter and creates multiple sources. A GstSrc pad is created for each source. Supports runtime addition and removal of sources. Supports DeepStream Smart Record DeepStream Smart Record https://docs.nvidia.com/metropolis/deepstream/dev-guide/text/DS_Smart_video.html . Component ID: 8a59cfd7-1c69-4a80-9e41-2b9820029a98 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3519, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsmultisrcinputwithrecord", "display_name": "nvidia::deepstream::NvDsMultiSrcInputWithRecord", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsmultisrcinputwithrecord", "priority": -1, "content": "Multi source bin with custom record functionality. Component ID: a8231113-4517-40e7-9de3-87b551f8cc5b Base Type: nvidia::deepstream::NvDsMultiSrcInput", "keywords": []}, {"id": 3520, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsmultisrcwarpedinput", "display_name": "nvidia::deepstream::NvDsMultiSrcWarpedInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsmultisrcwarpedinput", "priority": -1, "content": "Extends GstDsNvMultiUriSrcBin component to add dewarper after the decoder. Component ID: 2e6da3fa-46fc-47b3-83fc-9310edc3c4ed Base Type: nvidia::deepstream::NvDsMultiSrcInput", "keywords": []}, {"id": 3521, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsrecordaction", "display_name": "nvidia::deepstream::NvDsRecordAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsrecordaction", "priority": -1, "content": "Signal the NvDsMultiSrcInputWithRecord component to start/stop recording. This is a connector component. This component must be linked to another component which triggers the action and NvDsMultiSrcInputWithRecord component which performs the action. Component ID: fd0851c0-405e-4198-94b1-46ceb0006f54 Base Type: nvidia::deepstream::INvDsAction Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3522, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdssinglesrcinput", "display_name": "nvidia::deepstream::NvDsSingleSrcInput", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdssinglesrcinput", "priority": -1, "content": "Nvidia DeepStreamSDK NvUriSrc Bin. Refer to nvurisrcbin plugin Component ID: b4e59610-37c9-36fb-bfe0-7bc41e87c006 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3523, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdssourceinfoloader", "display_name": "nvidia::deepstream::NvDsSourceInfoLoader", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdssourceinfoloader", "priority": -1, "content": "Load source information from a YAML file. Other components can call methods of this component to read data from the file. Component ID: c68a0fa2-68f9-437c-b828-fb91b2a25376 Base Type: nvidia::gxf::Component Defined in: nvdssource/source_info_loader.hpp", "keywords": []}, {"id": 3524, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdssourcemanipulationaction", "display_name": "nvidia::deepstream::NvDsSourceManipulationAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdssourcemanipulationaction", "priority": -1, "content": "Signals the NvDsMultiSrcInput component to add or remove a source. This is a connector component. This component must be linked to another component which triggers the action and \u2018 NvDsMultiSrcInput \u2019 component which performs the action. Component ID: e9147d15-9c4f-4cc5-982d-08449ec594d1 Base Type: nvidia::deepstream::INvDsAction Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3525, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdssrdonesignal", "display_name": "nvidia::deepstream::NvDsSrDoneSignal", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdssrdonesignal", "priority": -1, "content": "Callback indicating recording finished along with information on the recorded file. This is a connector component. This component must be linked to NvDsSingleSrcInput which emits the signal and another component which will handle the signal callback. Component ID: 81ff2b7c-3614-342e-94f9-904ba5d46ee5 Base Type: nvidia::deepstream::INvDsSignal Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3526, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsstartsraction", "display_name": "nvidia::deepstream::NvDsStartSrAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsstartsraction", "priority": -1, "content": "Start smart record. This is a connector component. This component must be linked to another component which triggers the action and NvDsSingleSrcInput component which performs the action. Component ID: 77383657-3462-3e80-995d-b625fc75fdb7 Base Type: nvidia::deepstream::INvDsAction Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3527, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-nvdsstopsraction", "display_name": "nvidia::deepstream::NvDsStopSrAction", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-nvdsstopsraction", "priority": -1, "content": "Stop smart record. This is a connector component. This component must be linked to another component which triggers the action and NvDsSingleSrcInput component which performs the action. Component ID: ecd8c288-f4b3-3394-9adc-0abb88bf02fe Base Type: nvidia::deepstream::INvDsAction Defined in: nvdssource/nvdssource_signals.hpp", "keywords": []}, {"id": 3528, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#nvidia-deepstream-videotestsrc", "display_name": "nvidia::deepstream::VideoTestSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "nvidia-deepstream-videotestsrc", "priority": -1, "content": "Creates a test video stream. Refer to nvvideotestsrc plugin Component ID: b99f0737-f4d6-3cb1-b994-952f7cab140a Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3529, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsSourceExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "parameters", "priority": -1, "content": "source-info-file YAML file containing source information Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE", "keywords": []}, {"id": 3530, "doc_id": 3530, "filename": "text/ExtensionsManual/NvDsSourceExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsSourceExt", "display_name": "NvDsSourceExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsSourceExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream source and input related components. UUID: a632d022-3425-4848-9074-e6483ef74366 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3531, "doc_id": 3535, "filename": "text/ExtensionsManual/NvDsTemplateExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTemplateExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTemplateExt", "anchor": "id1", "priority": -1, "content": "customlib-name Set custom library Name to be used. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE customlib-props Set Custom Library Properties (key:value) string, can be set multiple times,vector is maintained internally. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING dummy-meta-insert Set to enable dummy meta data insertion Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL fill-dummy-batch-meta Set to fill dummy batch meta data sent from nvstreammux Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set GPU Device ID Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput video-template-config Handle to an nvidia::deepstream::INvDsVideoTemplatePluginConfigComponent component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsVideoTemplatePluginConfigComponent", "keywords": []}, {"id": 3532, "doc_id": 3535, "filename": "text/ExtensionsManual/NvDsTemplateExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTemplateExt#nvidia-deepstream-nvdsaudiotemplate", "display_name": "nvidia::deepstream::NvDsAudioTemplate", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTemplateExt", "anchor": "nvidia-deepstream-nvdsaudiotemplate", "priority": -1, "content": "A custom algorithm can be hooked for Transform In-Place use-cases. Refer to nvdsaudiotemplate plugin Component ID: 2156aefa-c1e2-383f-8040-8bd49744aa00 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3533, "doc_id": 3535, "filename": "text/ExtensionsManual/NvDsTemplateExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTemplateExt#nvidia-deepstream-nvdsvideotemplate", "display_name": "nvidia::deepstream::NvDsVideoTemplate", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTemplateExt", "anchor": "nvidia-deepstream-nvdsvideotemplate", "priority": -1, "content": "A custom algorithm can be hooked for Transform/In-Place use-cases. Refer to nvdsvideotemplate plugin Component ID: 061566d1-77d7-373c-8695-72ed09f6cedd Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3534, "doc_id": 3535, "filename": "text/ExtensionsManual/NvDsTemplateExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTemplateExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTemplateExt", "anchor": "parameters", "priority": -1, "content": "audio-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput audio-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - audio(S16LE, F32LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput audio-template-config Handle to an nvidia::deepstream::INvDsAudioTemplatePluginConfigComponent component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsAudioTemplatePluginConfigComponent customlib-name Set custom library Name to be used. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE customlib-props Set Custom Library Properties. (key:value) string can be set multiple times, vector is maintained internally. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3535, "doc_id": 3535, "filename": "text/ExtensionsManual/NvDsTemplateExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsTemplateExt", "display_name": "NvDsTemplateExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsTemplateExt", "anchor": "", "priority": -1, "content": "NVIDIA template components for processing data. UUID: 845a7fd3-51e8-4076-b3d9-e2974880925e Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3536, "doc_id": 3538, "filename": "text/ExtensionsManual/NvDsTrackerExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTrackerExt#nvidia-deepstream-nvdstracker", "display_name": "nvidia::deepstream::NvDsTracker", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTrackerExt", "anchor": "nvidia-deepstream-nvdstracker", "priority": -1, "content": "DeepStreamSDK NvTracker Bin. Internal Pipeline: queue-&gt;nvtracker . Refer to nvtracker plugin Component ID: 5b0aaa9d-f588-3485-b317-d13fec5cc2ae Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3537, "doc_id": 3538, "filename": "text/ExtensionsManual/NvDsTrackerExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTrackerExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTrackerExt", "anchor": "parameters", "priority": -1, "content": "compute-hw Compute Scaling HW. Valid values: 0: Default 1: GPU 2: VIC Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 display-tracking-id Display tracking id in object text. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True enable-batch-process Enable batch processing across multiple streams. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True enable-past-frame Enable adding past frame track into user meta. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 ll-config-file Low-level library config file path. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE ll-lib-file Low-level library file path. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE tracker-height Frame height at which the tracker should operate, in pixels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 384 tracker-width Frame width at which the tracker should operate, in pixels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 tracking-id-reset-mode Tracking ID reset mode when stream reset or EOS happens Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 tracking-surface-type Set Tracking Surface Type, default is ALL , (1) =&gt; SPOT Surface, (2) =&gt; AISLE Surface. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(I420, NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3538, "doc_id": 3538, "filename": "text/ExtensionsManual/NvDsTrackerExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsTrackerExt", "display_name": "NvDsTrackerExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsTrackerExt", "anchor": "", "priority": -1, "content": "NVIDIA Object Tracking Extension. UUID: f5aaeb53-e9b8-4317-87d1-9549d67c1638 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3539, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "id1", "priority": -1, "content": "capture-io-mode Capture I/O mode (matches src pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 cudadec-memtype Set to specify memory type for CUDA decoder buffers. Valid values: 0: memtype_device 1: memtype_pinned 2: memtype_unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 2 drop-frame-interval Interval to drop the frames. For example - when set to 5, every 5th frame will be given by decoder, all other frames are dropped. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 extra-controls Extra v4l2 controls (CIDs) for the device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING extract-sei-type5-data Set to extract and attach SEI type5 unregistered data on output buffer Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL gpu-id Set to GPU Device ID for decoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 low-latency-mode Set low latency mode for bitstreams having I and IPPP frames Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL num-extra-surfaces Additional number of surfaces in addition to min decode surfaces given by the v4l2 driver. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 output-io-mode Output side I/O mode (matches sink pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 skip-frames Type of frames to skip during decoding. Valid values: 0: decode_all 1: decode_non_ref 2: decode_key Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - jpeg;video(h264, h265, divx, vp8, vp9) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3540, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "id2", "priority": -1, "content": "bitrate Set bitrate for v4l2 encode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4000000 capture-io-mode Capture I/O mode (matches src pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 control-rate Set control rate for v4l2 encode. Valid values: 0: variable_bitrate 1: constant_bitrate Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 extended-colorformat Set Extended ColorFormat pixel values 0 to 255 in VUI info. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False extra-controls Extra v4l2 controls (CIDs) for the device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING force-idr Force an IDR frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False force-intra Force an INTRA frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set to GPU Device ID for Encoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 iframeinterval Encoding Intra Frame occurrence frequency. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 30 output-io-mode Output side I/O mode (matches sink pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 profile Set profile for v4l2 encode. Valid values: 0: Baseline 2: Main 4: High 7: High444 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(h264) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3541, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "id3", "priority": -1, "content": "bitrate Set bitrate for v4l2 encode. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 4000000 capture-io-mode Capture I/O mode (matches src pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 control-rate Set control rate for v4l2 encode. Valid values: 0: variable_bitrate 1: constant_bitrate Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 extended-colorformat Set Extended ColorFormat pixel values 0 to 255 in VUI info. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False extra-controls Extra v4l2 controls (CIDs) for the device. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING force-idr Force an IDR frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False force-intra Force an INTRA frame. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set to GPU Device ID for Encoder. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 iframeinterval Encoding Intra Frame occurrence frequency. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 30 output-io-mode Output side I/O mode (matches sink pad). Valid values: 0: auto 2: mmap 5: dmabuf-import Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 profile Set profile for v4l2 encode. Valid values: 0: Main 1: Main10 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(h265) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3542, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#nvidia-deepstream-nvdsh264encoder", "display_name": "nvidia::deepstream::NvDsH264Encoder", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "nvidia-deepstream-nvdsh264encoder", "priority": -1, "content": "Encode H.264 video streams via V4l2 API. Component ID: 199788fe-ee59-36d0-bfcf-3f02f8e4fb51 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3543, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#nvidia-deepstream-nvdsh265encoder", "display_name": "nvidia::deepstream::NvDsH265Encoder", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "nvidia-deepstream-nvdsh265encoder", "priority": -1, "content": "Encode H.265 video streams via V4l2 API. Component ID: d01cd29f-365f-3716-995d-db15051a8a0b Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3544, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#nvidia-deepstream-nvdsjpegdecoder", "display_name": "nvidia::deepstream::NvDsJpegDecoder", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "nvidia-deepstream-nvdsjpegdecoder", "priority": -1, "content": "Decode images from JPEG format. Refer to nvjpegdec plugin Component ID: 9d99b73c-ea51-36b8-99d1-92510fae716b Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3545, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#nvidia-deepstream-nvdsvideodecoder", "display_name": "nvidia::deepstream::NvDsVideoDecoder", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "nvidia-deepstream-nvdsvideodecoder", "priority": -1, "content": "Decode video streams via V4L2 API. Component ID: 08bd1163-214e-3b05-9d15-e42211b4a5fe Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3546, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTranscodeExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "parameters", "priority": -1, "content": "Enableperf Enable decode time measurement. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False gpu-id Set GPU Device ID for operation. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 idct-method The IDCT algorithm to use. Valid values: 0: islow 1: ifast 2: float Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - jpeg . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput max-errors Error out after receiving N consecutive decoding errors ( -1 = never fail, 0 = automatic, 1 = fail on first error). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3547, "doc_id": 3547, "filename": "text/ExtensionsManual/NvDsTranscodeExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsTranscodeExt", "display_name": "NvDsTranscodeExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsTranscodeExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream components for multimedia decoding and encoding. UUID: e5590555-9031-4187-a217-4518c149c2d0 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3548, "doc_id": 3550, "filename": "text/ExtensionsManual/NvDsTritonExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTritonExt#nvidia-deepstream-nvdstriton", "display_name": "nvidia::deepstream::NvDsTriton", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTritonExt", "anchor": "nvidia-deepstream-nvdstriton", "priority": -1, "content": "Nvidia DeepStreamSDK TensorRT Bin. Internal Pipeline: queue-&gt;nvinferserver . Refer to nvinferserver plugin Component ID: 93f32aa2-c79c-350c-862f-e090d52f2162 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3549, "doc_id": 3550, "filename": "text/ExtensionsManual/NvDsTritonExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsTritonExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsTritonExt", "anchor": "parameters", "priority": -1, "content": "batch-size Maximum batch size for inference. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 config-file-path Path to the configuration file for the current instance of nvinfer . Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_FILE filter-out-class-ids Ignore metadata for objects of specified class ids Use string with values of class ids in ClassID (int) to set the property. e.g. 0;2;3. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING gpu-id Set GPU Device ID Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 infer-on-class-ids Operate on objects with specified class ids Use string with values of class ids in ClassID (int) to set the property. e.g. 0:2:3 Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING infer-on-gie-id Infer on metadata generated by GIE with this unique ID. Set to -1 to infer on all metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 input-tensor-meta Use preprocessed input tensors attached as metadata instead of preprocessing inside the plugin Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL interval Specifies number of consecutive batches to be skipped for inference. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 model-engine-file Absolute path to the pre-generated serialized engine file for the model. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE output-instance-mask Instance mask expected in network output and attach it to metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False output-tensor-meta Attach inference tensor outputs as buffer metadata. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False process-mode Infer processing mode. Valid values: 1: primary 2: secondary Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 1 raw-output-file-write Write raw inference output to file. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False unique-id Unique ID for the element. Can be used to identify output of the element. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 15 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3550, "doc_id": 3550, "filename": "text/ExtensionsManual/NvDsTritonExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsTritonExt", "display_name": "NvDsTritonExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsTritonExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream Triton Extension UUID: 68de050b-138f-4f60-af99-e74125ab929e Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3551, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "id1", "priority": -1, "content": "addr The IP address to connect to Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port The port to connect to (default = 7174) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 buf-type Type of data to be handled by UCX - Video/Audio/Text Valid values: 0: nvdsucx-buf-video 1: nvdsucx-buf-nv-audio 2: nvdsucx-buf-raw-audio 4: nvdsucx-buf-text Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 gpu-id Set GPU Device ID for operation Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 num-nvbuf The number of NV buffers to allocate. 0 is unlimited Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 nvbuf-batch-size The maximal batch size of a NV buffer Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 raw-buf-size raw buffer size Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA, I420);audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3552, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "id2", "priority": -1, "content": "sync Sync on the clock Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 qos Generate Quality-of-Service events upstream Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL async Go asynchronously to PAUSED Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL throttle-time The time to keep between rendered buffers (0 = disabled) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 addr The IP address to listen on Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING port The port to listen to (default = 7174) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 buf-type Type of data to be handled by UCX - Video/Audio/Text Valid values: 0: nvdsucx-buf-video 1: nvdsucx-buf-nv-audio 2: nvdsucx-buf-raw-audio 4: nvdsucx-buf-text Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 num-conns The number of connections to handle from clients Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA, I420);audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3553, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "id3", "priority": -1, "content": "addr The IP address to connect to Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING port The port to connect to (default = 7174) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 buf-type Type of data to be handled by UCX - Video/Audio/Text Valid values: 0: nvdsucx-buf-video 1: nvdsucx-buf-nv-audio 2: nvdsucx-buf-raw-audio 4: nvdsucx-buf-text Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 gpu-id Set GPU Device ID for operation Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 num-nvbuf The number of NV buffers to allocate. 0 is unlimited Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 nvbuf-batch-size The maximal batch size of a NV buffer Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 raw-buf-size raw buffer size Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA, I420);audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3554, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#nvidia-deepstream-nvdsucxclientsink", "display_name": "nvidia::deepstream::NvDsUcxClientSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "nvidia-deepstream-nvdsucxclientsink", "priority": -1, "content": "Send data as a client over the network via UCX Component ID: fc770702-38c5-37a8-8ebb-24dd8ca035d3 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3555, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#nvidia-deepstream-nvdsucxclientsrc", "display_name": "nvidia::deepstream::NvDsUcxClientSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "nvidia-deepstream-nvdsucxclientsrc", "priority": -1, "content": "Receive data as a client over the network via UCX Component ID: 6d81f6cd-c324-353b-984d-f504c6b58b3c Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3556, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#nvidia-deepstream-nvdsucxserversink", "display_name": "nvidia::deepstream::NvDsUcxServerSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "nvidia-deepstream-nvdsucxserversink", "priority": -1, "content": "Send data as a server over the network via UCX Component ID: 73415b33-57c0-30e0-a7b3-f66428c640ab Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3557, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#nvidia-deepstream-nvdsucxserversrc", "display_name": "nvidia::deepstream::NvDsUcxServerSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "nvidia-deepstream-nvdsucxserversrc", "priority": -1, "content": "Receive data as a server over the network via UCX Component ID: ba85f498-a53d-35ba-881e-d9ffb20005d9 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3558, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUcxExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "parameters", "priority": -1, "content": "sync Sync on the clock Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 qos Generate Quality-of-Service events upstream Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL async Go asynchronously to PAUSED Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL addr The IP address to listen on Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port The port to listen to (default = 7174) Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 buf-type Type of data to be handled by UCX - Video/Audio/Text Valid values: 0: nvdsucx-buf-video 1: nvdsucx-buf-nv-audio 2: nvdsucx-buf-raw-audio 4: nvdsucx-buf-text Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA, I420);audio(S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3559, "doc_id": 3559, "filename": "text/ExtensionsManual/NvDsUcxExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsUcxExt", "display_name": "NvDsUcxExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsUcxExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream extension for sending/receiving data over UCX. Refer to nvdsucx plugin UUID: 4ee6215d-cb14-41e8-a266-5c45f4f9ffd4 Version: 0.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3560, "doc_id": 3564, "filename": "text/ExtensionsManual/NvDsUdpExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUdpExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUdpExt", "anchor": "id1", "priority": -1, "content": "blocksize Size in bytes to read per buffer (-1 = default) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-buffers Number of buffers to output before sending EOS (-1 = unlimited) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 typefind Run typefind before negotiating (deprecated, non-functional) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL do-timestamp Apply current stream time to buffers Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL port The port to receive the packets from, 0=allocate Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 payload-size Size of payload in RTP / UDP packet Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 header-size Size of RTP header Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 num-packets Number of packets for which memory to allocate. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 uri URI in the form of udp://multicast_group:port Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING local-iface-ip IP Address associated with network interface through which to receive the data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING caps The caps of the source pad Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING buffer-size Size of the kernel receive buffer in bytes, 0=default Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 reuse Enable reuse of the port setting this property won\u2019t have any effect. Port will always be reused. It is defined just to avoid warnings with rtspsrc Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL timeout Post a message after timeout nanoseconds (0 = disabled) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 address Address to receive packets for Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING multicast-iface The network interface on which to join the multicast group.This allows multiple interfaces seperated by comma. (\u201ceth0,eth1\u201d) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING auto-multicast Automatically join/leave multicast groups Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL loop Used for setting the multicast loop parameter. TRUE = enable, FALSE = disable Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL out Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3561, "doc_id": 3564, "filename": "text/ExtensionsManual/NvDsUdpExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUdpExt#nvidia-deepstream-nvdsudpsink", "display_name": "nvidia::deepstream::NvDsUdpSink", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUdpExt", "anchor": "nvidia-deepstream-nvdsudpsink", "priority": -1, "content": "Send data over the network via UDP using NVIDIA Rivermax SDK APIs. Refer to nvdsudpsink plugin Component ID: 79b6bdc5-07fc-3aa9-95df-3b66a67c3d85 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3562, "doc_id": 3564, "filename": "text/ExtensionsManual/NvDsUdpExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUdpExt#nvidia-deepstream-nvdsudpsrc", "display_name": "nvidia::deepstream::NvDsUdpSrc", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUdpExt", "anchor": "nvidia-deepstream-nvdsudpsrc", "priority": -1, "content": "Receive data over the network via UDP using NVIDIA Rivermax SDK APIs. Refer to nvdsudpsrc plugin Component ID: a80d8bbc-dc5a-3daa-85c2-693ced731747 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3563, "doc_id": 3564, "filename": "text/ExtensionsManual/NvDsUdpExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsUdpExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsUdpExt", "anchor": "parameters", "priority": -1, "content": "sync Sync on the clock Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL max-lateness Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 qos Generate Quality-of-Service events upstream Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL async Go asynchronously to PAUSED Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL ts-offset Timestamp offset in nanoseconds Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 enable-last-sample Enable the last-sample property Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL blocksize Size in bytes to pull per buffer (0 = default) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 render-delay Additional render delay of the sink in nanoseconds Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 throttle-time The time to keep between rendered buffers (0 = disabled) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 max-bitrate The maximum bits per second to render (0 = disabled) Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 processing-deadline Maximum processing deadline in nanoseconds Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 local-iface-ip IP Address associated with network interface through which to receive the data. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING host The host/IP/Multicast group to send the packets to Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_STRING port The port to send the packets to Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_INT64 payload-size Size of payload in RTP / UDP packet Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 chunk-size Number of memory chunks to allocate Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 packets-per-chunk Number of packets per memory chunk Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 packets-per-line Number of packets per line, required for Rivermax media APIs Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 sdp-file SDP file to parse the connection details. Set this property to use Rivermax media APIs for transmission. By default Rivermax Generic APIs are used. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_FILE auto-multicast Automatically join/leave the multicast groups, FALSE means user has to do it himself Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL loop Used for setting the multicast loop parameter. TRUE = enable, FALSE = disable Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL close-socket Close socket if passed as property on state change Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL in Handle to a nvidia::deepstream::NvDsStaticInput component. Supported formats - ANY Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput", "keywords": []}, {"id": 3564, "doc_id": 3564, "filename": "text/ExtensionsManual/NvDsUdpExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsUdpExt", "display_name": "NvDsUdpExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsUdpExt", "anchor": "", "priority": -1, "content": "NVIDIA DeepStream components to transfer data over the network using NVIDIA Rivermax SDK APIs UUID: 798c0dca-34b3-4f73-b794-ad5995186601 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3565, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#id1", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "id1", "priority": -1, "content": "columns Number of columns in the Tiled 2D output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 compute-hw Compute Scaling HW. Valid values: 0: Default 1: GPU 2: VIC Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 height Height of the tiled output in pixels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1080 interpolation-method Set interpolation methods. Valid values: 0: Nearest 1: Bilinear 2: Algo-1 3: Algo-2 4: Algo-3 5: Algo-4 6: Default Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 rows Number of rows in the Tiled 2D output. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1 show-source ID of the source to be shown. If -1 all the sources will be tiled else only a single source will be scaled into the output buffer. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: -1 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput width Width of the tiled output in pixels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 1920", "keywords": []}, {"id": 3566, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#id2", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "id2", "priority": -1, "content": "batch-size Maximum batch size for inference. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 height Height of each frame in output batched buffer. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput width Width of each frame in output batched buffer. Flags: GXF_PARAMETER_FLAGS_NONE Type: GXF_PARAMETER_TYPE_UINT64", "keywords": []}, {"id": 3567, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#id3", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "id3", "priority": -1, "content": "background Background type. Valid values: 0: checker 1: black 2: white 3: transparent Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 batched-background Background is batched. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True gpu-id GPU ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 latency Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 min-upstream-latency When sources with a higher latency are expected to be plugged in dynamically after the aggregator has started playing, this allows overriding the minimum latency reported by the initial source(s). This is only taken into account when larger than the actually reported minimum latency (nanoseconds). Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 start-time Start time to use if s``tart-time-selection=set``. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 18446744073709551615 start-time-selection Decides which start time is output. Valid values: 0: zero 1: first 2: set Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 video-in-%u Handle to an nvidia::deepstream::NvDsOnRequestInput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOnRequestInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(NV12, RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput", "keywords": []}, {"id": 3568, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#id4", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "id4", "priority": -1, "content": "handle-mouse-events Handle mouse events on the video renderer. Requires the \u2018renderer\u2019 parameter to be set. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True kb-input Handle to a NvDsKeyboardInput component to read keyboard input. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::INvDsKeyboardInput latency-probe-connector Handle to an nvidia::deepstream::NvDsProbeConnector component. The IO the probe will be installed on is used for latency measurement. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector nvdsosd-prop-controller Handle to an nvidia::deepstream::NvDsOSDPropertyController component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOSDPropertyController renderer-prop-controller Handle to an nvidia::deepstream::NvDsVideoRendererPropertyController component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsVideoRendererPropertyController tiler-out Handle to an nvidia::deepstream::NvDsProbeConnector component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsProbeConnector", "keywords": []}, {"id": 3569, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdsblender", "display_name": "nvidia::deepstream::NvDsBlender", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdsblender", "priority": -1, "content": "Blend multiple video streams. Component ID: 77e0adad-20ad-3222-a43c-60c42d5313d8 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3570, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdsosd", "display_name": "nvidia::deepstream::NvDsOSD", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdsosd", "priority": -1, "content": "Nvidia DeepStreamSDK NvOSD Bin. Internal Pipeline: queue-&gt;nvvidconv-&gt;queue-&gt;nvosd . Refer to nvdsosd plugin Component ID: c2d4834f-0829-39d8-9875-3c6b1c9827dc Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3571, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdsosdpropertycontroller", "display_name": "nvidia::deepstream::NvDsOSDPropertyController", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdsosdpropertycontroller", "priority": -1, "content": "Helper component to control properties of nvidia::deepstream::NvDsOSD . This is a connector component. It must be linked to two components - the NvDsOSD component to control properties, and another component which will set/get properties via the helper component APIs. Component ID: d4865eb4-fffb-314e-acd9-9a8a49e3c03b Base Type: nvidia::deepstream::INvDsPropertyController Defined in: nvdsvisualization/nvdsvisualization_prop_controllers.hpp", "keywords": []}, {"id": 3572, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdssegvisual", "display_name": "nvidia::deepstream::NvDsSegVisual", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdssegvisual", "priority": -1, "content": "Gstreamer NV Segmentation Visualization Plugin. Component ID: bf8cc54c-b420-3172-9e24-3e47151eb905 Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3573, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdstiler", "display_name": "nvidia::deepstream::NvDsTiler", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdstiler", "priority": -1, "content": "Tile input multi-stream buffer into a 2D array. Internal Pipeline: queue-&gt;nvmultistreamtiler . Component ID: cea150e2-d8fb-3d59-b835-1b0564633e2e Base Type: nvidia::deepstream::INvDsElement", "keywords": []}, {"id": 3574, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#nvidia-deepstream-nvdstilereventhandler", "display_name": "nvidia::deepstream::NvDsTilerEventHandler", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "nvidia-deepstream-nvdstilereventhandler", "priority": -1, "content": "Handle mouse and keyboard events for the DeepStream NvMultiStreamTiler plugin. Left click on a source in the tile to expand it. Right click to go back to the tiled view. For keyboard events, z&lt;row-idx&gt;&lt;col-idx&gt; expands the source at location ( &lt;row-idx&gt;,&lt;col-idx&gt; ). Click on z to go back to tiled view. Also toggles text overlay, disabled in tiled view, enabled when a source is expanded. Component ID: ea9e2715-e4b6-481b-b36e-71e7397f4cf2 Base Type: nvidia::deepstream::INvDsComponent", "keywords": []}, {"id": 3575, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "page", "name": "text/ExtensionsManual/NvDsVisualizationExt#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "parameters", "priority": -1, "content": "bbox-bg-colors Background Colors for object bounding boxes. Format - &lt;class-label1&gt;=hex1;&lt;class-label2&gt;=hex2 . hex is in RGBA hex format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING bbox-border-colors Border Colors for object bounding boxes. Format - &lt;class-label1&gt;=hex1;&lt;class-label2&gt;=hex2 . hex is in RGBA hex format. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING border-width Border width to set for object bounding boxes. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 clock-color clock-color. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 clock-font Clock font to be set. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING clock-font-size Font size of the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 display-bbox Boolean to control the display of bounding boxes. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL display-clock Boolean to control the display of the clock. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False display-mask Boolean to control the display of instance mask. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False display-text Boolean to control the display of text. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True display-tracking-id Boolean to control display of tracking ids in object labels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: True font Font to use for object labels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: Serif gpu-id Set GPU Device ID. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 hw-blend-color-attr Color attributes for all classes. Use string with values of color class attributes in ClassID (int), r(float), g(float), b(float), a(float) in order to set the property. Applicable only for HW mode on Jetson. e.g. 0,0.0,1.0,0.0,0.3:1,1.0,0.0,0.3,0.3. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_STRING Default: 0,0.000000,0.000000,0.000000,0.000000: nvbuf-memory-type Type of NvBufSurface Memory to be allocated for output buffers. Valid values: 0: nvbuf-mem-default 1: nvbuf-mem-cuda-pinned 2: nvbuf-mem-cuda-device 3: nvbuf-mem-cuda-unified Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 process-mode Rect and text draw process mode. Valid values: 0: CPU_MODE 1: GPU_MODE Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_INT64 Default: 0 property-controller Property Controller for NvDsOSD component. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsOSDPropertyController reformat-object-labels Reformat object labels with format &lt;primary label&gt; [tracking-id] &lt;secondary-labels-sorted-by-component-id&gt; . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_BOOL Default: False text-bg-color Text background color to set for object labels. RGBA hex format e.g. 0xff000044 for semi-transparent red. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 text-color Text color to set for object labels. RGBA hex format e.g. 0xff000044 for semi-transparent red. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 text-size Text size to set for object labels. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 video-in Handle to an nvidia::deepstream::NvDsStaticInput component. Supported formats - video(I420, NV12, P010_10LE, BGRx, RGBA, GRAY8, GBR, RGB, BGR, UYVP) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticInput video-out Handle to an nvidia::deepstream::NvDsStaticOutput component. Supported formats - video(RGBA) . Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_HANDLE Handle Type: nvidia::deepstream::NvDsStaticOutput x-clock-offset x-clock-offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0 y-clock-offset y-clock-offset. Flags: GXF_PARAMETER_FLAGS_OPTIONAL Type: GXF_PARAMETER_TYPE_UINT64 Default: 0", "keywords": []}, {"id": 3576, "doc_id": 3576, "filename": "text/ExtensionsManual/NvDsVisualizationExt.html", "domain_name": "std", "name": "text/ExtensionsManual/NvDsVisualizationExt", "display_name": "NvDsVisualizationExt", "type": "doc", "display_type": "Page", "docname": "text/ExtensionsManual/NvDsVisualizationExt", "anchor": "", "priority": -1, "content": "NVIDIA components for visualization. UUID: 25903cd4-fc5c-4139-987b-47bb27e8b424 Version: 1.6.0 Author: NVIDIA License: Proprietary", "keywords": []}, {"id": 3577, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#change-accuracy-metric", "display_name": "Change Accuracy Metric", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "change-accuracy-metric", "priority": -1, "content": "Three accuracy metrics are supported for either single camera MOT or MTMC: MOTA, IDF1 and HOTA. It can be changed in PipeTuner config file as: parameter_space: Init: \u2026 Eval: metric: &#x27;HOTA&#x27; # accuracy metric across [&#x27;MOTA&#x27;, &#x27;IDF1&#x27;, &#x27;HOTA&#x27;]", "keywords": []}, {"id": 3578, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#custom-algorithms", "display_name": "Custom Algorithms", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "custom-algorithms", "priority": -1, "content": "DeepStream and Metropolis provide multiple algorithms for DS perception and MTMC. Users can enable them by changing the corresponding config files.", "keywords": []}, {"id": 3579, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#custom-dataset", "display_name": "Custom Dataset", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "custom-dataset", "priority": -1, "content": "Steps to use customize dataset in PipeTuner are: Create video files Create ground truth labels Launch PipeTuner with the new config file Different use cases require different dataset files. Only need to generate the files for the desired use case. For example, if DS Perception Tuning is the use case, only need to follow \u201cCreate Video Files - DS Perception Tuning\u201d and \u201cCreate Ground Truth Labels - DS Perception Tuning\u201d.", "keywords": []}, {"id": 3580, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#custom-models", "display_name": "Custom Models", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "custom-models", "priority": -1, "content": "The PGIE and Re-ID models used in sample configs are included in mdx-perception containers already. When using customized PGIE and Re-ID models in PipeTuner, they need to be added in pipe-tuner-sample/models directory on the host machine following the below steps.", "keywords": []}, {"id": 3581, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#custom-tuning", "display_name": "Custom Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "custom-tuning", "priority": -1, "content": "This section describes how to customize the tuning process, including using new datasets, models and config files. Read the Understanding PipeTuner Config Path section to understand how paths are defined and mapped into docker containers.", "keywords": []}, {"id": 3582, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#data-augmentation", "display_name": "Data Augmentation", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "data-augmentation", "priority": -1, "content": "PipeTuner helps finding the optimal parameters for the dataset used. What if the dataset used for tuning may not be representative of the physical environment that the camera system would be deployed? If the tuned parameters are overfitted to the dataset while the dataset is not general enough, then these tuned parameters may not work well when actually deployed to the test environment. To mitigate this issue, PipeTuner provides an additional tool, which augment the dataset by introducing artificial noises or occlusion, so that the tuned params are robust to those variations that may be present in the real test environment. Currently the data augmentation tool has very simple occlusion-inducing capability only, but it can be extended to offer wider varieties in the future. A sample usage of the data augmentation tool is illustrated in the following sections.", "keywords": []}, {"id": 3583, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#deepstream-tuning-case", "display_name": "DeepStream Tuning Case", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "deepstream-tuning-case", "priority": -1, "content": "Once the set-up script is executed, the expected console output of DeepStream setup command would look like below: $ bash setup.sh deepstream Setup for PipeTuner and DeepStream SDK... Pulling required containers... 1.0: Pulling from nvidia/pipetuner Digest: sha256:17df032022cf1e94514f8625fadfff123e1ec3f297d8647bbd980cbd0683dfcf Status: Downloaded image for nvcr.io/nvidia/pipetuner:1.0 nvcr.io/nvidia/pipetuner:1.0 [1/2] Pulled pipe-tuner image 7.0-triton-multiarch: Pulling from nvidia/deepstream Digest: sha256:d94590278fb116176b54189c9740d3a3577f6ab71b875b68588dfc38947f657b Status: Downloaded image for nvcr.io/nvidia/deepstream:7.0-triton-multiarch nvcr.io/nvidia/deepstream:7.0-triton-multiarch [2/2] Pulled deepstream image Downloading NGC models... --2024-04-19 16:12:11-- https://api.ngc.nvidia.com/v2/models/nvidia/tao/peoplenet/versions/deployable_quantized_v2.6.1/zip Resolving api.ngc.nvidia.com (api.ngc.nvidia.com)... 34.209.247.55, 35.160.16.170 Connecting to api.ngc.nvidia.com (api.ngc.nvidia.com)|34.209.247.55|:443... connected. HTTP request sent, awaiting response... 302 Found \u2026 Saving to: \u2018../ngc_download//peoplenet_deployable_quantized.zip\u2019 ../ngc_download//peoplenet_deployable_ 100%[===========================================================================&gt;] 85.05M 26.3MB/s in 3.2s 2024-04-19 16:12:15 (26.3 MB/s) - \u2018../ngc_download//peoplenet_deployable_quantized.zip\u2019 saved [89182990/89182990] Archive: ../ngc_download//peoplenet_deployable_quantized.zip inflating: ../models/labels.txt inflating: ../models/resnet34_peoplenet_int8.etlt inflating: ../models/resnet34_peoplenet_int8.txt --2024-04-19 16:12:15-- https://api.ngc.nvidia.com/v2/models/nvidia/tao/reidentificationnet/versions/deployable_v1.2/files/resnet50_market1501_aicity156.onnx Resolving api.ngc.nvidia.com (api.ngc.nvidia.com)... 34.209.247.55, 35.160.16.170 Connecting to api.ngc.nvidia.com (api.ngc.nvidia.com)|34.209.247.55|:443... connected. HTTP request sent, awaiting response... 302 Found \u2026 Saving to: \u2018../models/resnet50_market1501_aicity156.onnx\u2019 resnet50_market1501_aicity156.onnx 100%[===========================================================================&gt;] 91.93M 29.0MB/s in 3.2s 2024-04-19 16:12:20 (29.0 MB/s) - \u2018../models/resnet50_market1501_aicity156.onnx\u2019 saved [96398132/96398132] Updating DeepStream Perception SV3DT configs... Sample data setup is done $ cd pipe-tuner-sample/scripts DeepStream users should see docker images like below. $ docker images REPOSITORY TAG nvcr.io/nvidia/pipetuner 1.0 nvcr.io/nvidia/deepstream 7.0-triton-multiarc Also, model files should be under the \u2018models\u2019 folder. They will be mapped into DeepStream containers during tuning. $ ls ../models labels.txt resnet34_peoplenet_int8.etlt resnet34_peoplenet_int8.txt resnet50_market1501_aicity156.onnx", "keywords": []}, {"id": 3584, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#ds-perception-tuning", "display_name": "DS Perception Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "ds-perception-tuning", "priority": -1, "content": "This use case optimizes DeepStream PGIE (i.e., object detection) and tracker parameters for perception accuracy. The pipeline for PipeExec step is constructed as: (file source streams) \u2192 Decoder \u2192 PGIE \u2192 MOT\u2192 (per-stream tracking results) PipeEval step is then performed for MOT Eval to generate accuracy KPI scores. To launch a pipeline with ResNet34-based PeopleNet model and NvDCF tracker with TAO ReID model, for example, run one of below commands based on your user group: For DeepStream users: $ bash launch.sh nvcr.io/nvidia/deepstream:7.0-triton-multiarch ../configs/config_PipeTuner/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml For Metropolis Microservices users: $ bash launch.sh nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 ../configs/config_PipeTuner/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml # For Metropolis Microservices users To launch a pipeline with Transformer-based PeopleNet model and NvDCF tracker with SWIN-based ReID model and SV3DT enabled, for example, run: $ bash launch.sh nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 ../configs/config_Pipecccccbldttjhbecjtvbvgrtdclfvtnetlifccucjnbuj Tuner/SDG_sample_PeopleNet-Transformer_NvDCF-SWIN-3D_MOT.yml # For Metropolis Microservices users", "keywords": []}, {"id": 3585, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#features", "display_name": "Features", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "features", "priority": -1, "content": "Allow tuning of DeepStream-based perception pipeline Allow tuning of end-to-end MTMC pipeline (i.e., DS-perception + MTMC-Analytics) Output BBO client log messages to the console and the log file. Log levels are DEBUG, INFO, WARNING, and ERROR. All level messages are logged in the log file, whereas higher than INFO messages are displayed in the console. Save DeepStream application\u2019s log messages as a file (log_DsAppRun.log) under \u201ccheckpoints/DsAppRun_output__XXXX\u201d Check the DS app\u2019s last log message is \u201cApp run failed\u201d, then find and show the messages with Error, ERROR, and [Exception] in a console. If the number of 0 scores from DS app is higher than a configurable parameter, then output error messages and stop all process If the number of DS app fails is higher than a configurable parameter, then output error messages and stop all process", "keywords": []}, {"id": 3586, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id1", "display_name": "DS Perception Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id1", "priority": -1, "content": "Add videos: Create a new video folder under pipe-tuner-sample/data. It should contain all the videos used for tuning. The videos need to have 1920x1080 resolution in mp4 format. pipe-tuner-sample data &lt;new dataset videos&gt; &lt;video0.mp4&gt; &lt;video1.mp4&gt; \u2026 Create sequence map: Create a new utils folder under pipe-tuner-sample/data. Create a txt file &lt;seqmap.txt&gt; containing all the video names without \u201c.mp4\u201d extension pipe-tuner-sample data &lt;new dataset utils&gt; &lt;seqmap.txt&gt; The content in &lt;seqmap.txt&gt; is below. The first line should always be \u201cname\u201d, and then each line is one video name. name &lt;video0&gt; &lt;video1&gt; \u2026 Update PipeTuner Config: Change datasetPath, seqmapPath in PipeTuner config SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml to match the path of the new tracker config. datasetPath: &quot;data/&lt;new dataset videos&gt;/&quot; seqmapPath: &quot;data/&lt;new dataset utils&gt;/&lt;seqmap.txt&gt;&quot;", "keywords": []}, {"id": 3587, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id2", "display_name": "MTMC Tuning with Frozen Perception", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id2", "priority": -1, "content": "Add videos: Not required. Create sequence map: The same as section \u201cCreate sequence map\u201d in DS Perception Tuning. Update PipeTuner Config: Change seqmapPath in PipeTuner config SDG_sample_MTMC_only.yml to match the path of the new tracker config. seqmapPath: \u201cdata/&lt;new dataset utils&gt;/&lt;seqmap.txt&gt;\u201d", "keywords": []}, {"id": 3588, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id3", "display_name": "MTMC E2E Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id3", "priority": -1, "content": "All the steps are the same as DS Perception Tuning except the PipeTuner config is in PipeTuner config SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MTMC.yml.", "keywords": []}, {"id": 3589, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id4", "display_name": "DS Perception Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id4", "priority": -1, "content": "Create ground truth files in data/&lt;new dataset videos&gt;. For each video, create gt.txt and seqinfo.ini like below pipe-tuner-sample data - &lt;new dataset videos&gt; - &lt;video0&gt; - seqinfo.ini - gt - gt.txt - &lt;video1&gt; - seqinfo.ini - gt - gt.txt - \u2026 gt.txt is the DS perception ground truth label file in the MOT format, which is frame_num, object_id, left, top, width, height, included_for_eval, class_id, visibility_ratio Example: 3,1,315,176,22,32,1,1,1 3,4,511,130,30,88,1,1,1 seqinfo.ini is the sequence information file. Its format is below. The first line must be [Sequence]. There can be multiple parameters, but only seqLength is actually needed. [Sequence] seqLength=&lt;num of frames in the video&gt; &lt;other info&gt; The evaluation script automatically finds the above ground truth files in datasetPath, so no need to change PipeTuner config.", "keywords": []}, {"id": 3590, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id5", "display_name": "MTMC Tuning with Frozen Perception", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id5", "priority": -1, "content": "Add MTMC camera calibration file and MTMC ground truth file under pipe-tuner-sample/data/&lt;new dataset utils&gt;. MTMC ground truth file format is camera, id, frame, left, top, width, height, x_on_ground, y_on_ground Run DeepStream perception pipeline to generate single camera tracking results with Re-ID features as MTMC input. The MTMC input is in JSON format and defined by Kafka schema. Place it under pipe-tuner-sample/data/&lt;new dataset utils&gt;. Change mtmcCalibrationPath, mtmcGroundTruthPath and mtmcPlaybackPath in PipeTuner config to match the path of the new tracker config. mtmcCalibrationPath: \u201cdata/&lt;new dataset utils&gt;/&lt;calibration.json&gt;\u201d mtmcGroundTruthPath: \u201cdata/&lt;new dataset utils&gt;/&lt;MTMC ground truth.txt&gt;\u201d mtmcPlaybackPath: \u201cdata/&lt;new dataset utils&gt;/&lt;MTMC input.json&gt;\u201d", "keywords": []}, {"id": 3591, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#id6", "display_name": "MTMC E2E Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "id6", "priority": -1, "content": "Add MTMC camera calibration file and MTMC ground truth file under pipe-tuner-sample/data/&lt;new dataset utils&gt;. MTMC ground truth file format is camera, id, frame, left, top, width, height, x_on_ground, y_on_ground Change mtmcCalibrationPath, mtmcGroundTruthPath in PipeTuner config to match the path of the new tracker config. mtmcCalibrationPath: \u201cdata/&lt;new dataset utils&gt;/&lt;calibration.json&gt;\u201d mtmcGroundTruthPath: \u201cdata/&lt;new dataset utils&gt;/&lt;MTMC ground truth.txt&gt;\u201d", "keywords": []}, {"id": 3592, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#introduction", "display_name": "Introduction", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "introduction", "priority": -1, "content": "Pipelines for AI applications (e.g, intelligent video analytics) typically consist of a set of inference and processing modules, each of which typically has a distinct functionality implemented using corresponding logics and algorithms. Such logics and algorithms may have a number of parameters that determine the behavior and characteristics just like how the coefficients in a polynomial function shape the output of the function. When you are trying to define and use a data processing pipeline for your application, such process typically entails a series of evaluations of the pipeline outputs in terms of a set of KPIs with a different set of parameters with respect to the expected outputs. Such a process of differing parameters is to get the best KPI from the pipeline, and it is typically carried out by a tedious manual iterative process in practice or a simple exhaustive/random search might be used, as shown in Figure 1: However, such a manual tuning process requires one to have in-depth knowledge on all the relevant data processing modules and their algorithms as well as how each parameter would affect the functionality. If the number of parameters is large in a pipeline, the complexity of the tuning would increase exponentially, and it would become a non-trivial task for ordinary users. In addition, tuning a pipeline for a particular use case or a dataset may negatively affect other use cases or a different dataset. Therefore, the tuning of a pipeline is an essential part of system deployment by users; yet it is one of the biggest challenges and pain points. PipeTuner is a tool that efficiently explores the (potentially very high-dimensional) parameter space and automatically finds the optimal parameters for the pipelines, which yields the highest KPI on the dataset provided by the user. An important advantage of using PipeTuner is that the users are not required to have technical knowledge on the pipeline and its parameters. Therefore, PipeTuner can make the seemingly-daunting task of pipeline tuning more accessible to a wider range of users in terms of technical knowledge. This document is a complete user guide for PipeTuner and walks users through easy-to-follow step-by-step instructions for tuning complete AI processing pipelines, including DeepStream-based perception pipelines and an end-to-end NVIDIA Metropolis multi-target multi-camera tracking pipeline, which is described in more details below: DeepStream perception pipeline: Typical DeepStream pipelines employ a detector (i.e., PGIE) and a multi-object tracker (MOT) to perform a perception task for each stream. PipeTuner allows users to optimize the detector and MOT parameters to achieve the highest-attainable perception accuracy KPI automatically based on the KPI metric and the dataset. Metropolis Multi-Target Multi-Camera tracking (MTMC) pipeline Metropolis MTMC consists of per-camera perception modules and a MTMC analytics module that aggregates the per-camera perception results to yield the global perception results across multiple cameras. The per-camera perception is carried out by DeepStream pipelines, and the perception results are fed to the MTMC analytics module. As the end-to-end MTMC pipeline consists into two parts, users are allowed to perform tuning only a part of the pipeline or the whole end-to-end pipeline as they wish. To help users to better understand and set up the PipeTuner workflow, sample data and config files with different detectors and tracking algorithms are provided as a part of the release on NGC. Users then can customize their pipelines and datasets for their own use cases. Terms Definition parameters A set of numerical values or discrete choices that determines the behavior of a software or algorithm in terms of accuracy and performance, typically defined in some configuration files, such as DeepStream or MTMC config files. pipeline A software that typically consists of multiple modules, each of which potentially has its own set of parameters, performs some processing given input data (e.g., video processing for perception or analytics). The output of a pipeline may include a set of metadata extracted from the input data, which can be evaluated qualitatively and quantitatively. accuracy metric An evaluation criteria or a method for getting a particular type of accuracy value, such as MOTA, IDF1 or HOTA. Those metrics are typically in the range of 0 and 1. optimizer An optimizing algorithm or library that is used to search globally optimal parameters in the defined parameter search space checkpoint A folder that stores the accuracy results and the corresponding parameters of an intermediate step during tuning. DS NVIDIA DeepStream SDK MOT Single camera multi-object tracking, requiring NVIDIA DeepStream SDK. The pipeline is DeepStream PGIE + Tracker. The output includes the metadata for target bounding boxes, IDs, frame numbers, etc. The same target is expected to have a unique ID persistently over frames in each camera/stream. MTMC Multi-target multi-camera tracking, requiring access to NVIDIA Metropolis Microservices. The pipeline consists of DS-based perception and MTMC analytics. The perception module for MTMC provides metadata for each target, including bounding boxes, IDs, and ReID embeddings. Then MTMC aggregates such metadata from multiple cameras and uses them to perform global target association and clustering over multiple cameras, and generates fused location data with globally-unique target IDs.", "keywords": []}, {"id": 3593, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#launch-pipetuner-with-the-new-config-file", "display_name": "Launch PipeTuner with the New Config File", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "launch-pipetuner-with-the-new-config-file", "priority": -1, "content": "Review the PipeTuner config file to ensure all the paths are valid. The tuning workflow is the same as the sample dataset. Summary Below table summarizes the files to include in a new dataset. \u201cv\u201d means the specific files are required for that use case; Dataset components Content format requirements File name requirements Path in the sample dataset PipeTuner config Single camera MOT tuning MTMC tuning with frozen perception MTMC E2E tuning Video files In mp4 format; All the videos have 1920x1080 resolution Videos must be stored under datasetPath folder. Video names must match sequence map. data/SDG_1min_videos/Retail_Synthetic_Cam01.mp4 data/SDG_1min_videos/Retail_Synthetic_Cam02.mp4 \u2026 datasetPath v v Sequence map Contains all the video names for tuning Any name is fine data/SDG_1min_utils/SDG_1min_all.txt seqmapPath v v v MOT ground truth MOT ground truth &lt;datasetPath&gt;/&lt;video name&gt;/gt/gt.txt data/SDG_1min_videos/Retail_Synthetic_Cam01/gt/gt.txt data/SDG_1min_videos/Retail_Synthetic_Cam02/gt/gt.txt \u2026 datasetPath v MOT sequence info Contains video information &lt;datasetPath&gt;/&lt;video_name&gt;/seqinfo.ini data/SDG_1min_videos/Retail_Synthetic_Cam01/seqinfo.ini datasetPath v \u2026 \u2026 MTMC camera calibration Camera calibration format defined by MDX team Any name is fine data/SDG_1min_utils/calibration.json mtmcCalibrationPath v v MTMC ground truth MTMC ground truth defined by MDX team Any name is fine data/SDG_1min_utils/ground_truth.txt mtmcGroundTruthPath v v MTMC sample input In JSON format; Messages follow kafka schema defined by MDX team Any name is fine data/SDG_1min_utils/mtmc_playback_sample.json mtmcPlaybackPath v", "keywords": []}, {"id": 3594, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#launch-tuning-process", "display_name": "Launch Tuning Process", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "launch-tuning-process", "priority": -1, "content": "To run the sample pipelines, enter pipe-tuner-sample/scripts: $ cd pipe-tuner-sample/scripts Script launch.sh takes in a PipeTuner config file, automatically launches the containers and starts the tuning process. Usage: $ bash launch.sh [deepstream or mdx-perception image name or id] [config_pipetuner.yml] Users can choose to run one config file from below examples. Each sample pipeline can take 3 to 40 hours to finish depending on the model size and GPU type. To reduce the tuning turn-around time, users may choose to use smaller dataset or decrease the max number of iterations (i.e., \u201cmax_iteration\u201d param in a PipeTuner config file in ../configs/config_PipeTuner/ folder) like in an example below. It\u2019s currently set as \u201c100\u201d, but users can set it to 5 or 10 for quick experiments. Users can still keep it as 100 and stop it in the middle (how to stop the tuning process in the middle is explained later) # black box optimization configs bbo: ... # different optimizers for tuning. Comment or uncomment to select different optimizers # change max_iteration to set tuning iterations optimizers: type1: name: &quot;pysot&quot; max_iteration: 100", "keywords": []}, {"id": 3595, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#models-on-ngc", "display_name": "Models on NGC", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "models-on-ngc", "priority": -1, "content": "Below PGIE and Re-ID models are used in sample configs, which can be downloaded from NGC. Object detector (i.e., PGIE) ResNet34-based PeopleNet Transformer-based PeopleNet ReID model ResNet50-based TAO ReID model SWIN Transformer ReID model", "keywords": []}, {"id": 3596, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#mtmc-analytics", "display_name": "MTMC Analytics", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "mtmc-analytics", "priority": -1, "content": "Currently used MTMC analytics algorithm config file is pipe-tuner-sample/configs/config_MTMC/config_mtmc_app.json. If some new MTMC config file is needed, place it as pipe-tuner-sample/configs/config_MTMC/&lt;new MTMC config.yml&gt;, and change mtmcPath in PipeTuner config to match the new path.", "keywords": []}, {"id": 3597, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#mtmc-e2e-tuning", "display_name": "MTMC E2E Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "mtmc-e2e-tuning", "priority": -1, "content": "This use case jointly optimizes DS perception (i.g., PGIE and tracker) and MTMC parameters for e2e MTMC accuracy tuning. This provides the highest flexibility for optimization, yet takes the longest time because of the pipeline complexity. The pipeline for PipeExec would look like: (file source streams) \u2192 Decoder \u2192 PGIE \u2192 MOT\u2192 (per-stream tracking results) \u2192 MTMC analytics \u2192 (MTMC results with global IDs) To launch the e2e MTMC pipeline with DS perception module consisting of ResNet34-based PeopleNet model and NvDCF tracker with TAO ReID model, for example, run: $ bash launch.sh nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 ../configs/config_PipeTuner/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MTMC.yml To launch the e2e MTMC pipeline with DS perception module consisting of Transformer-based PeopleNet model and NvDCF tracker with SWIN-based ReID model and SV3DT enabled, for example, run: $ bash launch.sh nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 ../configs/config_PipeTuner/SDG_sample_PeopleNet-Transformer_NvDCF-SWIN-3D_MTMC.yml", "keywords": []}, {"id": 3598, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#mtmc-tuning-case", "display_name": "MTMC Tuning Case", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "mtmc-tuning-case", "priority": -1, "content": "Once the setup script is executed like below: $ bash setup.sh metropolis Metropolis MTMC users should see docker images like below. The \u2018models\u2019 folder is empty because default models in mdx-perception container will be used. $ docker images REPOSITORY TAG nvcr.io/nvidia/pipetuner 1.0 nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception 2.1 The final directory under pipe-tuner-sample is like: pipe-tuner-sample \u251c\u2500\u2500 configs \u2502 \u251c\u2500\u2500 config_CameraMatrix \u2502 \u251c\u2500\u2500 config_GuiTool \u2502 \u251c\u2500\u2500 config_MTMC \u2502 \u251c\u2500\u2500 config_PGIE \u2502 \u251c\u2500\u2500 config_PipeTuner \u2502 \u2514\u2500\u2500 config_Tracker \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 SDG_1min_utils \u2502 \u2514\u2500\u2500 SDG_1min_videos \u251c\u2500\u2500 models \u251c\u2500\u2500 ngc_download \u251c\u2500\u2500 multi-camera-tracking (only for Metropolis Microservice) \u2514\u2500\u2500 scripts", "keywords": []}, {"id": 3599, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#mtmc-tuning-with-frozen-perception", "display_name": "MTMC Tuning with Frozen Perception", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "mtmc-tuning-with-frozen-perception", "priority": -1, "content": "This use case assumes the metadata from the DS perception pipeline (i.e., MOT results + ReID embeddings) are already generated and stored in JSON format. Only MTMC parameters are searched. The pipeline uses that as fixed input and searches for optimal MTMC parameters that would yield the highest MTMC accuracy. The pipeline for PipeExec step is: (MOT results + ReID embeddings) \u2192 MTMC analytics \u2192 (MTMC results with global IDs) To launch the pipeline, run: $ bash launch.sh nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 ../configs/config_PipeTuner/SDG_sample_MTMC_only.yml", "keywords": []}, {"id": 3600, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#multi-object-trackers", "display_name": "Multi-Object Trackers", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "multi-object-trackers", "priority": -1, "content": "Currently used DeepStream tracker is NvDCF_accuracy, but other algorithms such as NvDeepSORT or NvSORT can also be used. Place the new tracker config file as pipe-tuner-sample/configs/config_Tracker/&lt;new tracker config.yml&gt;, and change trackerPath in PipeTuner config to match the new path.", "keywords": []}, {"id": 3601, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#ngc-setup", "display_name": "NGC Setup", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "ngc-setup", "priority": -1, "content": "Users need to follow below steps to sign in to an NGC account and get an API key. Visit NGC sign in page, Enter your email address and click Next, or Create an Account. Choose your organization when prompted for Organization/Team. DeepStream users may use any organization and team; Metropolis Microservice users need to select nv-mdx/mdx-v2-0; Click Sign In. Generate an API key following the instructions. Log in to the NGC docker registry (nvcr.io) and enter the following credentials: $ docker login nvcr.io Username: $oauthtoken Password: &quot;YOUR_NGC_API_KEY&quot; where YOUR_NGC_API_KEY corresponds to the key you generated from the previous step. Metropolis Microservice users need to install NGC CLI following the instructions, and set ngc config as below. DeepStream users can skip this step. $ ngc config set Enter API key: &quot;YOUR_NGC_API_KEY&quot; Enter org: nfgnkvuikvjm Enter team: mdx-v2-0", "keywords": []}, {"id": 3602, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#object-detector-i-e-pgie", "display_name": "Object detector (i.e., PGIE)", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "object-detector-i-e-pgie", "priority": -1, "content": "Steps to customize a PGIE model and use it in PipeTuner are: Refer to how to customize a model in DeepStream. Place all the model resources under pipe-tuner-sample/models, such as label files, model files, model engine and customized libraries, etc. pipe-tuner-sample models labels.txt &lt;ETLT file&gt; &lt;ONNX file&gt; &lt;engine file&gt; &lt;Custom library if any&gt; \u2026 Create a new PGIE config file as pipe-tuner-sample/configs/config_PGIE/&lt;new PGIE config.txt&gt;, make sure below parameters match the absolute path of the new model. model-engine-file=&lt;path&gt;/pipe-tuner-sample/models/&lt;engine file&gt; labelfile-path=&lt;path&gt;/pipe-tuner-sample/models/labels.txt # for TAO model tlt-encoded-model=&lt;path&gt;/pipe-tuner-sample/models/&lt;ETLT file&gt; # for ONNX model onnx-file=&lt;path&gt;/pipe-tuner-sample/models/&lt;ONNX file&gt; Other parameters need changing based on the model architecture as well. Change pgiePath in PipeTuner config to match the path of the new PGIE config. pgiePath: &quot;configs/config_PGIE/&lt;new PGIE config.txt&gt;&quot;", "keywords": []}, {"id": 3603, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#optimization-manager-configs", "display_name": "Optimization Manager Configs", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "optimization-manager-configs", "priority": -1, "content": "When a DeepStream application could fail to run with errors or output zero KPI score, then the optimization manager can capture the failures or zero scores. If there are too many failures or zero scores from DeepStream application, then the optimization process stops immediately. We can set the thresholds for the number of zero scores and failures. threshold_zero_scores: if the number of zero scores from DeepStream application is higher than this parameter, then the process stops. threshold_ds_app_fails: if the number of failures of DeepStream application is higher than this parameter, then the process stops. # optimization manager configs optim_manager: # threshold for the number of 0 scores threshold_zero_scores: 10 # threshold for the number of DS app fails threshold_ds_app_fails: 3", "keywords": []}, {"id": 3604, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#optimizers", "display_name": "Optimizers", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "optimizers", "priority": -1, "content": "Five optimizers are supported: pysot, tpe, hyper, opentuner and scikit. Different optimizers generate different checkpoints, and the optimal checkpoint is selected from all the optimizers enabled. Uncomment below section in PipeTuner config to enable an optimizer (e.g. tpe). Typically 2 or 3 optimizers can give satisfying results. Change max_iteration to control the number of iterations for each optimizer. bbo: problem_type_is_min: false job_batch_size: 1 optimizers: type1: name: &quot;pysot&quot; max_iteration: 100 redundancy: 1 batch_size: 1 # type2: # name: &quot;tpe&quot; # max_iteration: 100 # redundancy: 1 # batch_size: 1 \u2026 It is recommended that worker_number is set equal to the number of optimizers used. servers: server1: \u2026 worker_number: 2", "keywords": []}, {"id": 3605, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#output", "display_name": "Output", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "output", "priority": -1, "content": "After launching, pipeline outputs are saved in the below directory as an example. pipe-tuner-sample \u251c\u2500\u2500 output \u2502 \u251c\u2500\u2500 log_client_2023-08-23_16-39-36 \u2502 \u251c\u2500\u2500 log_server_2023-08-23_16-39-36 \u2502 \u251c\u2500\u2500 &lt;PipeTuner configname.yml&gt; \u2502 \u2514\u2500\u2500 &lt;PipeTuner configname.yml&gt;_output \u2502 \u251c\u2500\u2500 checkpoints \u2502 \u2502 \u251c\u2500\u2500DsAppRun_output_20230823_163959 \u2502 \u2502 \u251c\u2500\u2500DsAppRun_output_20230823_164106 \u2502 \u2502 \u2514\u2500\u2500\u2026 \u2502 \u2514\u2500\u2500 results \u2502 \u251c\u2500\u2500configs_08-23-2023_16-39-57 \u2502 \u2514\u2500\u2500&lt;PipeTuner configname.yml&gt;-2023-08-23_16-39-36_accuracy.csv \u2514\u2500\u2500\u2026 Explanation: log_client_2023-08-23_16-39-36 and log_server_2023-08-23_16-39-36 are log files for the server and client inside the PipeTuner container. &lt;PipeTuner config name.yml&gt; stores the automatically generated config files for the tuning Each checkpoint folder (e.g. DsAppRun_output_20230823_163959) stores a checkpoint with tuned parameters and accuracy metric of that iteration. Also, the folder has the log file (log_DsAppRun.log) which contains the output of DeepStream app. configs_08-23-2023_16-39-57 stores the automatically generated config files for pipeline components such as PGIE, tracker. &lt;PipeTuner config name.yml&gt;-2023-08-23_16-39-36_accuracy.csv is a csv file that stores the accuracy metric and parameter values of all the iterations. Here shows how the console output would look like: Installing dependencies... Installing dependencies (1/2) Installing dependencies (2/2) Launch BBO client... Launch BBO server... PipeTuner started successfully! !!!!! To stop tuning process in the middle, press CTRL+C !!!!! adding: DsAppServer (deflated 63%) 2024-03-19 08:09:52,108 root INFO seq_list: [&#x27;Retail_Synthetic_Cam01&#x27;, &#x27;Retail_Synthetic_Cam02&#x27;, &#x27;Retail_Synthetic_Cam03&#x27;, &#x27;Retail_Synthetic_Cam04&#x27;, &#x27;Retail_Synthetic_Cam05&#x27;, &#x27;Retail_Synthetic_Cam06&#x27;, &#x27;Retail_Synthetic_Cam07&#x27;, &#x27;Retail_Synthetic_Cam08&#x27;] 2024-03-19 08:09:52,169 root INFO Writing configs to &lt;path&gt;/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT_test.yml_output/results/configs_03-19-2024_08-09-52 2024-03-19 08:09:52,169 root INFO send backend init 2024-03-19 08:09:52,170 root INFO creating optimizers... 2024-03-19 08:09:52,170 root INFO done. created 2 * Serving Flask app &#x27;ds_bbo_frontend_server&#x27; * Debug mode: on 2024-03-19 08:09:52,186 root INFO init jobs done 2024-03-19 08:09:52,187 root INFO progress: 0% (0/4) 2024-03-19 08:09:52,193 root INFO wait backend ready ... 2024-03-19 08:12:15,232 root INFO progress: 25% (1/4) ETA 00:07:09 2024-03-19 08:12:25,447 root INFO progress: 25% (1/4) ETA 00:07:39 ... 2024-03-19 08:13:47,190 root INFO progress: 50% (2/4) ETA 00:03:55 2024-03-19 08:13:57,413 root INFO progress: 75% (3/4) ETA 00:01:21 ... 2024-03-19 08:14:58,719 root INFO progress: 100% (4/4) ETA 00:00:00 2024-03-19 08:14:58,720 root INFO OPTIMIZATION DONE! \u2026 stopping workers... number of workers to stop: 2 number of workers to stop: 0 done. !!!!! Press CTRL+C key to end PipeTuner !!!!! Check what containers are running by: $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 83b909fc0ddb nvcr.io/nvidia/pipetuner:1.0 &quot;/bin/bash&quot; 44 minutes ago Up 44 minutes tuner_2024-01-17_21-44-58 41e514acf177 nvcr.io/nfgnkvuikvjm/mdx-v2-0/mdx-perception:2.1 &quot;/opt/nvidia/nvidia_\u2026&quot; 44 minutes ago Up 44 minutes ds_2024-01-17_21-44-58 TensorRT engine files are generated during the first iteration, so it may take 10 to 30 minutes longer than the next iterations.", "keywords": []}, {"id": 3606, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#parameter-search-space", "display_name": "Parameter Search Space", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "parameter-search-space", "priority": -1, "content": "There are lots of parameters in PGIE, tracker and MTMC config files. The search space of each parameter is defined in PipeTuner config file as parameter_name: [ lower_bound, upper_bound (included), distribution, data_type ]. During each iteration, a value is generated in the search range and overwrites the original PGIE, tracker or MTMC config file provided. parameter_name must exist in the original config file. lower_bound, upper_bound must be within the feasible range of a parameter. If a parameter appears in the original config file, but not in PipeTuner config, its value will be fixed as the original value. Below is an example in PipeTuner config. Different use cases have different parameter search space. Feel free to add, change or remove the search space. More parameters and larger search ranges require more optimizers and longer iterations to run, but can give better results than small range. parameter_space: Init: \u2026 NvDCF: BaseConfig: minDetectorConfidence: [ 0,0.9,linear,real ] StateEstimator: processNoiseVar4Loc: [ 1,10000,linear,real ] \u2026 PGIE: &quot;[class-attrs-all]&quot;: nms-iou-threshold: [ 0.3,0.8,linear,real ] \u2026 MTMC: default: locationBboxBottomGapThresh: [0.01,0.05,linear,real ] \u2026", "keywords": []}, {"id": 3607, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#prerequisites", "display_name": "Prerequisites", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "prerequisites", "priority": -1, "content": "PipeTuner supports both NVIDIA DeepStream SDK and Metropolis Microservices. The setup and usage have some differences listed below. DeepStream users Metropolis Microservices users Which user group do I belong to? I only want to use DeepStream SDK I want to use Metropolis Microservices. I clicked \u201cDownload for Enterprise GPU\u201d and applied for access Containers Users have access to DeepStream container Users have access to Metropolis Standalone Deployment package and mdx-perception container Use Cases Only DeepStream perception pipeline tuning is supported Both DeepStream perception and MTMC pipeline tuning are supported", "keywords": []}, {"id": 3608, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#quick-start", "display_name": "Quick Start", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "quick-start", "priority": -1, "content": "PipeTuner searches the optimal parameters by iterating the following three steps until the accuracy KPI converges or up to the max number of iterations (i.e., epochs) specified: ParamSearch Given the accuracy KPI score in the previous iteration, make an educated guess on the set of parameters that would yield a higher accuracy KPI. For the very first iteration, a random sampling in the parameter space would be conducted PipeExec Given the sampled/guessed parameter set, execute the pipeline with the params and generates metadata to allow accuracy evaluation PipeEval Given the metadata outputs from the pipeline and the dataset, perform the accuracy evaluation based on the accuracy metric and generates accuracy KPI score The sample PipeTuner config files are included in pipe-tuner-sample/configs/config_PipeTuner to help users to get familiarized with the workflow, so that later they can come up with their custom pipeline with their own dataset. Currently three different types of pipelines are supported for tuning: DS-based Perception tuning MTMC tuning with frozen perception MTMC end-to-end (E2E) tuning Users are allowed to choose to employ different neural net models in DeepStream for the first and the third use case, for example, Object detector ResNet34-based PeopleNet Transformer-based PeopleNet ReID model ResNet50-based TAO ReID model SWIN Transformer ReID model The multi-object tracking (MOT) in DeepStream can use any of the tracker types in DeepStream, but for the MTMC perception, the NvDCF tracker is used as it has the highest accuracy and also it supports both camera image-based 2D tracking and Single-View 3D Tracking (more info can be found in the DeepStream documentation). The instructions with the sample data and pipeline below section are designed to walk through the entire tuning process step-by-step.", "keywords": []}, {"id": 3609, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#re-id", "display_name": "Re-ID", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "re-id", "priority": -1, "content": "Steps to customize a Re-ID model and use it in PipeTuner are: Refer to customizing a Re-ID model in DeepStream tracker. Place all the model resources under pipe-tuner-sample/models. pipe-tuner-sample models &lt;ETLT file&gt; &lt;ONNX file&gt; &lt;engine file&gt; \u2026 Create a new tracker config file as pipe-tuner-sample/configs/config_Tracker/&lt;new tracker config.yml&gt;, make sure below parameters match the absolute path of the new model. # for TAO model tltEncodedModel: &lt;path&gt;/pipe-tuner-sample/models/Tracker/&lt;ETLT file&gt; # for ONNX model onnxFile: &lt;path&gt;/pipe-tuner-sample/models/Tracker/&lt;ONNX file&gt; modelEngineFile: &lt;path&gt;/pipe-tuner-sample/models/Tracker/&lt;engine file&gt; Other parameters need changing based on the model architecture as well. Change trackerPath in PipeTuner config to match the path of the new tracker config. trackerPath: &quot;configs/config_Tracker/&lt;new Tracker config.yml&gt;&quot;", "keywords": []}, {"id": 3610, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#retrieve-and-visualize-tuning-results", "display_name": "Retrieve and Visualize Tuning Results", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "retrieve-and-visualize-tuning-results", "priority": -1, "content": "PipeTuner provides the following features to get the tuned parameters and results. Plot accuracy convergence graph Retrieve the optimal checkpoint All the commands below are executed under pipe-tuner-sample/scripts Usage : After launching tuning for a couple of iterations, run below command to retrieve the optimal results from checkpoints already generated: $ bash result_analysis.sh &lt;output folder&gt; &lt;metric&gt; Here &lt;output folder&gt; is the output directory created in \u201claunch tuning process\u201d step: pipe-tuner-sample/output/&lt;PipeTuner configname.yml&gt;_output, and &lt;metric&gt; should be the same as evaluation metric defined in PipeTuner config among MOTA, IDF1 and HOTA. For example, to retrieve the result for SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml, users can run the following command: $ bash result_analysis.sh ../output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/ HOTA Result analysis is saved in the below directory: pipe-tuner-sample \u251c\u2500\u2500 output \u2502 \u251c\u2500\u2500 \u2026 \u2502 \u2514\u2500\u2500 SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output \u2502 \u251c\u2500\u2500 \u2026 \u2502 \u2514\u2500\u2500 results \u2502 \u251c\u2500\u2500accuracy_plot.png \u2502 \u2514\u2500\u2500DsAppRun_output_20230823_163959 \u2514\u2500\u2500\u2026 Explanation : The copied checkpoint folder under pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/results/ (e.g. DsAppRun_output_20230823_163959) is the optimal checkpoint with tuned PGIE, tracker, DeepStream configs and accuracy metric, which is good for deployment. accuracy_plot.png is the accuracy metric vs iteration figure: Console output : storage: /media/sdb/pipe-tuner-sample Result analysis command: docker run --gpus all --rm -itd --net=host --name analysis_2023-08-23_16-53-39 -v /var/run/docker.sock:/var/run/docker.sock -v /media/sdb/pipe-tuner-sample:/media/sdb/pipe-tuner-sample nvcr.io/nvidia/pipetuner:1.0 /bin/bash -c &quot;python3 /pipe-tuner/utils/plot_csv_results.py /media/sdb/pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/results/*.csv /media/sdb/pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/results/accuracy_plot.png; python3 /pipe-tuner/utils/retrieve_checkpoints.py /media/sdb/pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output HOTA;&quot; Found optimal HOTA: 44.942 Checkpoint path: /media/sdb/pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/checkpoints/DsAppRun_output_20230823_163959 Optimal checkpoint copied to: /media/sdb/pipe-tuner-sample/output/SDG_sample_PeopleNet-ResNet34_NvDCF-ResNet50_MOT.yml_output/results/DsAppRun_output_20230823_163959 \u2026", "keywords": []}, {"id": 3611, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#sample-data-setup", "display_name": "Sample Data Setup", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "sample-data-setup", "priority": -1, "content": "The sample data consists of a mini-synthetic dataset with eight 1-minute streams and config files for tuning. You can download the sample files pipe-tuner-sample.zip from NGC web UI. Click three-dots under Actions, and click one option to download the file like below. Once you download the sample file, unzip the file and run setup.sh to finish sample data for either DeepStream or Metropolis Microservices. $ unzip pipe-tuner-sample.zip $ cd pipe-tuner-sample/scripts $ # DeepStream or Metropolis Microservices users should run only one of the following two commands based on their usage $ bash setup.sh deepstream # DeepStream users $ bash setup.sh metropolis # Metropolis Microservices users", "keywords": []}, {"id": 3612, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#single-view-3d-tracking", "display_name": "Single-View 3D Tracking", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "single-view-3d-tracking", "priority": -1, "content": "Sample config_Tracker/config_tracker_NvDCF_accuracy_ResNet50_3D.yml and config_Tracker/config_tracker_NvDCF_accuracy_SWIN_3D.yml already provide examples for single camera 3D tracking. They use the pre-generated camera matrix configs in config_CameraMatrix directory. When switching to a new dataset, users need to: Generate the new camera matrix configs following the steps in DeepStream document Update cameraModelFilepath in tracker config with the absolute path of the new camera matrix configs", "keywords": []}, {"id": 3613, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#stop-pipetuner", "display_name": "Stop PipeTuner", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "stop-pipetuner", "priority": -1, "content": "When the optimization ends, \u201c!!!!! Press CTRL+C key to end PipeTuner !!!!!\u201d is displayed on the console. PipeTuner can simply be stopped with pressing CTRL+C key. Pressing CTRL+C key stops the PipeTuner and the running docker containers. Also, the PipeTuner can be stopped with the keys in the middle of the optimization.The tuning results are still saved in the output directory. For example, !!!!! Press CTRL+C key to end PipeTuner !!!!! ^C Ctrl + C pressed! Stopping containers... tuner_2024-04-23_21-36-49 ds_2024-04-23_21-36-49 Containers stopped successfully PipeTuner ends (Optional) The launch.sh stops the docker images, but it doesn\u2019t remove them. If users want to remove the The downloaded containers, they can simply be removed with command docker rm -f [container names] . $ docker rm -f tuner_2024-01-17_21-44-58 ds_2024-01-17_21-44-58", "keywords": []}, {"id": 3614, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#system-requirements", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "system-requirements", "priority": -1, "content": "PipeTuner requires the following components on an x86_64 system: OS Ubuntu 22.04 NVIDIA driver 535.104 or 535.161 Docker - Setup instructions (need to run without sudo privilege - Instructions) NVIDIA container toolkit - Setup instructions", "keywords": []}, {"id": 3615, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#understanding-pipetuner-config-path", "display_name": "Understanding PipeTuner Config Path", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "understanding-pipetuner-config-path", "priority": -1, "content": "&lt;path&gt;/pipe-tuner-sample/ is the only folder mapped from host to all the containers. All the tuning related files must be placed in this folder when customizing tuning. During runtime, rootPath in PipeTuner config is automatically overwritten by the sample data folder\u2019s absolute path &lt;path&gt;/pipe-tuner-sample/. In PipeTuner config, all the other paths are the relative path to rootPath. For example, if seqmapPath is data/SDG_1min_utils/SDG_1min_all.txt, its absolute path is &lt;path&gt;/pipe-tuner-sample/data/SDG_1min_utils/SDG_1min_all.txt parameter_space: Init: Exec: \u2026 rootPath: &quot;overwritten as &lt;path&gt;/pipe-tuner-sample/ runtime&quot; datasetPath: &quot;data/SDG_1min_videos&quot; seqmapPath: &quot;data/SDG_1min_utils/SDG_1min_all.txt&quot; \u2026 In PGIE and tracker config, all the paths are absolute paths. They need to be manually updated to match the actual paths on the machine. Paths in other config files are automatically generated, so no need to change them.", "keywords": []}, {"id": 3616, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#use-in-ds-perception-tuning", "display_name": "Use in DS Perception Tuning", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "use-in-ds-perception-tuning", "priority": -1, "content": "Tune DS perception parameters on the augmented dataset, and use the tuned config files on normal dataset without augmentation. Fewer ID switches and higher accuracy metrics are observed than tuning without augmentation. To use an augmentation dataset for DS perception tuning, just change datasetPath in PipeTuner config to match the path of the augmented dataset. What the figure below shows is that even if the original dataset does not have such large full-occlusion cases (i.e., the white vertical pole in the middle), if the pipeline is tuned with the augmented dataset with longer full occlusions, then the pipeline is tuned in such a way that the tracking can be done robustly even with the prolonged occlusions which were not present in the original dataset.", "keywords": []}, {"id": 3617, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "page", "name": "text/Pipetuner-guide#video-generation", "display_name": "Video Generation", "type": "section", "display_type": "Page section", "docname": "text/Pipetuner-guide", "anchor": "video-generation", "priority": -1, "content": "To generate augmented videos, execute below command under pipe-tuner-sample/scripts: $ bash create_aug_videos.sh &lt;input video folder&gt; &lt;input video folder&gt;: a folder that contains videos to be used for data augmentation Example: $ bash create_aug_videos.sh ../data/SDG_1min_videos/ Augmented videos are saved in the below directory. pipe-tuner-sample data SDG_1min_videos_augmented Retail_Synthetic_Cam01.mp4 Retail_Synthetic_Cam02.mp4 \u2026 Retail_Synthetic_Cam01/ Retail_Synthetic_Cam02/ Interpretation: Retail_Synthetic_Cam&lt;num&gt;.mp4 are generated augmented videos like below. Folder Retail_Synthetic_Cam&lt;num&gt; contains the single camera MOT labels, which are the same as the original dataset. Console output: Launch command: docker run --gpus all -it --rm --net=host --privileged -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY= -v /media/sdb/pipe-tuner-sample:/media/sdb/pipe-tuner-sample pipe-tuner:latest /bin/bash /pipe-tuner/utils/launch_augmenter.sh /media/sdb/pipe-tuner-sample/data/SDG_1min_videos Augment /media/sdb/pipe-tuner-sample/data/SDG_1min_videos/Retail_Synthetic_Cam01.mp4 as /media/sdb/pipe-tuner-sample/data/SDG_1min_videos_augmented/Retail_Synthetic_Cam01.mp4 [VideoSource] Total # of frames = 1800 [VideoSource] Video frame rate = 30 fps [FrameSourceUtil] Frame source type = VIDEO OpenCV: FFMPEG: tag 0x34363248/&#x27;H264&#x27; is not supported with codec id 27 and format &#x27;mp4 / MP4 (MPEG-4 Part 14)&#x27; OpenCV: FFMPEG: fallback to use tag 0x31637661/&#x27;avc1&#x27; Wrote 0 frames among 1800 Wrote 100 frames among 1800 \u2026", "keywords": []}, {"id": 3618, "doc_id": 3618, "filename": "text/Pipetuner-guide.html", "domain_name": "std", "name": "text/Pipetuner-guide", "display_name": "Pipetuner Guide", "type": "doc", "display_type": "Page", "docname": "text/Pipetuner-guide", "anchor": "", "priority": -1, "content": "", "keywords": []}]};