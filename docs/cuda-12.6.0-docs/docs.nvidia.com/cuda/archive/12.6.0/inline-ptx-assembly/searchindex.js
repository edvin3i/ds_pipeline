const searchData = {"envversion": {"sphinx.domains.c": 2, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 5, "sphinx.domains.index": 1, "sphinx.domains.javascript": 2, "sphinx.domains.math": 2, "sphinx.domains.python": 3, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.mermaid": 1, "repo_docs.ext.enhanced_search": 2, "sphinx": 56}, "data": [{"id": 0, "doc_id": 0, "filename": "contents.html", "domain_name": "std", "name": "contents", "display_name": "Contents", "type": "doc", "display_type": "Page", "docname": "contents", "anchor": "", "priority": -1, "content": "Tuning Guide. Using Inline PTX Assembly in CUDA Assembler (ASM) Statements Parameters Constraints Pitfalls Namespace Conflicts Memory Space Conflicts Incorrect Optimization Incorrect PTX Error Checking Notices Notice OpenCL Trademarks", "keywords": []}, {"id": 1, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#assembler-asm-statements", "display_name": "Assembler (ASM) Statements", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "assembler-asm-statements", "priority": -1, "content": "Assembler statements, asm() , provide a way to insert arbitrary PTX code into your CUDA program. A simple example is: asm(&quot;membar.gl;&quot;); This inserts a PTX membar.gl into your generated PTX code at the point of the asm() statement.", "keywords": []}, {"id": 2, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#constraints", "display_name": "Constraints", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "constraints", "priority": -1, "content": "There is a separate constraint letter for each PTX register type: &quot;h&quot; = .u16 reg &quot;r&quot; = .u32 reg &quot;l&quot; = .u64 reg &quot;f&quot; = .f32 reg &quot;d&quot; = .f64 reg Example: asm(&quot;cvt.f32.s64 %0, %1;&quot; : &quot;=f&quot;(x) : &quot;l&quot;(y)); generates: ld.s64 rd1, [y]; cvt.f32.s64 f1, rd1; st.f32 [x], f1; The constraint &quot;n&quot; may be used for immediate integer operands with a known value. Example: asm(&quot;add.u32 %0, %0, %1;&quot; : &quot;=r&quot;(x) : &quot;n&quot;(42)); generates: add.u32 r1, r1, 42; The constraint &quot;C&quot; can be used for operand of type \u2018array of const char\u2019, where the array contents are known at compile time. It is intended to allow customization of PTX instruction modes based on compile time computation (see examples). Here is the specification for the &quot;C&quot; constraint: &#x27;C&#x27;(constant-expression) The constant-expression is evaluated during compilation and shall generate the address of a variable V , where: V has static storage duration . V has type \u2018array of const char\u2019. V is constant-initialized . If V is a static class member, then V \u2019s initializing declaration is the declaration within the class. During translation, the compiler will replace a reference to the operand within the Assembler Template with the contents of V \u2019s initializer, except for the last trailing zero. No constraint modifiers are allowed for this constraint. This constraint can only be used in device code. (terms in italics are C++ standard terms and/or terms from the GNU inline asm specification). Here\u2019s an example of the use of C constraint to generate different PTX instruction modes based on compile time computation: constexpr int mode_rz = 0; constexpr int mode_rn = 1; template &lt;int mode&gt; struct helper; template&lt;&gt; struct helper&lt;mode_rz&gt; { static constexpr const char mode[] = &quot;.rz&quot;; }; template&lt;&gt; struct helper&lt;mode_rn&gt; { static constexpr const char mode[] = &quot;.rn&quot;; }; template &lt;int rounding_mode&gt; __device__ float compute_add(float a, float b) { float result; asm (&quot;add.f32%1 %0,%2,%3;&quot; : &quot;=f&quot;(result) : &quot;C&quot;(helper&lt;rounding_mode&gt;::mode), &quot;f&quot;(a), &quot;f&quot;(b)); return result; } __global__ void kern(float *result, float a, float b) { *result++ = compute_add&lt;mode_rn&gt;(a,b); // generates add.f32.rn *result = compute_add&lt;mode_rz&gt;(a,b); // generates add.f32.rz } Other examples (compile in C++17 or later dialect): struct S1 { static constexpr char buf1[] = &quot;Jumped&quot;; static constexpr char buf2[] = {&#x27;O&#x27;, &#x27;v&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, 0}; }; template &lt;const char *p1, const char *p2, const char *p3&gt; __device__ void doit() { asm volatile (&quot;%0 %1 %2&quot; : : &quot;C&quot;(p1), &quot;C&quot;(p2), &quot;C&quot;(p3)); } struct S2 { static const char buf[]; }; const char S2::buf[] = &quot;this&quot;; const char buf3[] = &quot;Jumped&quot;; extern const char buf4[]; __global__ void foo() { static const char v1[] = &quot;The&quot;; static constexpr char v2[] = &quot;Quick&quot;; static const char v3[] = { &#x27;B&#x27; , &#x27;r&#x27; , &#x27;o&#x27;, &#x27;w&#x27;, &#x27;n&#x27;, 0 }; static constexpr char v4[] = { &#x27;F&#x27;, &#x27;o&#x27;, &#x27;x&#x27;, 0 }; //OK: generates &#x27;The Quick Brown Fox Jumped Over&#x27; in PTX asm volatile (&quot;%0 %1 %2 %3 %4 %5&quot; : : &quot;C&quot;(v1) , &quot;C&quot;(v2), &quot;C&quot;(v3), &quot;C&quot;(v4), &quot;C&quot;(S1::buf1), &quot;C&quot;(S1::buf2) ); //OK: generates &#x27;Brown Fox Jumped&#x27; in PTX doit&lt;v3, v4, buf3&gt;(); //error cases const char n1[] = &quot;hi&quot;; //error: argument to &quot;C&quot; constraint is not a constant expression asm volatile (&quot;%0&quot; :: &quot;C&quot;(n1)); //error: S2::buf was not initialized at point of declaration asm volatile (&quot;%0&quot; :: &quot;C&quot;(S2::buf)); //error: buf4 was not initialized asm volatile (&quot;%0&quot; :: &quot;C&quot;(buf4)); } There is no constraint letter for 8-bit wide PTX registers. PTX instructions types accepting 8-bit wide types permit operands to be wider than the instruction-type size . Example: __device__ void copy_u8(char* in, char* out) { int d; asm(&quot;ld.u8 %0, [%1];&quot; : &quot;=r&quot;(d) : &quot;l&quot;(in)); *out = d; } generates: ld.u8 r1, [rd1]; st.u8 [rd2], r1; The behavior of using a constraint string that is not one of those specified above is undefined.", "keywords": []}, {"id": 3, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#error-checking", "display_name": "Error Checking", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "error-checking", "priority": -1, "content": "The following are some of the error checks that the compiler will do on inlinePTXasm: Multiple constraint letters for a single asm operand are not allowed, e.g.: asm(&quot;add.s32 %0, %1, %2;&quot; : &quot;=r&quot;(i) : &quot;rf&quot;(j), &quot;r&quot;(k)); error: an asm operand may specify only one constraint letter in a __device__/__global__ function Only scalar variables are allowed as asm operands. Specifically aggregates like \u2018struct\u2019 type variables are not allowed, e.g. int4 i4; asm(&quot;add.s32 %0, %1, %2;&quot; : &quot;=r&quot;(i4) : &quot;r&quot;(j), &quot;r&quot;(k)); error: an asm operand must have scalar type The type and size implied by a PTX asm constraint must match that of the associated operand. Example where size does not match: For \u2018char\u2019 type variable \u201cci\u201d, asm(&quot;add.s32 %0,%1,%2;&quot;:&quot;=r&quot;(ci):&quot;r&quot;(j),&quot;r&quot;(k)); error: asm operand type size(1) does not match type/size implied by constraint \u2018r\u2019 In order to use \u2018char\u2019 type variables \u201cci\u201d, \u201ccj\u201d, and \u201cck\u201d in the above asm statement, code segment similar to the following may be used, int temp = ci; asm(&quot;add.s32 %0,%1,%2;&quot;:&quot;=r&quot;(temp):&quot;r&quot;((int)cj),&quot;r&quot;((int)ck)); ci = temp; Another example where type does not match: For \u2018float\u2019 type variable \u201cfi\u201d, asm(&quot;add.s32 %0,%1,%2;&quot;:&quot;=r&quot;(fi):&quot;r&quot;(j),&quot;r&quot;(k)); error: asm operand type size(4) does not match type/size implied by constraint \u2018r\u2019", "keywords": []}, {"id": 4, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#incorrect-optimization", "display_name": "Incorrect Optimization", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "incorrect-optimization", "priority": -1, "content": "The compiler assumes that an asm() statement has no side effects except to change the output operands. To ensure that the asm is not deleted or moved during generation of PTX, you should use the volatile keyword, e.g.: asm volatile (&quot;mov.u32 %0, %%clock;&quot; : &quot;=r&quot;(x)); Normally any memory that is written to will be specified as an out operand, but if there is a hidden side effect on user memory (for example, indirect access of a memory location via an operand), or if you want to stop any memory optimizations around the asm() statement performed during generation of PTX, you can add a \u201cmemory\u201d clobbers specification after a 3rd colon, e.g.: asm volatile (&quot;mov.u32 %0, %%clock;&quot; : &quot;=r&quot;(x) :: &quot;memory&quot;); asm (&quot;st.u32 [%0], %1;&quot; :: &quot;l&quot;(p), &quot;r&quot;(x) : &quot;memory&quot;);", "keywords": []}, {"id": 5, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#incorrect-ptx", "display_name": "Incorrect PTX", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "incorrect-ptx", "priority": -1, "content": "The compiler front end does not parse the asm() statement template string and does not know what it means or even whether it is valid PTX input. So if there are any errors in the string it will not show up until ptxas . For example, if you pass a value with an \u201cr\u201d constraint but use it in an add.f64 you will get a parse error from ptxas. Similarly, operand modifiers are not supported. For example, in asm(&quot;mov.u32 %0, %n1;&quot; : &quot;=r&quot;(n) : &quot;r&quot;(1)); the \u2018n\u2019 modifier in \u201c%n1\u201d is not supported and will be passed to ptxas , where it can cause undefined behavior. Refer to the document nvcc.pdf for further compiler related details.", "keywords": []}, {"id": 6, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#memory-space-conflicts", "display_name": "Memory Space Conflicts", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "memory-space-conflicts", "priority": -1, "content": "Since asm() statements have no way of knowing what memory space a register is in, the user must make sure that the appropriate PTX instruction is used. For sm_20 and greater, any pointer argument to an asm() statement is passed as a generic address.", "keywords": []}, {"id": 7, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#namespace-conflicts", "display_name": "Namespace Conflicts", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "namespace-conflicts", "priority": -1, "content": "If the cube function (described before) is called and inlined multiple times in the code, it generates an error about duplicate definitions of the temp register t1. To avoid this error you need to: not inline the cube function, or, nest the t1 use inside {} so that it has a separate scope for each invocation, e.g.: __device__ int cube (int x) { int y; asm(&quot;{\\n\\t&quot; // use braces for local scope &quot; reg .u32 t1;\\n\\t&quot; // temp reg t1, &quot; mul.lo.u32 t1, %1, %1;\\n\\t&quot; // t1 = x * x &quot; mul.lo.u32 %0, t1, %1;\\n\\t&quot; // y = t1 * x &quot;}&quot; : &quot;=r&quot;(y) : &quot;r&quot; (x)); return y; } Note that you can similarly use braces for local labels inside the asm() statement.", "keywords": []}, {"id": 8, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notice", "priority": -1, "content": "This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (\u201cNVIDIA\u201d) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (\u201cTerms of Sale\u201d). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer\u2019s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer\u2019s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer\u2019s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201cMATERIALS\u201d) ARE BEING PROVIDED \u201cAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA\u2019s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.", "keywords": []}, {"id": 9, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#opencl", "display_name": "OpenCL", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opencl", "priority": -1, "content": "OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.", "keywords": []}, {"id": 10, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#parameters", "display_name": "Parameters", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameters", "priority": -1, "content": "An asm() statement becomes more complicated, and more useful, when we pass values in and out of the asm. The basic syntax is as follows: asm(&quot;template-string&quot; : &quot;constraint&quot;(output) : &quot;constraint&quot;(input)); where you can have multiple input or output operands separated by commas. The template string contains PTX instructions with references to the operands. Multiple PTX instructions can be given by separating them with semicolons. A simple example is as follows: asm(&quot;add.s32 %0, %1, %2;&quot; : &quot;=r&quot;(i) : &quot;r&quot;(j), &quot;r&quot;(k)); Each %n in the template string is an index into the following list of operands, in text order. So %0 refers to the first operand, %1 to the second operand, and so on. Since the output operands are always listed ahead of the input operands, they are assigned the smallest indices. This example is conceptually equivalent to the following: add.s32 i, j, k; Note that the numbered references in the string can be in arbitrary order. The following is equivalent to the above example: asm(&quot;add.s32 %0, %2, %1;&quot; : &quot;=r&quot;(i) : &quot;r&quot;(k), &quot;r&quot;(j)); You can also repeat a reference, e.g.: asm(&quot;add.s32 %0, %1, %1;&quot; : &quot;=r&quot;(i) : &quot;r&quot;(k)); is conceptually add.s32 i, k, k; If there is no input operand, you can drop the final colon, e.g.: asm(&quot;mov.s32 %0, 2;&quot; : &quot;=r&quot;(i)); If there is no output operand, the colon separators are adjacent, e.g.: asm(&quot;mov.s32 r1, %0;&quot; :: &quot;r&quot;(i)); If you want the % in a ptx instruction, then you should escape it with double %% , e.g.: asm(&quot;mov.u32 %0, %%clock;&quot; : &quot;=r&quot;(x)); The above was simplified to explain the ordering of the string % references. In reality, the operand values are passed via whatever mechanism the constraint specifies. The full list of constraints will be explained later, but the \u201cr\u201d constraint refers to a 32bit integer register. So the earlier example asm() statement: asm(&quot;add.s32 %0, %1, %2;&quot; : &quot;=r&quot;(i) : &quot;r&quot;(j), &quot;r&quot;(k)); produces the following code sequence in the output generated by the compiler: ld.s32 r1, [j]; ld.s32 r2, [k]; add.s32 r3, r1, r2; st.s32 [i], r3; This is where the distinction between input and output operands becomes important. The input operands are loaded into registers before the asm() statement, then the result register is stored to the output operand. The \u201c=\u201d modifier in \u201c=r\u201d specifies that the register is written to. There is also available a \u201c+\u201d modifier that specifies the register is both read and written, e.g.: asm(&quot;add.s32 %0, %0, %1;&quot; : &quot;+r&quot;(i) : &quot;r&quot; (j)); Multiple instructions can be combined into a single asm() statement; basically, anything legal can be put into the asm string. Multiple instructions can be split across multiple lines by making use of C/C++\u2019s implicit string concatenation. Both C++ style line end comments \u201c//\u201d and classical C-style comments \u201c/**/\u201d can be interspersed with these strings. To generate readable output in the PTX intermediate file it is best practice to terminate each instruction string except the last one with \u201cnt\u201d. For example, a cube routine could be written as: __device__ int cube (int x) { int y; asm(&quot;.reg .u32 t1;\\n\\t&quot; // temp reg t1 &quot; mul.lo.u32 t1, %1, %1;\\n\\t&quot; // t1 = x * x &quot; mul.lo.u32 %0, t1, %1;&quot; // y = t1 * x : &quot;=r&quot;(y) : &quot;r&quot; (x)); return y; } If an output operand is conditionally updated by the asm instructions, then the \u201c+\u201d modifier should be used. There is an implicit use of the output operand in such a case. For example, __device__ int cond (int x) { int y = 0; asm(&quot;{\\n\\t&quot; &quot; .reg .pred %p;\\n\\t&quot; &quot; setp.eq.s32 %p, %1, 34;\\n\\t&quot; // x == 34? &quot; @%p mov.s32 %0, 1;\\n\\t&quot; // set y to 1 if true &quot;}&quot; // conceptually y = (x==34)?1:y : &quot;+r&quot;(y) : &quot;r&quot; (x)); return y; }", "keywords": []}, {"id": 11, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#pitfalls", "display_name": "Pitfalls", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "pitfalls", "priority": -1, "content": "Although asm() statements are very flexible and powerful, you may encounter some pitfalls\u2014these are listed in this section.", "keywords": []}, {"id": 12, "doc_id": 13, "filename": "index.html", "domain_name": "page", "name": "index#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trademarks", "priority": -1, "content": "NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "keywords": []}, {"id": 13, "doc_id": 13, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "Using Inline PTX Assembly in CUDA", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "Inline PTX Assembly in CUDA The reference guide for inlining PTX (parallel thread execution) assembly statements into CUDA. The NVIDIA \u00ae CUDA \u00ae programming environment provides a parallel thread execution (PTX) instruction set architecture (ISA) for using the GPU as a data-parallel computing device. For more information on the PTX ISA, refer to the latest version of the PTX ISA reference document . This application note describes how to inline PTX assembly language statements into CUDA code.", "keywords": []}]};