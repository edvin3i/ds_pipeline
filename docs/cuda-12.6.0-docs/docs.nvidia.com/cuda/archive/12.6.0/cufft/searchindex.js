const searchData = {"envversion": {"sphinx.domains.c": 2, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 5, "sphinx.domains.index": 1, "sphinx.domains.javascript": 2, "sphinx.domains.math": 2, "sphinx.domains.python": 3, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.mermaid": 1, "repo_docs.ext.enhanced_search": 2, "sphinx": 56}, "data": [{"id": 0, "doc_id": 0, "filename": "contents.html", "domain_name": "std", "name": "contents", "display_name": "Contents", "type": "doc", "display_type": "Page", "docname": "contents", "anchor": "", "priority": -1, "content": "Introduction Using the cuFFT API Accessing cuFFT Fourier Transform Setup Free Memory Requirement Plan Initialization Time Fourier Transform Types Half-precision cuFFT Transforms Bfloat16-precision cuFFT Transforms Data Layout Multidimensional Transforms Advanced Data Layout Streamed cuFFT Transforms Multiple GPU cuFFT Transforms Plan Specification and Work Areas Helper Functions Multiple GPU 2D and 3D Transforms on Permuted Input Supported Functionality cuFFT Callback Routines Overview of the cuFFT Callback Routine Feature Specifying Load and Store Callback Routines Callback Routine Function Details Coding Considerations for the cuFFT Callback Routine Feature No Ordering Guarantees Within a Kernel Thread Safety CUDA Graphs Support Static Library and Callback Support Static library without callback support Accuracy and Performance Caller Allocated Work Area Support cuFFT Link-Time Optimized Kernels Overview of the cuFFT Callback Routine Feature cuFFT API Reference Return value cufftResult cuFFT Basic Plans cufftPlan1d() cufftPlan2d() cufftPlan3d() cufftPlanMany() cuFFT Extensible Plans cufftCreate() cufftDestroy() cufftMakePlan1d() cufftMakePlan2d() cufftMakePlan3d() cufftMakePlanMany() cufftMakePlanMany64() cufftXtMakePlanMany() cuFFT Plan Properties cufftSetPlanPropertyInt64() cufftGetPlanPropertyInt64() cufftResetPlanProperty() cuFFT Estimated Size of Work Area cufftEstimate1d() cufftEstimate2d() cufftEstimate3d() cufftEstimateMany() cuFFT Refined Estimated Size of Work Area cufftGetSize1d() cufftGetSize2d() cufftGetSize3d() cufftGetSizeMany() cufftGetSizeMany64() cufftXtGetSizeMany() cufftGetSize() cuFFT Caller Allocated Work Area Support cufftSetAutoAllocation() cufftSetWorkArea() cufftXtSetWorkAreaPolicy() cuFFT Execution cufftExecC2C() and cufftExecZ2Z() cufftExecR2C() and cufftExecD2Z() cufftExecC2R() and cufftExecZ2D() cufftXtExec() cufftXtExecDescriptor() cuFFT and Multiple GPUs cufftXtSetGPUs() cufftXtSetWorkArea() cuFFT Multiple GPU Execution cufftXtExecDescriptorC2C() and cufftXtExecDescriptorZ2Z() cufftXtExecDescriptorR2C() and cufftXtExecDescriptorD2Z() cufftXtExecDescriptorC2R() and cufftXtExecDescriptorZ2D() Memory Allocation and Data Movement Functions cufftXtMalloc() Parameter cufftXtSubFormat cufftXtFree() cufftXtMemcpy() Parameter cufftXtCopyType General Multiple GPU Descriptor Types cudaXtDesc cudaLibXtDesc cuFFT Callbacks cufftXtSetCallback() cufftXtClearCallback() cufftXtSetCallbackSharedSize() cufftSetStream() cufftGetVersion() cufftGetProperty() cuFFT Types Parameter cufftType Parameters for Transform Direction Type definitions for callbacks Other cuFFT Types cufftHandle cufftReal cufftDoubleReal cufftComplex cufftDoubleComplex Common types cudaDataType libraryPropertyType cuFFT Code Examples Multiple GPU Data Organization Multiple GPU Data Organization for Batched Transforms Multiple GPU Data Organization for Single 2D and 3D Transforms Multiple-GPU Data Organization for Single 1D Transforms FFTW Conversion Guide FFTW Interface to cuFFT Deprecated Functionality Notices Notice OpenCL Trademarks", "keywords": []}, {"id": 1, "doc_id": 1, "filename": "deprecated-functionality.html", "domain_name": "std", "name": "deprecated-functionality", "display_name": "Deprecated Functionality", "type": "doc", "display_type": "Page", "docname": "deprecated-functionality", "anchor": "", "priority": -1, "content": "Starting from CUDA 12.0: GPU architectures SM35 and SM37 are no longer supported. The minimum required architecture is SM50. Starting from CUDA 11.8: CUDA Graphs capture is no longer supported for callback routines that load data in out-of-place mode transforms. An upcoming release will update the cuFFT callback implementation, removing this limitation. Starting from CUDA 11.4: Support for callback functionality using separately compiled device code is deprecated on all GPU architectures. Callback functionality will continue to be supported for all GPU architectures. Starting from CUDA 11.0: GPU architecture SM30 is no longer supported. The minimum required architecture is SM35. Support for GPU architectures SM35, SM37 (Kepler), and SM50, SM52 (Maxwell) is deprecated. Function cufftSetCompatibilityMode was removed in version 9.1.", "keywords": []}, {"id": 2, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftCreate", "display_name": "cufftCreate", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftCreate", "priority": 1, "content": "cufftResult  cufftCreate cufftHandle  * plan Creates only an opaque handle, and allocates small data structures on the host. The cufftMakePlan*() calls actually do the plan generation. Parameters plan[In] \u2013 Pointer to a cufftHandle object. plan[Out] \u2013 Contains a cuFFT plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_ALLOC_FAILED \u2013 The allocation of resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 3, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftCreate.plan", "display_name": "cufftCreate.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftCreate", "priority": 1, "content": "cufftResult  cufftCreate cufftHandle  * plan Creates only an opaque handle, and allocates small data structures on the host. The cufftMakePlan*() calls actually do the plan generation. Parameters plan[In] \u2013 Pointer to a cufftHandle object. plan[Out] \u2013 Contains a cuFFT plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_ALLOC_FAILED \u2013 The allocation of resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 4, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftDestroy", "display_name": "cufftDestroy", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftDestroy", "priority": 1, "content": "cufftResult  cufftDestroy cufftHandle  plan Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. This function should be called once a plan is no longer needed, to avoid wasting GPU memory. In the case of multi-GPU plans, the plan created first should be destroyed last. Parameters plan[In] \u2013 The cufftHandle object of the plan to be destroyed. Return values CUFFT_SUCCESS \u2013 cuFFT successfully destroyed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle.", "keywords": []}, {"id": 5, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftDestroy.plan", "display_name": "cufftDestroy.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftDestroy", "priority": 1, "content": "cufftResult  cufftDestroy cufftHandle  plan Frees all GPU resources associated with a cuFFT plan and destroys the internal plan data structure. This function should be called once a plan is no longer needed, to avoid wasting GPU memory. In the case of multi-GPU plans, the plan created first should be destroyed last. Parameters plan[In] \u2013 The cufftHandle object of the plan to be destroyed. Return values CUFFT_SUCCESS \u2013 cuFFT successfully destroyed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle.", "keywords": []}, {"id": 6, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate1d", "display_name": "cufftEstimate1d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftEstimate1d", "priority": 1, "content": "cufftResult  cufftEstimate1d int  nx cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftEstimateMany for multiple transforms. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 7, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate1d.batch", "display_name": "cufftEstimate1d.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate1d", "priority": 1, "content": "cufftResult  cufftEstimate1d int  nx cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftEstimateMany for multiple transforms. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 8, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate1d.nx", "display_name": "cufftEstimate1d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate1d", "priority": 1, "content": "cufftResult  cufftEstimate1d int  nx cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftEstimateMany for multiple transforms. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 9, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate1d.type", "display_name": "cufftEstimate1d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate1d", "priority": 1, "content": "cufftResult  cufftEstimate1d int  nx cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftEstimateMany for multiple transforms. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 10, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate1d.workSize", "display_name": "cufftEstimate1d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate1d", "priority": 1, "content": "cufftResult  cufftEstimate1d int  nx cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftEstimateMany for multiple transforms. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 11, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate2d", "display_name": "cufftEstimate2d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftEstimate2d", "priority": 1, "content": "cufftResult  cufftEstimate2d int  nx int  ny cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 12, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate2d.nx", "display_name": "cufftEstimate2d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate2d", "priority": 1, "content": "cufftResult  cufftEstimate2d int  nx int  ny cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 13, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate2d.ny", "display_name": "cufftEstimate2d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate2d", "priority": 1, "content": "cufftResult  cufftEstimate2d int  nx int  ny cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 14, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate2d.type", "display_name": "cufftEstimate2d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate2d", "priority": 1, "content": "cufftResult  cufftEstimate2d int  nx int  ny cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 15, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate2d.workSize", "display_name": "cufftEstimate2d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate2d", "priority": 1, "content": "cufftResult  cufftEstimate2d int  nx int  ny cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 16, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d", "display_name": "cufftEstimate3d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 17, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d.nx", "display_name": "cufftEstimate3d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 18, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d.ny", "display_name": "cufftEstimate3d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 19, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d.nz", "display_name": "cufftEstimate3d.nz", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 20, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d.type", "display_name": "cufftEstimate3d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 21, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimate3d.workSize", "display_name": "cufftEstimate3d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimate3d", "priority": 1, "content": "cufftResult  cufftEstimate3d int  nx int  ny int  nz cufftType  type size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Parameters nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 22, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany", "display_name": "cufftEstimateMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 23, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.batch", "display_name": "cufftEstimateMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 24, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.idist", "display_name": "cufftEstimateMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 25, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.inembed", "display_name": "cufftEstimateMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 26, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.istride", "display_name": "cufftEstimateMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 27, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.n", "display_name": "cufftEstimateMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 28, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.odist", "display_name": "cufftEstimateMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 29, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.onembed", "display_name": "cufftEstimateMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 30, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.ostride", "display_name": "cufftEstimateMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 31, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.rank", "display_name": "cufftEstimateMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 32, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.type", "display_name": "cufftEstimateMany.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 33, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftEstimateMany.workSize", "display_name": "cufftEstimateMany.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftEstimateMany", "priority": 1, "content": "cufftResult  cufftEstimateMany int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; During plan execution, cuFFT requires a work area for temporary storage of intermediate results. This call returns an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. The cufftEstimateMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . All arrays are assumed to be in CPU memory. Parameters rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size, in bytes, of the work space. *workSize[Out] \u2013 Pointer to the size of the work space Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 34, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2C", "display_name": "cufftExecC2C", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecC2C", "priority": 1, "content": "cufftResult  cufftExecC2C cufftHandle  plan cufftComplex  * idata cufftComplex  * odata int  direction ;", "keywords": []}, {"id": 35, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2C.direction", "display_name": "cufftExecC2C.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2C", "priority": 1, "content": "cufftResult  cufftExecC2C cufftHandle  plan cufftComplex  * idata cufftComplex  * odata int  direction ;", "keywords": []}, {"id": 36, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2C.idata", "display_name": "cufftExecC2C.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2C", "priority": 1, "content": "cufftResult  cufftExecC2C cufftHandle  plan cufftComplex  * idata cufftComplex  * odata int  direction ;", "keywords": []}, {"id": 37, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2C.odata", "display_name": "cufftExecC2C.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2C", "priority": 1, "content": "cufftResult  cufftExecC2C cufftHandle  plan cufftComplex  * idata cufftComplex  * odata int  direction ;", "keywords": []}, {"id": 38, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2C.plan", "display_name": "cufftExecC2C.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2C", "priority": 1, "content": "cufftResult  cufftExecC2C cufftHandle  plan cufftComplex  * idata cufftComplex  * odata int  direction ;", "keywords": []}, {"id": 39, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2R", "display_name": "cufftExecC2R", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecC2R", "priority": 1, "content": "cufftResult  cufftExecC2R cufftHandle  plan cufftComplex  * idata cufftReal  * odata ;", "keywords": []}, {"id": 40, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2R.idata", "display_name": "cufftExecC2R.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2R", "priority": 1, "content": "cufftResult  cufftExecC2R cufftHandle  plan cufftComplex  * idata cufftReal  * odata ;", "keywords": []}, {"id": 41, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2R.odata", "display_name": "cufftExecC2R.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2R", "priority": 1, "content": "cufftResult  cufftExecC2R cufftHandle  plan cufftComplex  * idata cufftReal  * odata ;", "keywords": []}, {"id": 42, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecC2R.plan", "display_name": "cufftExecC2R.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecC2R", "priority": 1, "content": "cufftResult  cufftExecC2R cufftHandle  plan cufftComplex  * idata cufftReal  * odata ;", "keywords": []}, {"id": 43, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecD2Z", "display_name": "cufftExecD2Z", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecD2Z", "priority": 1, "content": "cufftResult  cufftExecD2Z cufftHandle  plan cufftDoubleReal  * idata cufftDoubleComplex  * odata ; cufftExecR2C() ( cufftExecD2Z() ) executes a single-precision (double-precision) real-to-complex, implicitly forward, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. This function stores the nonredundant Fourier coefficients in the odata array. Pointers to idata and odata are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex data type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Note the data layout differences between in-place and out-of-place transforms as described in Parameter cufftType . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the real input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). odata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 44, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecD2Z.idata", "display_name": "cufftExecD2Z.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecD2Z", "priority": 1, "content": "cufftResult  cufftExecD2Z cufftHandle  plan cufftDoubleReal  * idata cufftDoubleComplex  * odata ; cufftExecR2C() ( cufftExecD2Z() ) executes a single-precision (double-precision) real-to-complex, implicitly forward, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. This function stores the nonredundant Fourier coefficients in the odata array. Pointers to idata and odata are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex data type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Note the data layout differences between in-place and out-of-place transforms as described in Parameter cufftType . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the real input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). odata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 45, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecD2Z.odata", "display_name": "cufftExecD2Z.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecD2Z", "priority": 1, "content": "cufftResult  cufftExecD2Z cufftHandle  plan cufftDoubleReal  * idata cufftDoubleComplex  * odata ; cufftExecR2C() ( cufftExecD2Z() ) executes a single-precision (double-precision) real-to-complex, implicitly forward, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. This function stores the nonredundant Fourier coefficients in the odata array. Pointers to idata and odata are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex data type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Note the data layout differences between in-place and out-of-place transforms as described in Parameter cufftType . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the real input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). odata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 46, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecD2Z.plan", "display_name": "cufftExecD2Z.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecD2Z", "priority": 1, "content": "cufftResult  cufftExecD2Z cufftHandle  plan cufftDoubleReal  * idata cufftDoubleComplex  * odata ; cufftExecR2C() ( cufftExecD2Z() ) executes a single-precision (double-precision) real-to-complex, implicitly forward, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. This function stores the nonredundant Fourier coefficients in the odata array. Pointers to idata and odata are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex data type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Note the data layout differences between in-place and out-of-place transforms as described in Parameter cufftType . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the real input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). odata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 47, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecR2C", "display_name": "cufftExecR2C", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecR2C", "priority": 1, "content": "cufftResult  cufftExecR2C cufftHandle  plan cufftReal  * idata cufftComplex  * odata ;", "keywords": []}, {"id": 48, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecR2C.idata", "display_name": "cufftExecR2C.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecR2C", "priority": 1, "content": "cufftResult  cufftExecR2C cufftHandle  plan cufftReal  * idata cufftComplex  * odata ;", "keywords": []}, {"id": 49, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecR2C.odata", "display_name": "cufftExecR2C.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecR2C", "priority": 1, "content": "cufftResult  cufftExecR2C cufftHandle  plan cufftReal  * idata cufftComplex  * odata ;", "keywords": []}, {"id": 50, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecR2C.plan", "display_name": "cufftExecR2C.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecR2C", "priority": 1, "content": "cufftResult  cufftExecR2C cufftHandle  plan cufftReal  * idata cufftComplex  * odata ;", "keywords": []}, {"id": 51, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2D", "display_name": "cufftExecZ2D", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecZ2D", "priority": 1, "content": "cufftResult  cufftExecZ2D cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleReal  * odata ; cufftExecC2R() ( cufftExecZ2D() ) executes a single-precision (double-precision) complex-to-real, implicitly inverse, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. The input array holds only the nonredundant complex Fourier coefficients. This function stores the real output values in the odata array. and pointers are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the real output data (in GPU memory). odata[Out] \u2013 Contains the real output data. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 52, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2D.idata", "display_name": "cufftExecZ2D.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2D", "priority": 1, "content": "cufftResult  cufftExecZ2D cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleReal  * odata ; cufftExecC2R() ( cufftExecZ2D() ) executes a single-precision (double-precision) complex-to-real, implicitly inverse, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. The input array holds only the nonredundant complex Fourier coefficients. This function stores the real output values in the odata array. and pointers are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the real output data (in GPU memory). odata[Out] \u2013 Contains the real output data. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 53, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2D.odata", "display_name": "cufftExecZ2D.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2D", "priority": 1, "content": "cufftResult  cufftExecZ2D cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleReal  * odata ; cufftExecC2R() ( cufftExecZ2D() ) executes a single-precision (double-precision) complex-to-real, implicitly inverse, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. The input array holds only the nonredundant complex Fourier coefficients. This function stores the real output values in the odata array. and pointers are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the real output data (in GPU memory). odata[Out] \u2013 Contains the real output data. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 54, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2D.plan", "display_name": "cufftExecZ2D.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2D", "priority": 1, "content": "cufftResult  cufftExecZ2D cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleReal  * odata ; cufftExecC2R() ( cufftExecZ2D() ) executes a single-precision (double-precision) complex-to-real, implicitly inverse, cuFFT transform plan. cuFFT uses as input data the GPU memory pointed to by the idata parameter. The input array holds only the nonredundant complex Fourier coefficients. This function stores the real output values in the odata array. and pointers are both required to be aligned to cufftComplex data type in single-precision transforms and cufftDoubleComplex type in double-precision transforms. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the real output data (in GPU memory). odata[Out] \u2013 Contains the real output data. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and odata is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 55, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2Z", "display_name": "cufftExecZ2Z", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftExecZ2Z", "priority": 1, "content": "cufftResult  cufftExecZ2Z cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleComplex  * odata int  direction ; cufftExecC2C() ( cufftExecZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by the idata parameter as input data. This function stores the Fourier coefficients in the odata array. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . odata[Out] \u2013 ontains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 56, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2Z.direction", "display_name": "cufftExecZ2Z.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2Z", "priority": 1, "content": "cufftResult  cufftExecZ2Z cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleComplex  * odata int  direction ; cufftExecC2C() ( cufftExecZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by the idata parameter as input data. This function stores the Fourier coefficients in the odata array. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . odata[Out] \u2013 ontains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 57, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2Z.idata", "display_name": "cufftExecZ2Z.idata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2Z", "priority": 1, "content": "cufftResult  cufftExecZ2Z cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleComplex  * odata int  direction ; cufftExecC2C() ( cufftExecZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by the idata parameter as input data. This function stores the Fourier coefficients in the odata array. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . odata[Out] \u2013 ontains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 58, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2Z.odata", "display_name": "cufftExecZ2Z.odata", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2Z", "priority": 1, "content": "cufftResult  cufftExecZ2Z cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleComplex  * odata int  direction ; cufftExecC2C() ( cufftExecZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by the idata parameter as input data. This function stores the Fourier coefficients in the odata array. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . odata[Out] \u2013 ontains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 59, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftExecZ2Z.plan", "display_name": "cufftExecZ2Z.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftExecZ2Z", "priority": 1, "content": "cufftResult  cufftExecZ2Z cufftHandle  plan cufftDoubleComplex  * idata cufftDoubleComplex  * odata int  direction ; cufftExecC2C() ( cufftExecZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by the idata parameter as input data. This function stores the Fourier coefficients in the odata array. If idata and odata are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . idata[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. odata[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . odata[Out] \u2013 ontains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 60, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetPlanPropertyInt64", "display_name": "cufftGetPlanPropertyInt64", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftGetPlanPropertyInt64 cufftHandle  plan cufftProperty  property long  long  int  * propertyValueInt64 ; Retrieves the property value identified by the key property associated with the cuFFT plan plan . The value for the property, which is a signed long long integer, is set in the address space pointed by propertyValueInt64 . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Pointer to the value to be set with the value of the property. Return values CUFFT_SUCCESS \u2013 cuFFT successfully retrieved the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported. CUFFT_INVALID_VALUE \u2013 Invalid property, or pointer propertyValueInt64 is null", "keywords": []}, {"id": 61, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetPlanPropertyInt64.plan", "display_name": "cufftGetPlanPropertyInt64.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftGetPlanPropertyInt64 cufftHandle  plan cufftProperty  property long  long  int  * propertyValueInt64 ; Retrieves the property value identified by the key property associated with the cuFFT plan plan . The value for the property, which is a signed long long integer, is set in the address space pointed by propertyValueInt64 . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Pointer to the value to be set with the value of the property. Return values CUFFT_SUCCESS \u2013 cuFFT successfully retrieved the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported. CUFFT_INVALID_VALUE \u2013 Invalid property, or pointer propertyValueInt64 is null", "keywords": []}, {"id": 62, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetPlanPropertyInt64.property", "display_name": "cufftGetPlanPropertyInt64.property", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftGetPlanPropertyInt64 cufftHandle  plan cufftProperty  property long  long  int  * propertyValueInt64 ; Retrieves the property value identified by the key property associated with the cuFFT plan plan . The value for the property, which is a signed long long integer, is set in the address space pointed by propertyValueInt64 . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Pointer to the value to be set with the value of the property. Return values CUFFT_SUCCESS \u2013 cuFFT successfully retrieved the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported. CUFFT_INVALID_VALUE \u2013 Invalid property, or pointer propertyValueInt64 is null", "keywords": []}, {"id": 63, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetPlanPropertyInt64.propertyValueInt64", "display_name": "cufftGetPlanPropertyInt64.propertyValueInt64", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftGetPlanPropertyInt64 cufftHandle  plan cufftProperty  property long  long  int  * propertyValueInt64 ; Retrieves the property value identified by the key property associated with the cuFFT plan plan . The value for the property, which is a signed long long integer, is set in the address space pointed by propertyValueInt64 . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Pointer to the value to be set with the value of the property. Return values CUFFT_SUCCESS \u2013 cuFFT successfully retrieved the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported. CUFFT_INVALID_VALUE \u2013 Invalid property, or pointer propertyValueInt64 is null", "keywords": []}, {"id": 64, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetProperty", "display_name": "cufftGetProperty", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetProperty", "priority": 1, "content": "cufftResult  cufftGetProperty libraryPropertyType  type int  * value ; Return in *value the number for the property described by type of the dynamically linked CUFFT library. Parameters type[In] \u2013 CUDA library property. value[Out] \u2013 Contains the integer value for the requested property. Return values CUFFT_SUCCESS \u2013 The property value was successfully returned. CUFFT_INVALID_TYPE \u2013 The property type is not recognized. CUFFT_INVALID_VALUE \u2013 value is NULL .", "keywords": []}, {"id": 65, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetProperty.type", "display_name": "cufftGetProperty.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetProperty", "priority": 1, "content": "cufftResult  cufftGetProperty libraryPropertyType  type int  * value ; Return in *value the number for the property described by type of the dynamically linked CUFFT library. Parameters type[In] \u2013 CUDA library property. value[Out] \u2013 Contains the integer value for the requested property. Return values CUFFT_SUCCESS \u2013 The property value was successfully returned. CUFFT_INVALID_TYPE \u2013 The property type is not recognized. CUFFT_INVALID_VALUE \u2013 value is NULL .", "keywords": []}, {"id": 66, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetProperty.value", "display_name": "cufftGetProperty.value", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetProperty", "priority": 1, "content": "cufftResult  cufftGetProperty libraryPropertyType  type int  * value ; Return in *value the number for the property described by type of the dynamically linked CUFFT library. Parameters type[In] \u2013 CUDA library property. value[Out] \u2013 Contains the integer value for the requested property. Return values CUFFT_SUCCESS \u2013 The property value was successfully returned. CUFFT_INVALID_TYPE \u2013 The property type is not recognized. CUFFT_INVALID_VALUE \u2013 value is NULL .", "keywords": []}, {"id": 67, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize", "display_name": "cufftGetSize", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSize", "priority": 1, "content": "cufftResult  cufftGetSize cufftHandle  plan size_t  * workSize ; Once plan generation has been done, either with the original API or the extensible API, this call returns the actual size of the work area required to support the plan. Callers who choose to manage work area allocation within their application must use this call after plan generation, and after any cufftSet*() calls subsequent to plan generation, if those calls might alter the required work space size. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 68, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize.plan", "display_name": "cufftGetSize.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize", "priority": 1, "content": "cufftResult  cufftGetSize cufftHandle  plan size_t  * workSize ; Once plan generation has been done, either with the original API or the extensible API, this call returns the actual size of the work area required to support the plan. Callers who choose to manage work area allocation within their application must use this call after plan generation, and after any cufftSet*() calls subsequent to plan generation, if those calls might alter the required work space size. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 69, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize.workSize", "display_name": "cufftGetSize.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize", "priority": 1, "content": "cufftResult  cufftGetSize cufftHandle  plan size_t  * workSize ; Once plan generation has been done, either with the original API or the extensible API, this call returns the actual size of the work area required to support the plan. Callers who choose to manage work area allocation within their application must use this call after plan generation, and after any cufftSet*() calls subsequent to plan generation, if those calls might alter the required work space size. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 70, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d", "display_name": "cufftGetSize1d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 71, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d.batch", "display_name": "cufftGetSize1d.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 72, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d.nx", "display_name": "cufftGetSize1d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 73, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d.plan", "display_name": "cufftGetSize1d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 74, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d.type", "display_name": "cufftGetSize1d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 75, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize1d.workSize", "display_name": "cufftGetSize1d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize1d", "priority": 1, "content": "cufftResult  cufftGetSize1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate1d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftGetSizeMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx parameter is not a supported size.", "keywords": []}, {"id": 76, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d", "display_name": "cufftGetSize2d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 77, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d.nx", "display_name": "cufftGetSize2d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 78, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d.ny", "display_name": "cufftGetSize2d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 79, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d.plan", "display_name": "cufftGetSize2d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 80, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d.type", "display_name": "cufftGetSize2d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 81, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize2d.workSize", "display_name": "cufftGetSize2d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize2d", "priority": 1, "content": "cufftResult  cufftGetSize2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate2d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension (number of rows). ny[In] \u2013 The transform size in the y dimension (number of columns). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 82, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d", "display_name": "cufftGetSize3d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 83, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.nx", "display_name": "cufftGetSize3d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 84, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.ny", "display_name": "cufftGetSize3d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 85, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.nz", "display_name": "cufftGetSize3d.nz", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 86, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.plan", "display_name": "cufftGetSize3d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 87, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.type", "display_name": "cufftGetSize3d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 88, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSize3d.workSize", "display_name": "cufftGetSize3d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSize3d", "priority": 1, "content": "cufftResult  cufftGetSize3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimate3d() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work space. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 89, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany", "display_name": "cufftGetSizeMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 90, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.batch", "display_name": "cufftGetSizeMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 91, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.idist", "display_name": "cufftGetSizeMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 92, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.inembed", "display_name": "cufftGetSizeMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 93, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.istride", "display_name": "cufftGetSizeMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 94, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.n", "display_name": "cufftGetSizeMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 95, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.odist", "display_name": "cufftGetSizeMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 96, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.onembed", "display_name": "cufftGetSizeMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 97, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.ostride", "display_name": "cufftGetSizeMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 98, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.plan", "display_name": "cufftGetSizeMany.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 99, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.rank", "display_name": "cufftGetSizeMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 100, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.type", "display_name": "cufftGetSizeMany.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 101, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany.workSize", "display_name": "cufftGetSizeMany.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany", "priority": 1, "content": "cufftResult  cufftGetSizeMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 102, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64", "display_name": "cufftGetSizeMany64", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 103, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.batch", "display_name": "cufftGetSizeMany64.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 104, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.idist", "display_name": "cufftGetSizeMany64.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 105, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.inembed", "display_name": "cufftGetSizeMany64.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 106, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.istride", "display_name": "cufftGetSizeMany64.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 107, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.n", "display_name": "cufftGetSizeMany64.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 108, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.odist", "display_name": "cufftGetSizeMany64.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 109, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.onembed", "display_name": "cufftGetSizeMany64.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 110, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.ostride", "display_name": "cufftGetSizeMany64.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 111, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.plan", "display_name": "cufftGetSizeMany64.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 112, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.rank", "display_name": "cufftGetSizeMany64.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 113, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.type", "display_name": "cufftGetSizeMany64.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 114, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetSizeMany64.workSize", "display_name": "cufftGetSizeMany64.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetSizeMany64", "priority": 1, "content": "cufftResult  cufftGetSizeMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters, and taking into account any plan settings that may have been made. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose total size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose total size exceeds 4G elements, the fastest changing dimension must be even. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 115, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetVersion", "display_name": "cufftGetVersion", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftGetVersion", "priority": 1, "content": "cufftResult  cufftGetVersion int  * version ; Returns the version number of cuFFT. Parameters *version[In] \u2013 Pointer to the version number. *version[Out] \u2013 Contains the version number. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the version number.", "keywords": []}, {"id": 116, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftGetVersion.version", "display_name": "cufftGetVersion.version", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftGetVersion", "priority": 1, "content": "cufftResult  cufftGetVersion int  * version ; Returns the version number of cuFFT. Parameters *version[In] \u2013 Pointer to the version number. *version[Out] \u2013 Contains the version number. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the version number.", "keywords": []}, {"id": 117, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftHandle", "display_name": "cufftHandle", "type": "type", "display_type": "C type", "docname": "index", "anchor": "c.cufftHandle", "priority": 1, "content": "type  cufftHandle A handle type used to store and access cuFFT plans. The user receives a handle after creating a cuFFT plan and uses this handle to execute the plan. typedef unsigned int cufftHandle;", "keywords": []}, {"id": 118, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d", "display_name": "cufftMakePlan1d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 119, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d.batch", "display_name": "cufftMakePlan1d.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 120, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d.nx", "display_name": "cufftMakePlan1d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 121, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d.plan", "display_name": "cufftMakePlan1d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 122, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d.type", "display_name": "cufftMakePlan1d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 123, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan1d.workSize", "display_name": "cufftMakePlan1d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan1d", "priority": 1, "content": "cufftResult  cufftMakePlan1d cufftHandle  plan int  nx cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). For multiple GPUs, this must be a power of 2. type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). For multiple GPUs this must be a complex to complex transform. batch[In] \u2013 Number of transforms of size nx . Please consider using cufftMakePlanMany for multiple transforms. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED` \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 124, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d", "display_name": "cufftMakePlan2d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 125, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d.nx", "display_name": "cufftMakePlan2d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 126, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d.ny", "display_name": "cufftMakePlan2d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 127, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d.plan", "display_name": "cufftMakePlan2d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 128, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d.type", "display_name": "cufftMakePlan2d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 129, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan2d.workSize", "display_name": "cufftMakePlan2d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan2d", "priority": 1, "content": "cufftResult  cufftMakePlan2d cufftHandle  plan int  nx int  ny cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). For 2 GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 130, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d", "display_name": "cufftMakePlan3d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 131, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.nx", "display_name": "cufftMakePlan3d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 132, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.ny", "display_name": "cufftMakePlan3d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 133, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.nz", "display_name": "cufftMakePlan3d.nz", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 134, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.plan", "display_name": "cufftMakePlan3d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 135, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.type", "display_name": "cufftMakePlan3d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 136, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlan3d.workSize", "display_name": "cufftMakePlan3d.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlan3d", "priority": 1, "content": "cufftResult  cufftMakePlan3d cufftHandle  plan int  nx int  ny int  nz cufftType  type size_t  * workSize ; Following a call to cufftCreate() makes a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. ny[In] \u2013 The transform size in the y dimension. For multiple GPUs, this must be factorable into primes less than or equal to 127. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). For multiple GPUs, this must be factorable into primes less than or equal to 127. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work area(s). Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 137, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany", "display_name": "cufftMakePlanMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 138, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.batch", "display_name": "cufftMakePlanMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 139, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.idist", "display_name": "cufftMakePlanMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 140, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.inembed", "display_name": "cufftMakePlanMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 141, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.istride", "display_name": "cufftMakePlanMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 142, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.n", "display_name": "cufftMakePlanMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 143, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.odist", "display_name": "cufftMakePlanMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 144, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.onembed", "display_name": "cufftMakePlanMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 145, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.ostride", "display_name": "cufftMakePlanMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 146, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.plan", "display_name": "cufftMakePlanMany.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 147, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.rank", "display_name": "cufftMakePlanMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 148, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.type", "display_name": "cufftMakePlanMany.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 149, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany.workSize", "display_name": "cufftMakePlanMany.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany", "priority": 1, "content": "cufftResult  cufftMakePlanMany cufftHandle  plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3) n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension | idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data | onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. | ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension | odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data | type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 150, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64", "display_name": "cufftMakePlanMany64", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 151, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.batch", "display_name": "cufftMakePlanMany64.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 152, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.idist", "display_name": "cufftMakePlanMany64.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 153, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.inembed", "display_name": "cufftMakePlanMany64.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 154, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.istride", "display_name": "cufftMakePlanMany64.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 155, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.n", "display_name": "cufftMakePlanMany64.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 156, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.odist", "display_name": "cufftMakePlanMany64.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 157, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.onembed", "display_name": "cufftMakePlanMany64.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 158, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.ostride", "display_name": "cufftMakePlanMany64.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 159, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.plan", "display_name": "cufftMakePlanMany64.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 160, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.rank", "display_name": "cufftMakePlanMany64.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 161, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.type", "display_name": "cufftMakePlanMany64.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 162, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftMakePlanMany64.workSize", "display_name": "cufftMakePlanMany64.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftMakePlanMany64", "priority": 1, "content": "cufftResult  cufftMakePlanMany64 cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist long  long  int  * onembed long  long  int  ostride long  long  int  odist cufftType  type long  long  int  batch size_t  * workSize ; Following a call to cufftCreate() makes a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. This API is identical to cufftMakePlanMany except that the arguments specifying sizes and strides are 64 bit integers. This API makes very large transforms possible. cuFFT includes kernels that use 32 bit indexes, and kernels that use 64 bit indexes. cuFFT planning selects 32 bit kernels whenever possible to avoid any overhead due to 64 bit arithmetic. All sizes and types of transform are supported by this interface, with two exceptions. For transforms whose size exceeds 4G elements, the dimensions specified in the array n must be factorable into primes that are less than or equal to 127. For real to complex and complex to real transforms whose size exceeds 4G elements, the fastest changing dimension must be even. The cufftPlanMany64() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). For 2 GPUs this must be a complex to complex transform. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked or multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 163, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan1d", "display_name": "cufftPlan1d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftPlan1d", "priority": 1, "content": "cufftResult  cufftPlan1d cufftHandle  * plan int  nx cufftType  type int  batch ; Creates a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftPlanMany for multiple transforms. plan[Out] \u2013 Contains a cuFFT 1D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 164, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan1d.batch", "display_name": "cufftPlan1d.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan1d", "priority": 1, "content": "cufftResult  cufftPlan1d cufftHandle  * plan int  nx cufftType  type int  batch ; Creates a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftPlanMany for multiple transforms. plan[Out] \u2013 Contains a cuFFT 1D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 165, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan1d.nx", "display_name": "cufftPlan1d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan1d", "priority": 1, "content": "cufftResult  cufftPlan1d cufftHandle  * plan int  nx cufftType  type int  batch ; Creates a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftPlanMany for multiple transforms. plan[Out] \u2013 Contains a cuFFT 1D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 166, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan1d.plan", "display_name": "cufftPlan1d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan1d", "priority": 1, "content": "cufftResult  cufftPlan1d cufftHandle  * plan int  nx cufftType  type int  batch ; Creates a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftPlanMany for multiple transforms. plan[Out] \u2013 Contains a cuFFT 1D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 167, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan1d.type", "display_name": "cufftPlan1d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan1d", "priority": 1, "content": "cufftResult  cufftPlan1d cufftHandle  * plan int  nx cufftType  type int  batch ; Creates a 1D FFT plan configuration for a specified signal size and data type. The batch input parameter tells cuFFT how many 1D transforms to configure. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size (e.g. 256 for a 256-point FFT). type[In] \u2013 The transform data type (e.g., CUFFT_C2C for single precision complex to complex). batch[In] \u2013 Number of transforms of size nx . Please consider using cufftPlanMany for multiple transforms. plan[Out] \u2013 Contains a cuFFT 1D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 The nx or batch parameter is not a supported size.", "keywords": []}, {"id": 168, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan2d", "display_name": "cufftPlan2d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftPlan2d", "priority": 1, "content": "cufftResult  cufftPlan2d cufftHandle  * plan int  nx int  ny cufftType  type ; Creates a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). plan[Out] \u2013 Contains a cuFFT 2D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 169, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan2d.nx", "display_name": "cufftPlan2d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan2d", "priority": 1, "content": "cufftResult  cufftPlan2d cufftHandle  * plan int  nx int  ny cufftType  type ; Creates a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). plan[Out] \u2013 Contains a cuFFT 2D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 170, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan2d.ny", "display_name": "cufftPlan2d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan2d", "priority": 1, "content": "cufftResult  cufftPlan2d cufftHandle  * plan int  nx int  ny cufftType  type ; Creates a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). plan[Out] \u2013 Contains a cuFFT 2D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 171, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan2d.plan", "display_name": "cufftPlan2d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan2d", "priority": 1, "content": "cufftResult  cufftPlan2d cufftHandle  * plan int  nx int  ny cufftType  type ; Creates a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). plan[Out] \u2013 Contains a cuFFT 2D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 172, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan2d.type", "display_name": "cufftPlan2d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan2d", "priority": 1, "content": "cufftResult  cufftPlan2d cufftHandle  * plan int  nx int  ny cufftType  type ; Creates a 2D FFT plan configuration according to specified signal sizes and data type. This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_C2R for single precision complex to real). plan[Out] \u2013 Contains a cuFFT 2D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 Either or both of the nx or ny parameters is not a supported size.", "keywords": []}, {"id": 173, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d", "display_name": "cufftPlan3d", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 174, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d.nx", "display_name": "cufftPlan3d.nx", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 175, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d.ny", "display_name": "cufftPlan3d.ny", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 176, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d.nz", "display_name": "cufftPlan3d.nz", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 177, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d.plan", "display_name": "cufftPlan3d.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 178, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlan3d.type", "display_name": "cufftPlan3d.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlan3d", "priority": 1, "content": "cufftResult  cufftPlan3d cufftHandle  * plan int  nx int  ny int  nz cufftType  type ; Creates a 3D FFT plan configuration according to specified signal sizes and data type. This function is the same as cufftPlan2d() except that it takes a third size parameter nz . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. nx[In] \u2013 The transform size in the x dimension. This is slowest changing dimension of a transform (strided in memory). ny[In] \u2013 The transform size in the y dimension. nz[In] \u2013 The transform size in the z dimension. This is fastest changing dimension of a transform (contiguous in memory). type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). plan[Out] \u2013 Contains a cuFFT 3D plan handle value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the nx , ny , or nz parameters is not a supported size.", "keywords": []}, {"id": 179, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany", "display_name": "cufftPlanMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 180, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.batch", "display_name": "cufftPlanMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 181, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.idist", "display_name": "cufftPlanMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 182, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.inembed", "display_name": "cufftPlanMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 183, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.istride", "display_name": "cufftPlanMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 184, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.n", "display_name": "cufftPlanMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 185, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.odist", "display_name": "cufftPlanMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 186, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.onembed", "display_name": "cufftPlanMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 187, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.ostride", "display_name": "cufftPlanMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 188, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.plan", "display_name": "cufftPlanMany.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 189, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.rank", "display_name": "cufftPlanMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 190, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftPlanMany.type", "display_name": "cufftPlanMany.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftPlanMany", "priority": 1, "content": "cufftResult  cufftPlanMany cufftHandle  * plan int  rank int  * n int  * inembed int  istride int  idist int  * onembed int  ostride int  odist cufftType  type int  batch ; Creates a FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. The cufftPlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. All arrays are assumed to be in CPU memory. Please note that behavior of cufftPlanMany function when inembed and onembed is NULL is different than corresponding function in FFTW library fftw_plan_many_dft . This call can only be used once for a given handle. It will fail and return CUFFT_INVALID_PLAN if the plan is locked, i.e. the handle was previously used with a different cufftPlan or cufftMakePlan call. Parameters plan[In] \u2013 Pointer to a cufftHandle object. rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. type[In] \u2013 The transform data type (e.g., CUFFT_R2C for single precision real to complex). batch[In] \u2013 Batch size for this transform. plan[Out] \u2013 Contains a cuFFT plan handle. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when the plan is locked. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 191, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftResetPlanProperty", "display_name": "cufftResetPlanProperty", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftResetPlanProperty", "priority": 1, "content": "cufftResult  cufftResetPlanProperty cufftHandle  plan cufftProperty  property ; Resets the value of the property identified by the key property , associated with the cuFFT plan plan , to its default value. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . Return values CUFFT_SUCCESS \u2013 cuFFT successfully reset the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported for plan , or cannot be reset at present time (see Behavior column on cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property", "keywords": []}, {"id": 192, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftResetPlanProperty.plan", "display_name": "cufftResetPlanProperty.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftResetPlanProperty", "priority": 1, "content": "cufftResult  cufftResetPlanProperty cufftHandle  plan cufftProperty  property ; Resets the value of the property identified by the key property , associated with the cuFFT plan plan , to its default value. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . Return values CUFFT_SUCCESS \u2013 cuFFT successfully reset the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported for plan , or cannot be reset at present time (see Behavior column on cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property", "keywords": []}, {"id": 193, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftResetPlanProperty.property", "display_name": "cufftResetPlanProperty.property", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftResetPlanProperty", "priority": 1, "content": "cufftResult  cufftResetPlanProperty cufftHandle  plan cufftProperty  property ; Resets the value of the property identified by the key property , associated with the cuFFT plan plan , to its default value. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . Return values CUFFT_SUCCESS \u2013 cuFFT successfully reset the property value. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported for plan , or cannot be reset at present time (see Behavior column on cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property", "keywords": []}, {"id": 194, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetAutoAllocation", "display_name": "cufftSetAutoAllocation", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftSetAutoAllocation", "priority": 1, "content": "cufftResult  cufftSetAutoAllocation cufftHandle  plan int  autoAllocate ; cufftSetAutoAllocation() indicates that the caller intends to allocate and manage work areas for plans that have been generated. cuFFT default behavior is to allocate the work area at plan generation time. If cufftSetAutoAllocation() has been called with autoAllocate set to 0 (\u201cfalse\u201d) prior to one of the cufftMakePlan*() calls, cuFFT does not allocate the work area. This is the preferred sequence for callers wishing to manage work area allocation. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . autoAllocate[In] \u2013 Indicates whether to allocate work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 195, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetAutoAllocation.autoAllocate", "display_name": "cufftSetAutoAllocation.autoAllocate", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetAutoAllocation", "priority": 1, "content": "cufftResult  cufftSetAutoAllocation cufftHandle  plan int  autoAllocate ; cufftSetAutoAllocation() indicates that the caller intends to allocate and manage work areas for plans that have been generated. cuFFT default behavior is to allocate the work area at plan generation time. If cufftSetAutoAllocation() has been called with autoAllocate set to 0 (\u201cfalse\u201d) prior to one of the cufftMakePlan*() calls, cuFFT does not allocate the work area. This is the preferred sequence for callers wishing to manage work area allocation. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . autoAllocate[In] \u2013 Indicates whether to allocate work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 196, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetAutoAllocation.plan", "display_name": "cufftSetAutoAllocation.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetAutoAllocation", "priority": 1, "content": "cufftResult  cufftSetAutoAllocation cufftHandle  plan int  autoAllocate ; cufftSetAutoAllocation() indicates that the caller intends to allocate and manage work areas for plans that have been generated. cuFFT default behavior is to allocate the work area at plan generation time. If cufftSetAutoAllocation() has been called with autoAllocate set to 0 (\u201cfalse\u201d) prior to one of the cufftMakePlan*() calls, cuFFT does not allocate the work area. This is the preferred sequence for callers wishing to manage work area allocation. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . autoAllocate[In] \u2013 Indicates whether to allocate work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 197, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetPlanPropertyInt64", "display_name": "cufftSetPlanPropertyInt64", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftSetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftSetPlanPropertyInt64 cufftHandle  plan cufftProperty  property const  long  long  int  propertyValueInt64 ; Associates a cuFFT plan with a property identified by the key property . The value for the property is given by value propertyValueInt64 , which is a signed long long integer. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Value to set for the property, a long long signed integer. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the property. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported, or it cannot be set at the time (e.g. some properties cannot be set after calling a planning routine for the plan, see cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property or value with which to set the property", "keywords": []}, {"id": 198, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetPlanPropertyInt64.plan", "display_name": "cufftSetPlanPropertyInt64.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftSetPlanPropertyInt64 cufftHandle  plan cufftProperty  property const  long  long  int  propertyValueInt64 ; Associates a cuFFT plan with a property identified by the key property . The value for the property is given by value propertyValueInt64 , which is a signed long long integer. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Value to set for the property, a long long signed integer. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the property. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported, or it cannot be set at the time (e.g. some properties cannot be set after calling a planning routine for the plan, see cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property or value with which to set the property", "keywords": []}, {"id": 199, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetPlanPropertyInt64.property", "display_name": "cufftSetPlanPropertyInt64.property", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftSetPlanPropertyInt64 cufftHandle  plan cufftProperty  property const  long  long  int  propertyValueInt64 ; Associates a cuFFT plan with a property identified by the key property . The value for the property is given by value propertyValueInt64 , which is a signed long long integer. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Value to set for the property, a long long signed integer. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the property. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported, or it cannot be set at the time (e.g. some properties cannot be set after calling a planning routine for the plan, see cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property or value with which to set the property", "keywords": []}, {"id": 200, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetPlanPropertyInt64.propertyValueInt64", "display_name": "cufftSetPlanPropertyInt64.propertyValueInt64", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetPlanPropertyInt64", "priority": 1, "content": "cufftResult  cufftSetPlanPropertyInt64 cufftHandle  plan cufftProperty  property const  long  long  int  propertyValueInt64 ; Associates a cuFFT plan with a property identified by the key property . The value for the property is given by value propertyValueInt64 , which is a signed long long integer. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . property[In] \u2013 The property identifier, of type cufftPlanProperty . propertyValueInt64[In] \u2013 Value to set for the property, a long long signed integer. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the property. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_NOT_SUPPORTED \u2013 The property is not supported, or it cannot be set at the time (e.g. some properties cannot be set after calling a planning routine for the plan, see cuFFT Plan Properties ). CUFFT_INVALID_VALUE \u2013 Invalid property or value with which to set the property", "keywords": []}, {"id": 201, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetStream", "display_name": "cufftSetStream", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftSetStream", "priority": 1, "content": "cufftResult  cufftSetStream cufftHandle  plan cudaStream_t  stream ; Associates a CUDA stream with a cuFFT plan. All kernel launches made during plan execution are now done through the associated stream, enabling overlap with activity in other streams (e.g. data copying). The association remains until the plan is destroyed or the stream is changed with another call to cufftSetStream() . Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. For previous versions of cuFFT, cufftSetStream() will return an error in multiple GPU plans. Note that starting from CUDA 12.2 (cuFFT 11.0.8), on multi-GPU plans, stream can be associated with any context on any GPU. However, repeated calls to cufftSetStream() with streams from different contexts incur a small time penalty. Optimal performance is obtained when repeated calls to cufftSetStream use streams from the same CUDA context. Parameters plan[In] \u2013 The cufftHandle object to associate with the stream. stream[In] \u2013 A valid CUDA stream created with cudaStreamCreate() ; 0 for the default stream. Return values CUFFT_SUCCESS \u2013 The stream was associated with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or plan is multi-gpu in cuFFT version prior to 10.4.0.", "keywords": []}, {"id": 202, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetStream.plan", "display_name": "cufftSetStream.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetStream", "priority": 1, "content": "cufftResult  cufftSetStream cufftHandle  plan cudaStream_t  stream ; Associates a CUDA stream with a cuFFT plan. All kernel launches made during plan execution are now done through the associated stream, enabling overlap with activity in other streams (e.g. data copying). The association remains until the plan is destroyed or the stream is changed with another call to cufftSetStream() . Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. For previous versions of cuFFT, cufftSetStream() will return an error in multiple GPU plans. Note that starting from CUDA 12.2 (cuFFT 11.0.8), on multi-GPU plans, stream can be associated with any context on any GPU. However, repeated calls to cufftSetStream() with streams from different contexts incur a small time penalty. Optimal performance is obtained when repeated calls to cufftSetStream use streams from the same CUDA context. Parameters plan[In] \u2013 The cufftHandle object to associate with the stream. stream[In] \u2013 A valid CUDA stream created with cudaStreamCreate() ; 0 for the default stream. Return values CUFFT_SUCCESS \u2013 The stream was associated with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or plan is multi-gpu in cuFFT version prior to 10.4.0.", "keywords": []}, {"id": 203, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetStream.stream", "display_name": "cufftSetStream.stream", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetStream", "priority": 1, "content": "cufftResult  cufftSetStream cufftHandle  plan cudaStream_t  stream ; Associates a CUDA stream with a cuFFT plan. All kernel launches made during plan execution are now done through the associated stream, enabling overlap with activity in other streams (e.g. data copying). The association remains until the plan is destroyed or the stream is changed with another call to cufftSetStream() . Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. For previous versions of cuFFT, cufftSetStream() will return an error in multiple GPU plans. Note that starting from CUDA 12.2 (cuFFT 11.0.8), on multi-GPU plans, stream can be associated with any context on any GPU. However, repeated calls to cufftSetStream() with streams from different contexts incur a small time penalty. Optimal performance is obtained when repeated calls to cufftSetStream use streams from the same CUDA context. Parameters plan[In] \u2013 The cufftHandle object to associate with the stream. stream[In] \u2013 A valid CUDA stream created with cudaStreamCreate() ; 0 for the default stream. Return values CUFFT_SUCCESS \u2013 The stream was associated with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or plan is multi-gpu in cuFFT version prior to 10.4.0.", "keywords": []}, {"id": 204, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetWorkArea", "display_name": "cufftSetWorkArea", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftSetWorkArea", "priority": 1, "content": "cufftResult  cufftSetWorkArea cufftHandle  plan void  * workArea ; cufftSetWorkArea() overrides the work area pointer associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftExecute*() calls assume that the work area pointer is valid and that it points to a contiguous region in device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workArea[In] \u2013 Pointer to workArea . For multiple GPUs, multiple work area pointers must be given. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 205, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetWorkArea.plan", "display_name": "cufftSetWorkArea.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetWorkArea", "priority": 1, "content": "cufftResult  cufftSetWorkArea cufftHandle  plan void  * workArea ; cufftSetWorkArea() overrides the work area pointer associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftExecute*() calls assume that the work area pointer is valid and that it points to a contiguous region in device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workArea[In] \u2013 Pointer to workArea . For multiple GPUs, multiple work area pointers must be given. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 206, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftSetWorkArea.workArea", "display_name": "cufftSetWorkArea.workArea", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftSetWorkArea", "priority": 1, "content": "cufftResult  cufftSetWorkArea cufftHandle  plan void  * workArea ; cufftSetWorkArea() overrides the work area pointer associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftExecute*() calls assume that the work area pointer is valid and that it points to a contiguous region in device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *workArea[In] \u2013 Pointer to workArea . For multiple GPUs, multiple work area pointers must be given. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 207, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtClearCallback", "display_name": "cufftXtClearCallback", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtClearCallback", "priority": 1, "content": "cufftResult  cufftXtClearCallback cufftHandle  plan cufftXtCallbackType  type cufftXtClearCallback() instructs cuFFT to stop invoking the specified callback type when executing the plan. Only the specified callback is cleared. If no callback of this type had been specified, the return code is CUFFT_SUCCESS . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. Return values CUFFT_SUCCESS \u2013 cuFFT successfully disassociated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 208, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtClearCallback.plan", "display_name": "cufftXtClearCallback.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtClearCallback", "priority": 1, "content": "cufftResult  cufftXtClearCallback cufftHandle  plan cufftXtCallbackType  type cufftXtClearCallback() instructs cuFFT to stop invoking the specified callback type when executing the plan. Only the specified callback is cleared. If no callback of this type had been specified, the return code is CUFFT_SUCCESS . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. Return values CUFFT_SUCCESS \u2013 cuFFT successfully disassociated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 209, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtClearCallback.type", "display_name": "cufftXtClearCallback.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtClearCallback", "priority": 1, "content": "cufftResult  cufftXtClearCallback cufftHandle  plan cufftXtCallbackType  type cufftXtClearCallback() instructs cuFFT to stop invoking the specified callback type when executing the plan. Only the specified callback is cleared. If no callback of this type had been specified, the return code is CUFFT_SUCCESS . Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. Return values CUFFT_SUCCESS \u2013 cuFFT successfully disassociated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 210, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExec", "display_name": "cufftXtExec", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExec", "priority": 1, "content": "cufftResult  cufftXtExec cufftHandle  plan void  * input void  * output int  direction ; Function cufftXtExec executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by the input parameter as input data. This function stores the Fourier coefficients in the output array. If input and output are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the input data (in GPU memory) to transform. output[In] \u2013 Pointer to the output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. output[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 211, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExec.direction", "display_name": "cufftXtExec.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExec", "priority": 1, "content": "cufftResult  cufftXtExec cufftHandle  plan void  * input void  * output int  direction ; Function cufftXtExec executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by the input parameter as input data. This function stores the Fourier coefficients in the output array. If input and output are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the input data (in GPU memory) to transform. output[In] \u2013 Pointer to the output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. output[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 212, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExec.input", "display_name": "cufftXtExec.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExec", "priority": 1, "content": "cufftResult  cufftXtExec cufftHandle  plan void  * input void  * output int  direction ; Function cufftXtExec executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by the input parameter as input data. This function stores the Fourier coefficients in the output array. If input and output are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the input data (in GPU memory) to transform. output[In] \u2013 Pointer to the output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. output[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 213, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExec.output", "display_name": "cufftXtExec.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExec", "priority": 1, "content": "cufftResult  cufftXtExec cufftHandle  plan void  * input void  * output int  direction ; Function cufftXtExec executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by the input parameter as input data. This function stores the Fourier coefficients in the output array. If input and output are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the input data (in GPU memory) to transform. output[In] \u2013 Pointer to the output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. output[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 214, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExec.plan", "display_name": "cufftXtExec.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExec", "priority": 1, "content": "cufftResult  cufftXtExec cufftHandle  plan void  * input void  * output int  direction ; Function cufftXtExec executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by the input parameter as input data. This function stores the Fourier coefficients in the output array. If input and output are the same, this method does an in-place transform. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the input data (in GPU memory) to transform. output[In] \u2013 Pointer to the output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. output[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata , odata , and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 215, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptor", "display_name": "cufftXtExecDescriptor", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptor", "priority": 1, "content": "cufftResult  cufftXtExecDescriptor cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; Function cufftXtExecDescriptor() executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input descriptor as input data and cudaLibXtDesc *output as output data. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. idata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 216, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptor.direction", "display_name": "cufftXtExecDescriptor.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptor", "priority": 1, "content": "cufftResult  cufftXtExecDescriptor cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; Function cufftXtExecDescriptor() executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input descriptor as input data and cudaLibXtDesc *output as output data. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. idata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 217, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptor.input", "display_name": "cufftXtExecDescriptor.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptor", "priority": 1, "content": "cufftResult  cufftXtExecDescriptor cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; Function cufftXtExecDescriptor() executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input descriptor as input data and cudaLibXtDesc *output as output data. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. idata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 218, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptor.output", "display_name": "cufftXtExecDescriptor.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptor", "priority": 1, "content": "cufftResult  cufftXtExecDescriptor cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; Function cufftXtExecDescriptor() executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input descriptor as input data and cudaLibXtDesc *output as output data. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. idata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 219, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptor.plan", "display_name": "cufftXtExecDescriptor.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptor", "priority": 1, "content": "cufftResult  cufftXtExecDescriptor cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; Function cufftXtExecDescriptor() executes any cuFFT transform regardless of precision and type. In case of complex-to-real and real-to-complex transforms direction parameter is ignored. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input descriptor as input data and cudaLibXtDesc *output as output data. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . Ignored for complex-to-real and real-to-complex transforms. idata[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters idata and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 220, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2C", "display_name": "cufftXtExecDescriptorC2C", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ;", "keywords": []}, {"id": 221, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2C.direction", "display_name": "cufftXtExecDescriptorC2C.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ;", "keywords": []}, {"id": 222, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2C.input", "display_name": "cufftXtExecDescriptorC2C.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ;", "keywords": []}, {"id": 223, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2C.output", "display_name": "cufftXtExecDescriptorC2C.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ;", "keywords": []}, {"id": 224, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2C.plan", "display_name": "cufftXtExecDescriptorC2C.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ;", "keywords": []}, {"id": 225, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2R", "display_name": "cufftXtExecDescriptorC2R", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2R", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2R cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 226, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2R.input", "display_name": "cufftXtExecDescriptorC2R.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2R", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2R cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 227, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2R.output", "display_name": "cufftXtExecDescriptorC2R.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2R", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2R cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 228, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorC2R.plan", "display_name": "cufftXtExecDescriptorC2R.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorC2R", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorC2R cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 229, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorD2Z", "display_name": "cufftXtExecDescriptorD2Z", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorD2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorD2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorR2C() ( cufftXtExecDescriptorD2Z() ) executes a single-precision (double-precision) real-to-complex transform plan. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 230, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorD2Z.input", "display_name": "cufftXtExecDescriptorD2Z.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorD2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorD2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorR2C() ( cufftXtExecDescriptorD2Z() ) executes a single-precision (double-precision) real-to-complex transform plan. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 231, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorD2Z.output", "display_name": "cufftXtExecDescriptorD2Z.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorD2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorD2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorR2C() ( cufftXtExecDescriptorD2Z() ) executes a single-precision (double-precision) real-to-complex transform plan. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 232, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorD2Z.plan", "display_name": "cufftXtExecDescriptorD2Z.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorD2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorD2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorR2C() ( cufftXtExecDescriptorD2Z() ) executes a single-precision (double-precision) real-to-complex transform plan. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 233, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorR2C", "display_name": "cufftXtExecDescriptorR2C", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorR2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorR2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 234, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorR2C.input", "display_name": "cufftXtExecDescriptorR2C.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorR2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorR2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 235, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorR2C.output", "display_name": "cufftXtExecDescriptorR2C.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorR2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorR2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 236, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorR2C.plan", "display_name": "cufftXtExecDescriptorR2C.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorR2C", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorR2C cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ;", "keywords": []}, {"id": 237, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2D", "display_name": "cufftXtExecDescriptorZ2D", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2D", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2D cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorC2R() ( cufftXtExecDescriptorZ2D() ) executes a single-precision (double-precision) complex-to-real transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 238, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2D.input", "display_name": "cufftXtExecDescriptorZ2D.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2D", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2D cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorC2R() ( cufftXtExecDescriptorZ2D() ) executes a single-precision (double-precision) complex-to-real transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 239, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2D.output", "display_name": "cufftXtExecDescriptorZ2D.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2D", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2D cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorC2R() ( cufftXtExecDescriptorZ2D() ) executes a single-precision (double-precision) complex-to-real transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 240, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2D.plan", "display_name": "cufftXtExecDescriptorZ2D.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2D", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2D cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output ; cufftXtExecDescriptorC2R() ( cufftXtExecDescriptorZ2D() ) executes a single-precision (double-precision) complex-to-real transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 241, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2Z", "display_name": "cufftXtExecDescriptorZ2Z", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; cufftXtExecDescriptorC2C() ( cufftXtExecDescriptorZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 242, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2Z.direction", "display_name": "cufftXtExecDescriptorZ2Z.direction", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; cufftXtExecDescriptorC2C() ( cufftXtExecDescriptorZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 243, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2Z.input", "display_name": "cufftXtExecDescriptorZ2Z.input", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; cufftXtExecDescriptorC2C() ( cufftXtExecDescriptorZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 244, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2Z.output", "display_name": "cufftXtExecDescriptorZ2Z.output", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; cufftXtExecDescriptorC2C() ( cufftXtExecDescriptorZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 245, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtExecDescriptorZ2Z.plan", "display_name": "cufftXtExecDescriptorZ2Z.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtExecDescriptorZ2Z", "priority": 1, "content": "cufftResult  cufftXtExecDescriptorZ2Z cufftHandle  plan cudaLibXtDesc  * input cudaLibXtDesc  * output int  direction ; cufftXtExecDescriptorC2C() ( cufftXtExecDescriptorZ2Z() ) executes a single-precision (double-precision) complex-to-complex transform plan in the transform direction as specified by direction parameter. cuFFT uses the GPU memory pointed to by cudaLibXtDesc *input as input data. Since only in-place multiple GPU functionality is supported, this function also stores the result in the cudaLibXtDesc *input arrays. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . *input[In] \u2013 Pointer to the complex input data (in GPU memory) to transform. *output[In] \u2013 Pointer to the complex output data (in GPU memory). direction[In] \u2013 The transform direction: CUFFT_FORWARD or CUFFT_INVERSE . input[Out] \u2013 Contains the complex Fourier coefficients. Return values CUFFT_SUCCESS \u2013 cuFFT successfully executed the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 At least one of the parameters input and direction is not valid. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_EXEC_FAILED \u2013 cuFFT failed to execute the transform on the GPU. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 246, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtFree", "display_name": "cufftXtFree", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtFree", "priority": 1, "content": "cufftResult  cufftXtFree cudaLibXtDesc  * descriptor ; cufftXtFree() frees the descriptor and all memory associated with it. The descriptor and memory must have been returned by a previous call to cufftXtMalloc() . Parameters *descriptor[In] \u2013 Pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to free descriptor and associated GPU memory. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 247, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtFree.descriptor", "display_name": "cufftXtFree.descriptor", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtFree", "priority": 1, "content": "cufftResult  cufftXtFree cudaLibXtDesc  * descriptor ; cufftXtFree() frees the descriptor and all memory associated with it. The descriptor and memory must have been returned by a previous call to cufftXtMalloc() . Parameters *descriptor[In] \u2013 Pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to free descriptor and associated GPU memory. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected.", "keywords": []}, {"id": 248, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany", "display_name": "cufftXtGetSizeMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 249, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.batch", "display_name": "cufftXtGetSizeMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 250, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.executiontype", "display_name": "cufftXtGetSizeMany.executiontype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 251, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.idist", "display_name": "cufftXtGetSizeMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 252, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.inembed", "display_name": "cufftXtGetSizeMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 253, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.inputtype", "display_name": "cufftXtGetSizeMany.inputtype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 254, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.istride", "display_name": "cufftXtGetSizeMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 255, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.n", "display_name": "cufftXtGetSizeMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 256, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.odist", "display_name": "cufftXtGetSizeMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 257, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.onembed", "display_name": "cufftXtGetSizeMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 258, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.ostride", "display_name": "cufftXtGetSizeMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 259, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.outputtype", "display_name": "cufftXtGetSizeMany.outputtype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 260, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.plan", "display_name": "cufftXtGetSizeMany.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 261, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.rank", "display_name": "cufftXtGetSizeMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 262, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtGetSizeMany.workSize", "display_name": "cufftXtGetSizeMany.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtGetSizeMany", "priority": 1, "content": "cufftResult  cufftXtGetSizeMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; This call gives a more accurate estimate of the work area size required for a plan than cufftEstimateSizeMany() , given the specified parameters that match signature of cufftXtMakePlanMany function, and taking into account any plan settings that may have been made. For more information about valid combinations of inputtype , outputtype and executiontype parameters please refer to documentation of cufftXtMakePlanMany function. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] ( cudaDataType ) \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] ( cudaDataType ) \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] ( cudaDataType ) \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size of the work area. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 263, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany", "display_name": "cufftXtMakePlanMany", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 264, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.batch", "display_name": "cufftXtMakePlanMany.batch", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 265, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.executiontype", "display_name": "cufftXtMakePlanMany.executiontype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 266, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.idist", "display_name": "cufftXtMakePlanMany.idist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 267, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.inembed", "display_name": "cufftXtMakePlanMany.inembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 268, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.inputtype", "display_name": "cufftXtMakePlanMany.inputtype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 269, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.istride", "display_name": "cufftXtMakePlanMany.istride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 270, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.n", "display_name": "cufftXtMakePlanMany.n", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 271, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.odist", "display_name": "cufftXtMakePlanMany.odist", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 272, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.onembed", "display_name": "cufftXtMakePlanMany.onembed", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 273, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.ostride", "display_name": "cufftXtMakePlanMany.ostride", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 274, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.outputtype", "display_name": "cufftXtMakePlanMany.outputtype", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 275, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.plan", "display_name": "cufftXtMakePlanMany.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 276, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.rank", "display_name": "cufftXtMakePlanMany.rank", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 277, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMakePlanMany.workSize", "display_name": "cufftXtMakePlanMany.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMakePlanMany", "priority": 1, "content": "cufftResult  cufftXtMakePlanMany cufftHandle  plan int  rank long  long  int  * n long  long  int  * inembed long  long  int  istride long  long  int  idist cudaDataType  inputtype long  long  int  * onembed long  long  int  ostride long  long  int  odist cudaDataType  outputtype long  long  int  batch size_t  * workSize cudaDataType  executiontype ; Following a call to cufftCreate() makes an FFT plan configuration of dimension rank , with sizes specified in the array n . The batch input parameter tells cuFFT how many transforms to configure. With this function, batched plans of 1, 2, or 3 dimensions may be created. Type specifiers inputtype , outputtype and executiontype dictate type and precision of transform to be performed. Not all combinations of parameters are supported. Currently all three parameters need to match precision. Parameters inputtype and outputtype need to match transform type complex-to-complex, real-to-complex or complex-to-real. Parameter executiontype needs to match precision and be of a complex type. Example: for a half-precision real-to-complex transform, parameters inputtype , outputtype and executiontype would have values of CUDA_R_16F , CUDA_C_16F and CUDA_C_16F respectively. Similarly, a bfloat16 complex-to-real transform would use CUDA_C_16BF for inputtype and executiontype , and CUDA_R_16BF for outputtype . The cufftXtMakePlanMany() API supports more complicated input and output data layouts via the advanced data layout parameters: inembed , istride , idist , onembed , ostride , and odist . If inembed and onembed are set to NULL , all other stride information is ignored, and default strides are used. The default assumes contiguous data arrays. If cufftXtSetGPUs() was called prior to this call with multiple GPUs, then workSize will contain multiple sizes. See sections on multiple GPUs for more details. All arrays are assumed to be in CPU memory. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . rank[In] \u2013 Dimensionality of the transform (1, 2, or 3). n[In] \u2013 Array of size rank , describing the size of each dimension, n[0] being the size of the outermost and n[rank-1] innermost (contiguous) dimension of a transform. For multiple GPUs and rank equal to 1, the sizes must be a power of 2. For multiple GPUs and rank equal to 2 or 3, the sizes must be factorable into primes less than or equal to 127. inembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the input data in memory, inembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. istride[In] \u2013 Indicates the distance between two successive input elements in the least significant (i.e., innermost) dimension. idist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the input data. inputtype[In] \u2013 Type of input data. onembed[In] \u2013 Pointer of size rank that indicates the storage dimensions of the output data in memory, onembed[0] being the storage dimension of the outermost dimension. If set to NULL all other advanced data layout parameters are ignored. ostride[In] \u2013 Indicates the distance between two successive output elements in the output array in the least significant (i.e., innermost) dimension. odist[In] \u2013 Indicates the distance between the first element of two consecutive signals in a batch of the output data. outputtype[In] \u2013 Type of output data. batch[In] \u2013 Batch size for this transform. *workSize[In] \u2013 Pointer to the size(s), in bytes, of the work areas. For example for two GPUs worksize must be declared to have two elements. executiontype[In] \u2013 Type of data to be used for computations. *workSize[Out] \u2013 Pointer to the size(s) of the work areas. Return values CUFFT_SUCCESS \u2013 cuFFT successfully created the FFT plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. Handle is not valid when multi-GPU restrictions are not met. CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_SIZE \u2013 One or more of the parameters is not a supported size.", "keywords": []}, {"id": 278, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMalloc", "display_name": "cufftXtMalloc", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtMalloc", "priority": 1, "content": "cufftResult  cufftXtMalloc cufftHandle  plan cudaLibXtDesc  * * descriptor cufftXtSubFormat  format ; cufftXtMalloc() allocates a descriptor, and all memory for data in GPUs associated with the plan, and returns a pointer to the descriptor. Note the descriptor contains an array of device pointers so that the application may preprocess or postprocess the data on the GPUs. The enumerated parameter cufftXtSubFormat_t indicates if the buffer will be used for input or output. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . **descriptor[In] \u2013 Pointer to a pointer to a cudaLibXtDesc object. format[In] \u2013 cufftXtSubFormat`` value. **descriptor[Out] \u2013 Pointer to a pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to allocate descriptor and GPU memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle or it is not a multiple GPU plan . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in the descriptor.", "keywords": []}, {"id": 279, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMalloc.descriptor", "display_name": "cufftXtMalloc.descriptor", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMalloc", "priority": 1, "content": "cufftResult  cufftXtMalloc cufftHandle  plan cudaLibXtDesc  * * descriptor cufftXtSubFormat  format ; cufftXtMalloc() allocates a descriptor, and all memory for data in GPUs associated with the plan, and returns a pointer to the descriptor. Note the descriptor contains an array of device pointers so that the application may preprocess or postprocess the data on the GPUs. The enumerated parameter cufftXtSubFormat_t indicates if the buffer will be used for input or output. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . **descriptor[In] \u2013 Pointer to a pointer to a cudaLibXtDesc object. format[In] \u2013 cufftXtSubFormat`` value. **descriptor[Out] \u2013 Pointer to a pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to allocate descriptor and GPU memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle or it is not a multiple GPU plan . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in the descriptor.", "keywords": []}, {"id": 280, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMalloc.format", "display_name": "cufftXtMalloc.format", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMalloc", "priority": 1, "content": "cufftResult  cufftXtMalloc cufftHandle  plan cudaLibXtDesc  * * descriptor cufftXtSubFormat  format ; cufftXtMalloc() allocates a descriptor, and all memory for data in GPUs associated with the plan, and returns a pointer to the descriptor. Note the descriptor contains an array of device pointers so that the application may preprocess or postprocess the data on the GPUs. The enumerated parameter cufftXtSubFormat_t indicates if the buffer will be used for input or output. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . **descriptor[In] \u2013 Pointer to a pointer to a cudaLibXtDesc object. format[In] \u2013 cufftXtSubFormat`` value. **descriptor[Out] \u2013 Pointer to a pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to allocate descriptor and GPU memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle or it is not a multiple GPU plan . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in the descriptor.", "keywords": []}, {"id": 281, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMalloc.plan", "display_name": "cufftXtMalloc.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMalloc", "priority": 1, "content": "cufftResult  cufftXtMalloc cufftHandle  plan cudaLibXtDesc  * * descriptor cufftXtSubFormat  format ; cufftXtMalloc() allocates a descriptor, and all memory for data in GPUs associated with the plan, and returns a pointer to the descriptor. Note the descriptor contains an array of device pointers so that the application may preprocess or postprocess the data on the GPUs. The enumerated parameter cufftXtSubFormat_t indicates if the buffer will be used for input or output. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . **descriptor[In] \u2013 Pointer to a pointer to a cudaLibXtDesc object. format[In] \u2013 cufftXtSubFormat`` value. **descriptor[Out] \u2013 Pointer to a pointer to a cudaLibXtDesc object. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to allocate descriptor and GPU memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle or it is not a multiple GPU plan . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in the descriptor.", "keywords": []}, {"id": 282, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMemcpy", "display_name": "cufftXtMemcpy", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtMemcpy", "priority": 1, "content": "cufftResult  cufftXtMemcpy cufftHandle  plan void  * dstPointer void  * srcPointer cufftXtCopyType  type ; cufftXtMemcpy() copies data between buffers on the host and GPUs or between GPUs. The enumerated parameter cufftXtCopyType_t indicates the type and direction of transfer. Calling cufftXtMemcpy function for multi-GPU batched FFT plans with CUFFT_COPY_DEVICE_TO_DEVICE transfer type is not supported. Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . dstPointer[In] \u2013 Pointer to the destination address(es). srcPointer[In] \u2013 Pointer to the source address(es). type[In] \u2013 cufftXtCopyType value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to copy memory between host and GPUs or between GPUs. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 283, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMemcpy.dstPointer", "display_name": "cufftXtMemcpy.dstPointer", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMemcpy", "priority": 1, "content": "cufftResult  cufftXtMemcpy cufftHandle  plan void  * dstPointer void  * srcPointer cufftXtCopyType  type ; cufftXtMemcpy() copies data between buffers on the host and GPUs or between GPUs. The enumerated parameter cufftXtCopyType_t indicates the type and direction of transfer. Calling cufftXtMemcpy function for multi-GPU batched FFT plans with CUFFT_COPY_DEVICE_TO_DEVICE transfer type is not supported. Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . dstPointer[In] \u2013 Pointer to the destination address(es). srcPointer[In] \u2013 Pointer to the source address(es). type[In] \u2013 cufftXtCopyType value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to copy memory between host and GPUs or between GPUs. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 284, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMemcpy.plan", "display_name": "cufftXtMemcpy.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMemcpy", "priority": 1, "content": "cufftResult  cufftXtMemcpy cufftHandle  plan void  * dstPointer void  * srcPointer cufftXtCopyType  type ; cufftXtMemcpy() copies data between buffers on the host and GPUs or between GPUs. The enumerated parameter cufftXtCopyType_t indicates the type and direction of transfer. Calling cufftXtMemcpy function for multi-GPU batched FFT plans with CUFFT_COPY_DEVICE_TO_DEVICE transfer type is not supported. Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . dstPointer[In] \u2013 Pointer to the destination address(es). srcPointer[In] \u2013 Pointer to the source address(es). type[In] \u2013 cufftXtCopyType value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to copy memory between host and GPUs or between GPUs. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 285, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMemcpy.srcPointer", "display_name": "cufftXtMemcpy.srcPointer", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMemcpy", "priority": 1, "content": "cufftResult  cufftXtMemcpy cufftHandle  plan void  * dstPointer void  * srcPointer cufftXtCopyType  type ; cufftXtMemcpy() copies data between buffers on the host and GPUs or between GPUs. The enumerated parameter cufftXtCopyType_t indicates the type and direction of transfer. Calling cufftXtMemcpy function for multi-GPU batched FFT plans with CUFFT_COPY_DEVICE_TO_DEVICE transfer type is not supported. Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . dstPointer[In] \u2013 Pointer to the destination address(es). srcPointer[In] \u2013 Pointer to the source address(es). type[In] \u2013 cufftXtCopyType value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to copy memory between host and GPUs or between GPUs. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 286, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtMemcpy.type", "display_name": "cufftXtMemcpy.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtMemcpy", "priority": 1, "content": "cufftResult  cufftXtMemcpy cufftHandle  plan void  * dstPointer void  * srcPointer cufftXtCopyType  type ; cufftXtMemcpy() copies data between buffers on the host and GPUs or between GPUs. The enumerated parameter cufftXtCopyType_t indicates the type and direction of transfer. Calling cufftXtMemcpy function for multi-GPU batched FFT plans with CUFFT_COPY_DEVICE_TO_DEVICE transfer type is not supported. Note that starting from CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported on multi-GPU plans. When associating a stream with a plan, cufftXtMemcpy() remains synchronous across the multiple GPUs. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . dstPointer[In] \u2013 Pointer to the destination address(es). srcPointer[In] \u2013 Pointer to the source address(es). type[In] \u2013 cufftXtCopyType value. Return values CUFFT_SUCCESS \u2013 cuFFT successfully allows user to copy memory between host and GPUs or between GPUs. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_VALUE \u2013 One or more invalid parameters were passed to the API. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified in a descriptor.", "keywords": []}, {"id": 287, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallback", "display_name": "cufftXtSetCallback", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtSetCallback", "priority": 1, "content": "cufftResult  cufftXtSetCallback cufftHandle  plan void  * * callbackRoutine cufftXtCallbackType  type void  * * callerInfo cufftXtSetCallback() specifies a load or store callback to be used with the plan. This call is valid only after a call to cufftMakePlan*() , which does the plan generation. If there was already a callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call cufftXtSetCallbackSharedSize with the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . callbackRoutine[In] \u2013 Array of callback routine pointers, one per GPU. type[In] \u2013 Type of callback routine. callerInfo[In] \u2013 Optional array of device pointers to caller specific information, one per GPU. Return values CUFFT_SUCCESS \u2013 cuFFT successfully associated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 288, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallback.callbackRoutine", "display_name": "cufftXtSetCallback.callbackRoutine", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallback", "priority": 1, "content": "cufftResult  cufftXtSetCallback cufftHandle  plan void  * * callbackRoutine cufftXtCallbackType  type void  * * callerInfo cufftXtSetCallback() specifies a load or store callback to be used with the plan. This call is valid only after a call to cufftMakePlan*() , which does the plan generation. If there was already a callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call cufftXtSetCallbackSharedSize with the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . callbackRoutine[In] \u2013 Array of callback routine pointers, one per GPU. type[In] \u2013 Type of callback routine. callerInfo[In] \u2013 Optional array of device pointers to caller specific information, one per GPU. Return values CUFFT_SUCCESS \u2013 cuFFT successfully associated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 289, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallback.callerInfo", "display_name": "cufftXtSetCallback.callerInfo", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallback", "priority": 1, "content": "cufftResult  cufftXtSetCallback cufftHandle  plan void  * * callbackRoutine cufftXtCallbackType  type void  * * callerInfo cufftXtSetCallback() specifies a load or store callback to be used with the plan. This call is valid only after a call to cufftMakePlan*() , which does the plan generation. If there was already a callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call cufftXtSetCallbackSharedSize with the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . callbackRoutine[In] \u2013 Array of callback routine pointers, one per GPU. type[In] \u2013 Type of callback routine. callerInfo[In] \u2013 Optional array of device pointers to caller specific information, one per GPU. Return values CUFFT_SUCCESS \u2013 cuFFT successfully associated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 290, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallback.plan", "display_name": "cufftXtSetCallback.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallback", "priority": 1, "content": "cufftResult  cufftXtSetCallback cufftHandle  plan void  * * callbackRoutine cufftXtCallbackType  type void  * * callerInfo cufftXtSetCallback() specifies a load or store callback to be used with the plan. This call is valid only after a call to cufftMakePlan*() , which does the plan generation. If there was already a callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call cufftXtSetCallbackSharedSize with the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . callbackRoutine[In] \u2013 Array of callback routine pointers, one per GPU. type[In] \u2013 Type of callback routine. callerInfo[In] \u2013 Optional array of device pointers to caller specific information, one per GPU. Return values CUFFT_SUCCESS \u2013 cuFFT successfully associated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 291, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallback.type", "display_name": "cufftXtSetCallback.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallback", "priority": 1, "content": "cufftResult  cufftXtSetCallback cufftHandle  plan void  * * callbackRoutine cufftXtCallbackType  type void  * * callerInfo cufftXtSetCallback() specifies a load or store callback to be used with the plan. This call is valid only after a call to cufftMakePlan*() , which does the plan generation. If there was already a callback of this type associated with the plan, this new callback routine replaces it. If the new callback requires shared memory, you must call cufftXtSetCallbackSharedSize with the amount of shared memory it needs. cuFFT will not retain the amount of shared memory associated with the previous callback. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . callbackRoutine[In] \u2013 Array of callback routine pointers, one per GPU. type[In] \u2013 Type of callback routine. callerInfo[In] \u2013 Optional array of device pointers to caller specific information, one per GPU. Return values CUFFT_SUCCESS \u2013 cuFFT successfully associated the callback function with the plan. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 292, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallbackSharedSize", "display_name": "cufftXtSetCallbackSharedSize", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtSetCallbackSharedSize", "priority": 1, "content": "cufftResult  cufftXtSetCallbackSharedSize cufftHandle  plan cufftXtCallbackType  type size_t  sharedSize cufftXtSetCallbackSharedSize() instructs cuFFT to dynamically allocate shared memory at launch time, for use by the callback. The maximum allowable amount of shared memory is 16K bytes. cuFFT passes a pointer to this shared memory to the callback routine at execution time. This shared memory is only valid for the life of the load or store callback operation. During execution, cuFFT may overwrite shared memory for its own purposes. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. sharedSize[In] \u2013 Amount of shared memory requested. Return values CUFFT_SUCCESS \u2013 cuFFT will invoke the callback routine with a pointer to the requested amount of shared memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_ALLOC_FAILED \u2013 cuFFT will not be able to allocate the requested amount of shared memory.", "keywords": []}, {"id": 293, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallbackSharedSize.plan", "display_name": "cufftXtSetCallbackSharedSize.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallbackSharedSize", "priority": 1, "content": "cufftResult  cufftXtSetCallbackSharedSize cufftHandle  plan cufftXtCallbackType  type size_t  sharedSize cufftXtSetCallbackSharedSize() instructs cuFFT to dynamically allocate shared memory at launch time, for use by the callback. The maximum allowable amount of shared memory is 16K bytes. cuFFT passes a pointer to this shared memory to the callback routine at execution time. This shared memory is only valid for the life of the load or store callback operation. During execution, cuFFT may overwrite shared memory for its own purposes. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. sharedSize[In] \u2013 Amount of shared memory requested. Return values CUFFT_SUCCESS \u2013 cuFFT will invoke the callback routine with a pointer to the requested amount of shared memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_ALLOC_FAILED \u2013 cuFFT will not be able to allocate the requested amount of shared memory.", "keywords": []}, {"id": 294, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallbackSharedSize.sharedSize", "display_name": "cufftXtSetCallbackSharedSize.sharedSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallbackSharedSize", "priority": 1, "content": "cufftResult  cufftXtSetCallbackSharedSize cufftHandle  plan cufftXtCallbackType  type size_t  sharedSize cufftXtSetCallbackSharedSize() instructs cuFFT to dynamically allocate shared memory at launch time, for use by the callback. The maximum allowable amount of shared memory is 16K bytes. cuFFT passes a pointer to this shared memory to the callback routine at execution time. This shared memory is only valid for the life of the load or store callback operation. During execution, cuFFT may overwrite shared memory for its own purposes. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. sharedSize[In] \u2013 Amount of shared memory requested. Return values CUFFT_SUCCESS \u2013 cuFFT will invoke the callback routine with a pointer to the requested amount of shared memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_ALLOC_FAILED \u2013 cuFFT will not be able to allocate the requested amount of shared memory.", "keywords": []}, {"id": 295, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetCallbackSharedSize.type", "display_name": "cufftXtSetCallbackSharedSize.type", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetCallbackSharedSize", "priority": 1, "content": "cufftResult  cufftXtSetCallbackSharedSize cufftHandle  plan cufftXtCallbackType  type size_t  sharedSize cufftXtSetCallbackSharedSize() instructs cuFFT to dynamically allocate shared memory at launch time, for use by the callback. The maximum allowable amount of shared memory is 16K bytes. cuFFT passes a pointer to this shared memory to the callback routine at execution time. This shared memory is only valid for the life of the load or store callback operation. During execution, cuFFT may overwrite shared memory for its own purposes. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . type[In] \u2013 Type of callback routine. sharedSize[In] \u2013 Amount of shared memory requested. Return values CUFFT_SUCCESS \u2013 cuFFT will invoke the callback routine with a pointer to the requested amount of shared memory. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_ALLOC_FAILED \u2013 cuFFT will not be able to allocate the requested amount of shared memory.", "keywords": []}, {"id": 296, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetGPUs", "display_name": "cufftXtSetGPUs", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtSetGPUs", "priority": 1, "content": "cufftResult  cufftXtSetGPUs cufftHandle  plan int  nGPUs int  * whichGPUs ; cufftXtSetGPUs() identifies which GPUs are to be used with the plan. As in the single GPU case cufftCreate() creates a plan and cufftMakePlan*() does the plan generation. In cuFFT prior to 10.4.0, this call will return an error if a non-default stream has been associated with the plan. Note that the call to cufftXtSetGPUs() must occur after the call to cufftCreate() and prior to the call to cufftMakePlan*() . Parameter whichGPUs of cufftXtSetGPUs() function determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of whichGPUs ). Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nGPUs[In] \u2013 Number of GPUs to use. whichGPUs[In] \u2013 The GPUs to use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_VALUE \u2013 The requested number of GPUs was less than 2 or more than 8. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified. CUFFT_INVALID_SIZE \u2013 Transform size that plan was created for does not meet minimum size criteria.", "keywords": []}, {"id": 297, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetGPUs.nGPUs", "display_name": "cufftXtSetGPUs.nGPUs", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetGPUs", "priority": 1, "content": "cufftResult  cufftXtSetGPUs cufftHandle  plan int  nGPUs int  * whichGPUs ; cufftXtSetGPUs() identifies which GPUs are to be used with the plan. As in the single GPU case cufftCreate() creates a plan and cufftMakePlan*() does the plan generation. In cuFFT prior to 10.4.0, this call will return an error if a non-default stream has been associated with the plan. Note that the call to cufftXtSetGPUs() must occur after the call to cufftCreate() and prior to the call to cufftMakePlan*() . Parameter whichGPUs of cufftXtSetGPUs() function determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of whichGPUs ). Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nGPUs[In] \u2013 Number of GPUs to use. whichGPUs[In] \u2013 The GPUs to use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_VALUE \u2013 The requested number of GPUs was less than 2 or more than 8. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified. CUFFT_INVALID_SIZE \u2013 Transform size that plan was created for does not meet minimum size criteria.", "keywords": []}, {"id": 298, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetGPUs.plan", "display_name": "cufftXtSetGPUs.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetGPUs", "priority": 1, "content": "cufftResult  cufftXtSetGPUs cufftHandle  plan int  nGPUs int  * whichGPUs ; cufftXtSetGPUs() identifies which GPUs are to be used with the plan. As in the single GPU case cufftCreate() creates a plan and cufftMakePlan*() does the plan generation. In cuFFT prior to 10.4.0, this call will return an error if a non-default stream has been associated with the plan. Note that the call to cufftXtSetGPUs() must occur after the call to cufftCreate() and prior to the call to cufftMakePlan*() . Parameter whichGPUs of cufftXtSetGPUs() function determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of whichGPUs ). Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nGPUs[In] \u2013 Number of GPUs to use. whichGPUs[In] \u2013 The GPUs to use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_VALUE \u2013 The requested number of GPUs was less than 2 or more than 8. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified. CUFFT_INVALID_SIZE \u2013 Transform size that plan was created for does not meet minimum size criteria.", "keywords": []}, {"id": 299, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetGPUs.whichGPUs", "display_name": "cufftXtSetGPUs.whichGPUs", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetGPUs", "priority": 1, "content": "cufftResult  cufftXtSetGPUs cufftHandle  plan int  nGPUs int  * whichGPUs ; cufftXtSetGPUs() identifies which GPUs are to be used with the plan. As in the single GPU case cufftCreate() creates a plan and cufftMakePlan*() does the plan generation. In cuFFT prior to 10.4.0, this call will return an error if a non-default stream has been associated with the plan. Note that the call to cufftXtSetGPUs() must occur after the call to cufftCreate() and prior to the call to cufftMakePlan*() . Parameter whichGPUs of cufftXtSetGPUs() function determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of whichGPUs ). Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . nGPUs[In] \u2013 Number of GPUs to use. whichGPUs[In] \u2013 The GPUs to use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle, or a non-default stream has been associated with the plan in cuFFT prior to 10.4.0 . CUFFT_ALLOC_FAILED \u2013 The allocation of GPU resources for the plan failed. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_VALUE \u2013 The requested number of GPUs was less than 2 or more than 8. CUFFT_INVALID_DEVICE \u2013 An invalid GPU index was specified. CUFFT_INVALID_SIZE \u2013 Transform size that plan was created for does not meet minimum size criteria.", "keywords": []}, {"id": 300, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkArea", "display_name": "cufftXtSetWorkArea", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtSetWorkArea", "priority": 1, "content": "cufftResult  cufftXtSetWorkArea cufftHandle  plan void  * * workArea ; cufftXtSetWorkArea() overrides the work areas associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftXtExec*() calls assume that the work area is valid and that it points to a contiguous region in each device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . workArea[In] \u2013 Pointer to the pointers to workArea. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 A GPU associated with the plan could not be selected.", "keywords": []}, {"id": 301, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkArea.plan", "display_name": "cufftXtSetWorkArea.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetWorkArea", "priority": 1, "content": "cufftResult  cufftXtSetWorkArea cufftHandle  plan void  * * workArea ; cufftXtSetWorkArea() overrides the work areas associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftXtExec*() calls assume that the work area is valid and that it points to a contiguous region in each device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . workArea[In] \u2013 Pointer to the pointers to workArea. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 A GPU associated with the plan could not be selected.", "keywords": []}, {"id": 302, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkArea.workArea", "display_name": "cufftXtSetWorkArea.workArea", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetWorkArea", "priority": 1, "content": "cufftResult  cufftXtSetWorkArea cufftHandle  plan void  * * workArea ; cufftXtSetWorkArea() overrides the work areas associated with a plan. If the work area was auto-allocated, cuFFT frees the auto-allocated space. The cufftXtExec*() calls assume that the work area is valid and that it points to a contiguous region in each device memory that does not overlap with any other work area. If this is not the case, results are indeterminate. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . workArea[In] \u2013 Pointer to the pointers to workArea. Return values CUFFT_SUCCESS \u2013 cuFFT successfully set the GPUs to use. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize. CUFFT_INVALID_DEVICE \u2013 A GPU associated with the plan could not be selected.", "keywords": []}, {"id": 303, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkAreaPolicy", "display_name": "cufftXtSetWorkAreaPolicy", "type": "function", "display_type": "C function", "docname": "index", "anchor": "c.cufftXtSetWorkAreaPolicy", "priority": 1, "content": "cufftResult  cufftXtSetWorkAreaPolicy cufftHandle  plan cufftXtWorkAreaPolicy  policy size_t  * workSize ; cufftXtSetWorkAreaPolicy() indicates that the caller intends to change work area size for a given plan handle. cuFFT\u2019s default behavior is to allocate the work area at plan generation time with a default size that depends on the plan type and other parameters. If cufftXtSetWorkAreaPolicy() has been called with the policy parameter set to CUFFT_WORKAREA_MINIMAL , cuFFT will attempt to re-plan the handle to use zero bytes of work area memory. If the cufftXtSetWorkAreaPolicy() call is successful the auto-allocated work area memory is released. Currently the policies CUFFT_WORKAREA_PERFORMANCE , CUFFT_WORKAREA_USER and the workSize parameter are not supported and reserved for use in future cuFFT releases. This function can be called once per lifetime of a plan handle. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . policy[In] \u2013 Type of work area policy to apply. *workSize[In] \u2013 Reserved for future use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_SIZE \u2013 FFT size does not allow use of the selected policy. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 304, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkAreaPolicy.plan", "display_name": "cufftXtSetWorkAreaPolicy.plan", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetWorkAreaPolicy", "priority": 1, "content": "cufftResult  cufftXtSetWorkAreaPolicy cufftHandle  plan cufftXtWorkAreaPolicy  policy size_t  * workSize ; cufftXtSetWorkAreaPolicy() indicates that the caller intends to change work area size for a given plan handle. cuFFT\u2019s default behavior is to allocate the work area at plan generation time with a default size that depends on the plan type and other parameters. If cufftXtSetWorkAreaPolicy() has been called with the policy parameter set to CUFFT_WORKAREA_MINIMAL , cuFFT will attempt to re-plan the handle to use zero bytes of work area memory. If the cufftXtSetWorkAreaPolicy() call is successful the auto-allocated work area memory is released. Currently the policies CUFFT_WORKAREA_PERFORMANCE , CUFFT_WORKAREA_USER and the workSize parameter are not supported and reserved for use in future cuFFT releases. This function can be called once per lifetime of a plan handle. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . policy[In] \u2013 Type of work area policy to apply. *workSize[In] \u2013 Reserved for future use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_SIZE \u2013 FFT size does not allow use of the selected policy. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 305, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkAreaPolicy.policy", "display_name": "cufftXtSetWorkAreaPolicy.policy", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetWorkAreaPolicy", "priority": 1, "content": "cufftResult  cufftXtSetWorkAreaPolicy cufftHandle  plan cufftXtWorkAreaPolicy  policy size_t  * workSize ; cufftXtSetWorkAreaPolicy() indicates that the caller intends to change work area size for a given plan handle. cuFFT\u2019s default behavior is to allocate the work area at plan generation time with a default size that depends on the plan type and other parameters. If cufftXtSetWorkAreaPolicy() has been called with the policy parameter set to CUFFT_WORKAREA_MINIMAL , cuFFT will attempt to re-plan the handle to use zero bytes of work area memory. If the cufftXtSetWorkAreaPolicy() call is successful the auto-allocated work area memory is released. Currently the policies CUFFT_WORKAREA_PERFORMANCE , CUFFT_WORKAREA_USER and the workSize parameter are not supported and reserved for use in future cuFFT releases. This function can be called once per lifetime of a plan handle. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . policy[In] \u2013 Type of work area policy to apply. *workSize[In] \u2013 Reserved for future use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_SIZE \u2013 FFT size does not allow use of the selected policy. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 306, "doc_id": 369, "filename": "index.html", "domain_name": "c", "name": "cufftXtSetWorkAreaPolicy.workSize", "display_name": "cufftXtSetWorkAreaPolicy.workSize", "type": "functionParam", "display_type": "C function parameter", "docname": "index", "anchor": "c.cufftXtSetWorkAreaPolicy", "priority": 1, "content": "cufftResult  cufftXtSetWorkAreaPolicy cufftHandle  plan cufftXtWorkAreaPolicy  policy size_t  * workSize ; cufftXtSetWorkAreaPolicy() indicates that the caller intends to change work area size for a given plan handle. cuFFT\u2019s default behavior is to allocate the work area at plan generation time with a default size that depends on the plan type and other parameters. If cufftXtSetWorkAreaPolicy() has been called with the policy parameter set to CUFFT_WORKAREA_MINIMAL , cuFFT will attempt to re-plan the handle to use zero bytes of work area memory. If the cufftXtSetWorkAreaPolicy() call is successful the auto-allocated work area memory is released. Currently the policies CUFFT_WORKAREA_PERFORMANCE , CUFFT_WORKAREA_USER and the workSize parameter are not supported and reserved for use in future cuFFT releases. This function can be called once per lifetime of a plan handle. Parameters plan[In] \u2013 cufftHandle returned by cufftCreate . policy[In] \u2013 Type of work area policy to apply. *workSize[In] \u2013 Reserved for future use. Return values CUFFT_SUCCESS \u2013 cuFFT successfully returned the size of the work space. CUFFT_INVALID_PLAN \u2013 The plan parameter is not a valid handle. CUFFT_INVALID_SIZE \u2013 FFT size does not allow use of the selected policy. CUFFT_INTERNAL_ERROR \u2013 An internal driver error was detected. CUFFT_SETUP_FAILED \u2013 The cuFFT library failed to initialize.", "keywords": []}, {"id": 307, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#accessing-cufft", "display_name": "Accessing cuFFT", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "accessing-cufft", "priority": -1, "content": "The cuFFT and cuFFTW libraries are available as shared libraries. They consist of compiled programs ready for users to incorporate into applications with the compiler and linker. cuFFT can be downloaded from https://developer.nvidia.com/cufft . By selecting Download CUDA Production Release users are all able to install the package containing the CUDA Toolkit, SDK code samples and development drivers. The CUDA Toolkit contains cuFFT and the samples include simplecuFFT . The Linux release for simplecuFFT assumes that the root install directory is /usr/local/cuda and that the locations of the products are contained there as follows. Modify the Makefile as appropriate for your system. Product Location and name Include file nvcc compiler /bin/nvcc cuFFT library {lib, lib64}/libcufft.so inc/cufft.h cuFFT library with Xt functionality {lib, lib64}/libcufft.so inc/cufftXt.h cuFFTW library {lib, lib64}/libcufftw.so inc/cufftw.h The most common case is for developers to modify an existing CUDA routine (for example, filename.cu ) to call cuFFT routines. In this case the include file cufft.h or cufftXt.h should be inserted into filename.cu file and the library included in the link line. A single compile and link line might appear as /usr/local/cuda/bin/nvcc [options] filename.cu \u2026 -I/usr/local/cuda/inc -L/usr/local/cuda/lib -lcufft Of course there will typically be many compile lines and the compiler g++ may be used for linking so long as the library path is set correctly. Users of the FFTW interface (see FFTW Interface to cuFFT ) should include cufftw.h and link with both cuFFT and cuFFTW libraries. Functions in the cuFFT and cuFFTW library assume that the data is in GPU visible memory. This means any memory allocated by cudaMalloc , cudaMallocHost and cudaMallocManaged or registered with cudaHostRegister can be used as input, output or plan work area with cuFFT and cuFFTW functions. For the best performance input data, output data and plan work area should reside in device memory. cuFFTW library also supports input data and output data that is not GPU visible.", "keywords": []}, {"id": 308, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#accuracy-and-performance", "display_name": "Accuracy and Performance", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "accuracy-and-performance", "priority": -1, "content": "A DFT can be implemented as a matrix vector multiplication that requires O(N^{2}) operations. However, the cuFFT Library employs the Cooley-Tukey algorithm to reduce the number of required operations to optimize the performance of particular transform sizes. This algorithm expresses the DFT matrix as a product of sparse building block matrices. The cuFFT Library implements the following building blocks: radix-2, radix-3, radix-5, and radix-7. Hence the performance of any transform size that can be factored as 2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d} (where a , b , c , and d are non-negative integers) is optimized in the cuFFT library. There are also radix-m building blocks for other primes, m, whose value is &lt; 128. When the length cannot be decomposed as multiples of powers of primes from 2 to 127, Bluestein\u2019s algorithm is used. Since the Bluestein implementation requires more computations per output point than the Cooley-Tukey implementation, the accuracy of the Cooley-Tukey algorithm is better. The pure Cooley-Tukey implementation has excellent accuracy, with the relative error growing proportionally to \\log_{2}(N) , where N is the transform size in points. For sizes handled by the Cooley-Tukey code path, the most efficient implementation is obtained by applying the following constraints (listed in order from the most generic to the most specialized constraint, with each subsequent constraint providing the potential of an additional performance improvement). Half precision transforms might not be suitable for all kinds of problems due to limited range represented by half precision floating point arithmetics. Please note that the first element of FFT result is the sum of all input elements and it is likely to overflow for certain inputs. Results produced by the cuFFT library are deterministic (ie, bitwise reproducible) as long as the following are kept constant between runs: plan input parameters, cuFFT version, and GPU model. cuFFT batched plans require that input data includes valid signal for all batches. Performance optimizations in batched mode can combine signal from different batches for processing. Optimizations used in cuFFT can vary from version to version. Applies to Recommendation Comment All Use single precision transforms. Single precision transforms require less bandwidth per computation than double precision transforms. All Restrict the size along all dimensions to be representable as 2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d} . The cuFFT library has highly optimized kernels for transforms whose dimensions have these prime factors. In general the best performance occurs when using powers of 2, followed by powers of 3, then 5, 7. All Restrict the size along each dimension to use fewer distinct prime factors. A transform of size 2^{n} or 3^{n} will usually be faster than one of size 2^{i} \\times 3^{j} even if the latter is slightly smaller, due to the composition of specialized paths. All Restrict the data to be contiguous in memory when performing a single transform. When performing multiple transforms make the individual datasets contiguous The cuFFT library has been optimized for this data layout. All Perform multiple (i.e., batched) transforms. Additional optimizations are performed in batched mode. real-to-complex transforms or complex-to-real transforms Ensure problem size of x dimension is a multiple of 4. This scheme uses more efficient kernels to implement conjugate symmetry property. real-to-complex transforms or complex-to-real transforms Use out-of-place mode. This scheme uses more efficient kernels than in-place mode. Multiple GPU transforms Use PCI Express 3.0 between GPUs and ensure the GPUs are on the same switch. The faster the interconnect between the GPUs, the faster the performance.", "keywords": []}, {"id": 309, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#advanced-data-layout", "display_name": "Advanced Data Layout", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "advanced-data-layout", "priority": -1, "content": "The advanced data layout feature allows transforming only a subset of an input array, or outputting to only a portion of a larger data structure. It can be set by calling function: cufftResult cufftPlanMany(cufftHandle *plan, int rank, int *n, int *inembed, int istride, int idist, int *onembed, int ostride, int odist, cufftType type, int batch); Passing inembed or onembed set to NULL is a special case and is equivalent to passing n for each. This is same as the basic data layout and other advanced parameters such as istride are ignored. If the advanced parameters are to be used, then all of the advanced interface parameters must be specified correctly. Advanced parameters are defined in units of the relevant data type ( cufftReal , cufftDoubleReal , cufftComplex , or cufftDoubleComplex ). Advanced layout can be perceived as an additional layer of abstraction above the access to input/output data arrays. An element of coordinates [z][y][x] in signal number b in the batch will be associated with the following addresses in the memory: 1D input[ b * idist + x * istride ] output[ b * odist + x * ostride ] 2D input[ b * idist` + (x * inembed[1] + y) * istride ] output[ b * odist + (x * onembed[1] + y) * ostride ] 3D input[ b * idist + ((x * inembed[1] + y) * inembed[2] + z) * istride ] output[ b * odist + ((x * onembed[1] + y) * onembed[2] + z) * ostride ] The istride and ostride parameters denote the distance between two successive input and output elements in the least significant (that is, the innermost) dimension respectively. In a single 1D transform, if every input element is to be used in the transform, istride should be set to 1 ; if every other input element is to be used in the transform, then istride should be set to 2 . Similarly, in a single 1D transform, if it is desired to output final elements one after another compactly, ostride should be set to 1 ; if spacing is desired between the least significant dimension output data, ostride should be set to the distance between the elements. The inembed and onembed parameters define the number of elements in each dimension in the input array and the output array respectively. The inembed[rank-1] contains the number of elements in the least significant (innermost) dimension of the input data excluding the istride elements; the number of total elements in the least significant dimension of the input array is then istride*inembed[rank-1] . The inembed[0] or onembed[0] corresponds to the most significant (that is, the outermost) dimension and is effectively ignored since the idist or odist parameter provides this information instead. Note that the size of each dimension of the transform should be less than or equal to the inembed and onembed values for the corresponding dimension, that is n[i] \u2264 inembed[i] , n[i] \u2264 onembed[i] , where i \\in \\{ 0,\\ldots,rank - 1\\} . The idist and odist parameters indicate the distance between the first element of two consecutive batches in the input and output data.", "keywords": []}, {"id": 310, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#bfloat16-precision-cufft-transforms", "display_name": "Bfloat16-precision cuFFT Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "bfloat16-precision-cufft-transforms", "priority": -1, "content": "cuFFT supports bfloat16 precision using the nv_bfloat16 data type. Please note that cuFFT utilizes a combination of single- and bfloat16-precision arithmetic operations when computing the FFT in bfloat16 precision. Bfloat16-precision transforms have similar limitations to half-precision transforms: Minimum GPU architecture is SM_80 Sizes are restricted to powers of two only Strides on the real part of real-to-complex and complex-to-real transforms are not supported More than one GPU is not supported Transforms spanning more than 4 billion elements are not supported Please refer to cufftXtMakePlanMany function for plan creation details. The CUDA Toolkit provides the cuda_bf16.h header with types and intrinsic functions for handling bfloat16-precision arithmetic.", "keywords": []}, {"id": 311, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#callback-routine-function-details", "display_name": "Callback Routine Function Details", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "callback-routine-function-details", "priority": -1, "content": "Below are the function prototypes, and typedefs for pointers to the user supplied callback routines that cuFFT calls to load data prior to the transform. typedef cufftComplex (*cufftCallbackLoadC)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftDoubleComplex (*cufftCallbackLoadZ)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftReal (*cufftCallbackLoadR)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftDoubleReal (*cufftCallbackLoadD)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); Parameters for all of the load callbacks are defined as below: offset : offset of the input element from the start of output data. This is not a byte offset, rather it is the number of elements from start of data. dataIn : device pointer to the start of the input array that was passed in the cufftExecute call. callerInfo : device pointer to the optional caller specified data passed in the cufftXtSetCallback call. sharedPointer : pointer to shared memory, valid only if the user has called cufftXtSetCallbackSharedSize() . Below are the function prototypes, and typedefs for pointers to the user supplied callback routines that cuFFT calls to store data after completion of the transform. Note that the store callback functions do not return a value. This is because a store callback function is responsible not only for transforming the data as desired, but also for writing the data to the desired location. This allows the store callback to rearrange the data, for example to shift the zero frequency result to the center of the ouput. typedef void (*cufftCallbackStoreC)(void *dataOut, size_t offset, cufftComplex element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreZ)(void *dataOut, size_t offset, cufftDoubleComplex element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreR)(void *dataOut, size_t offset, cufftReal element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreD)(void *dataOut, size_t offset, cufftDoubleReal element, void *callerInfo, void *sharedPointer); Parameters for all of the store callbacks are defined as below: offset : offset of the output element from the start of output data. This is not a byte offset, rather it is the number of elements from start of data. dataOut : device pointer to the start of the output array that was passed in the cufftExecute call. element : the real or complex result computed by CUFFT for the element specified by the offset argument. callerInfo : device pointer to the optional caller specified data passed in the cufftXtSetCallback call. sharedPointer : pointer to shared memory, valid only if the user has called cufftXtSetCallbackSharedSize() .", "keywords": []}, {"id": 312, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#caller-allocated-work-area-support", "display_name": "Caller Allocated Work Area Support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "caller-allocated-work-area-support", "priority": -1, "content": "cuFFT plans may use additional memory to store intermediate results. The cuFFT library offers several functions to manage this temporary memory utilization behavior: cufftSetAutoAllocation cufftEstimate1d , cufftEstimate2d , cufftEstimate3d and cufftEstimateMany cufftGetSize cufftXtSetWorkAreaPolicy The first two functions manage allocation and ownership of temporary memory. By default cuFFT always allocates its own work area in GPU memory. Each cuFFT handle allocates data separately. If multiple cuFFT plans are to be launched sequentially it is possible to assign the same memory chunk as work area to all those plans and reduce memory overhead. The memory assigned as work area needs to be GPU visible. In addition to the regular memory acquired with cudaMalloc , usage of CUDA Unified Virtual Addressing enables cuFFT to use the following types of memory as work area memory: pinned host memory, managed memory, memory on GPU other than the one performing the calculations. While this provides flexibility, it comes with a performance penalty whose magnitude depends on the available memory bandwidth. The cufftEstimateNd , cufftEstimateMany , and cufftGetSize functions provide information about the required memory size for cases where the user is allocating the work space buffer. In version 9.2 cuFFT also introduced the cufftXtSetWorkAreaPolicy function. This function allows fine tuning of work area memory usage. cuFFT 9.2 version supports only the CUFFT_WORKAREA_MINIMAL policy, which instructs cuFFT to re-plan the existing plan without the need to use work area memory. Also as of cuFFT 9.2, supported FFT transforms that allow for CUFFT_WORKAREA_MINIMAL policy are as follows: Transforms of type C2C are supported with sizes up to 4096 in any dimension. Transforms of type Z2Z are supported with sizes up to 2048 in any dimension. Only single GPU transforms are supported. Depending on the FFT transform size, a different FFT algorithm may be used when the CUFFT_WORKAREA_MINIMAL policy is set.", "keywords": []}, {"id": 313, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#coding-considerations-for-the-cufft-callback-routine-feature", "display_name": "Coding Considerations for the cuFFT Callback Routine Feature", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "coding-considerations-for-the-cufft-callback-routine-feature", "priority": -1, "content": "cuFFT supports callbacks on all types of transforms, dimension, batch, stride between elements or number of GPUs. Callbacks are supported for transforms of single and double precision. cuFFT supports a wide range of parameters, and based on those for a given plan, it attempts to optimize performance. The number of kernels launched, and for each of those, the number of blocks launched and the number of threads per block, will vary depending on how cuFFT decomposes the transform. For some configurations, cuFFT will load or store (and process) multiple inputs or outputs per thread. For some configurations, threads may load or store inputs or outputs in any order, and cuFFT does not guarantee that the inputs or outputs handled by a given thread will be contiguous. These characteristics may vary with transform size, transform type (e.g. C2C vs C2R), number of dimensions, and GPU architecture. These variations may also change from one library version to the next. cuFFT will call the load callback routine, for each point in the input, once and only once. Similarly it will call the store callback routine, for each point in the output, once and only once. If the transform is being done in-place (i.e. the input and output data are in the same memory location) the store callback for a given element cannot overwrite other elements. It can either overwrite the given element, or write in a completely distinct output buffer. When more than one kernel are used to implement a transform, the thread and block structure of the first kernel (the one that does the load) is often different from the thread and block structure of the last kernel (the one that does the store). One common use of callbacks is to reduce the amount of data read or written to memory, either by selective filtering or via type conversions. When more than one kernel are used to implement a transform, cuFFT alternates using the workspace and the output buffer to write intermediate results. This means that the output buffer must always be large enough to accommodate the entire transform. For multi-GPU transforms, the index passed to the callback routine is the element index from the start of data on that GPU , not from the start of the entire input or output data array. For transforms whose dimensions can be factored into powers of 2, 3, 5, or 7, cuFFT guarantees that it will call the load and store callback routines from points in the kernel that is safe to call __syncthreads function from within callback routine. Caller is responsible for guaranteeing that the callback routine is at a point where the callback code has converged, to avoid deadlock. For plans whose dimensions are factored into higher primes, results of a callback routine calling __syncthreads are not defined.", "keywords": []}, {"id": 314, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cuda-graphs-support", "display_name": "CUDA Graphs Support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cuda-graphs-support", "priority": -1, "content": "Using CUDA Graphs with cuFFT is supported on single GPU plans. It is also supported on multiple GPU plans starting with cuFFT version 10.4.0. The stream associated with a cuFFT plan must meet the requirements stated in Creating a Graph Using Stream Capture . Starting from CUDA 11.8 (including CUDA 12.0 onward), CUDA Graphs are no longer supported for callback routines that load data in out-of-place mode transforms. An upcoming release will update the cuFFT callback implementation, removing this limitation. cuFFT deprecated callback functionality based on separate compiled device code in cuFFT 11.4.", "keywords": []}, {"id": 315, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cudadatatype", "display_name": "cudaDataType", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cudadatatype", "priority": -1, "content": "The cudaDataType data type is an enumeration of the types supported by CUDA libraries. typedef enum cudaDataType_t { CUDA_R_16F= 2, // 16 bit real CUDA_C_16F= 6, // 16 bit complex CUDA_R_32F= 0, // 32 bit real CUDA_C_32F= 4, // 32 bit complex CUDA_R_64F= 1, // 64 bit real CUDA_C_64F= 5, // 64 bit complex CUDA_R_8I= 3, // 8 bit real as a signed integer CUDA_C_8I= 7, // 8 bit complex as a pair of signed integers CUDA_R_8U= 8, // 8 bit real as an unsigned integer CUDA_C_8U= 9 // 8 bit complex as a pair of unsigned integers } cudaDataType;", "keywords": []}, {"id": 316, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cudalibxtdesc", "display_name": "cudaLibXtDesc", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cudalibxtdesc", "priority": -1, "content": "A descriptor type used in multiple GPU routines that contains information about the library used. struct cudaLibXtDesc_t{ int version; //descriptor version cudaXtDesc *descriptor; //multi-GPU memory descriptor libFormat library; //which library recognizes the format int subFormat; //library specific enumerator of sub formats void *libDescriptor; //library specific descriptor e.g. FFT transform plan object }; typedef struct cudaLibXtDesc_t cudaLibXtDesc;", "keywords": []}, {"id": 317, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cudaxtdesc", "display_name": "cudaXtDesc", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cudaxtdesc", "priority": -1, "content": "A descriptor type used in multiple GPU routines that contains information about the GPUs and their memory locations. struct cudaXtDesc_t{ int version; //descriptor version int nGPUs; //number of GPUs int GPUs[MAX_CUDA_DESCRIPTOR_GPUS]; //array of device IDs void *data[MAX_CUDA_DESCRIPTOR_GPUS]; //array of pointers to data, one per GPU size_t size[MAX_CUDA_DESCRIPTOR_GPUS]; //array of data sizes, one per GPU void *cudaXtState; //opaque CUDA utility structure }; typedef struct cudaXtDesc_t cudaXtDesc;", "keywords": []}, {"id": 318, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-api-reference", "display_name": "cuFFT API Reference", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-api-reference", "priority": -1, "content": "This chapter specifies the behavior of the cuFFT library functions by describing their input/output parameters, data types, and error codes. The cuFFT library is initialized upon the first invocation of an API function, and cuFFT shuts down automatically when all user-created FFT plans are destroyed.", "keywords": []}, {"id": 319, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-callback-routines", "display_name": "cuFFT Callback Routines", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-callback-routines", "priority": -1, "content": "Callback routines are user-supplied kernel routines that cuFFT will call when loading or storing data. They allow the user to do data pre- or post- processing without additional kernel calls. Starting from CUDA 11.4, support for callback functionality using separately compiled device code is deprecated on all GPU architectures. Callback functionality will continue to be supported for all GPU architectures.", "keywords": []}, {"id": 320, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-code-examples", "display_name": "cuFFT Code Examples", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-code-examples", "priority": -1, "content": "For simple examples of complex and real 1D, 2D, and 3D transforms that use cuFFT to perform forward and inverse FFTs, refer to the cuFFT Library samples on GitHub .", "keywords": []}, {"id": 321, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-estimated-size-of-work-area", "display_name": "cuFFT Estimated Size of Work Area", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-estimated-size-of-work-area", "priority": -1, "content": "During plan execution, cuFFT requires a work area for temporary storage of intermediate results. The cufftEstimate*() calls return an estimate for the size of the work area required, given the specified parameters, and assuming default plan settings. Some problem sizes require much more storage than others. In particular powers of 2 are very efficient in terms of temporary storage. Large prime numbers, however, use different algorithms and may need up to the eight times that of a similarly sized power of 2. These routines return estimated workSize values which may still be smaller than the actual values needed especially for values of n that are not multiples of powers of 2, 3, 5 and 7. More refined values are given by the cufftGetSize*() routines, but these values may still be conservative.", "keywords": []}, {"id": 322, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-extensible-plans", "display_name": "cuFFT Extensible Plans", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-extensible-plans", "priority": -1, "content": "This API separates handle creation from plan generation. This makes it possible to change plan settings, which may alter the outcome of the plan generation phase, before the plan is actually generated.", "keywords": []}, {"id": 323, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-link-time-optimized-kernels", "display_name": "cuFFT Link-Time Optimized Kernels", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-link-time-optimized-kernels", "priority": -1, "content": "Starting from CUDA 12.4, cuFFT ships Link-Time Optimized (LTO) kernels. These kernels are linked and finalized at runtime as part of the cuFFT planning routines. This enables the cuFFT library to generate kernels optimized for the underlying architecture and the specific problem to solve. The current LTO kernel coverage includes: Kernels for 64-bit addressing (with FFTs spanning addresses greater than 2^(32)-1 elements). Some single- and double-precision R2C and C2R sizes. The number and coverage of LTO kernels will grow with future releases of cuFFT. We encourage our users to test whether LTO kernels improve the performance for their use case. Users can opt-in into LTO kernels by setting the NVFFT_PLAN_PROPERTY_INT64_PATIENT_JIT plan property using the cufftSetPlanProperty routine. In order to finalize LTO kernels, cuFFT relies on the nvJitLink library that ships as part of the CUDA Toolkit. Finalizing the kernels at runtime can cause an increase in planning time (which could be in the order of hundreds of milliseconds, depending on the cuFFT plan and hardware characteristics of the host system), in exchange for faster execution time of the optimized kernels. Note that nvJitLink caches kernels linked at runtime to speed-up subsequent kernel finalizations in repeated planning routines. If for any reason the runtime linking of the kernel fails, cuFFT will fall back to offline-compiled kernels to compute the FFT. cuFFT LTO kernels for a given toolkit version require using the nvJitLink library from the same toolkit or greater, but within the same toolkit major. For example, cuFFT in 12.4 requires nvJitLink to be from a CUDA Toolkit 12.X, with X &gt;= 4 . The nvJitLink library is loaded dynamically, and should be present in the system\u2019s dynamic linking path (e.g. LD_LIBRARY_PATH on Unix systems, or PATH on Windows systems).", "keywords": []}, {"id": 324, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-plan-properties", "display_name": "cuFFT Plan Properties", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-plan-properties", "priority": -1, "content": "Users can further customize cuFFT plans using plan properties. These properties can be set, queried and reset on a per-plan basis as needed, using the routines listed in this section. The current supported properties are listed below: Property Underlying Type Description Behavior NVFFT_PLAN_PROPERTY_INT64_PATIENT_JIT long long int Runtime LTO kernels are enabled when set to not-zero value. See Link-Time Optimized Kernels Runtime LTO kernles are disabled when set to zero (default) Can be set / reset before planning Cannot be set / reset after planning", "keywords": []}, {"id": 325, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufft-refined-estimated-size-of-work-area", "display_name": "cuFFT Refined Estimated Size of Work Area", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufft-refined-estimated-size-of-work-area", "priority": -1, "content": "The cufftGetSize*() routines give a more accurate estimate of the work area size required for a plan than the cufftEstimate*() routines as they take into account any plan settings that may have been made. As discussed in the section cuFFT Estimated Size of Work Area , the workSize value(s) returned may be conservative especially for values of n that are not multiples of powers of 2, 3, 5 and 7.", "keywords": []}, {"id": 326, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufftcomplex", "display_name": "cufftComplex", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufftcomplex", "priority": -1, "content": "A single-precision, floating-point complex data type that consists of interleaved real and imaginary components. typedef cuComplex cufftComplex;", "keywords": []}, {"id": 327, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufftdoublecomplex", "display_name": "cufftDoubleComplex", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufftdoublecomplex", "priority": -1, "content": "A double-precision, floating-point complex data type that consists of interleaved real and imaginary components. typedef cuDoubleComplex cufftDoubleComplex;", "keywords": []}, {"id": 328, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufftdoublereal", "display_name": "cufftDoubleReal", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufftdoublereal", "priority": -1, "content": "A double-precision, floating-point real data type. typedef double cufftDoubleReal;", "keywords": []}, {"id": 329, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#cufftreal", "display_name": "cufftReal", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cufftreal", "priority": -1, "content": "A single-precision, floating-point real data type. typedef float cufftReal;", "keywords": []}, {"id": 330, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#data-layout", "display_name": "Data Layout", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "data-layout", "priority": -1, "content": "In the cuFFT Library, data layout depends strictly on the configuration and the transform type. In the case of general complex-to-complex transform both the input and output data shall be a cufftComplex / cufftDoubleComplex array in single- and double-precision modes respectively. In C2R mode an input array (x_{1},x_{2},\\ldots,x_{\\lfloor\\frac{N}{2}\\rfloor + 1}) of only non-redundant complex elements is required. The output array (X_{1},X_{2},\\ldots,X_{N}) consists of cufftReal / cufftDouble elements in this mode. Finally, R2C demands an input array (X_{1},X_{2},\\ldots,X_{N}) of real values and returns an array (x_{1},x_{2},\\ldots,x_{\\lfloor\\frac{N}{2}\\rfloor + 1}) of non-redundant complex elements. In real-to-complex and complex-to-real transforms the size of input data and the size of output data differ. For out-of-place transforms a separate array of appropriate size is created. For in-place transforms the user should use padded data layout. This layout is FFTW compatibile. In the padded layout output signals begin at the same memory addresses as the input data. Therefore input data for real-to-complex and output data for complex-to-real must be padded. Expected sizes of input/output data for 1-d transforms are summarized in the table below: FFT type input data size output data size C2C x  cufftComplex x  cufftComplex C2R \\left\\lfloor \\frac{x}{2} \\right\\rfloor + 1  cufftComplex x  cufftReal R2C* x  cufftReal \\left\\lfloor \\frac{x}{2} \\right\\rfloor + 1  cufftComplex The real-to-complex transform is implicitly a forward transform. For an in-place real-to-complex transform where FFTW compatible output is desired, the input size must be padded to \\left( {\\lfloor\\frac{N}{2}\\rfloor + 1} \\right) complex elements. For out-of-place transforms, input and output sizes match the logical transform size N and the non-redundant size \\lfloor\\frac{N}{2}\\rfloor + 1 , respectively. The complex-to-real transform is implicitly inverse. For in-place complex-to-real FFTs where FFTW compatible output is selected (default padding mode), the input size is assumed to be \\lfloor\\frac{N}{2}\\rfloor + 1  cufftComplex elements. Note that in-place complex-to-real FFTs may overwrite arbitrary imaginary input point values when non-unit input and output strides are chosen. Out-of-place complex-to-real FFT will always overwrite input buffer. For out-of-place transforms, input and output sizes match the logical transform non-redundant size \\lfloor\\frac{N}{2}\\rfloor + 1 and size N , respectively.", "keywords": []}, {"id": 331, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#deprecated-functionality", "display_name": "Deprecated Functionality", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "deprecated-functionality", "priority": -1, "content": "Starting from CUDA 12.0: GPU architectures SM35 and SM37 are no longer supported. The minimum required architecture is SM50. Starting from CUDA 11.8: CUDA Graphs capture is no longer supported for callback routines that load data in out-of-place mode transforms. An upcoming release will update the cuFFT callback implementation, removing this limitation. Starting from CUDA 11.4: Support for callback functionality using separately compiled device code is deprecated on all GPU architectures. Callback functionality will continue to be supported for all GPU architectures. Starting from CUDA 11.0: GPU architecture SM30 is no longer supported. The minimum required architecture is SM35. Support for GPU architectures SM35, SM37 (Kepler), and SM50, SM52 (Maxwell) is deprecated. Function cufftSetCompatibilityMode was removed in version 9.1.", "keywords": []}, {"id": 332, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#fftw-conversion-guide", "display_name": "FFTW Conversion Guide", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fftw-conversion-guide", "priority": -1, "content": "cuFFT differs from FFTW in that FFTW has many plans and a single execute function while cuFFT has fewer plans, but multiple execute functions. The cuFFT execute functions determine the precision (single or double) and whether the input is complex or real valued. The following table shows the relationship between the two interfaces. FFTW function cuFFT function fftw_plan_dft_1d(), fftw_plan_dft_r2c_1d(), fftw_plan_dft_c2r_1d() cufftPlan1d() fftw_plan_dft_2d(), fftw_plan_dft_r2c_2d(), fftw_plan_dft_c2r_2d() cufftPlan2d() fftw_plan_dft_3d(), fftw_plan_dft_r2c_3d(), fftw_plan_dft_c2r_3d() cufftPlan3d() fftw_plan_dft(), fftw_plan_dft_r2c(), fftw_plan_dft_c2r() cufftPlanMany() fftw_plan_many_dft(), fftw_plan_many_dft_r2c(), fftw_plan_many_dft_c2r() cufftPlanMany() fftw_execute() cufftExecC2C(), cufftExecZ2Z(), cufftExecR2C(), cufftExecD2Z(), cufftExecC2R(), cufftExecZ2D() fftw_destroy_plan() cufftDestroy()", "keywords": []}, {"id": 333, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#fftw-interface-to-cufft", "display_name": "FFTW Interface to cuFFT", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fftw-interface-to-cufft", "priority": -1, "content": "NVIDIA provides FFTW3 interfaces to the cuFFT library. This allows applications using FFTW to use NVIDIA GPUs with minimal modifications to program source code. To use the interface first do the following two steps It is recommended that you replace the include file fftw3.h with cufftw.h Instead of linking with the double/single precision libraries such as fftw3/fftw3f libraries, link with both the cuFFT and cuFFTW libraries Ensure the search path includes the directory containing cuda_runtime_api.h After an application is working using the FFTW3 interface, users may want to modify their code to move data to and from the GPU and use the routines documented in the FFTW Conversion Guide for the best performance. The following tables show which components and functions of FFTW3 are supported in cuFFT. Section in FFTW manual Supported Unsupported Complex numbers fftw_complex, fftwf_complex types Precision double fftw3 , single fftwf3 long double fftw3l , quad precision fftw3q are not supported since CUDA functions operate on double and single precision floating-point quantities Memory Allocation fftw_malloc(), fftw_free(), fftw_alloc_real(), fftw_alloc_complex(), fftwf_alloc_real(), fftwf_alloc_complex() Multi-threaded FFTW fftw3_threads, fftw3_omp are not supported Distributed-memory FFTW with MPI fftw3_mpi,fftw3f_mpi are not supported Note that for each of the double precision functions below there is a corresponding single precision version with the letters fftw replaced by fftwf . Section in FFTW manual Supported Unsupported Using Plans fftw_execute(), fftw_destroy_plan(), fftw_cleanup() fftw_print_plan(), fftw_cost(), fftw_flops() exist but are not functional Basic Interface Complex DFTs fftw_plan_dft_1d(), fftw_plan_dft_2d(), fftw_plan_dft_3d(), fftw_plan_dft() Planner Flags Planner flags are ignored and the same plan is returned regardless Real-data DFTs fftw_plan_dft_r2c_1d(), fftw_plan_dft_r2c_2d(), fftw_plan_dft_r2c_3d(), fftw_plan_dft_r2c(), fftw_plan_dft_c2r_1d(), fftw_plan_dft_c2r_2d(), fftw_plan_dft_c2r_3d(), fftw_plan_dft_c2r() Read-data DFT Array Format Not supported Read-to-Real Transform Not supported Read-to-Real Transform Kinds Not supported Advanced Interface Advanced Complex DFTs fftw_plan_many_dft() with multiple 1D, 2D, 3D transforms fftw_plan_many_dft() with 4D or higher transforms or a 2D or higher batch of embedded transforms Advanced Real-data DFTs fftw_plan_many_dft_r2c(), fftw_plan_many_dft_c2r() with multiple 1D, 2D, 3D transforms fftw_plan_many_dft_r2c(), fftw_plan_many_dft_c2r() with 4D or higher transforms or a 2D or higher batch of embedded transforms Advanced Real-to-Real Transforms Not supported Guru Interface Interleaved and split arrays Interleaved format Split format Guru vector and transform sizes fftw_iodim struct Guru Complex DFTs fftw_plan_guru_dft(), fftw_plan_guru_dft_r2c(), fftw_plan_guru_dft_c2r() with multiple 1D, 2D, 3D transforms fftw_plan_guru_dft(), fftw_plan_guru_dft_r2c(), fftw_plan_guru_dft_c2r() with 4D or higher transforms or a 2D or higher batch of transforms Guru Real-data DFTs Not supported Guru Real-to-real Transforms Not supported 64-bit Guru Interface fftw_plan_guru64_dft(), fftw_plan_guru64_dft_r2c(), fftw_plan_guru64_dft_c2r() with multiple 1D, 2D, 3D transforms fftw_plan_guru64_dft(), fftw_plan_guru64_dft_r2c(), fftw_plan_guru64_dft_c2r() with 4D or higher transforms or a 2D or higher batch of transforms New-array Execute Functions fftw_execute_dft(), fftw_execute_dft_r2c(), fftw_execute_dft_c2r() with interleaved format Split format and real-to-real functions Wisdom fftw_export_wisdom_to_file(), fftw_import_wisdom_from_file() exist but are not functional. Other wisdom functions do not have entry points in the library.", "keywords": []}, {"id": 334, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#fourier-transform-setup", "display_name": "Fourier Transform Setup", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fourier-transform-setup", "priority": -1, "content": "The first step in using the cuFFT Library is to create a plan using one of the following: cufftPlan1D() / cufftPlan2D() / cufftPlan3D() - Create a simple plan for a 1D/2D/3D transform respectively. cufftPlanMany() - Creates a plan supporting batched input and strided data layouts. cufftXtMakePlanMany() - Creates a plan supporting batched input and strided data layouts for any supported precision. Among the plan creation functions, cufftPlanMany() allows use of more complicated data layouts and batched executions. Execution of a transform of a particular size and type may take several stages of processing. When a plan for the transform is generated, cuFFT derives the internal steps that need to be taken. These steps may include multiple kernel launches, memory copies, and so on. In addition, all the intermediate buffer allocations (on CPU/GPU memory) take place during planning. These buffers are released when the plan is destroyed. In the worst case, the cuFFT Library allocates space for 8*batch*n[0]*..*n[rank-1] cufftComplex or cufftDoubleComplex elements (where batch denotes the number of transforms that will be executed in parallel, rank is the number of dimensions of the input data (see Multidimensional Transforms ) and n[] is the array of transform dimensions) for single and double-precision transforms respectively. Depending on the configuration of the plan, less memory may be used. In some specific cases, the temporary space allocations can be as low as 1*batch*n[0]*..*n[rank-1] cufftComplex or cufftDoubleComplex elements. This temporary space is allocated separately for each individual plan when it is created (i.e., temporary space is not shared between the plans). The next step in using the library is to call an execution function such as cufftExecC2C() (see Parameter cufftType ) which will perform the transform with the specifications defined at planning. One can create a cuFFT plan and perform multiple transforms on different data sets by providing different input and output pointers. Once the plan is no longer needed, the cufftDestroy() function should be called to release the resources allocated for the plan.", "keywords": []}, {"id": 335, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#fourier-transform-types", "display_name": "Fourier Transform Types", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fourier-transform-types", "priority": -1, "content": "Apart from the general complex-to-complex (C2C) transform, cuFFT implements efficiently two other types: real-to-complex (R2C) and complex-to-real (C2R). In many practical applications the input vector is real-valued. It can be easily shown that in this case the output satisfies Hermitian symmetry ( X_{k} = X_{N - k}^{\\ast} , where the star denotes complex conjugation). The converse is also true: for complex-Hermitian input the inverse transform will be purely real-valued. cuFFT takes advantage of this redundancy and works only on the first half of the Hermitian vector. Transform execution functions for single and double-precision are defined separately as: cufftExecC2C() / cufftExecZ2Z() - complex-to-complex transforms for single/double precision. cufftExecR2C() / cufftExecD2Z() - real-to-complex forward transform for single/double precision. cufftExecC2R() / cufftExecZ2D() - complex-to-real inverse transform for single/double precision. Each of those functions demands different input data layout (see Data Layout for details). Complex-to-real (C2R) transforms accept complex-Hermitian input. For one-dimensional signals, this requires the 0th element (and the \\frac{N}{2} th input if N is even) to be real-valued, i.e. its imaginary part should be zero. For d-dimension signals, this means x_{(n_{1},n_{2},\\ldots,n_{d})} = x_{(N_{1} - n_{1},N_{2} - n_{2},\\ldots,N_{d} - n_{d})}^{\\ast} . Otherwise, the behavior of the transform is undefined. Also see Multidimensional Transforms . Functions cufftXtExec() and cufftXtExecDescriptor() can perform transforms on any of the supported types.", "keywords": []}, {"id": 336, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#free-memory-requirement", "display_name": "Free Memory Requirement", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "free-memory-requirement", "priority": -1, "content": "The first program call to any cuFFT function causes the initialization of the cuFFT kernels. This can fail if there is not enough free memory on the GPU. It is advisable to initialize cufft first (e.g. by creating a plan) and then allocating memory.", "keywords": []}, {"id": 337, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#half-precision-cufft-transforms", "display_name": "Half-precision cuFFT Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "half-precision-cufft-transforms", "priority": -1, "content": "Half-precision transforms have the following limitations: Minimum GPU architecture is SM_53 Sizes are restricted to powers of two only Strides on the real part of real-to-complex and complex-to-real transforms are not supported More than one GPU is not supported Transforms spanning more than 4 billion elements are not supported Please refer to cufftXtMakePlanMany function for plan creation details. The CUDA Toolkit provides the cuda_fp16.h header with types and intrinsic functions for handling half-precision arithmetic.", "keywords": []}, {"id": 338, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#helper-functions", "display_name": "Helper Functions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "helper-functions", "priority": -1, "content": "Multiple GPU cuFFT execution functions assume a certain data layout in terms of what input data has been copied to which GPUs prior to execution, and what output data resides in which GPUs post execution. cuFFT provides functions to assist users in manipulating data on multiple GPUs. These must be called after the call to cufftMakePlan*() . On a single GPU users may call cudaMalloc() and cudaFree() to allocate and free GPU memory. To provide similar functionality in the multiple GPU case, cuFFT includes cufftXtMalloc() and cufftXtFree() functions. The function cufftXtMalloc() returns a descriptor which specifies the location of these memories. On a single GPU users may call cudaMemcpy() to transfer data between host and GPU memory. To provide similar functionality in the multiple GPU case, cuFFT includes cufftXtMemcpy() which allows users to copy between host and multiple GPU memories or even between the GPU memories. All single GPU cuFFT FFTs return output the data in natural order, that is the ordering of the result is the same as if a DFT had been performed on the data. Some Fast Fourier Transforms produce intermediate results where the data is left in a permutation of the natural output. When batch is one, data is left in the GPU memory in a permutation of the natural output. When cufftXtMemcpy() is used to copy data from GPU memory back to host memory, the results are in natural order regardless of whether the data on the GPUs is in natural order or permuted. Using CUFFT_COPY_DEVICE_TO_DEVICE allows users to copy data from the permuted data format produced after a single transform to the natural order on GPUs.", "keywords": []}, {"id": 339, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#id1", "display_name": "Overview of the cuFFT Callback Routine Feature", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "id1", "priority": -1, "content": "cuFFT provides a set of APIs that allow the cuFFT user to provide CUDA functions that re-direct or manipulate the data as it is loaded prior to processing the FFT, or stored once the FFT has been done. For the load callback, cuFFT passes the callback routine the address of the input data and the offset to the value to be loaded from device memory, and the callback routine returns the value it wishes cuFFT to use instead. For the store callback, cuFFT passes the callback routine the value it has computed, along with the address of the output data and the offset to the value to be written to device memory, and the callback routine modifies the value and stores the modified result.", "keywords": []}, {"id": 340, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#librarypropertytype", "display_name": "libraryPropertyType", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "librarypropertytype", "priority": -1, "content": "The libraryPropertyType data type is an enumeration of library property types. (ie. CUDA version X.Y.Z would yield MAJOR_VERSION=X , MINOR_VERSION=Y , PATCH_LEVEL=Z ) typedef enum libraryPropertyType_t { MAJOR_VERSION, MINOR_VERSION, PATCH_LEVEL } libraryPropertyType;", "keywords": []}, {"id": 341, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#memory-allocation-and-data-movement-functions", "display_name": "Memory Allocation and Data Movement Functions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "memory-allocation-and-data-movement-functions", "priority": -1, "content": "Multiple GPU cuFFT execution functions assume a certain data layout in terms of what input data has been copied to which GPUs prior to execution, and what output data resides in which GPUs post execution. The following functions assist in allocation, setup and retrieval of the data. They must be called after the call to cufftMakePlan*() .", "keywords": []}, {"id": 342, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multidimensional-transforms", "display_name": "Multidimensional Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multidimensional-transforms", "priority": -1, "content": "Multidimensional DFT map a d -dimensional array x_{\\mathbf{n}} , where \\mathbf{n} = (n_{1},n_{2},\\ldots,n_{d}) into its frequency domain array given by: X_{\\mathbf{k}} = \\sum\\limits_{n = 0}^{N - 1}x_{\\mathbf{n}}e^{-2\\pi i\\frac{\\mathbf{k}\\mathbf{n}}{\\mathbf{N}}} where \\frac{\\mathbf{n}}{\\mathbf{N}} = (\\frac{n_{1}}{N_{1}},\\frac{n_{2}}{N_{2}},\\ldots,\\frac{n_{d}}{N_{d}}) , and the summation denotes the set of nested summations \\sum\\limits_{n_{1} = 0}^{N_{1} - 1}\\sum\\limits_{n_{2} = 0}^{N_{2} - 1}\\ldots\\sum\\limits_{n_{d} = 0}^{N_{d} - 1} cuFFT supports one-dimensional, two-dimensional and three-dimensional transforms, which can all be called by the same cufftExec* functions (see Fourier Transform Types ). Similar to the one-dimensional case, the frequency domain representation of real-valued input data satisfies Hermitian symmetry, defined as: x_{(n_{1},n_{2},\\ldots,n_{d})} = x_{(N_{1} - n_{1},N_{2} - n_{2},\\ldots,N_{d} - n_{d})}^{\\ast} . C2R and R2C algorithms take advantage of this fact by operating only on half of the elements of signal array, namely on: x_{\\mathbf{n}} for \\mathbf{n} \\in \\{ 1,\\ldots,N_{1}\\} \\times \\ldots \\times \\{ 1,\\ldots,N_{d - 1}\\} \\times \\{ 1,\\ldots,\\lfloor\\frac{N_{d}}{2}\\rfloor + 1\\} . The general rules of data alignment described in Data Layout apply to higher-dimensional transforms. The following table summarizes input and output data sizes for multidimensional DFTs: Dims FFT type Input data size Output data size 1D C2C \\mathbf{N}_{1}  cufftComplex \\mathbf{N}_{1}  cufftComplex 1D C2R \\lfloor\\frac{\\mathbf{N}_{1}}{2}\\rfloor + 1  cufftComplex \\mathbf{N}_{1}  cufftReal 1D R2C \\mathbf{N}_{1}  cufftReal \\lfloor\\frac{\\mathbf{N}_{1}}{2}\\rfloor + 1  cufftComplex 2D C2C \\mathbf{N}_{1}\\mathbf{N}_{2}  cufftComplex \\mathbf{N}_{1}\\mathbf{N}_{2}  cufftComplex 2D C2R \\mathbf{N}_{1}(\\lfloor\\frac{\\mathbf{N}_{2}}{2}\\rfloor + 1)  cufftComplex \\mathbf{N}_{1}\\mathbf{N}_{2}  cufftReal 2D R2C \\mathbf{N}_{1}\\mathbf{N}_{2}  cufftReal \\mathbf{N}_{1}(\\lfloor\\frac{\\mathbf{N}_{2}}{2}\\rfloor + 1)  cufftComplex 3D C2C \\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}  cufftComplex \\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}  cufftComplex 3D C2R \\mathbf{N}_{1}\\mathbf{N}_{2}(\\lfloor\\frac{\\mathbf{N}_{3}}{2}\\rfloor + 1)  cufftComplex \\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}  cufftReal 3D R2C \\mathbf{N}_{1}\\mathbf{N}_{2}\\mathbf{N}_{3}  cufftReal \\mathbf{N}_{1}\\mathbf{N}_{2}(\\lfloor\\frac{\\mathbf{N}_{3}}{2}\\rfloor + 1)  cufftComplex For example, static declaration of a three-dimensional array for the output of an out-of-place real-to-complex transform will look like this: cufftComplex odata[N1][N2][N3/2+1];", "keywords": []}, {"id": 343, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-2d-and-3d-transforms-on-permuted-input", "display_name": "Multiple GPU 2D and 3D Transforms on Permuted Input", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-2d-and-3d-transforms-on-permuted-input", "priority": -1, "content": "For single 2D or 3D transforms on multiple GPUs, when cufftXtMemcpy() distributes the data to the GPUs, the array is divided on the X axis. E.G. for two GPUs half of the X dimenson points, for all Y (and Z) values, are copied to each of the GPUs. When the transform is computed, the data are permuted such that they are divided on the Y axis. I.E. half of the Y dimension points, for all X (and Z) values are on each of the GPUs. When cuFFT creates a 2D or 3D plan for a single transform on multiple GPUs, it actually creates two plans. One plan expects input to be divided on the X axis. The other plan expects data to be divided on the Y axis. This is done because many algorithms compute a forward FFT, then perform some point-wise operation on the result, and then compute the inverse FFT. A memory copy to restore the data to the original order would be expensive. To avoid this, cufftXtMemcpy and cufftXtExecDescriptor() keep track of the data ordering so that the correct operation is used. The ability of cuFFT to process data in either order makes the following sequence possible. cufftCreate() - create an empty plan, as in the single GPU case cufftXtSetGPUs() - define which GPUs are to be used cufftMakePlan{1d,2d,3d,Many}() - create the plan. cufftXtMalloc() - allocate descriptor and data on the GPUs cufftXtMemcpy() - copy data to the GPUs cufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z() - compute the forward FFT userFunction() - modify the data in the frequency domain cufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z() - compute the inverse FFT Note that it was not necessary to copy/permute the data between execute calls cufftXtMemcpy() - copy data to the host cufftXtFree() - free any memory allocated with cufftXtMalloc() cufftDestroy() - free cuFFT plan resources", "keywords": []}, {"id": 344, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-cufft-transforms", "display_name": "Multiple GPU cuFFT Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-cufft-transforms", "priority": -1, "content": "cuFFT supports using up to sixteen GPUs connected to a CPU to perform Fourier Transforms whose calculations are distributed across the GPUs. An API has been defined to allow users to write new code or modify existing code to use this functionality. Some existing functions such as the creation of a plan using cufftCreate() also apply in the multiple GPU case. Multiple GPU routines contain Xt in their name. The memory on the GPUs is managed by helper functions cufftXtMalloc()/cufftXtFree() and cufftXtMemcpy() using the cudaLibXtDesc descriptor. Performance is a function of the bandwidth between the GPUs, the computational ability of the individual GPUs, and the type and number of FFT to be performed. The highest performance is obtained using NVLink interconnect ( https://www.nvidia.com/object/nvlink.html ). The second best option is using PCI Express 3.0 between the GPUs and ensuring that both GPUs are on the same switch. Note that multiple GPU execution is not guaranteed to solve a given size problem in a shorter time than single GPU execution. The multiple GPU extensions to cuFFT are built on the extensible cuFFT API. The general steps in defining and executing a transform with this API are: cufftCreate() - create an empty plan, as in the single GPU case cufftXtSetGPUs() - define which GPUs are to be used Optional: cufftEstimate{1d,2d,3d,Many}() - estimate the sizes of the work areas required. These are the same functions used in the single GPU case although the definition of the argument workSize reflects the number of GPUs used. cufftMakePlan{1d,2d,3d,Many}() - create the plan. These are the same functions used in the single GPU case although the definition of the argument workSize reflects the number of GPUs used. Optional: cufftGetSize{1d,2d,3d,Many}() - refined estimate of the sizes of the work areas required. These are the same functions used in the single GPU case although the definition of the argument workSize reflects the number of GPUs used. Optional: cufftGetSize() - check workspace size. This is the same function used in the single GPU case although the definition of the argument workSize reflects the number of GPUs used. Optional: cufftXtSetWorkArea() - do your own workspace allocation. cufftXtMalloc() - allocate descriptor and data on the GPUs cufftXtMemcpy() - copy data to the GPUs cufftXtExecDescriptorC2C()/cufftXtExecDescriptorZ2Z() - execute the plan cufftXtMemcpy() - copy data from the GPUs cufftXtFree() - free any memory allocated with cufftXtMalloc() cufftDestroy() - free cuFFT plan resources", "keywords": []}, {"id": 345, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-data-organization", "display_name": "Multiple GPU Data Organization", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-data-organization", "priority": -1, "content": "This chapter explains how data are distributed between the GPUs, before and after a multiple GPU transform. For simplicity, it is assumed in this chapter that the caller has specified GPU 0 and GPU 1 to perform the transform.", "keywords": []}, {"id": 346, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-data-organization-for-batched-transforms", "display_name": "Multiple GPU Data Organization for Batched Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-data-organization-for-batched-transforms", "priority": -1, "content": "For batches of transforms, each individual transform is executed on a single GPU. If possible the batches are evenly distributed among the GPUs. For a batch of size m performed on n GPUs, where m is not divisible by n , the first m % n GPUs will perform \\left\\lfloor \\frac{m}{n} \\right\\rfloor+\\ 1 transforms. The remaining GPUs will perform \\left\\lfloor \\frac{m}{n} \\right\\rfloor transforms. For example, in a batch of 15 transforms performed on 4 GPUs, the first three GPUs would perform 4 transforms, and the last GPU would perform 3 transforms. This approach removes the need for data exchange between the GPUs, and results in nearly perfect scaling for cases where the batch size is divisible by the number of GPUs.", "keywords": []}, {"id": 347, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-data-organization-for-single-1d-transforms", "display_name": "Multiple-GPU Data Organization for Single 1D Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-data-organization-for-single-1d-transforms", "priority": -1, "content": "By default for 1D transforms, the initial distribution of data to the GPUs is similar to the 2D and 3D cases. For a transform of dimension x on two GPUs, GPU 0 receives data ranging from 0\u2026(x/2-1). GPU 1 receives data ranging from (x/2)\u2026(x-1). Similarly, with 4 GPUs, the data are evenly distributed among all 4 GPUs. Before computation can begin, data are redistributed among the GPUs. It is possible to perform this redistribution in the copy from host memory, in cases where the application does not need to pre-process the data prior to the transform. To do this, the application can create the data descriptor with cufftXtMalloc using the sub-format CUFFT_XT_FORMAT_1D_INPUT_SHUFFLED . This can significantly reduce the time it takes to execute the transform. cuFFT performs multiple GPU 1D transforms by decomposing the transform size into factors Factor1 and Factor2 , and treating the data as a grid of size Factor1 x Factor2 . The four steps done to calculate the 1D FFT are: Factor1 transforms of size Factor2 , data exchange between the GPUs, a pointwise twiddle multiplication, and Factor2 transforms of size Factor1 . To gain efficiency by overlapping computation with data exchange, cuFFT breaks the whole transform into independent segments or strings, which can be processed while others are in flight. A side effect of this algorithm is that the output of the transform is not in linear order. The output in GPU memory is in strings, each of which is composed of Factor2 substrings of equal size. Each substring contains contiguous results starting Factor1 elements subsequent to start of the previous substring. Each string starts substring size elements after the start of the previous string. The strings appear in order, the first half on GPU 0, and the second half on GPU 1. See the example below: transform size = 1024 number of strings = 8 Factor1 = 64 Factor2 = 16 substrings per string for output layout is Factor2 (16) string size = 1024/8 = 128 substring size = 128/16 = 8 stride between substrings = 1024/16 = Factor1 (64) On GPU 0: string 0 has substrings with indices 0...7 64...71 128...135 ... 960...967 string 1 has substrings with indices 8...15 72...79 136...143 ... 968...975 ... On GPU 1: string 4 has substrings with indices 32...39 96...103 160...167 ... 992...999 ... string 7 has substrings with indices 56...63 120...127 184...191 ... 1016...1023 The cufftXtQueryPlan API allows the caller to retrieve a structure containing the number of strings, the decomposition factors, and (in the case of power of 2 size) some useful mask and shift elements. The example below shows how cufftXtQueryPlan is invoked. It also shows how to translate from an index in the host input array to the corresponding index on the device, and vice versa. /* * These routines demonstrate the use of cufftXtQueryPlan to get the 1D * factorization and convert between permuted and linear indexes. */ /* * Set up a 1D plan that will execute on GPU 0 and GPU1, and query * the decomposition factors */ int main(int argc, char **argv){ cufftHandle plan; cufftResult stat; int whichGPUs[2] = { 0, 1 }; cufftXt1dFactors factors; stat = cufftCreate( &amp;plan ); if (stat != CUFFT_SUCCESS) { printf(&quot;Create error %d\\n&quot;,stat); return 1; } stat = cufftXtSetGPUs( plan, 2, whichGPUs ); if (stat != CUFFT_SUCCESS) { printf(&quot;SetGPU error %d\\n&quot;,stat); return 1; } stat = cufftMakePlan1d( plan, size, CUFFT_C2C, 1, workSizes ); if (stat != CUFFT_SUCCESS) { printf(&quot;MakePlan error %d\\n&quot;,stat); return 1; } stat = cufftXtQueryPlan( plan, (void *) &amp;factors, CUFFT_QUERY_1D_FACTORS ); if (stat != CUFFT_SUCCESS) { printf(&quot;QueryPlan error %d\\n&quot;,stat); return 1; } printf(&quot;Factor 1 %zd, Factor2 %zd\\n&quot;,factors.factor1,factors.factor2); cufftDestroy(plan); return 0; } /* * Given an index into a permuted array, and the GPU index return the * corresponding linear index from the beginning of the input buffer. * * Parameters: * factors input: pointer to cufftXt1dFactors as returned by * cufftXtQueryPlan * permutedIx input: index of the desired element in the device output * array * linearIx output: index of the corresponding input element in the * host array * GPUix input: index of the GPU containing the desired element */ cufftResult permuted2Linear( cufftXt1dFactors * factors, size_t permutedIx, size_t *linearIx, int GPUIx ) { size_t indexInSubstring; size_t whichString; size_t whichSubstring; // the low order bits of the permuted index match those of the linear index indexInSubstring = permutedIx &amp; factors-&gt;substringMask; // the next higher bits are the substring index whichSubstring = (permutedIx &gt;&gt; factors-&gt;substringShift) &amp; factors-&gt;factor2Mask; // the next higher bits are the string index on this GPU whichString = (permutedIx &gt;&gt; factors-&gt;stringShift) &amp; factors-&gt;stringMask; // now adjust the index for the second GPU if (GPUIx) { whichString += factors-&gt;stringCount/2; } // linear index low order bits are the same // next higher linear index bits are the string index *linearIx = indexInSubstring + ( whichString &lt;&lt; factors-&gt;substringShift ); // next higher bits of linear address are the substring index *linearIx += whichSubstring &lt;&lt; factors-&gt;factor1Shift; return CUFFT_SUCCESS; } /* * Given a linear index into a 1D array, return the GPU containing the permuted * result, and index from the start of the data buffer for that element. * * Parameters: * factors input: pointer to cufftXt1dFactors as returned by * cufftXtQueryPlan * linearIx input: index of the desired element in the host input * array * permutedIx output: index of the corresponding result in the device * output array * GPUix output: index of the GPU containing the result */ cufftResult linear2Permuted( cufftXt1dFactors * factors, size_t linearIx, size_t *permutedIx, int *GPUIx ) { size_t indexInSubstring; size_t whichString; size_t whichSubstring; size_t whichStringMask; int whichStringShift; if (linearIx &gt;= factors-&gt;size) { return CUFFT_INVALID_VALUE; } // get a useful additional mask and shift count whichStringMask = factors-&gt;stringCount -1; whichStringShift = (factors-&gt;factor1Shift + factors-&gt;factor2Shift) - factors-&gt;stringShift ; // the low order bits identify the index within the substring indexInSubstring = linearIx &amp; factors-&gt;substringMask; // first determine which string has our linear index. // the low order bits indentify the index within the substring. // the next higher order bits identify which string. whichString = (linearIx &gt;&gt; factors-&gt;substringShift) &amp; whichStringMask; // the first stringCount/2 strings are in the first GPU, // the rest are in the second. *GPUIx = whichString/(factors-&gt;stringCount/2); // next determine which substring within the string has our index // the substring index is in the next higher order bits of the index whichSubstring = (linearIx &gt;&gt;(factors-&gt;substringShift + whichStringShift)) &amp; factors-&gt;factor2Mask; // now we can re-assemble the index *permutedIx = indexInSubstring; *permutedIx += whichSubstring &lt;&lt; factors-&gt;substringShift; if ( !*GPUIx ) { *permutedIx += whichString &lt;&lt; factors-&gt;stringShift; } else { *permutedIx += (whichString - (factors-&gt;stringCount/2) ) &lt;&lt; factors-&gt;stringShift; } return CUFFT_SUCCESS; }", "keywords": []}, {"id": 348, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#multiple-gpu-data-organization-for-single-2d-and-3d-transforms", "display_name": "Multiple GPU Data Organization for Single 2D and 3D Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "multiple-gpu-data-organization-for-single-2d-and-3d-transforms", "priority": -1, "content": "Single transforms performed on multiple GPUs require the data to be divided between the GPUs. Then execution takes place in phases. For example with 2 GPUs, for 2D and 3D transforms with even sized dimensions, each GPU does half of the transform in (rank - 1) dimensions. Then data are exchanged between the GPUs so that the final dimension can be processed. Since 2D and 3D transforms support sizes other than powers of 2, it is possible that the data can not be evenly distributed among the GPUs. In general for the case of n GPUs, a dimension of size m that is not a multiple of n would be distributed such that the first m % n GPUs would get one extra row for 2D transforms, one extra plane for 3D transforms. Take for example, a 2D transform on 4 GPUs, using an array declared in C as data[x][y] , where x is 65 and y is 99. The surface is distributed prior to the transform such that GPU 0 receives a surface with dimensions [17][99] , and GPUs 1\u20263 receive surfaces with dimensions [16][99] . After the transform, each GPU again has a portion of the surface, but divided in the y dimension. GPUs 0\u20262 have surfaces with dimensions [65][25] . GPU 3 has a surface with dimensions [65][24] For a 3D transform on 4 GPUs consider an array declared in C as data[x][y][z] , where x is 103, y is 122, and z is 64. The volume is distributed prior to the transform such that each GPUs 0\u20262 receive volumes with dimensions [26][122][64] , and GPU 3 receives a volume with dimensions [25][122][64] . After the transform, each GPU again has a portion of the surface, but divided in the y dimension. GPUs 0 and 1 have a volumes with dimensions [103][31][64] , and GPUs 2 and 3 have volumes with dimensions [103][30][64] .", "keywords": []}, {"id": 349, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#no-ordering-guarantees-within-a-kernel", "display_name": "No Ordering Guarantees Within a Kernel", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-ordering-guarantees-within-a-kernel", "priority": -1, "content": "Note that there are no guarantees on the relative order of execution of blocks within a grid. As such, callbacks should not rely on any particular ordering within a kernel. For instance, reordering data (such as an FFT-shift) could rely on the order of execution of the blocks. Results in this case would be undefined.", "keywords": []}, {"id": 350, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notice", "priority": -1, "content": "This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (\u201cNVIDIA\u201d) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (\u201cTerms of Sale\u201d). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer\u2019s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer\u2019s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer\u2019s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201cMATERIALS\u201d) ARE BEING PROVIDED \u201cAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA\u2019s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.", "keywords": []}, {"id": 351, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#opencl", "display_name": "OpenCL", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opencl", "priority": -1, "content": "OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.", "keywords": []}, {"id": 352, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#overview-of-the-cufft-callback-routine-feature", "display_name": "Overview of the cuFFT Callback Routine Feature", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "overview-of-the-cufft-callback-routine-feature", "priority": -1, "content": "cuFFT provides a set of APIs that allow the cuFFT user to provide CUDA functions that re-direct or manipulate the data as it is loaded prior to processing the FFT, or stored once the FFT has been done. For the load callback, cuFFT passes the callback routine the address of the input data and the offset to the value to be loaded from device memory, and the callback routine returns the value it wishes cuFFT to use instead. For the store callback, cuFFT passes the callback routine the value it has computed, along with the address of the output data and the offset to the value to be written to device memory, and the callback routine modifies the value and stores the modified result. In order to provide a callback to cuFFT, a plan is created and configured normally using the extensible plan APIs. After the call to cufftCreate and cufftMakePlan , the user may associate a load callback routine, or a store callback routine, or both, with the plan, by calling cufftXtSetCallback . The caller also has the option to specify a device pointer to an opaque structure they wish to associate with the plan. This pointer will be passed to the callback routine by the cuFFT library. The caller may use this structure to remember plan dimensions and strides, or have a pointer to auxiliary data, etc. With some restrictions, the callback routine is allowed to request shared memory for its own use. If the requested amount of shared memory is available, cufft will pass a pointer to it when it calls the callback routine. CUFFT allows for 8 types of callback routine, one for each possible combination of: load or store, real or complex, single precision or double. It is the caller\u2019s responsibility to provide a routine that matches the function prototype for the type of routine specified. If there is already a callback of the specified type associated with the plan, the set callback function will replace it with the new one. The callback routine extensions to cuFFT are built on the extensible cuFFT API. The general steps in defining and executing a transform with callbacks are: cufftCreate() - create an empty plan, as in the single GPU case cufftMakePlan{1d,2d,3d,Many}() - create the plan. These are the same functions used in the single GPU case. cufftXtSetCallback() - called for load and/or store callback for this plan cufftExecC2C() etc. - execute the plan cufftDestroy() - free cuFFT plan resources Callback functions are not supported on transforms with a dimension size that does not factor into primes smaller than 127. Callback functions on plans whose dimensions\u2019 prime factors are limited to 2, 3, 5, and 7 can safely call __syncthreads() . On other plans, results are not defined. The callback API is available in the statically linked cuFFT library only, and only on 64 bit LINUX operating systems.", "keywords": []}, {"id": 353, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#parameter-cuffttype", "display_name": "Parameter cufftType", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameter-cuffttype", "priority": -1, "content": "The cuFFT library supports complex- and real-data transforms. The cufftType data type is an enumeration of the types of transform data supported by cuFFT. typedef enum cufftType_t { CUFFT_R2C = 0x2a, // Real to complex (interleaved) CUFFT_C2R = 0x2c, // Complex (interleaved) to real CUFFT_C2C = 0x29, // Complex to complex (interleaved) CUFFT_D2Z = 0x6a, // Double to double-complex (interleaved) CUFFT_Z2D = 0x6c, // Double-complex (interleaved) to double CUFFT_Z2Z = 0x69 // Double-complex to double-complex (interleaved) } cufftType;", "keywords": []}, {"id": 354, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#parameter-cufftxtcopytype", "display_name": "Parameter cufftXtCopyType", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameter-cufftxtcopytype", "priority": -1, "content": "cufftXtCopyType_t is an enumerated type for multiple GPU functions that specifies the type of copy for cufftXtMemcpy() . CUFFT_COPY_HOST_TO_DEVICE copies data from a contiguous host buffer to multiple device buffers, in the layout cuFFT requires for input data. dstPointer must point to a cudaLibXtDesc structure, and srcPointer must point to a host memory buffer. CUFFT_COPY_DEVICE_TO_HOST copies data from multiple device buffers, in the layout cuFFT produces for output data, to a contiguous host buffer. dstPointer must point to a host memory buffer, and srcPointer must point to a cudaLibXtDesc structure. CUFFT_COPY_DEVICE_TO_DEVICE copies data from multiple device buffers, in the layout cuFFT produces for output data, to multiple device buffers, in the layout cuFFT requires for input data. dstPointer and srcPointer must point to different cudaLibXtDesc structures (and therefore memory locations). That is, the copy cannot be in-place. Note that device_to_device cufftXtMemcpy() for 2D and 3D data is not currently supported. typedef enum cufftXtCopyType_t { CUFFT_COPY_HOST_TO_DEVICE, CUFFT_COPY_DEVICE_TO_HOST, CUFFT_COPY_DEVICE_TO_DEVICE } cufftXtCopyType;", "keywords": []}, {"id": 355, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#parameter-cufftxtsubformat", "display_name": "Parameter cufftXtSubFormat", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameter-cufftxtsubformat", "priority": -1, "content": "cufftXtSubFormat_t is an enumerated type that indicates if the buffer will be used for input or output and the ordering of the data. typedef enum cufftXtSubFormat_t { CUFFT_XT_FORMAT_INPUT, //by default input is in linear order across GPUs CUFFT_XT_FORMAT_OUTPUT, //by default output is in scrambled order depending on transform CUFFT_XT_FORMAT_INPLACE, //by default inplace is input order, which is linear across GPUs CUFFT_XT_FORMAT_INPLACE_SHUFFLED, //shuffled output order after execution of the transform CUFFT_FORMAT_UNDEFINED } cufftXtSubFormat;", "keywords": []}, {"id": 356, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#parameters-for-transform-direction", "display_name": "Parameters for Transform Direction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameters-for-transform-direction", "priority": -1, "content": "The cuFFT library defines forward and inverse Fast Fourier Transforms according to the sign of the complex exponential term. #define cuFFTFORWARD -1 #define cuFFTINVERSE 1 cuFFT performs un-normalized FFTs; that is, performing a forward FFT on an input data set followed by an inverse FFT on the resulting set yields data that is equal to the input, scaled by the number of elements. Scaling either transform by the reciprocal of the size of the data set is left for the user to perform as seen fit.", "keywords": []}, {"id": 357, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#plan-initialization-time", "display_name": "Plan Initialization Time", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "plan-initialization-time", "priority": -1, "content": "During plan initialization, cuFFT conducts a series of steps, including heuristics to determine which kernels to be used as well as kernel module loads. Starting from CUDA 12.0, cuFFT delivers a larger portion of kernels using the CUDA Parallel Thread eXecution assembly form (PTX code), instead of the binary form (cubin object). The PTX code of cuFFT kernels are loaded and compiled further to the binary code by the CUDA device driver at runtime when a cuFFT plan is initialized. This is called just-in-time (JIT) compilation . JIT compilation slightly increases cuFFT plan initialization time, depending on the transform size and the speed of the host CPU (see Module load driver API ) . But the JIT overhead occurs only when a binary code is generated for the first time during plan initialization using one of the plan creation functions . The device driver automatically caches a copy of the generated binary code to avoid repeating the compilation in subsequent invocations. If necessary, CUDA_CACHE_PATH or CUDA_CACHE_MAXSIZE can be customized to set the cache folder and max size (see detail in CUDA Environmental Variables ), but the default settings are fine in general.", "keywords": []}, {"id": 358, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#plan-specification-and-work-areas", "display_name": "Plan Specification and Work Areas", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "plan-specification-and-work-areas", "priority": -1, "content": "In the single GPU case a plan is created by a call to cufftCreate() followed by a call to cufftMakePlan*() . For multiple GPUs, the GPUs to use for execution are identified by a call to cufftXtSetGPUs() and this must occur after the call to cufftCreate() and prior to the call to cufftMakePlan*() . Note that when cufftMakePlan*() is called for a single GPU, the work area is on that GPU. In a multiple GPU plan, the returned work area has multiple entries; one value per GPU. That is workSize points to a size_t array, one entry per GPU. Also the strides and batches apply to the entire plan across all GPUs associated with the plan. Once a plan is locked by a call to cufftMakePlan*() , different descriptors may be specified in calls to cufftXtExecDescriptor*() to execute the plan on different data sets, but the new descriptors must use the same GPUs in the same order. As in the single GPU case, cufftEstimateSize{Many,1d,2d,3d}() and cufftGetSize{Many,1d,2d,3d}() give estimates of the work area sizes required for a multiple GPU plan and in this case workSize points to a size_t array, one entry per GPU. Similarly the actual work size returned by cufftGetSize() is a size_t array, one entry per GPU in the multiple GPU case.", "keywords": []}, {"id": 359, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#return-value-cufftresult", "display_name": "Return value cufftResult", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "return-value-cufftresult", "priority": -1, "content": "All cuFFT Library return values except for CUFFT_SUCCESS indicate that the current API call failed and the user should reconfigure to correct the problem. The possible return values are defined as follows: typedef enum cufftResult_t { CUFFT_SUCCESS = 0, // The cuFFT operation was successful CUFFT_INVALID_PLAN = 1, // cuFFT was passed an invalid plan handle CUFFT_ALLOC_FAILED = 2, // cuFFT failed to allocate GPU or CPU memory CUFFT_INVALID_TYPE = 3, // No longer used CUFFT_INVALID_VALUE = 4, // User specified an invalid pointer or parameter CUFFT_INTERNAL_ERROR = 5, // Driver or internal cuFFT library error CUFFT_EXEC_FAILED = 6, // Failed to execute an FFT on the GPU CUFFT_SETUP_FAILED = 7, // The cuFFT library failed to initialize CUFFT_INVALID_SIZE = 8, // User specified an invalid transform size CUFFT_UNALIGNED_DATA = 9, // No longer used CUFFT_INCOMPLETE_PARAMETER_LIST = 10, // Missing parameters in call CUFFT_INVALID_DEVICE = 11, // Execution of a plan was on different GPU than plan creation CUFFT_PARSE_ERROR = 12, // Internal plan database error CUFFT_NO_WORKSPACE = 13 // No workspace has been provided prior to plan execution CUFFT_NOT_IMPLEMENTED = 14, // Function does not implement functionality for parameters given. CUFFT_LICENSE_ERROR = 15, // Used in previous versions. CUFFT_NOT_SUPPORTED = 16 // Operation is not supported for parameters given. } cufftResult; Users are encouraged to check return values from cuFFT functions for errors as shown in cuFFT Code Examples .", "keywords": []}, {"id": 360, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#specifying-load-and-store-callback-routines", "display_name": "Specifying Load and Store Callback Routines", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "specifying-load-and-store-callback-routines", "priority": -1, "content": "In order to associate a callback routine with a plan, it is necessary to obtain a device pointer to the callback routine. As an example, if the user wants to specify a load callback for an R2C transform, they would write the device code for the callback function, and define a global device variable that contains a pointer to the function: __device__ cufftReal myOwnCallback(void *dataIn, size_t offset, void *callerInfo, void *sharedPtr) { cufftReal ret; // use offset, dataIn, and optionally callerInfo to // compute the return value return ret; } __device__ cufftCallbackLoadR myOwnCallbackPtr = myOwnCallback; From the host side, the user then has to get the address of the callback routine, which is stored in myOwnCallbackPtr . This is done with cudaMemcpyFromSymbol , as follows: cufftCallbackLoadR hostCopyOfCallbackPtr; cudaMemcpyFromSymbol(&amp;hostCopyOfCallbackPtr, myOwnCallbackPtr, sizeof(hostCopyOfCallbackPtr)); hostCopyOfCallbackPtr then contains the device address of the callback routine, that should be passed to cufftXtSetCallback . Note that, for multi-GPU transforms, hostCopyOfCallbackPtr will need to be an array of pointers, and the cudaMemcpyFromSymbol will have to be invoked for each GPU. Please note that __managed__ variables are not suitable to pass to cufftSetCallback due to restrictions on variable usage (See the NVIDIA CUDA Programming Guide for more information about __managed__ variables).", "keywords": []}, {"id": 361, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#static-library-and-callback-support", "display_name": "Static Library and Callback Support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "static-library-and-callback-support", "priority": -1, "content": "Starting with release 6.5, the cuFFT libraries are also delivered in a static form as libcufft_static.a and libcufftw_static.a on Linux and Mac. Static libraries are not supported on Windows. The static cufft and cufftw libraries depend on thread abstraction layer library libculibos.a . For example, on linux, to compile a small application using cuFFT against the dynamic library, the following command can be used: nvcc mCufftApp.c -lcufft -o myCufftApp For cufftw on Linux, to compile a small application against the dynamic library, the following command can be used: nvcc mCufftwApp.c -lcufftw -lcufft -o myCufftwApp Whereas to compile against the static cuFFT library, extra steps need to be taken. The library needs to be device linked. It may happen during building and linking of a simple program, or as a separate step. The entire process is described in Using Separarate Compilation in CUDA . For cuFFT and cufftw in version 9.0 or later any supported architecture can be used to do the device linking: Static cuFFT compilation command: nvcc mCufftApp.c -lcufft_static -lculibos -o myCufftApp Static cufftw compilation command: nvcc mCufftwApp.c -lcufftw_static -lcufft_static -lculibos -o myCufftwApp Prior to version 9.0 proper linking required specifying a subset of supported architectures, as shown in the following commands: Static cuFFT compilation command: nvcc mCufftApp.c -lcufft_static -lculibos -o myCufftApp\\ -gencode arch=compute_20,\\&quot;code=sm_20\\&quot;\\ -gencode arch=compute_30,\\&quot;code=sm_30\\&quot;\\ -gencode arch=compute_35,\\&quot;code=sm_35\\&quot;\\ -gencode arch=compute_50,\\&quot;code=sm_50\\&quot;\\ -gencode arch=compute_60,\\&quot;code=sm_60\\&quot;\\ -gencode arch=compute_60,\\&quot;code=compute_60\\&quot; Static cufftw compilation command: nvcc mCufftwApp.c -lcufftw_static -lcufft_static -lculibos -o myCufftwApp\\ -gencode arch=compute_20,\\&quot;code=sm_20\\&quot;\\ -gencode arch=compute_30,\\&quot;code=sm_30\\&quot;\\ -gencode arch=compute_35,\\&quot;code=sm_35\\&quot;\\ -gencode arch=compute_50,\\&quot;code=sm_50\\&quot;\\ -gencode arch=compute_60,\\&quot;code=sm_60\\&quot;\\ -gencode arch=compute_60,\\&quot;code=compute_60\\&quot; Please note that the cuFFT library might not contain code for certain architectures as long as there is code for a lower architecture that is binary compatibile (e.g. SM37, SM52, SM61). This is reflected in link commands above and significant when using versions prior r9.0. To determine if a specific SM is included in the cuFFT library, one may use cuobjdump utility. For example, if you wish to know if SM_50 is included, the command to run is cuobjdump -arch sm_50 libcufft_static.a . Some kernels are built only on select architectures (e.g. kernels with half precision arithmetics are present only for SM53 and above). This can cause warnings at link time that architectures are missing from these kernels. These warnings can be safely ignored. It is also possible to use the native Host C++ compiler and perform device link as a separate step. Please consult NVCC documentation for more details. Depending on the Host Operating system, some additional libraries like pthread or dl might be needed on the linking line. Note that in this case, the library cuda is not needed. The CUDA Runtime will try to open explicitly the cuda library if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available. The cuFFT static library supports user supplied callback routines. The callback routines are CUDA device code, and must be separately compiled with NVCC and linked with the cuFFT library. Please refer to the NVCC documentation regarding separate compilation for details. If you specify an SM when compiling your callback functions, you must specify one of the SM\u2019s cuFFT includes.", "keywords": []}, {"id": 362, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#static-library-without-callback-support", "display_name": "Static library without callback support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "static-library-without-callback-support", "priority": -1, "content": "Starting with cuFFT version 9.2, a new variant of the cuFTT static library, libcufft_static_nocallback.a , was added. This new version does not contain callback functionality and can be linked using the host compiler only.", "keywords": []}, {"id": 363, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#streamed-cufft-transforms", "display_name": "Streamed cuFFT Transforms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "streamed-cufft-transforms", "priority": -1, "content": "Every cuFFT plan may be associated with a CUDA stream. Once so associated, all launches of the internal stages of that plan take place through the specified stream. Streaming of cuFFT execution allows for potential overlap between transforms and memory copies. (See the NVIDIA CUDA Programming Guide for more information on streams.) If no stream is associated with a plan, launches take place in stream(0) , the default CUDA stream. Note that many plan executions require multiple kernel launches. cuFFT uses private streams internally to sort operations, including event syncrhonization. cuFFT does not guarantee ordering of internal operations, and the order is only preserved with respect to the streams set by the user. As of CUDA 11.2 (cuFFT 10.4.0), cufftSetStream() is supported in multiple GPU cases. However, calls to cufftXtMemcpy() are still synchronous across multiple GPUs when using streams. In previous versions of cuFFT, cufftSetStream() returns an error in the multiple GPU case. Likewise, calling certain multi-GPU functions such as cufftXtSetCallback() after setting a stream with cufftSetStream() will result in an error (see API functions for more details). Please note that in order to overlap plans using single plan handle user needs to manage work area buffers. Each concurrent plan execution needs it\u2019s exclusive work area. Work area can be set by cufftSetWorkArea function.", "keywords": []}, {"id": 364, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#supported-functionality", "display_name": "Supported Functionality", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-functionality", "priority": -1, "content": "Starting with cuFFT version 7.0, a subset of single GPU functionality is supported for multiple GPU execution. Requirements and limitations: All GPUs must have the same CUDA architecture level and support Unified Virtual Address Space. On Windows, the GPU boards must be operating in Tesla Compute Cluster (TCC) mode. For an application that uses the CUDA Driver API, running cuFFT on multiple GPUs is only compatible with applications using the primary context on each GPU. Strided input and output are not supported. Running cuFFT on more than 8 GPUs (16 GPUs is max) is supported on machines with NVLink only. While transforms with batch count greater than one do not impose additional constraints, those with a single batch have some restrictions. Single-batch FFTs support only in-place mode, and have additional constraints depending on the FFT type. This behavior is summarized in the following table: batch=1 1D 2D 3D C2C / Z2Z 2,4,8,16 GPUs power of 2 sizes only Minimum size for 2-4 GPUs is 64 Minimum size for 8 GPUs is 128 Minimum size for 16 GPUs is 1024 2-16 GPUs One of the following conditions is met for each dimension: Dimension must factor into primes less than or equal to 127 Maximum dimension size is 4096 for single precision Maximum dimension size is 2048 for double precision Minimum size is 32 R2C / D2Z not supported 2-16 GPUs One of the following conditions is met for each dimension: Dimension must factor into primes less than or equal to 127 Maximum dimension size is 4096 for single precision Maximum dimension size is 2048 for double precision Minimum size is 32 Fastest changing dimension size needs to be even Supports only CUFFT_XT_FORMAT_INPLACE input descriptor format No callback support C2R / Z2D not supported 2-16 GPUs One of the following conditions is met for each dimension: Dimension must factor into primes less than or equal to 127 Maximum dimension size is 4096 for single precision Maximum dimension size is 2048 for double precision Minimum size is 32 Fastest changing dimension size needs to be even Supports only CUFFT_XT_FORMAT_INPLACE_SHUFFLED input descriptor format No callback support General guidelines are: Parameter whichGPUs of cufftXtSetGPUs() function determines ordering of the GPUs with respect to data decomposition (first data chunk is placed on GPU denoted by first element of whichGPUs ) The data for the entire transform must fit within the memory of the GPUs assigned to it. For batch size m on n GPUs : The first m % n GPUs execute \\left\\lfloor \\frac{m}{n} \\right\\rfloor+\\ 1 transforms. The remaining GPUs execute \\left\\lfloor \\frac{m}{n} \\right\\rfloor transforms. Batch size output differences: Single GPU cuFFT results are always returned in natural order. When multiple GPUs are used to perform more than one transform, the results are also returned in natural order. When multiple GPUs are used to perform a single transform the results are returned in a permutation of the normal results to reduce communication time. This behavior is summarized in the following table: Number of GPUs Number of transforms Output Order on GPUs One One or multiple transforms Natural order Multiple One Permuted results Multiple Multiple Natural order To produce natural order results in GPU memory for multi-GPU runs in the 1D single transform case, requires calling cufftXtMemcpy() with CUFFT_COPY_DEVICE_TO_DEVICE . 2D and 3D multi-GPU transforms support execution of a transform given permuted order results as input. After execution in this case, the output will be in natural order. It is also possible to use cufftXtMemcpy() with CUFFT_COPY_DEVICE_TO_DEVICE to return 2D or 3D data to natural order. See the cuFFT Code Examples section for single GPU and multiple GPU examples.", "keywords": []}, {"id": 365, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#thread-safety", "display_name": "Thread Safety", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "thread-safety", "priority": -1, "content": "cuFFT APIs are thread safe as long as different host threads execute FFTs using different plans and the output data are disjoint.", "keywords": []}, {"id": 366, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trademarks", "priority": -1, "content": "NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "keywords": []}, {"id": 367, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#type-definitions-for-callbacks", "display_name": "Type definitions for callbacks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "type-definitions-for-callbacks", "priority": -1, "content": "The cuFFT library supports callback funtions for all combinations of single or double precision, real or complex data, load or store. These are enumerated in the parameter cufftXtCallbackType . typedef enum cufftXtCallbackType_t { CUFFT_CB_LD_COMPLEX = 0x0, CUFFT_CB_LD_COMPLEX_DOUBLE = 0x1, CUFFT_CB_LD_REAL = 0x2, CUFFT_CB_LD_REAL_DOUBLE = 0x3, CUFFT_CB_ST_COMPLEX = 0x4, CUFFT_CB_ST_COMPLEX_DOUBLE = 0x5, CUFFT_CB_ST_REAL = 0x6, CUFFT_CB_ST_REAL_DOUBLE = 0x7, CUFFT_CB_UNDEFINED = 0x8 } cufftXtCallbackType; The corresponding function prototypes and pointer type definitions are as follows: typedef cufftComplex (*cufftCallbackLoadC)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftDoubleComplex (*cufftCallbackLoadZ)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftReal (*cufftCallbackLoadR)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef cufftDoubleReal(*cufftCallbackLoadD)(void *dataIn, size_t offset, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreC)(void *dataOut, size_t offset, cufftComplex element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreZ)(void *dataOut, size_t offset, cufftDoubleComplex element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreR)(void *dataOut, size_t offset, cufftReal element, void *callerInfo, void *sharedPointer); typedef void (*cufftCallbackStoreD)(void *dataOut, size_t offset, cufftDoubleReal element, void *callerInfo, void *sharedPointer);", "keywords": []}, {"id": 368, "doc_id": 369, "filename": "index.html", "domain_name": "page", "name": "index#using-the-cufft-api", "display_name": "Using the cuFFT API", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "using-the-cufft-api", "priority": -1, "content": "This chapter provides a general overview of the cuFFT library API. For more complete information on specific functions, see cuFFT API Reference . Users are encouraged to read this chapter before continuing with more detailed descriptions. The Discrete Fourier transform (DFT) maps a complex-valued vector x_{k} ( time domain ) into its frequency domain representation given by: X_{k} = \\sum\\limits_{n = 0}^{N - 1}x_{n}e^{-2\\pi i\\frac{kn}{N}} where X_{k} is a complex-valued vector of the same size. This is known as a forward DFT. If the sign on the exponent of e is changed to be positive, the transform is an inverse transform. Depending on N , different algorithms are deployed for the best performance. The cuFFT API is modeled after FFTW , which is one of the most popular and efficient CPU-based FFT libraries. cuFFT provides a simple configuration mechanism called a plan that uses internal building blocks to optimize the transform for the given configuration and the particular GPU hardware selected. Then, when the execution function is called, the actual transform takes place following the plan of execution. The advantage of this approach is that once the user creates a plan, the library retains whatever state is needed to execute the plan multiple times without recalculation of the configuration. This model works well for cuFFT because different kinds of FFTs require different thread configurations and GPU resources, and the plan interface provides a simple way of reusing configurations. Computing a number BATCH of one-dimensional DFTs of size NX using cuFFT will typically look like this: #define NX 256 #define BATCH 10 #define RANK 1 ... { cufftHandle plan; cufftComplex *data; ... cudaMalloc((void**)&amp;data, sizeof(cufftComplex)*NX*BATCH); cufftPlanMany(&amp;plan, RANK, NX, &amp;iembed, istride, idist, &amp;oembed, ostride, odist, CUFFT_C2C, BATCH); ... cufftExecC2C(plan, data, data, CUFFT_FORWARD); cudaDeviceSynchronize(); ... cufftDestroy(plan); cudaFree(data); }", "keywords": []}, {"id": 369, "doc_id": 369, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "Introduction", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "cuFFT API Reference The API reference guide for cuFFT, the CUDA Fast Fourier Transform library. This document describes cuFFT, the NVIDIA\u00ae CUDA\u00ae Fast Fourier Transform (FFT) product. It consists of two separate libraries: cuFFT and cuFFTW. The cuFFT library is designed to provide high performance on NVIDIA GPUs. The cuFFTW library is provided as a porting tool to enable users of FFTW to start using NVIDIA GPUs with a minimum amount of effort. The FFT is a divide-and-conquer algorithm for efficiently computing discrete Fourier transforms of complex or real-valued data sets. It is one of the most important and widely used numerical algorithms in computational physics and general signal processing. The cuFFT library provides a simple interface for computing FFTs on an NVIDIA GPU, which allows users to quickly leverage the floating-point power and parallelism of the GPU in a highly optimized and tested FFT library. The cuFFT product supports a wide range of FFT inputs and options efficiently on NVIDIA GPUs. This version of the cuFFT library supports the following features: Algorithms highly optimized for input sizes that can be written in the form 2^{a} \\times 3^{b} \\times 5^{c} \\times 7^{d} . In general the smaller the prime factor, the better the performance, i.e., powers of two are fastest. An O\\left( n\\log n \\right) algorithm for every input data size Half-precision (16-bit floating point), single-precision (32-bit floating point) and double-precision (64-bit floating point). Transforms of lower precision have higher performance. Complex and real-valued input and output. Real valued input or output require less computations and data than complex values and often have faster time to solution. Types supported are: C2C - Complex input to complex output R2C - Real input to complex output C2R - Symmetric complex input to real output 1D, 2D and 3D transforms Execution of multiple 1D, 2D and 3D transforms simultaneously. These batched transforms have higher performance than single transforms. In-place and out-of-place transforms Arbitrary intra- and inter-dimension element strides (strided layout) FFTW compatible data layout Execution of transforms across multiple GPUs Streamed execution, enabling asynchronous computation and data movement The cuFFTW library provides the FFTW3 API to facilitate porting of existing FFTW applications. Please note that starting from CUDA 11.0, the minimum supported GPU architecture is SM35. See Deprecated Functionality .", "keywords": []}]};