const searchData = {"envversion": {"sphinx.domains.c": 2, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 5, "sphinx.domains.index": 1, "sphinx.domains.javascript": 2, "sphinx.domains.math": 2, "sphinx.domains.python": 3, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.mermaid": 1, "repo_docs.ext.enhanced_search": 2, "sphinx": 56}, "data": [{"id": 0, "doc_id": 0, "filename": "contents.html", "domain_name": "std", "name": "contents", "display_name": "Contents", "type": "doc", "display_type": "Page", "docname": "contents", "anchor": "", "priority": -1, "content": "Introduction Getting Started System Requirements Installation User Interface Error Handling Enumerations Functions General Information Query Functions Compilation Functions Typedefs Supported Compile Options Host Helper Functions Language Execution Space Separate Compilation Dynamic Parallelism Integer Size Include Syntax Predefined Macros Predefined Types Builtin Functions Default C++ Dialect Basic Usage Accessing Lowered Names Example Notes Interfacing With Template Host Code Template Host Code Example Versioning Scheme NVRTC Shared Library Versioning NVRTC-builtins Library Miscellaneous Notes Thread Safety Stack Size NVRTC Static Library Example: SAXPY Code (saxpy.cpp) Host Type Name Build Instructions Example: Using Lowered Name Code (lowered-name.cpp) Lowered Name Build Instructions Example: Using nvrtcGetTypeName Code (host-type-name.cpp) nvrtcGetTypeName Build Instructions Example: Dynamic Parallelism Dynamic Parallelism Build Instructions Example: Device LTO (link time optimization) Code (offline.cu) Code (online.cpp) Device LTO Build Instructions Notices Notice OpenCL Trademarks", "keywords": []}, {"id": 1, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "display_name": "NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE", "priority": 1, "content": "enumerator  NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "keywords": []}, {"id": 2, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_COMPILATION", "display_name": "NVRTC_ERROR_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult23NVRTC_ERROR_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_COMPILATION", "keywords": []}, {"id": 3, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_INTERNAL_ERROR", "display_name": "NVRTC_ERROR_INTERNAL_ERROR", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 4, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_INVALID_INPUT", "display_name": "NVRTC_ERROR_INVALID_INPUT", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 5, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_INVALID_OPTION", "display_name": "NVRTC_ERROR_INVALID_OPTION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_OPTION", "keywords": []}, {"id": 6, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_INVALID_PROGRAM", "display_name": "NVRTC_ERROR_INVALID_PROGRAM", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 7, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "display_name": "NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 8, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "display_name": "NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "keywords": []}, {"id": 9, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "display_name": "NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "keywords": []}, {"id": 10, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_OUT_OF_MEMORY", "display_name": "NVRTC_ERROR_OUT_OF_MEMORY", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE", "priority": 1, "content": "enumerator  NVRTC_ERROR_OUT_OF_MEMORY", "keywords": []}, {"id": 11, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "display_name": "NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE", "priority": 1, "content": "enumerator  NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "keywords": []}, {"id": 12, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "display_name": "NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE", "priority": 1, "content": "enumerator  NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 13, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "NVRTC_SUCCESS", "display_name": "NVRTC_SUCCESS", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult13NVRTC_SUCCESSE", "priority": 1, "content": "enumerator  NVRTC_SUCCESS", "keywords": []}, {"id": 14, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcAddNameExpression", "display_name": "nvrtcAddNameExpression", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc", "priority": 1, "content": "nvrtcResult  nvrtcAddNameExpression nvrtcProgram  prog const  char  * const  name_expression nvrtcAddNameExpression notes the given name expression denoting the address of a global function or device /__constant__ variable. The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name. nvrtcGetLoweredName  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "keywords": []}, {"id": 15, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcAddNameExpression::name_expression", "display_name": "nvrtcAddNameExpression::name_expression", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc", "priority": 1, "content": "nvrtcResult  nvrtcAddNameExpression nvrtcProgram  prog const  char  * const  name_expression nvrtcAddNameExpression notes the given name expression denoting the address of a global function or device /__constant__ variable. The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name. nvrtcGetLoweredName  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "keywords": []}, {"id": 16, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcAddNameExpression::prog", "display_name": "nvrtcAddNameExpression::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc", "priority": 1, "content": "nvrtcResult  nvrtcAddNameExpression nvrtcProgram  prog const  char  * const  name_expression nvrtcAddNameExpression notes the given name expression denoting the address of a global function or device /__constant__ variable. The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name. nvrtcGetLoweredName  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "keywords": []}, {"id": 17, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCompileProgram", "display_name": "nvrtcCompileProgram", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCompileProgram nvrtcProgram  prog int  numOptions const  char  * const  * options nvrtcCompileProgram compiles the given program. It supports compile options listed in Supported Compile Options . Parameters prog \u2013 [in]  CUDA Runtime Compilation program. numOptions \u2013 [in]  Number of compiler options passed. options \u2013 [in]  Compiler options in the form of C string array. options can be NULL when numOptions is 0. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_OPTION NVRTC_ERROR_COMPILATION NVRTC_ERROR_BUILTIN_OPERATION_FAILURE NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 18, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCompileProgram::numOptions", "display_name": "nvrtcCompileProgram::numOptions", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCompileProgram nvrtcProgram  prog int  numOptions const  char  * const  * options nvrtcCompileProgram compiles the given program. It supports compile options listed in Supported Compile Options . Parameters prog \u2013 [in]  CUDA Runtime Compilation program. numOptions \u2013 [in]  Number of compiler options passed. options \u2013 [in]  Compiler options in the form of C string array. options can be NULL when numOptions is 0. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_OPTION NVRTC_ERROR_COMPILATION NVRTC_ERROR_BUILTIN_OPERATION_FAILURE NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 19, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCompileProgram::options", "display_name": "nvrtcCompileProgram::options", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCompileProgram nvrtcProgram  prog int  numOptions const  char  * const  * options nvrtcCompileProgram compiles the given program. It supports compile options listed in Supported Compile Options . Parameters prog \u2013 [in]  CUDA Runtime Compilation program. numOptions \u2013 [in]  Number of compiler options passed. options \u2013 [in]  Compiler options in the form of C string array. options can be NULL when numOptions is 0. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_OPTION NVRTC_ERROR_COMPILATION NVRTC_ERROR_BUILTIN_OPERATION_FAILURE NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 20, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCompileProgram::prog", "display_name": "nvrtcCompileProgram::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCompileProgram nvrtcProgram  prog int  numOptions const  char  * const  * options nvrtcCompileProgram compiles the given program. It supports compile options listed in Supported Compile Options . Parameters prog \u2013 [in]  CUDA Runtime Compilation program. numOptions \u2013 [in]  Number of compiler options passed. options \u2013 [in]  Compiler options in the form of C string array. options can be NULL when numOptions is 0. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_OPTION NVRTC_ERROR_COMPILATION NVRTC_ERROR_BUILTIN_OPERATION_FAILURE NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 21, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram", "display_name": "nvrtcCreateProgram", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 22, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::headers", "display_name": "nvrtcCreateProgram::headers", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 23, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::includeNames", "display_name": "nvrtcCreateProgram::includeNames", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 24, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::name", "display_name": "nvrtcCreateProgram::name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 25, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::numHeaders", "display_name": "nvrtcCreateProgram::numHeaders", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 26, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::prog", "display_name": "nvrtcCreateProgram::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 27, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcCreateProgram::src", "display_name": "nvrtcCreateProgram::src", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc", "priority": 1, "content": "nvrtcResult  nvrtcCreateProgram nvrtcProgram  * prog const  char  * src const  char  * name int  numHeaders const  char  * const  * headers const  char  * const  * includeNames nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcDestroyProgram  Parameters prog \u2013 [out]  CUDA Runtime Compilation program. src \u2013 [in]  CUDA program source. name \u2013 [in]  CUDA program name. name can be NULL ; &quot;default_program&quot; is used when name is NULL or \u201c\u201d. numHeaders \u2013 [in]  Number of headers used. numHeaders must be greater than or equal to 0. headers \u2013 [in]  Sources of the headers. headers can be NULL when numHeaders is 0. includeNames \u2013 [in]  Name of each header by which they can be included in the CUDA program source. includeNames can be NULL when numHeaders is 0. These headers must be included with the exact names specified here. Returns NVRTC_SUCCESS NVRTC_ERROR_OUT_OF_MEMORY NVRTC_ERROR_PROGRAM_CREATION_FAILURE NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 28, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcDestroyProgram", "display_name": "nvrtcDestroyProgram", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv419nvrtcDestroyProgramP12nvrtcProgram", "priority": 1, "content": "nvrtcResult  nvrtcDestroyProgram nvrtcProgram  * prog nvrtcDestroyProgram destroys the given program. nvrtcCreateProgram  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 29, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcDestroyProgram::prog", "display_name": "nvrtcDestroyProgram::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcDestroyProgramP12nvrtcProgram", "priority": 1, "content": "nvrtcResult  nvrtcDestroyProgram nvrtcProgram  * prog nvrtcDestroyProgram destroys the given program. nvrtcCreateProgram  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 30, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBIN", "display_name": "nvrtcGetCUBIN", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv413nvrtcGetCUBIN12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBIN nvrtcProgram  prog char  * cubin nvrtcGetCUBIN stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . No cubin is available if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBINSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubin \u2013 [out]  Compiled and assembled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 31, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBIN::cubin", "display_name": "nvrtcGetCUBIN::cubin", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv413nvrtcGetCUBIN12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBIN nvrtcProgram  prog char  * cubin nvrtcGetCUBIN stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . No cubin is available if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBINSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubin \u2013 [out]  Compiled and assembled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 32, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBIN::prog", "display_name": "nvrtcGetCUBIN::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv413nvrtcGetCUBIN12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBIN nvrtcProgram  prog char  * cubin nvrtcGetCUBIN stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . No cubin is available if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBINSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubin \u2013 [out]  Compiled and assembled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 33, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBINSize", "display_name": "nvrtcGetCUBINSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBINSize nvrtcProgram  prog size_t  * cubinSizeRet nvrtcGetCUBINSize sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . The value of cubinSizeRet is set to 0 if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBIN  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubinSizeRet \u2013 [out]  Size of the generated cubin. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 34, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBINSize::cubinSizeRet", "display_name": "nvrtcGetCUBINSize::cubinSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBINSize nvrtcProgram  prog size_t  * cubinSizeRet nvrtcGetCUBINSize sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . The value of cubinSizeRet is set to 0 if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBIN  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubinSizeRet \u2013 [out]  Size of the generated cubin. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 35, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetCUBINSize::prog", "display_name": "nvrtcGetCUBINSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetCUBINSize nvrtcProgram  prog size_t  * cubinSizeRet nvrtcGetCUBINSize sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . The value of cubinSizeRet is set to 0 if the value specified to -arch is a virtual architecture instead of an actual architecture. nvrtcGetCUBIN  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. cubinSizeRet \u2013 [out]  Size of the generated cubin. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 36, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetErrorString", "display_name": "nvrtcGetErrorString", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv419nvrtcGetErrorString11nvrtcResult", "priority": 1, "content": "const  char  * nvrtcGetErrorString nvrtcResult  result nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to &quot;NVRTC_SUCCESS&quot; . For unrecognized enumeration values, it returns &quot;NVRTC_ERROR unknown&quot; . Parameters result \u2013 [in]  CUDA Runtime Compilation API result code. Returns Message string for the given nvrtcResult code.", "keywords": []}, {"id": 37, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetErrorString::result", "display_name": "nvrtcGetErrorString::result", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetErrorString11nvrtcResult", "priority": 1, "content": "const  char  * nvrtcGetErrorString nvrtcResult  result nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to &quot;NVRTC_SUCCESS&quot; . For unrecognized enumeration values, it returns &quot;NVRTC_ERROR unknown&quot; . Parameters result \u2013 [in]  CUDA Runtime Compilation API result code. Returns Message string for the given nvrtcResult code.", "keywords": []}, {"id": 38, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIR", "display_name": "nvrtcGetLTOIR", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv413nvrtcGetLTOIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIR nvrtcProgram  prog char  * LTOIR nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of prog in the memory pointed by LTOIR . No LTO IR is available if the program was compiled without -dlto . nvrtcGetLTOIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIR \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 39, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIR::LTOIR", "display_name": "nvrtcGetLTOIR::LTOIR", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv413nvrtcGetLTOIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIR nvrtcProgram  prog char  * LTOIR nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of prog in the memory pointed by LTOIR . No LTO IR is available if the program was compiled without -dlto . nvrtcGetLTOIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIR \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 40, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIR::prog", "display_name": "nvrtcGetLTOIR::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv413nvrtcGetLTOIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIR nvrtcProgram  prog char  * LTOIR nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of prog in the memory pointed by LTOIR . No LTO IR is available if the program was compiled without -dlto . nvrtcGetLTOIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIR \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 41, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIRSize", "display_name": "nvrtcGetLTOIRSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIRSize nvrtcProgram  prog size_t  * LTOIRSizeRet nvrtcGetLTOIRSize sets the value of LTOIRSizeRet with the size of the LTO IR generated by the previous compilation of prog . The value of LTOIRSizeRet is set to 0 if the program was not compiled with -dlto . nvrtcGetLTOIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIRSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 42, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIRSize::LTOIRSizeRet", "display_name": "nvrtcGetLTOIRSize::LTOIRSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIRSize nvrtcProgram  prog size_t  * LTOIRSizeRet nvrtcGetLTOIRSize sets the value of LTOIRSizeRet with the size of the LTO IR generated by the previous compilation of prog . The value of LTOIRSizeRet is set to 0 if the program was not compiled with -dlto . nvrtcGetLTOIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIRSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 43, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLTOIRSize::prog", "display_name": "nvrtcGetLTOIRSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetLTOIRSize nvrtcProgram  prog size_t  * LTOIRSizeRet nvrtcGetLTOIRSize sets the value of LTOIRSizeRet with the size of the LTO IR generated by the previous compilation of prog . The value of LTOIRSizeRet is set to 0 if the program was not compiled with -dlto . nvrtcGetLTOIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. LTOIRSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 44, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLoweredName", "display_name": "nvrtcGetLoweredName", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc", "priority": 1, "content": "nvrtcResult  nvrtcGetLoweredName nvrtcProgram  prog const  char  * const  name_expression const  char  * * lowered_name nvrtcGetLoweredName extracts the lowered (mangled) name for a global function or device /__constant__ variable, and updates *lowered_name to point to it. The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression. nvrtcAddNameExpression  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. lowered_name \u2013 [out]  initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression. Returns NVRTC_SUCCESS NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 45, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLoweredName::lowered_name", "display_name": "nvrtcGetLoweredName::lowered_name", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc", "priority": 1, "content": "nvrtcResult  nvrtcGetLoweredName nvrtcProgram  prog const  char  * const  name_expression const  char  * * lowered_name nvrtcGetLoweredName extracts the lowered (mangled) name for a global function or device /__constant__ variable, and updates *lowered_name to point to it. The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression. nvrtcAddNameExpression  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. lowered_name \u2013 [out]  initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression. Returns NVRTC_SUCCESS NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 46, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLoweredName::name_expression", "display_name": "nvrtcGetLoweredName::name_expression", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc", "priority": 1, "content": "nvrtcResult  nvrtcGetLoweredName nvrtcProgram  prog const  char  * const  name_expression const  char  * * lowered_name nvrtcGetLoweredName extracts the lowered (mangled) name for a global function or device /__constant__ variable, and updates *lowered_name to point to it. The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression. nvrtcAddNameExpression  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. lowered_name \u2013 [out]  initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression. Returns NVRTC_SUCCESS NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 47, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetLoweredName::prog", "display_name": "nvrtcGetLoweredName::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc", "priority": 1, "content": "nvrtcResult  nvrtcGetLoweredName nvrtcProgram  prog const  char  * const  name_expression const  char  * * lowered_name nvrtcGetLoweredName extracts the lowered (mangled) name for a global function or device /__constant__ variable, and updates *lowered_name to point to it. The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression. nvrtcAddNameExpression  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. name_expression \u2013 [in]  constant expression denoting the address of a global function or device /__constant__ variable. lowered_name \u2013 [out]  initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression. Returns NVRTC_SUCCESS NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION NVRTC_ERROR_INVALID_PROGRAM NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 48, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVM", "display_name": "nvrtcGetNVVM", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv412nvrtcGetNVVM12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVM nvrtcProgram  prog char  * nvvm DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIR (and nvrtcGetLTOIRSize) instead.", "keywords": []}, {"id": 49, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVM::nvvm", "display_name": "nvrtcGetNVVM::nvvm", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv412nvrtcGetNVVM12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVM nvrtcProgram  prog char  * nvvm DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIR (and nvrtcGetLTOIRSize) instead.", "keywords": []}, {"id": 50, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVM::prog", "display_name": "nvrtcGetNVVM::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv412nvrtcGetNVVM12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVM nvrtcProgram  prog char  * nvvm DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIR (and nvrtcGetLTOIRSize) instead.", "keywords": []}, {"id": 51, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVMSize", "display_name": "nvrtcGetNVVMSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVMSize nvrtcProgram  prog size_t  * nvvmSizeRet DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIRSize (and nvrtcGetLTOIR) instead.", "keywords": []}, {"id": 52, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVMSize::nvvmSizeRet", "display_name": "nvrtcGetNVVMSize::nvvmSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVMSize nvrtcProgram  prog size_t  * nvvmSizeRet DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIRSize (and nvrtcGetLTOIR) instead.", "keywords": []}, {"id": 53, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNVVMSize::prog", "display_name": "nvrtcGetNVVMSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetNVVMSize nvrtcProgram  prog size_t  * nvvmSizeRet DEPRECATION NOTICE: This function will be removed in a future release. Please use nvrtcGetLTOIRSize (and nvrtcGetLTOIR) instead.", "keywords": []}, {"id": 54, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNumSupportedArchs", "display_name": "nvrtcGetNumSupportedArchs", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv425nvrtcGetNumSupportedArchsPi", "priority": 1, "content": "nvrtcResult  nvrtcGetNumSupportedArchs int  * numArchs nvrtcGetNumSupportedArchs sets the output parameter numArchs with the number of architectures supported by NVRTC. This can then be used to pass an array to nvrtcGetSupportedArchs to get the supported architectures. see nvrtcGetSupportedArchs  Parameters numArchs \u2013 [out]  number of supported architectures. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 55, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetNumSupportedArchs::numArchs", "display_name": "nvrtcGetNumSupportedArchs::numArchs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv425nvrtcGetNumSupportedArchsPi", "priority": 1, "content": "nvrtcResult  nvrtcGetNumSupportedArchs int  * numArchs nvrtcGetNumSupportedArchs sets the output parameter numArchs with the number of architectures supported by NVRTC. This can then be used to pass an array to nvrtcGetSupportedArchs to get the supported architectures. see nvrtcGetSupportedArchs  Parameters numArchs \u2013 [out]  number of supported architectures. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 56, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIR", "display_name": "nvrtcGetOptiXIR", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIR nvrtcProgram  prog char  * optixir nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of prog in the memory pointed by optixir . No OptiX IR is available if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. Optix \u2013 [out]  IR Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 57, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIR::optixir", "display_name": "nvrtcGetOptiXIR::optixir", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIR nvrtcProgram  prog char  * optixir nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of prog in the memory pointed by optixir . No OptiX IR is available if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. Optix \u2013 [out]  IR Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 58, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIR::prog", "display_name": "nvrtcGetOptiXIR::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIR nvrtcProgram  prog char  * optixir nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of prog in the memory pointed by optixir . No OptiX IR is available if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIRSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. Optix \u2013 [out]  IR Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 59, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIRSize", "display_name": "nvrtcGetOptiXIRSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIRSize nvrtcProgram  prog size_t  * optixirSizeRet nvrtcGetOptiXIRSize sets the value of optixirSizeRet with the size of the OptiX IR generated by the previous compilation of prog . The value of nvrtcGetOptiXIRSize is set to 0 if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. optixirSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 60, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIRSize::optixirSizeRet", "display_name": "nvrtcGetOptiXIRSize::optixirSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIRSize nvrtcProgram  prog size_t  * optixirSizeRet nvrtcGetOptiXIRSize sets the value of optixirSizeRet with the size of the OptiX IR generated by the previous compilation of prog . The value of nvrtcGetOptiXIRSize is set to 0 if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. optixirSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 61, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetOptiXIRSize::prog", "display_name": "nvrtcGetOptiXIRSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetOptiXIRSize nvrtcProgram  prog size_t  * optixirSizeRet nvrtcGetOptiXIRSize sets the value of optixirSizeRet with the size of the OptiX IR generated by the previous compilation of prog . The value of nvrtcGetOptiXIRSize is set to 0 if the program was compiled with options incompatible with OptiX IR generation. nvrtcGetOptiXIR  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. optixirSizeRet \u2013 [out]  Size of the generated LTO IR. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 62, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTX", "display_name": "nvrtcGetPTX", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv411nvrtcGetPTX12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetPTX nvrtcProgram  prog char  * ptx nvrtcGetPTX stores the PTX generated by the previous compilation of prog in the memory pointed by ptx . nvrtcGetPTXSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptx \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 63, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTX::prog", "display_name": "nvrtcGetPTX::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv411nvrtcGetPTX12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetPTX nvrtcProgram  prog char  * ptx nvrtcGetPTX stores the PTX generated by the previous compilation of prog in the memory pointed by ptx . nvrtcGetPTXSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptx \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 64, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTX::ptx", "display_name": "nvrtcGetPTX::ptx", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv411nvrtcGetPTX12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetPTX nvrtcProgram  prog char  * ptx nvrtcGetPTX stores the PTX generated by the previous compilation of prog in the memory pointed by ptx . nvrtcGetPTXSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptx \u2013 [out]  Compiled result. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 65, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTXSize", "display_name": "nvrtcGetPTXSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetPTXSize nvrtcProgram  prog size_t  * ptxSizeRet nvrtcGetPTXSize sets the value of ptxSizeRet with the size of the PTX generated by the previous compilation of prog (including the trailing NULL ). nvrtcGetPTX  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptxSizeRet \u2013 [out]  Size of the generated PTX (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 66, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTXSize::prog", "display_name": "nvrtcGetPTXSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetPTXSize nvrtcProgram  prog size_t  * ptxSizeRet nvrtcGetPTXSize sets the value of ptxSizeRet with the size of the PTX generated by the previous compilation of prog (including the trailing NULL ). nvrtcGetPTX  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptxSizeRet \u2013 [out]  Size of the generated PTX (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 67, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetPTXSize::ptxSizeRet", "display_name": "nvrtcGetPTXSize::ptxSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetPTXSize nvrtcProgram  prog size_t  * ptxSizeRet nvrtcGetPTXSize sets the value of ptxSizeRet with the size of the PTX generated by the previous compilation of prog (including the trailing NULL ). nvrtcGetPTX  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. ptxSizeRet \u2013 [out]  Size of the generated PTX (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 68, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLog", "display_name": "nvrtcGetProgramLog", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv418nvrtcGetProgramLog12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLog nvrtcProgram  prog char  * log nvrtcGetProgramLog stores the log generated by the previous compilation of prog in the memory pointed by log . nvrtcGetProgramLogSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. log \u2013 [out]  Compilation log. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 69, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLog::log", "display_name": "nvrtcGetProgramLog::log", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcGetProgramLog12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLog nvrtcProgram  prog char  * log nvrtcGetProgramLog stores the log generated by the previous compilation of prog in the memory pointed by log . nvrtcGetProgramLogSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. log \u2013 [out]  Compilation log. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 70, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLog::prog", "display_name": "nvrtcGetProgramLog::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv418nvrtcGetProgramLog12nvrtcProgramPc", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLog nvrtcProgram  prog char  * log nvrtcGetProgramLog stores the log generated by the previous compilation of prog in the memory pointed by log . nvrtcGetProgramLogSize  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. log \u2013 [out]  Compilation log. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 71, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLogSize", "display_name": "nvrtcGetProgramLogSize", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLogSize nvrtcProgram  prog size_t  * logSizeRet nvrtcGetProgramLogSize sets logSizeRet with the size of the log generated by the previous compilation of prog (including the trailing NULL ). Note that compilation log may be generated with warnings and informative messages, even when the compilation of prog succeeds. nvrtcGetProgramLog  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. logSizeRet \u2013 [out]  Size of the compilation log (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 72, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLogSize::logSizeRet", "display_name": "nvrtcGetProgramLogSize::logSizeRet", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLogSize nvrtcProgram  prog size_t  * logSizeRet nvrtcGetProgramLogSize sets logSizeRet with the size of the log generated by the previous compilation of prog (including the trailing NULL ). Note that compilation log may be generated with warnings and informative messages, even when the compilation of prog succeeds. nvrtcGetProgramLog  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. logSizeRet \u2013 [out]  Size of the compilation log (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 73, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetProgramLogSize::prog", "display_name": "nvrtcGetProgramLogSize::prog", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t", "priority": 1, "content": "nvrtcResult  nvrtcGetProgramLogSize nvrtcProgram  prog size_t  * logSizeRet nvrtcGetProgramLogSize sets logSizeRet with the size of the log generated by the previous compilation of prog (including the trailing NULL ). Note that compilation log may be generated with warnings and informative messages, even when the compilation of prog succeeds. nvrtcGetProgramLog  Parameters prog \u2013 [in]  CUDA Runtime Compilation program. logSizeRet \u2013 [out]  Size of the compilation log (including the trailing NULL ). Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 74, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetSupportedArchs", "display_name": "nvrtcGetSupportedArchs", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv422nvrtcGetSupportedArchsPi", "priority": 1, "content": "nvrtcResult  nvrtcGetSupportedArchs int  * supportedArchs nvrtcGetSupportedArchs populates the array passed via the output parameter supportedArchs with the architectures supported by NVRTC. The array is sorted in the ascending order. The size of the array to be passed can be determined using nvrtcGetNumSupportedArchs . see nvrtcGetNumSupportedArchs  Parameters supportedArchs \u2013 [out]  sorted array of supported architectures. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 75, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetSupportedArchs::supportedArchs", "display_name": "nvrtcGetSupportedArchs::supportedArchs", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv422nvrtcGetSupportedArchsPi", "priority": 1, "content": "nvrtcResult  nvrtcGetSupportedArchs int  * supportedArchs nvrtcGetSupportedArchs populates the array passed via the output parameter supportedArchs with the architectures supported by NVRTC. The array is sorted in the ascending order. The size of the array to be passed can be determined using nvrtcGetNumSupportedArchs . see nvrtcGetNumSupportedArchs  Parameters supportedArchs \u2013 [out]  sorted array of supported architectures. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 76, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName", "display_name": "nvrtcGetTypeName", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE", "priority": 1, "content": "inline  nvrtcResult  nvrtcGetTypeName const  std :: type_info  &amp; tinfo std :: string  * result nvrtcGetTypeName stores the source level name of a type in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters tinfo \u2013 [in]  reference to object of type std::type_info for a given type. result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 77, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName", "display_name": "nvrtcGetTypeName", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE", "priority": 1, "content": "template &lt; typename  T &gt; nvrtcResult  nvrtcGetTypeName std :: string  * result nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 78, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName::T", "display_name": "nvrtcGetTypeName::T", "type": "templateParam", "display_type": "C++ template parameter", "docname": "index", "anchor": "_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE", "priority": 1, "content": "template &lt; typename  T &gt; nvrtcResult  nvrtcGetTypeName std :: string  * result nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 79, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName::result", "display_name": "nvrtcGetTypeName::result", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE", "priority": 1, "content": "inline  nvrtcResult  nvrtcGetTypeName const  std :: type_info  &amp; tinfo std :: string  * result nvrtcGetTypeName stores the source level name of a type in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters tinfo \u2013 [in]  reference to object of type std::type_info for a given type. result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 80, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName::result", "display_name": "nvrtcGetTypeName::result", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE", "priority": 1, "content": "template &lt; typename  T &gt; nvrtcResult  nvrtcGetTypeName std :: string  * result nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 81, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcGetTypeName::tinfo", "display_name": "nvrtcGetTypeName::tinfo", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE", "priority": 1, "content": "inline  nvrtcResult  nvrtcGetTypeName const  std :: type_info  &amp; tinfo std :: string  * result nvrtcGetTypeName stores the source level name of a type in the given std::string location. This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name. Windows-specific notes: nvrtcGetTypeName() is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe. The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl. Parameters tinfo \u2013 [in]  reference to object of type std::type_info for a given type. result \u2013 [in]  pointer to std::string in which to store the type name. Returns NVRTC_SUCCESS NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 82, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcProgram", "display_name": "nvrtcProgram", "type": "type", "display_type": "C++ type", "docname": "index", "anchor": "_CPPv412nvrtcProgram", "priority": 1, "content": "typedef  struct  _nvrtcProgram  * nvrtcProgram nvrtcProgram is the unit of compilation, and an opaque handle for a program. To compile a CUDA program string, an instance of nvrtcProgram must be created first with nvrtcCreateProgram , then compiled with nvrtcCompileProgram .", "keywords": []}, {"id": 83, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult", "display_name": "nvrtcResult", "type": "enum", "display_type": "C++ enum", "docname": "index", "anchor": "_CPPv411nvrtcResult", "priority": 1, "content": "enum  nvrtcResult The enumerated type nvrtcResult defines API call result codes. NVRTC API functions return nvrtcResult to indicate the call result. Values:", "keywords": []}, {"id": 84, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "display_name": "nvrtcResult::NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE", "priority": 1, "content": "enumerator  NVRTC_ERROR_BUILTIN_OPERATION_FAILURE", "keywords": []}, {"id": 85, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_COMPILATION", "display_name": "nvrtcResult::NVRTC_ERROR_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult23NVRTC_ERROR_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_COMPILATION", "keywords": []}, {"id": 86, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_INTERNAL_ERROR", "display_name": "nvrtcResult::NVRTC_ERROR_INTERNAL_ERROR", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INTERNAL_ERROR", "keywords": []}, {"id": 87, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_INVALID_INPUT", "display_name": "nvrtcResult::NVRTC_ERROR_INVALID_INPUT", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 88, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_INVALID_OPTION", "display_name": "nvrtcResult::NVRTC_ERROR_INVALID_OPTION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_OPTION", "keywords": []}, {"id": 89, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_INVALID_PROGRAM", "display_name": "nvrtcResult::NVRTC_ERROR_INVALID_PROGRAM", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME", "priority": 1, "content": "enumerator  NVRTC_ERROR_INVALID_PROGRAM", "keywords": []}, {"id": 90, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "display_name": "nvrtcResult::NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID", "keywords": []}, {"id": 91, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "display_name": "nvrtcResult::NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION", "keywords": []}, {"id": 92, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "display_name": "nvrtcResult::NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE", "priority": 1, "content": "enumerator  NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION", "keywords": []}, {"id": 93, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_OUT_OF_MEMORY", "display_name": "nvrtcResult::NVRTC_ERROR_OUT_OF_MEMORY", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE", "priority": 1, "content": "enumerator  NVRTC_ERROR_OUT_OF_MEMORY", "keywords": []}, {"id": 94, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "display_name": "nvrtcResult::NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE", "priority": 1, "content": "enumerator  NVRTC_ERROR_PROGRAM_CREATION_FAILURE", "keywords": []}, {"id": 95, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "display_name": "nvrtcResult::NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE", "priority": 1, "content": "enumerator  NVRTC_ERROR_TIME_FILE_WRITE_FAILED", "keywords": []}, {"id": 96, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcResult::NVRTC_SUCCESS", "display_name": "nvrtcResult::NVRTC_SUCCESS", "type": "enumerator", "display_type": "C++ enumerator", "docname": "index", "anchor": "_CPPv4N11nvrtcResult13NVRTC_SUCCESSE", "priority": 1, "content": "enumerator  NVRTC_SUCCESS", "keywords": []}, {"id": 97, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcVersion", "display_name": "nvrtcVersion", "type": "function", "display_type": "C++ function", "docname": "index", "anchor": "_CPPv412nvrtcVersionPiPi", "priority": 1, "content": "nvrtcResult  nvrtcVersion int  * major int  * minor nvrtcVersion sets the output parameters major and minor with the CUDA Runtime Compilation version number. Parameters major \u2013 [out]  CUDA Runtime Compilation major version number. minor \u2013 [out]  CUDA Runtime Compilation minor version number. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 98, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcVersion::major", "display_name": "nvrtcVersion::major", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv412nvrtcVersionPiPi", "priority": 1, "content": "nvrtcResult  nvrtcVersion int  * major int  * minor nvrtcVersion sets the output parameters major and minor with the CUDA Runtime Compilation version number. Parameters major \u2013 [out]  CUDA Runtime Compilation major version number. minor \u2013 [out]  CUDA Runtime Compilation minor version number. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 99, "doc_id": 144, "filename": "index.html", "domain_name": "cpp", "name": "nvrtcVersion::minor", "display_name": "nvrtcVersion::minor", "type": "functionParam", "display_type": "C++ function parameter", "docname": "index", "anchor": "_CPPv412nvrtcVersionPiPi", "priority": 1, "content": "nvrtcResult  nvrtcVersion int  * major int  * minor nvrtcVersion sets the output parameters major and minor with the CUDA Runtime Compilation version number. Parameters major \u2013 [out]  CUDA Runtime Compilation major version number. minor \u2013 [out]  CUDA Runtime Compilation minor version number. Returns NVRTC_SUCCESS NVRTC_ERROR_INVALID_INPUT", "keywords": []}, {"id": 100, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#accessing-lowered-names", "display_name": "Accessing Lowered Names", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "accessing-lowered-names", "priority": -1, "content": "NVRTC will mangle __global__ function names and names of __device__ and __constant__ variables as specified by the IA64 ABI. If the generated PTX is being loaded using the CUDA Driver API, the kernel function or __device__ / __constant__ variable must be looked up by name, but this is hard to do when the name has been mangled. To address this problem, NVRTC provides API functions that map source level __global__ function or __device__ / __constant__ variable names to the mangled names present in the generated PTX. The two API functions nvrtcAddNameExpression and nvrtcGetLoweredName work together to provide this functionality. First, a \u2018name expression\u2019 string denoting the address for the __global__ function or __device__ / __constant__ variable is provided to nvrtcAddNameExpression . Then, the program is compiled with nvrtcCompileProgram . During compilation, NVRTC will parse the name expression string as a C++ constant expression at the end of the user program. The constant expression must provide the address of the __global__ function or __device__ / __constant__ variable. Finally, the function nvrtcGetLoweredName is called with the original name expression and it returns a pointer to the lowered name. The lowered name can be used to refer to the kernel or variable in the CUDA Driver API. NVRTC guarantees that any __global__ function or __device__/__constant__ variable referenced in a call to nvrtcAddNameExpression will be present in the generated PTX (if the definition is available in the input source code).", "keywords": []}, {"id": 101, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#basic-usage", "display_name": "Basic Usage", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "basic-usage", "priority": -1, "content": "This section of the document uses a simple example, Single-Precision \u03b1\u22c5X Plus Y (SAXPY), shown in Figure 1 to explain what is involved in runtime compilation with NVRTC. For brevity and readability, error checks on the API return values are not shown. The complete code listing is available in Example: SAXPY . Figure 1. CUDA source string for SAXPY const char *saxpy = &quot; \\n\\ extern \\&quot;C\\&quot; __global__ \\n\\ void saxpy(float a, float *x, float *y, float *out, size_t n) \\n\\ { \\n\\ size_t tid = blockIdx.x * blockDim.x + threadIdx.x; \\n\\ if (tid &lt; n) { \\n\\ out[tid] = a * x[tid] + y[tid]; \\n\\ } \\n\\ } \\n&quot;; First, an instance of nvrtcProgram needs to be created. Figure 2 shows creation of nvrtcProgram for SAXPY. As SAXPY does not require any header, 0 is passed as numHeaders , and NULL as headers and includeNames . Figure 2. nvrtcProgram creation for SAXPY nvrtcProgram prog; nvrtcCreateProgram(&amp;prog, // prog saxpy, // buffer &quot;saxpy.cu&quot;, // name 0, // numHeaders NULL, // headers NULL); // includeNames If SAXPY had any #include directives, the contents of the files that are #include\u2019d can be passed as elements of headers, and their names as elements of includeNames. For example, #include &lt;foo.h&gt; and #include &lt;bar.h&gt; would require 2 as numHeaders , { &quot;&lt;contents of foo.h&gt;&quot;, &quot;&lt;contents of bar.h&gt;&quot; } as headers, and { &quot;foo.h&quot;, &quot;bar.h&quot; } as includeNames ( &lt;contents of foo.h&gt; and &lt;contents of bar.h&gt; must be replaced by the actual contents of foo.h and bar.h ). Alternatively, the compile option -I can be used if the header is guaranteed to exist in the file system at runtime. Once the instance of nvrtcProgram for compilation is created, it can be compiled by nvrtcCompileProgram as shown in Figure 3. Two compile options are used in this example, --gpu-architecture=compute_80 and --fmad=false , to generate code for the compute_80 architecture and to disable the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations. Other combinations of compile options can be used as needed and Supported Compile Options lists valid compile options. Figure 3. Compilation of SAXPY for compute_80 with FMAD enabled const char *opts[] = {&quot;--gpu-architecture=compute_80&quot;, &quot;--fmad=false&quot;}; nvrtcCompileProgram(prog, // prog 2, // numOptions opts); // options After the compilation completes, users can obtain the program compilation log and the generated PTX as Figure 4 shows. NVRTC does not generate valid PTX when the compilation fails, and it may generate program compilation log even when the compilation succeeds if needed. An nvrtcProgram can be compiled by nvrtcCompileProgram multiple times with different compile options, and users can only retrieve the PTX and the log generated by the last compilation. Figure 4. Obtaining generated PTX and program compilation log // Obtain compilation log from the program. size_t logSize; nvrtcGetProgramLogSize(prog, &amp;logSize); char *log = new char[logSize]; nvrtcGetProgramLog(prog, log); // Obtain PTX from the program. size_t ptxSize; nvrtcGetPTXSize(prog, &amp;ptxSize); char *ptx = new char[ptxSize]; nvrtcGetPTX(prog, ptx); When the instance of nvrtcProgram is no longer needed, it can be destroyed by nvrtcDestroyProgram as shown in Figure 5. Figure 5. Destruction of nvrtcProgram nvrtcDestroyProgram(&amp;prog); The generated PTX can be further manipulated by the CUDA Driver API for execution or linking. Figure 6 shows an example code sequence for execution of the generated PTX. Figure 6. Execution of SAXPY using the PTX generated by NVRTC CUdevice cuDevice; CUcontext context; CUmodule module; CUfunction kernel; cuInit(0); cuDeviceGet(&amp;cuDevice, 0); cuCtxCreate(&amp;context, 0, cuDevice); cuModuleLoadDataEx(&amp;module, ptx, 0, 0, 0); cuModuleGetFunction(&amp;kernel, module, &quot;saxpy&quot;); size_t n = size_t n = NUM_THREADS * NUM_BLOCKS; size_t bufferSize = n * sizeof(float); float a = ...; float *hX = ..., *hY = ..., *hOut = ...; CUdeviceptr dX, dY, dOut; cuMemAlloc(&amp;dX, bufferSize); cuMemAlloc(&amp;dY, bufferSize); cuMemAlloc(&amp;dOut, bufferSize); cuMemcpyHtoD(dX, hX, bufferSize); cuMemcpyHtoD(dY, hY, bufferSize); void *args[] = { &amp;a, &amp;dX, &amp;dY, &amp;dOut, &amp;n }; cuLaunchKernel(kernel, NUM_THREADS, 1, 1, // grid dim NUM_BLOCKS, 1, 1, // block dim 0, NULL, // shared mem and stream args, // arguments 0); cuCtxSynchronize(); cuMemcpyDtoH(hOut, dOut, bufferSize);", "keywords": []}, {"id": 102, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#builtin-functions", "display_name": "Builtin Functions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "builtin-functions", "priority": -1, "content": "Builtin functions provided by the CUDA Runtime headers when compiling offline with nvcc are available, unless otherwise noted.", "keywords": []}, {"id": 103, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#code-host-type-name-cpp", "display_name": "Code (host-type-name.cpp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-host-type-name-cpp", "priority": -1, "content": "#include &lt;nvrtc.h&gt; #include &lt;cuda.h&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #define NVRTC_SAFE_CALL(x) \\ do { \\ nvrtcResult result = x; \\ if (result != NVRTC_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define CUDA_SAFE_CALL(x) \\ do { \\ CUresult result = x; \\ if (result != CUDA_SUCCESS) { \\ const char *msg; \\ cuGetErrorName(result, &amp;msg); \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; msg &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) const char *gpu_program = &quot; \\n\\ namespace N1 { struct S1_t { int i; double d; }; } \\n\\ template&lt;typename T&gt; \\n\\ __global__ void f3(int *result) { *result = sizeof(T); } \\n\\ \\n&quot;; // note: this structure is also defined in GPU code string. Should ideally // be in a header file included by both GPU code string and by CPU code. namespace N1 { struct S1_t { int i; double d; }; }; template &lt;typename T&gt; std::string getKernelNameForType(void) { // Look up the source level name string for the type &quot;T&quot; using // nvrtcGetTypeName() and use it to create the kernel name std::string type_name; NVRTC_SAFE_CALL(nvrtcGetTypeName&lt;T&gt;(&amp;type_name)); return std::string(&quot;f3&lt;&quot;) + type_name + &quot;&gt;&quot;; } int main() { // Create an instance of nvrtcProgram nvrtcProgram prog; NVRTC_SAFE_CALL( nvrtcCreateProgram(&amp;prog, // prog gpu_program, // buffer &quot;gpu_program.cu&quot;, // name 0, // numHeaders NULL, // headers NULL)); // includeNames // add all name expressions for kernels std::vector&lt;std::string&gt; name_vec; std::vector&lt;int&gt; expected_result; // note the name expressions are parsed as constant expressions name_vec.push_back(getKernelNameForType&lt;int&gt;()); expected_result.push_back(sizeof(int)); name_vec.push_back(getKernelNameForType&lt;double&gt;()); expected_result.push_back(sizeof(double)); name_vec.push_back(getKernelNameForType&lt;N1::S1_t&gt;()); expected_result.push_back(sizeof(N1::S1_t)); // add name expressions to NVRTC. Note this must be done before // the program is compiled. for (size_t i = 0; i &lt; name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, name_vec[i].c_str())); nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog 0, // numOptions NULL); // options // Obtain compilation log from the program. size_t logSize; NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &amp;logSize)); char *log = new char[logSize]; NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log)); std::cout &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; delete[] log; if (compileResult != NVRTC_SUCCESS) { exit(1); } // Obtain PTX from the program. size_t ptxSize; NVRTC_SAFE_CALL(nvrtcGetPTXSize(prog, &amp;ptxSize)); char *ptx = new char[ptxSize]; NVRTC_SAFE_CALL(nvrtcGetPTX(prog, ptx)); // Load the generated PTX CUdevice cuDevice; CUcontext context; CUmodule module; CUDA_SAFE_CALL(cuInit(0)); CUDA_SAFE_CALL(cuDeviceGet(&amp;cuDevice, 0)); CUDA_SAFE_CALL(cuCtxCreate(&amp;context, 0, cuDevice)); CUDA_SAFE_CALL(cuModuleLoadDataEx(&amp;module, ptx, 0, 0, 0)); CUdeviceptr dResult; int hResult = 0; CUDA_SAFE_CALL(cuMemAlloc(&amp;dResult, sizeof(hResult))); CUDA_SAFE_CALL(cuMemcpyHtoD(dResult, &amp;hResult, sizeof(hResult))); // for each of the name expressions previously provided to NVRTC, // extract the lowered name for corresponding __global__ function, // and launch it. for (size_t i = 0; i &lt; name_vec.size(); ++i) { const char *name; // note: this call must be made after NVRTC program has been // compiled and before it has been destroyed. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, name_vec[i].c_str(), // name expression &amp;name // lowered name )); // get pointer to kernel from loaded PTX CUfunction kernel; CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, name)); // launch the kernel std::cout &lt;&lt; &quot;\\nlaunching &quot; &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; name_vec[i] &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; void *args[] = { &amp;dResult }; CUDA_SAFE_CALL( cuLaunchKernel(kernel, 1, 1, 1, // grid dim 1, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0)); // arguments CUDA_SAFE_CALL(cuCtxSynchronize()); // Retrieve the result CUDA_SAFE_CALL(cuMemcpyDtoH(&amp;hResult, dResult, sizeof(hResult))); // check against expected value if (expected_result[i] != hResult) { std::cout &lt;&lt; &quot;\\n Error: expected result = &quot; &lt;&lt; expected_result[i] &lt;&lt; &quot; , actual result = &quot; &lt;&lt; hResult &lt;&lt; std::endl; exit(1); } } // for // Release resources. CUDA_SAFE_CALL(cuMemFree(dResult)); CUDA_SAFE_CALL(cuModuleUnload(module)); CUDA_SAFE_CALL(cuCtxDestroy(context)); delete[] ptx; // Destroy the program. NVRTC_SAFE_CALL(nvrtcDestroyProgram(&amp;prog)); return 0; }", "keywords": []}, {"id": 104, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#code-lowered-name-cpp", "display_name": "Code (lowered-name.cpp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-lowered-name-cpp", "priority": -1, "content": "#include &lt;nvrtc.h&gt; #include &lt;cuda.h&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #define NVRTC_SAFE_CALL(x) \\ do { \\ nvrtcResult result = x; \\ if (result != NVRTC_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define CUDA_SAFE_CALL(x) \\ do { \\ CUresult result = x; \\ if (result != CUDA_SUCCESS) { \\ const char *msg; \\ cuGetErrorName(result, &amp;msg); \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; msg &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) const char *gpu_program = &quot; __device__ int V1; // set from host code \\n\\ static __global__ void f1(int *result) { *result = V1 + 10; } \\n\\ namespace N1 { \\n\\ namespace N2 { \\n\\ __constant__ int V2; // set from host code \\n\\ __global__ void f2(int *result) { *result = V2 + 20; } \\n\\ } \\n\\ } \\n\\ template&lt;typename T&gt; \\n\\ __global__ void f3(int *result) { *result = sizeof(T); } \\n\\ \\n&quot;; int main() { // Create an instance of nvrtcProgram nvrtcProgram prog; NVRTC_SAFE_CALL(nvrtcCreateProgram(&amp;prog, // prog gpu_program, // buffer &quot;prog.cu&quot;, // name 0, // numHeaders NULL, // headers NULL)); // includeNames // add all name expressions for kernels std::vector&lt;std::string&gt; kernel_name_vec; std::vector&lt;std::string&gt; variable_name_vec; std::vector&lt;int&gt; variable_initial_value; std::vector&lt;int&gt; expected_result; // note the name expressions are parsed as constant expressions kernel_name_vec.push_back(&quot;&amp;f1&quot;); expected_result.push_back(10 + 100); kernel_name_vec.push_back(&quot;N1::N2::f2&quot;); expected_result.push_back(20 + 200); kernel_name_vec.push_back(&quot;f3&lt;int&gt;&quot;); expected_result.push_back(sizeof(int)); kernel_name_vec.push_back(&quot;f3&lt;double&gt;&quot;); expected_result.push_back(sizeof(double)); // add kernel name expressions to NVRTC. Note this must be done before // the program is compiled. for (size_t i = 0; i &lt; kernel_name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, kernel_name_vec[i].c_str())); // add expressions for __device__ / __constant__ variables to NVRTC variable_name_vec.push_back(&quot;&amp;V1&quot;); variable_initial_value.push_back(100); variable_name_vec.push_back(&quot;&amp;N1::N2::V2&quot;); variable_initial_value.push_back(200); for (size_t i = 0; i &lt; variable_name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, variable_name_vec[i].c_str())); nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog 0, // numOptions NULL); // options // Obtain compilation log from the program. size_t logSize; NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &amp;logSize)); char *log = new char[logSize]; NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log)); std::cout &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; delete[] log; if (compileResult != NVRTC_SUCCESS) { exit(1); } // Obtain PTX from the program. size_t ptxSize; NVRTC_SAFE_CALL(nvrtcGetPTXSize(prog, &amp;ptxSize)); char *ptx = new char[ptxSize]; NVRTC_SAFE_CALL(nvrtcGetPTX(prog, ptx)); // Load the generated PTX CUdevice cuDevice; CUcontext context; CUmodule module; CUDA_SAFE_CALL(cuInit(0)); CUDA_SAFE_CALL(cuDeviceGet(&amp;cuDevice, 0)); CUDA_SAFE_CALL(cuCtxCreate(&amp;context, 0, cuDevice)); CUDA_SAFE_CALL(cuModuleLoadDataEx(&amp;module, ptx, 0, 0, 0)); CUdeviceptr dResult; int hResult = 0; CUDA_SAFE_CALL(cuMemAlloc(&amp;dResult, sizeof(hResult))); CUDA_SAFE_CALL(cuMemcpyHtoD(dResult, &amp;hResult, sizeof(hResult))); // for each of the __device__/__constant__ variable address // expressions provided to NVRTC, extract the lowered name for the // corresponding variable, and set its value for (size_t i = 0; i &lt; variable_name_vec.size(); ++i) { const char *name; // note: this call must be made after NVRTC program has been // compiled and before it has been destroyed. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, variable_name_vec[i].c_str(), // name expression &amp;name // lowered name )); int initial_value = variable_initial_value[i]; // get pointer to variable using lowered name, and set its // initial value CUdeviceptr variable_addr; CUDA_SAFE_CALL(cuModuleGetGlobal(&amp;variable_addr, NULL, module, name)); CUDA_SAFE_CALL(cuMemcpyHtoD(variable_addr, &amp;initial_value, sizeof(initial_value))); } // for each of the kernel name expressions previously provided to NVRTC, // extract the lowered name for corresponding __global__ function, // and launch it. for (size_t i = 0; i &lt; kernel_name_vec.size(); ++i) { const char *name; // note: this call must be made after NVRTC program has been // compiled and before it has been destroyed. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, kernel_name_vec[i].c_str(), // name expression &amp;name // lowered name )); // get pointer to kernel from loaded PTX CUfunction kernel; CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, name)); // launch the kernel std::cout &lt;&lt; &quot;\\nlaunching &quot; &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; kernel_name_vec[i] &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; void *args[] = { &amp;dResult }; CUDA_SAFE_CALL( cuLaunchKernel(kernel, 1, 1, 1, // grid dim 1, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0)); // arguments CUDA_SAFE_CALL(cuCtxSynchronize()); // Retrieve the result CUDA_SAFE_CALL(cuMemcpyDtoH(&amp;hResult, dResult, sizeof(hResult))); // check against expected value if (expected_result[i] != hResult) { std::cout &lt;&lt; &quot;\\n Error: expected result = &quot; &lt;&lt; expected_result[i] &lt;&lt; &quot; , actual result = &quot; &lt;&lt; hResult &lt;&lt; std::endl; exit(1); } } // for // Release resources. CUDA_SAFE_CALL(cuMemFree(dResult)); CUDA_SAFE_CALL(cuModuleUnload(module)); CUDA_SAFE_CALL(cuCtxDestroy(context)); delete[] ptx; // Destroy the program. NVRTC_SAFE_CALL(nvrtcDestroyProgram(&amp;prog)); return 0; }", "keywords": []}, {"id": 105, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#code-offline-cu", "display_name": "Code (offline.cu)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-offline-cu", "priority": -1, "content": "__device__ float compute(float a, float x, float y) { return a * x + y; }", "keywords": []}, {"id": 106, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#code-online-cpp", "display_name": "Code (online.cpp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-online-cpp", "priority": -1, "content": "#include &lt;nvrtc.h&gt; #include &lt;cuda.h&gt; #include &lt;nvJitLink.h&gt; #include &lt;iostream&gt; #define NUM_THREADS 128 #define NUM_BLOCKS 32 #define NVRTC_SAFE_CALL(x) \\ do { \\ nvrtcResult result = x; \\ if (result != NVRTC_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define CUDA_SAFE_CALL(x) \\ do { \\ CUresult result = x; \\ if (result != CUDA_SUCCESS) { \\ const char *msg; \\ cuGetErrorName(result, &amp;msg); \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; msg &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define NVJITLINK_SAFE_CALL(h,x) \\ do { \\ nvJitLinkResult result = x; \\ if (result != NVJITLINK_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;; \\ size_t lsize; \\ result = nvJitLinkGetErrorLogSize(h, &amp;lsize); \\ if (result == NVJITLINK_SUCCESS &amp;&amp; lsize &gt; 0) { \\ char *log = (char*)malloc(lsize); \\ result = nvJitLinkGetErrorLog(h, log); \\ if (result == NVJITLINK_SUCCESS) { \\ std::cerr &lt;&lt; &quot;error: &quot; &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; \\ free(log); \\ } \\ } \\ exit(1); \\ } \\ } while(0) const char *lto_saxpy = &quot; \\n\\ extern __device__ float compute(float a, float x, float y); \\n\\ \\n\\ extern \\&quot;C\\&quot; __global__ \\n\\ void saxpy(float a, float *x, float *y, float *out, size_t n) \\n\\ { \\n\\ size_t tid = blockIdx.x * blockDim.x + threadIdx.x; \\n\\ if (tid &lt; n) { \\n\\ out[tid] = compute(a, x[tid], y[tid]); \\n\\ } \\n\\ } \\n&quot;; int main(int argc, char *argv[]) { size_t numBlocks = 32; size_t numThreads = 128; // Create an instance of nvrtcProgram with the code string. nvrtcProgram prog; NVRTC_SAFE_CALL( nvrtcCreateProgram(&amp;prog, // prog lto_saxpy, // buffer &quot;lto_saxpy.cu&quot;, // name 0, // numHeaders NULL, // headers NULL)); // includeNames // specify that LTO IR should be generated for LTO operation const char *opts[] = {&quot;-dlto&quot;, &quot;--relocatable-device-code=true&quot;}; nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog 2, // numOptions opts); // options // Obtain compilation log from the program. size_t logSize; NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &amp;logSize)); char *log = new char[logSize]; NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log)); std::cout &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; delete[] log; if (compileResult != NVRTC_SUCCESS) { exit(1); } // Obtain generated LTO IR from the program. size_t LTOIRSize; NVRTC_SAFE_CALL(nvrtcGetLTOIRSize(prog, &amp;LTOIRSize)); char *LTOIR = new char[LTOIRSize]; NVRTC_SAFE_CALL(nvrtcGetLTOIR(prog, LTOIR)); // Destroy the program. NVRTC_SAFE_CALL(nvrtcDestroyProgram(&amp;prog)); CUdevice cuDevice; CUcontext context; CUmodule module; CUfunction kernel; CUDA_SAFE_CALL(cuInit(0)); CUDA_SAFE_CALL(cuDeviceGet(&amp;cuDevice, 0)); CUDA_SAFE_CALL(cuCtxCreate(&amp;context, 0, cuDevice)); // Load the generated LTO IR and the LTO IR generated offline // and link them together. nvJitLinkHandle handle; // Dynamically determine the arch to link for int major = 0; int minor = 0; CUDA_SAFE_CALL(cuDeviceGetAttribute(&amp;major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, cuDevice)); CUDA_SAFE_CALL(cuDeviceGetAttribute(&amp;minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, cuDevice)); int arch = major*10 + minor; char smbuf[16]; sprintf(smbuf, &quot;-arch=sm_%d&quot;, arch); const char *lopts[] = {&quot;-dlto&quot;, smbuf}; NVJITLINK_SAFE_CALL(handle, nvJitLinkCreate(&amp;handle, 2, lopts)); // NOTE: assumes &quot;offline.fatbin&quot; is in the current directory // The fatbinary contains LTO IR generated offline using nvcc NVJITLINK_SAFE_CALL(handle, nvJitLinkAddFile(handle, NVJITLINK_INPUT_FATBIN, &quot;offline.fatbin&quot;)); NVJITLINK_SAFE_CALL(handle, nvJitLinkAddData(handle, NVJITLINK_INPUT_LTOIR, (void *)LTOIR, LTOIRSize, &quot;lto_online&quot;)); // The call to nvJitLinkComplete causes linker to link together the two // LTO IR modules (offline and online), do optimization on the linked LTO IR, // and generate cubin from it. NVJITLINK_SAFE_CALL(handle, nvJitLinkComplete(handle)); size_t cubinSize; NVJITLINK_SAFE_CALL(handle, nvJitLinkGetLinkedCubinSize(handle, &amp;cubinSize)); void *cubin = malloc(cubinSize); NVJITLINK_SAFE_CALL(handle, nvJitLinkGetLinkedCubin(handle, cubin)); NVJITLINK_SAFE_CALL(handle, nvJitLinkDestroy(&amp;handle)); CUDA_SAFE_CALL(cuModuleLoadData(&amp;module, cubin)); CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, &quot;saxpy&quot;)); // Generate input for execution, and create output buffers. size_t n = NUM_THREADS * NUM_BLOCKS; size_t bufferSize = n * sizeof(float); float a = 5.1f; float *hX = new float[n], *hY = new float[n], *hOut = new float[n]; for (size_t i = 0; i &lt; n; ++i) { hX[i] = static_cast&lt;float&gt;(i); hY[i] = static_cast&lt;float&gt;(i * 2); } CUdeviceptr dX, dY, dOut; CUDA_SAFE_CALL(cuMemAlloc(&amp;dX, bufferSize)); CUDA_SAFE_CALL(cuMemAlloc(&amp;dY, bufferSize)); CUDA_SAFE_CALL(cuMemAlloc(&amp;dOut, bufferSize)); CUDA_SAFE_CALL(cuMemcpyHtoD(dX, hX, bufferSize)); CUDA_SAFE_CALL(cuMemcpyHtoD(dY, hY, bufferSize)); // Execute SAXPY. void *args[] = { &amp;a, &amp;dX, &amp;dY, &amp;dOut, &amp;n }; CUDA_SAFE_CALL( cuLaunchKernel(kernel, NUM_BLOCKS, 1, 1, // grid dim NUM_THREADS, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0)); // arguments CUDA_SAFE_CALL(cuCtxSynchronize()); // Retrieve and print output. CUDA_SAFE_CALL(cuMemcpyDtoH(hOut, dOut, bufferSize)); for (size_t i = 0; i &lt; n; ++i) { std::cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; hX[i] &lt;&lt; &quot; + &quot; &lt;&lt; hY[i] &lt;&lt; &quot; = &quot; &lt;&lt; hOut[i] &lt;&lt; &#x27;\\n&#x27;; } // Release resources. CUDA_SAFE_CALL(cuMemFree(dX)); CUDA_SAFE_CALL(cuMemFree(dY)); CUDA_SAFE_CALL(cuMemFree(dOut)); CUDA_SAFE_CALL(cuModuleUnload(module)); CUDA_SAFE_CALL(cuCtxDestroy(context)); free(cubin); delete[] hX; delete[] hY; delete[] hOut; delete[] LTOIR; return 0; }", "keywords": []}, {"id": 107, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#code-saxpy-cpp", "display_name": "Code (saxpy.cpp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-saxpy-cpp", "priority": -1, "content": "#include &lt;nvrtc.h&gt; #include &lt;cuda.h&gt; #include &lt;iostream&gt; #define NUM_THREADS 128 #define NUM_BLOCKS 32 #define NVRTC_SAFE_CALL(x) \\ do { \\ nvrtcResult result = x; \\ if (result != NVRTC_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define CUDA_SAFE_CALL(x) \\ do { \\ CUresult result = x; \\ if (result != CUDA_SUCCESS) { \\ const char *msg; \\ cuGetErrorName(result, &amp;msg); \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; msg &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) const char *saxpy = &quot; \\n\\ extern \\&quot;C\\&quot; __global__ \\n\\ void saxpy(float a, float *x, float *y, float *out, size_t n) \\n\\ { \\n\\ size_t tid = blockIdx.x * blockDim.x + threadIdx.x; \\n\\ if (tid &lt; n) { \\n\\ out[tid] = a * x[tid] + y[tid]; \\n\\ } \\n\\ } \\n&quot;; int main() { // Create an instance of nvrtcProgram with the SAXPY code string. nvrtcProgram prog; NVRTC_SAFE_CALL( nvrtcCreateProgram(&amp;prog, // prog saxpy, // buffer &quot;saxpy.cu&quot;, // name 0, // numHeaders NULL, // headers NULL)); // includeNames // Compile the program with fmad disabled. // Note: Can specify GPU target architecture explicitly with &#x27;-arch&#x27; flag. const char *opts[] = {&quot;--fmad=false&quot;}; nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog 1, // numOptions opts); // options // Obtain compilation log from the program. size_t logSize; NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &amp;logSize)); char *log = new char[logSize]; NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log)); std::cout &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; delete[] log; if (compileResult != NVRTC_SUCCESS) { exit(1); } // Obtain PTX from the program. size_t ptxSize; NVRTC_SAFE_CALL(nvrtcGetPTXSize(prog, &amp;ptxSize)); char *ptx = new char[ptxSize]; NVRTC_SAFE_CALL(nvrtcGetPTX(prog, ptx)); // Destroy the program. NVRTC_SAFE_CALL(nvrtcDestroyProgram(&amp;prog)); // Load the generated PTX and get a handle to the SAXPY kernel. CUdevice cuDevice; CUcontext context; CUmodule module; CUfunction kernel; CUDA_SAFE_CALL(cuInit(0)); CUDA_SAFE_CALL(cuDeviceGet(&amp;cuDevice, 0)); CUDA_SAFE_CALL(cuCtxCreate(&amp;context, 0, cuDevice)); CUDA_SAFE_CALL(cuModuleLoadDataEx(&amp;module, ptx, 0, 0, 0)); CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, &quot;saxpy&quot;)); // Generate input for execution, and create output buffers. size_t n = NUM_THREADS * NUM_BLOCKS; size_t bufferSize = n * sizeof(float); float a = 5.1f; float *hX = new float[n], *hY = new float[n], *hOut = new float[n]; for (size_t i = 0; i &lt; n; ++i) { hX[i] = static_cast&lt;float&gt;(i); hY[i] = static_cast&lt;float&gt;(i * 2); } CUdeviceptr dX, dY, dOut; CUDA_SAFE_CALL(cuMemAlloc(&amp;dX, bufferSize)); CUDA_SAFE_CALL(cuMemAlloc(&amp;dY, bufferSize)); CUDA_SAFE_CALL(cuMemAlloc(&amp;dOut, bufferSize)); CUDA_SAFE_CALL(cuMemcpyHtoD(dX, hX, bufferSize)); CUDA_SAFE_CALL(cuMemcpyHtoD(dY, hY, bufferSize)); // Execute SAXPY. void *args[] = { &amp;a, &amp;dX, &amp;dY, &amp;dOut, &amp;n }; CUDA_SAFE_CALL( cuLaunchKernel(kernel, NUM_BLOCKS, 1, 1, // grid dim NUM_THREADS, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0)); // arguments CUDA_SAFE_CALL(cuCtxSynchronize()); // Retrieve and print output. CUDA_SAFE_CALL(cuMemcpyDtoH(hOut, dOut, bufferSize)); for (size_t i = 0; i &lt; n; ++i) { std::cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; hX[i] &lt;&lt; &quot; + &quot; &lt;&lt; hY[i] &lt;&lt; &quot; = &quot; &lt;&lt; hOut[i] &lt;&lt; &#x27;\\n&#x27;; } // Release resources. CUDA_SAFE_CALL(cuMemFree(dX)); CUDA_SAFE_CALL(cuMemFree(dY)); CUDA_SAFE_CALL(cuMemFree(dOut)); CUDA_SAFE_CALL(cuModuleUnload(module)); CUDA_SAFE_CALL(cuCtxDestroy(context)); delete[] hX; delete[] hY; delete[] hOut; delete[] ptx; return 0; }", "keywords": []}, {"id": 108, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#compilation", "display_name": "Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compilation", "priority": -1, "content": "NVRTC defines the following type and functions for actual compilation. Functions nvrtcResult  nvrtcAddNameExpression (nvrtcProgram prog, const char *const name_expression) nvrtcAddNameExpression notes the given name expression denoting the address of a global function or device /__constant__ variable. nvrtcResult  nvrtcCompileProgram (nvrtcProgram prog, int numOptions, const char *const *options) nvrtcCompileProgram compiles the given program. nvrtcResult  nvrtcCreateProgram (nvrtcProgram *prog, const char *src, const char *name, int numHeaders, const char *const *headers, const char *const *includeNames) nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it. nvrtcResult  nvrtcDestroyProgram (nvrtcProgram *prog) nvrtcDestroyProgram destroys the given program. nvrtcResult  nvrtcGetCUBIN (nvrtcProgram prog, char *cubin) nvrtcGetCUBIN stores the cubin generated by the previous compilation of prog in the memory pointed by cubin . nvrtcResult  nvrtcGetCUBINSize (nvrtcProgram prog, size_t *cubinSizeRet) nvrtcGetCUBINSize sets the value of cubinSizeRet with the size of the cubin generated by the previous compilation of prog . nvrtcResult  nvrtcGetLTOIR (nvrtcProgram prog, char *LTOIR) nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of prog in the memory pointed by LTOIR . nvrtcResult  nvrtcGetLTOIRSize (nvrtcProgram prog, size_t *LTOIRSizeRet) nvrtcGetLTOIRSize sets the value of LTOIRSizeRet with the size of the LTO IR generated by the previous compilation of prog . nvrtcResult  nvrtcGetLoweredName (nvrtcProgram prog, const char *const name_expression, const char **lowered_name) nvrtcGetLoweredName extracts the lowered (mangled) name for a global function or device /__constant__ variable, and updates *lowered_name to point to it. nvrtcResult  nvrtcGetNVVM (nvrtcProgram prog, char *nvvm) DEPRECATION NOTICE: This function will be removed in a future release. nvrtcResult  nvrtcGetNVVMSize (nvrtcProgram prog, size_t *nvvmSizeRet) DEPRECATION NOTICE: This function will be removed in a future release. nvrtcResult  nvrtcGetOptiXIR (nvrtcProgram prog, char *optixir) nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of prog in the memory pointed by optixir . nvrtcResult  nvrtcGetOptiXIRSize (nvrtcProgram prog, size_t *optixirSizeRet) nvrtcGetOptiXIRSize sets the value of optixirSizeRet with the size of the OptiX IR generated by the previous compilation of prog . nvrtcResult  nvrtcGetPTX (nvrtcProgram prog, char *ptx) nvrtcGetPTX stores the PTX generated by the previous compilation of prog in the memory pointed by ptx . nvrtcResult  nvrtcGetPTXSize (nvrtcProgram prog, size_t *ptxSizeRet) nvrtcGetPTXSize sets the value of ptxSizeRet with the size of the PTX generated by the previous compilation of prog (including the trailing NULL ). nvrtcResult  nvrtcGetProgramLog (nvrtcProgram prog, char *log) nvrtcGetProgramLog stores the log generated by the previous compilation of prog in the memory pointed by log . nvrtcResult  nvrtcGetProgramLogSize (nvrtcProgram prog, size_t *logSizeRet) nvrtcGetProgramLogSize sets logSizeRet with the size of the log generated by the previous compilation of prog (including the trailing NULL ). Typedefs nvrtcProgram  nvrtcProgram is the unit of compilation, and an opaque handle for a program.", "keywords": []}, {"id": 109, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#default-c-dialect", "display_name": "Default C++ Dialect", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "default-c-dialect", "priority": -1, "content": "The default C++ dialect is C++17. Other dialects can be selected using the -std flag.", "keywords": []}, {"id": 110, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#device-lto-build-instructions", "display_name": "Device LTO Build Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-lto-build-instructions", "priority": -1, "content": "Assuming the environment variable CUDA_PATH points to the CUDA Toolkit installation directory, build this example as: Compile offline.cu to fatbinary containing LTO IR (change lto_52 to a different lto_XX architecture as appropriate). nvcc -arch lto_52 -rdc=true -fatbin offline.cu With NVRTC shared library: Windows: cl.exe online.cpp /Feonline ^ /I &quot;%CUDA_PATH%\\include&quot; ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvJitLink.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib Linux: g++ online.cpp -o online \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc -lnvJitLink -lcuda \\ -Wl,-rpath,$CUDA_PATH/lib64 With NVRTC static library: Windows: cl.exe online.cpp /Feonline ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc-builtins_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvJitLink_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvptxcompiler_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib user32.lib Ws2_32.lib Linux: g++ online.cpp -o online \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc_static -lnvrtc-builtins_static -lnvJitLink_static -lnvptxcompiler_static -lcuda \\ -lpthread", "keywords": []}, {"id": 111, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#dynamic-parallelism", "display_name": "Dynamic Parallelism", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dynamic-parallelism", "priority": -1, "content": "NVRTC supports dynamic parallelism under the following conditions: Compilation target must be compute 35 or higher. Either separate compilation ( --relocatable-device-code=true or --device-c ) or extensible whole program compilation ( --extensible-whole-program ) must be enabled. Generated PTX must be linked against the CUDA device runtime (cudadevrt) library (refer to Separate Compilation ). Example: Dynamic Parallelism provides a simple example.", "keywords": []}, {"id": 112, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#dynamic-parallelism-build-instructions", "display_name": "Dynamic Parallelism Build Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dynamic-parallelism-build-instructions", "priority": -1, "content": "Assuming the environment variable CUDA_PATH points to CUDA Toolkit installation directory, build this example as: With NVRTC shared library: Windows: cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism ^ /I &quot;%CUDA_PATH%\\include&quot; ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc.lib &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib Linux: g++ dynamic-parallelism.cpp -o dynamic-parallelism \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc -lcuda \\ -Wl,-rpath,$CUDA_PATH/lib64 With NVRTC static library: Windows: cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc-builtins_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvptxcompiler_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib user32.lib Ws2_32.lib Linux: g++ dynamic-parallelism.cpp -o dynamic-parallelism \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \\ -lpthread", "keywords": []}, {"id": 113, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#error-handling", "display_name": "Error Handling", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "error-handling", "priority": -1, "content": "NVRTC defines the following enumeration type and function for API call error handling. Enumerations nvrtcResult  The enumerated type nvrtcResult defines API call result codes. Functions const char *  nvrtcGetErrorString (nvrtcResult result) nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to &quot;NVRTC_SUCCESS&quot; .", "keywords": []}, {"id": 114, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#example", "display_name": "Example", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "example", "priority": -1, "content": "Example: Using Lowered Name`_ lists a complete runnable example. Some relevant snippets: The GPU source code (\u2018gpu_program\u2019) contains definitions of various __global__ functions/function templates and __device__ / __constant__ variables: const char *gpu_program = &quot; \\n\\ __device__ int V1; // set from host code \\n\\ static __global__ void f1(int *result) { *result = V1 + 10; } \\n\\ namespace N1 { \\n\\ namespace N2 { \\n\\ __constant__ int V2; // set from host code \\n\\ __global__ void f2(int *result) { *result = V2 + 20; } \\n\\ } \\n\\ } \\n\\ template&lt;typename T&gt; \\n\\ __global__ void f3(int *result) { *result = sizeof(T); } \\n\\ The host source code invokes nvrtcAddNameExpression with various name expressions referring to the address of __global__ functions and __device__ / __constant__ variables: kernel_name_vec.push_back(&quot;&amp;f1&quot;); .. kernel_name_vec.push_back(&quot;N1::N2::f2&quot;); .. kernel_name_vec.push_back(&quot;f3&lt;int&gt;&quot;); .. kernel_name_vec.push_back(&quot;f3&lt;double&gt;&quot;); // add name expressions to NVRTC. Note this must be done before // the program is compiled. for (size_t i = 0; i &lt; name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, kernel_name_vec[i].c_str())); .. // add expressions for __device__ / __constant__ variables to NVRTC variable_name_vec.push_back(&quot;&amp;V1&quot;); .. variable_name_vec.push_back(&quot;&amp;N1::N2::V2&quot;); .. for (size_t i = 0; i &lt; variable_name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, variable_name_vec[i].c_str())); The GPU program is then compiled with nvrtcCompileProgram . The generated PTX is loaded on the GPU. The mangled names of the __device__ / __constant__ variables and __global__ functions are looked up: // note: this call must be made after NVRTC program has been // compiled and before it has been destroyed. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, variable_name_vec[i].c_str(), // name expression &amp;name // lowered name )); .. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, kernel_name_vec[i].c_str(), // name expression &amp;name // lowered name )); The mangled name of the __device__ / __constant__ variable is then used to lookup the variable in the module and update its value using the CUDA Driver API: CUdeviceptr variable_addr; CUDA_SAFE_CALL(cuModuleGetGlobal(&amp;variable_addr, NULL, module, name)); CUDA_SAFE_CALL(cuMemcpyHtoD(variable_addr, &amp;initial_value, sizeof(initial_value))); The mangled name of the kernel is then used to launch it using the CUDA Driver API: CUfunction kernel; CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, name)); ... CUDA_SAFE_CALL( cuLaunchKernel(kernel, 1, 1, 1, // grid dim 1, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0));", "keywords": []}, {"id": 115, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#example-device-lto-link-time-optimization", "display_name": "Example: Device LTO (link time optimization)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "example-device-lto-link-time-optimization", "priority": -1, "content": "This section demonstrates device link time optimization (LTO). There are two units of LTO IR. The first unit is generated offline using nvcc, by specifying the architecture as -arch lto_XX (refer to Code (offline.cu) ). The generated LTO IR is packaged in a fatbinary. The second unit is generated online using NVRTC, by specifying the flag -dlto (refer to Code (online.cpp) ). These two units are then passed to libnvJitLink* API functions, which link together the LTO IR, run the optimizer on the linked IR and generate a cubin (refer to Code (online.cpp) ). The cubin is then loaded on the GPU and executed.", "keywords": []}, {"id": 116, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#example-dynamic-parallelism", "display_name": "Example: Dynamic Parallelism", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "example-dynamic-parallelism", "priority": -1, "content": "Code (dynamic-parallelism.cpp) #include &lt;nvrtc.h&gt; #include &lt;cuda.h&gt; #include &lt;iostream&gt; #define NVRTC_SAFE_CALL(x) \\ do { \\ nvrtcResult result = x; \\ if (result != NVRTC_SUCCESS) { \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) #define CUDA_SAFE_CALL(x) \\ do { \\ CUresult result = x; \\ if (result != CUDA_SUCCESS) { \\ const char *msg; \\ cuGetErrorName(result, &amp;msg); \\ std::cerr &lt;&lt; &quot;\\nerror: &quot; #x &quot; failed with error &quot; \\ &lt;&lt; msg &lt;&lt; &#x27;\\n&#x27;; \\ exit(1); \\ } \\ } while(0) const char *dynamic_parallelism = &quot; \\n\\ extern \\&quot;C\\&quot; __global__ \\n\\ void child(float *out, size_t n) \\n\\ { \\n\\ size_t tid = blockIdx.x * blockDim.x + threadIdx.x; \\n\\ if (tid &lt; n) { \\n\\ out[tid] = tid; \\n\\ } \\n\\ } \\n\\ \\n\\ extern \\&quot;C\\&quot; __global__ \\n\\ void parent(float *out, size_t n, \\n\\ size_t numBlocks, size_t numThreads) \\n\\ { \\n\\ child&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(out, n); \\n\\ cudaDeviceSynchronize(); \\n\\ } \\n&quot;; int main(int argc, char *argv[]) { if (argc &lt; 2) { std::cout &lt;&lt; &quot;Usage: dynamic-parallelism &lt;path to cudadevrt library&gt;\\n\\n&quot; &lt;&lt; &quot;&lt;path to cudadevrt library&gt; must include the cudadevrt\\n&quot; &lt;&lt; &quot;library name itself, e.g., Z:\\\\path\\\\to\\\\cudadevrt.lib on \\n&quot; &lt;&lt; &quot;Windows and /path/to/libcudadevrt.a on Linux.\\n&quot;; exit(1); } size_t numBlocks = 32; size_t numThreads = 128; // Create an instance of nvrtcProgram with the code string. nvrtcProgram prog; NVRTC_SAFE_CALL( nvrtcCreateProgram(&amp;prog, // prog dynamic_parallelism, // buffer &quot;dynamic_parallelism.cu&quot;, // name 0, // numHeaders NULL, // headers NULL)); // includeNames // Compile the program for compute_35 with rdc enabled. const char *opts[] = {&quot;--gpu-architecture=compute_35&quot;, &quot;--relocatable-device-code=true&quot;}; nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog 2, // numOptions opts); // options // Obtain compilation log from the program. size_t logSize; NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &amp;logSize)); char *log = new char[logSize]; NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log)); std::cout &lt;&lt; log &lt;&lt; &#x27;\\n&#x27;; delete[] log; if (compileResult != NVRTC_SUCCESS) { exit(1); } // Obtain PTX from the program. size_t ptxSize; NVRTC_SAFE_CALL(nvrtcGetPTXSize(prog, &amp;ptxSize)); char *ptx = new char[ptxSize]; NVRTC_SAFE_CALL(nvrtcGetPTX(prog, ptx)); // Destroy the program. NVRTC_SAFE_CALL(nvrtcDestroyProgram(&amp;prog)); // Load the generated PTX and get a handle to the parent kernel. CUdevice cuDevice; CUcontext context; CUlinkState linkState; CUmodule module; CUfunction kernel; CUDA_SAFE_CALL(cuInit(0)); CUDA_SAFE_CALL(cuDeviceGet(&amp;cuDevice, 0)); CUDA_SAFE_CALL(cuCtxCreate(&amp;context, 0, cuDevice)); CUDA_SAFE_CALL(cuLinkCreate(0, 0, 0, &amp;linkState)); CUDA_SAFE_CALL(cuLinkAddFile(linkState, CU_JIT_INPUT_LIBRARY, argv[1], 0, 0, 0)); CUDA_SAFE_CALL(cuLinkAddData(linkState, CU_JIT_INPUT_PTX, (void *)ptx, ptxSize, &quot;dynamic_parallelism.ptx&quot;, 0, 0, 0)); size_t cubinSize; void *cubin; CUDA_SAFE_CALL(cuLinkComplete(linkState, &amp;cubin, &amp;cubinSize)); CUDA_SAFE_CALL(cuModuleLoadData(&amp;module, cubin)); CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, &quot;parent&quot;)); // Generate input for execution, and create output buffers. size_t n = numBlocks * numThreads; size_t bufferSize = n * sizeof(float); float *hOut = new float[n]; CUdeviceptr dX, dY, dOut; CUDA_SAFE_CALL(cuMemAlloc(&amp;dOut, bufferSize)); // Execute parent kernel. void *args[] = { &amp;dOut, &amp;n, &amp;numBlocks, &amp;numThreads }; CUDA_SAFE_CALL( cuLaunchKernel(kernel, 1, 1, 1, // grid dim 1, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0)); // arguments CUDA_SAFE_CALL(cuCtxSynchronize()); // Retrieve and print output. CUDA_SAFE_CALL(cuMemcpyDtoH(hOut, dOut, bufferSize)); for (size_t i = 0; i &lt; n; ++i) { std::cout &lt;&lt; hOut[i] &lt;&lt; &#x27;\\n&#x27;; } // Release resources. CUDA_SAFE_CALL(cuMemFree(dOut)); CUDA_SAFE_CALL(cuModuleUnload(module)); CUDA_SAFE_CALL(cuLinkDestroy(linkState)); CUDA_SAFE_CALL(cuCtxDestroy(context)); delete[] hOut; delete[] ptx; return 0; }", "keywords": []}, {"id": 117, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#execution-space", "display_name": "Execution Space", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "execution-space", "priority": -1, "content": "NVRTC uses __host__ as the default execution space, and it generates an error if it encounters any host code in the input. That is, if the input contains entities with explicit __host__ annotations or no execution space annotation, NVRTC will emit an error. __host__ __device__ functions are treated as device functions. NVRTC provides a compile option, --device-as-default-execution-space (refer to Supported Compile Options ), that enables an alternative compilation mode, in which entities with no execution space annotations are treated as __device__ entities .", "keywords": []}, {"id": 118, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#general-information-query", "display_name": "General Information Query", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "general-information-query", "priority": -1, "content": "NVRTC defines the following function for general information query. Functions nvrtcResult  nvrtcGetNumSupportedArchs (int *numArchs) nvrtcGetNumSupportedArchs sets the output parameter numArchs with the number of architectures supported by NVRTC. nvrtcResult  nvrtcGetSupportedArchs (int *supportedArchs) nvrtcGetSupportedArchs populates the array passed via the output parameter supportedArchs with the architectures supported by NVRTC. nvrtcResult  nvrtcVersion (int *major, int *minor) nvrtcVersion sets the output parameters major and minor with the CUDA Runtime Compilation version number.", "keywords": []}, {"id": 119, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#host-helper", "display_name": "Host Helper", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "host-helper", "priority": -1, "content": "NVRTC defines the following functions for easier interaction with host code. Functions nvrtcResult  nvrtcGetTypeName (const std::type_info &amp;tinfo, std::string *result) nvrtcGetTypeName stores the source level name of a type in the given std::string location. nvrtcResult  nvrtcGetTypeName (std::string *result) nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location.", "keywords": []}, {"id": 120, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#host-type-name-build-instructions", "display_name": "Host Type Name Build Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "host-type-name-build-instructions", "priority": -1, "content": "Assuming the environment variable CUDA_PATH points to the CUDA Toolkit installation directory, build this example as: With NVRTC shared library: Windows: cl.exe saxpy.cpp /Fesaxpy ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc.lib &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib Linux: g++ saxpy.cpp -o saxpy \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc -lcuda \\ -Wl,-rpath,$CUDA_PATH/lib64 With NVRTC static library: Windows: cl.exe saxpy.cpp /Fesaxpy ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc-builtins_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvptxcompiler_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib user32.lib Ws2_32.lib Linux: g++ saxpy.cpp -o saxpy \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \\ -lpthread", "keywords": []}, {"id": 121, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#include-syntax", "display_name": "Include Syntax", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "include-syntax", "priority": -1, "content": "When nvrtcCompileProgram() is called, the current working directory is added to the header search path used for locating files included with the quoted syntax (for example, #include &quot;foo.h&quot; ), before the code is compiled.", "keywords": []}, {"id": 122, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#installation", "display_name": "Installation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "installation", "priority": -1, "content": "NVRTC is part of the CUDA Toolkit release and the components are organized as follows in the CUDA toolkit installation directory: On Windows: include\\nvrtc.h bin\\nvrtc64_Major Release VersionMinor Release Version_0.dll bin\\nvrtc-builtins64_Major Release VersionMinor Release Version.dll lib\\x64\\nvrtc.lib lib\\x64\\nvrtc_static.lib lib\\x64\\nvrtc-builtins_static.lib doc\\pdf\\NVRTC_User_Guide.pdf On Linux: include/nvrtc.h lib64/libnvrtc.so lib64/libnvrtc.so.Major Release Version.Minor Release Version lib64/libnvrtc.so.Major Release Version.Minor Release Version.&lt;build version&gt; lib64/libnvrtc-builtins.so lib64/libnvrtc-builtins.so.Major Release Version.Minor Release Version lib64/libnvrtc-builtins.so.Major Release Version.Minor Release Version.&lt;build version&gt; lib64/libnvrtc_static.a lib64/libnvrtc-builtins_static.a doc/pdf/NVRTC_User_Guide.pdf", "keywords": []}, {"id": 123, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#integer-size", "display_name": "Integer Size", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "integer-size", "priority": -1, "content": "Different operating systems define integer type sizes differently. Linux x86_64 implements LP64, and Windows x86_64 implements LLP64. short int long long long pointers and size_t LLP64 16 32 32 64 64 LP64 16 32 64 64 64 NVRTC implements LP64 on Linux and LLP64 on Windows. NVRTC supports 128-bit integer types through the __int128 type. This can be enabled with the --device-int128 flag. 128-bit integer support is not available on Windows.", "keywords": []}, {"id": 124, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#interfacing-with-template-host-code", "display_name": "Interfacing With Template Host Code", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "interfacing-with-template-host-code", "priority": -1, "content": "In some scenarios, it is useful to instantiate __global__ function templates in device code based on template arguments in host code. The NVRTC helper function nvrtcGetTypeName can be used to extract the source level name of a type in host code, and this string can be used to instantiate a __global__ function template and get the mangled name of the instantiation using the nvrtcAddNameExpression and nvrtcGetLoweredName functions. nvrtcGetTypeName is defined inline in the NVRTC header file, and is available when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses the abi::__cxa_demangle and UnDecorateSymbolName host code functions when using gcc/clang and cl.exe compilers, respectively. Users may need to specify additional header paths and libraries to find the host functions used ( abi::__cxa_demangle / UnDecorateSymbolName ). Refer to the build instructions for the example below for reference ( nvrtcGetTypeName Build Instructions ).", "keywords": []}, {"id": 125, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#language", "display_name": "Language", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "language", "priority": -1, "content": "Unlike the offline nvcc compiler, NVRTC is meant for compiling only device CUDA C++ code. It does not accept host code or host compiler extensions in the input code, unless otherwise noted.", "keywords": []}, {"id": 126, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#lowered-name-build-instructions", "display_name": "Lowered Name Build Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "lowered-name-build-instructions", "priority": -1, "content": "Assuming the environment variable CUDA_PATH points to CUDA Toolkit installation directory, build this example as: With NVRTC shared library: Windows: cl.exe lowered-name.cpp /Felowered-name ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc.lib &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib Linux: g++ lowered-name.cpp -o lowered-name \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc -lcuda \\ -Wl,-rpath,$CUDA_PATH/lib64 With NVRTC static library: Windows: cl.exe lowered-name.cpp /Felowered-name ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc-builtins_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvptxcompiler_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib user32.lib Ws2_32.lib Linux: g++ lowered-name.cpp -o lowered-name \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \\ -lcuda -lpthread", "keywords": []}, {"id": 127, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#notes", "display_name": "Notes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notes", "priority": -1, "content": "Sequence of calls: All name expressions must be added using nvrtcAddNameExpression before the NVRTC program is compiled with nvrtcCompileProgram . This is required because the name expressions are parsed at the end of the user program, and may trigger template instantiations. The lowered names must be looked up by calling nvrtcGetLoweredName only after the NVRTC program has been compiled, and before it has been destroyed. The pointer returned by nvrtcGetLoweredName points to memory owned by NVRTC, and this memory is freed when the NVRTC program has been destroyed ( nvrtcDestroyProgram ). Thus the correct sequence of calls is: nvrtcAddNameExpression , nvrtcCompileProgram , nvrtcGetLoweredName , nvrtcDestroyProgram . Identical Name Expressions: The name expression string passed to nvrtcAddNameExpression and nvrtcGetLoweredName must have identical characters. For example, \u201cfoo\u201d and \u201cfoo \u201d are not identical strings, even though semantically they refer to the same entity (foo), because the second string has a extra whitespace character. Constant Expressions: The characters in the name expression string are parsed as a C++ constant expression at the end of the user program. Any errors during parsing will cause compilation failure and compiler diagnostics will be generated in the compilation log. The constant expression must refer to the address of a __global__ function or __device__/__constant__ variable. Address of overloaded function: If the NVRTC source code has multiple overloaded __global__ functions, then the name expression must use a cast operation to disambiguate. However, casts are not allowed in constant expression for C++ dialects before C++11. If using such name expressions, please compile the code in C++11 or later dialect using the -std command line flag. Example: Consider that the GPU code string contains: __global__ void foo(int) { } __global__ void foo(char) { } The name expression (void(*)(int))foo correctly disambiguates foo(int) , but the program must be compiled in C++11 or later dialect (such as -std=c++11 ) because casts are not allowed in pre-C++11 constant expressions.", "keywords": []}, {"id": 128, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notice", "priority": -1, "content": "This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (\u201cNVIDIA\u201d) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (\u201cTerms of Sale\u201d). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer\u2019s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer\u2019s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer\u2019s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201cMATERIALS\u201d) ARE BEING PROVIDED \u201cAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA\u2019s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.", "keywords": []}, {"id": 129, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#nvrtc-builtins-library", "display_name": "NVRTC-builtins Library", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvrtc-builtins-library", "priority": -1, "content": "The NVRTC-builtins library contains helper code that is part of the NVRTC package. It is only used by the NVRTC library internally. Each NVRTC library is only compatible with the NVRTC-builtins library from the same CUDA toolkit.", "keywords": []}, {"id": 130, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#nvrtc-shared-library-versioning", "display_name": "NVRTC Shared Library Versioning", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvrtc-shared-library-versioning", "priority": -1, "content": "In the following, MAJOR and MINOR denote the major and minor versions of the CUDA Toolkit. For example, for CUDA 11.2, MAJOR is \u201c11\u201d and MINOR is \u201c2\u201d. Linux: In CUDA toolkits prior to CUDA 11.3, the soname was set to \u201cMAJOR.MINOR\u201d. In CUDA 11.3 and later 11.x toolkits, the soname field is set to \u201c11.2\u201d. In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the soname field is set to \u201cMAJOR\u201d. Windows: In CUDA toolkits prior to cuda 11.3, the DLL name was of the form \u201cnvrtc64_XY_0.dll\u201d, where X = MAJOR, Y = MINOR. In CUDA 11.3 and later 11.x toolkits, the DLL name is \u201cnvrtc64_112_0.dll\u201d. In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the DLL name is of the form \u201cnvrtc64_X0_0.dll\u201d where X = MAJOR. Consider a CUDA toolkit with major version &gt; 11. The NVRTC shared library in this CUDA toolkit will have the same soname (Linux) or DLL name (Windows) as an NVRTC shared library in a previous minor version of the same CUDA toolkit. Similarly, the NVRTC shared library in CUDA 11.3 and later 11.x releases will have the same soname (Linux) or DLL name (Windows) as the NVRTC shared library in CUDA 11.2. As a consequence of the versioning scheme described above, an NVRTC client that links against a particular NVRTC shared library will continue to work with a future NVRTC shared library with a matching soname (Linux) or DLL name (Windows). This allows the NVRTC client to take advantage of bug fixes and enhancements available in the more recent NVRTC shared library 1 . However, the more recent NVRTC shared library may generate PTX with a version that is not accepted by the CUDA Driver API functions of an older CUDA driver, as explained in the Best Practices Guide . Some approaches to resolving this issue: Install a more recent CUDA driver that is compatible with the CUDA toolkit containing the NVRTC library being used. Compile directly to SASS instead of PTX with NVRTC (refer to Best Practices Guide ). Alternately, an NVRTC client can either link against the static NVRTC library or redistribute a specific version of the NVRTC shared library and use dlopen (Linux) or LoadLibrary (Windows) functions to use that library at run time. Either approach allows the NVRTC client to maintain control over the version of NVRTC being used during deployment, to ensure predictable functionality and performance.", "keywords": []}, {"id": 131, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#nvrtc-static-library", "display_name": "NVRTC Static Library", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvrtc-static-library", "priority": -1, "content": "The NVRTC static library references functions defined in the NVRTC-builtins static library and the PTX compiler static library. Please see Build Instructions for an example.", "keywords": []}, {"id": 132, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#nvrtcgettypename-build-instructions", "display_name": "nvrtcGetTypeName Build Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvrtcgettypename-build-instructions", "priority": -1, "content": "Assuming the environment variable CUDA_PATH points to CUDA Toolkit installation directory, build this example as: With NVRTC shared library: Windows: cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc.lib &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib DbgHelp.lib Linux: g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc -lcuda \\ -Wl,-rpath,$CUDA_PATH/lib64 With NVRTC static library: Windows: cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name ^ /I &quot;%CUDA_PATH%&quot;\\include ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvrtc-builtins_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\nvptxcompiler_static.lib ^ &quot;%CUDA_PATH%&quot;\\lib\\x64\\cuda.lib DbgHelp.lib user32.lib Ws2_32.lib Linux: g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \\ -I $CUDA_PATH/include \\ -L $CUDA_PATH/lib64 \\ -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \\ -lcuda -lpthread", "keywords": []}, {"id": 133, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#opencl", "display_name": "OpenCL", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opencl", "priority": -1, "content": "OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.", "keywords": []}, {"id": 134, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#predefined-macros", "display_name": "Predefined Macros", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "predefined-macros", "priority": -1, "content": "__CUDACC_RTC__ : useful for distinguishing between runtime and offline nvcc compilation in user code. __CUDACC__ : defined with same semantics as with offline nvcc compilation. __CUDACC_RDC__ : defined with same semantics as with offline nvcc compilation. __CUDACC_EWP__ : defined with same semantics as with offline nvcc compilation. __CUDACC_DEBUG__ : defined with same semantics as with offline nvcc compilation. __CUDA_ARCH__ : defined with same semantics as with offline nvcc compilation. __CUDA_ARCH_LIST__ : defined with same semantics as with offline nvcc compilation. __CUDACC_VER_MAJOR__ : defined with the major version number as returned by nvrtcVersion . __CUDACC_VER_MINOR__ : defined with the minor version number as returned by nvrtcVersion . __CUDACC_VER_BUILD__ : defined with the build version number. __NVCC_DIAG_PRAGMA_SUPPORT__ : defined with same semantics as with offline nvcc compilation. __CUDACC_RTC_INT128__ : defined when -device-int128 flag is specified during compilation, and indicates that __int128 type is supported. NULL : null pointer constant. va_start va_end va_arg va_copy : defined when language dialect C++11 or later is selected. __cplusplus _WIN64 : defined on Windows platforms. __LP64__ : defined on non-Windows platforms where long int and pointer types are 64-bits. __cdecl : defined to empty on all platforms. __ptr64 : defined to empty on Windows platforms. __CUDACC_RTC_MINIMAL__ : defined when -minimal flag is specified during compilation (since CUDA 12.4). Macros defined in nv/target header are implicitly provided, e.g., NV_IF_TARGET .", "keywords": []}, {"id": 135, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#predefined-types", "display_name": "Predefined Types", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "predefined-types", "priority": -1, "content": "clock_t size_t ptrdiff_t va_list : Note that the definition of this type may be different than the one selected by nvcc when compiling CUDA code. Predefined types such as dim3 , char4 , etc., that are available in the CUDA Runtime headers when compiling offline with nvcc are also available, unless otherwise noted. std::initializer_list&lt;T&gt; : implicitly provided in C++11 and later dialects, unless -builtin-initializer-list=false is specified. std::move&lt;T&gt;, std::forward&lt;T&gt; : implicitly provided in C++11 and later dialects, unless -builtin-move-forward=false is specified.", "keywords": []}, {"id": 136, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#separate-compilation", "display_name": "Separate Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "separate-compilation", "priority": -1, "content": "NVRTC itself does not provide any linker. Users can, however, use the nvJitLink library or cuLinkAddData in the CUDA Driver API to link the generated relocatable PTX code with other relocatable code. To generate relocatable PTX code, the compile option --relocatable-device-code=true or --device-c is required.", "keywords": []}, {"id": 137, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#stack-size", "display_name": "Stack Size", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "stack-size", "priority": -1, "content": "On Linux, NVRTC will increase the stack size to the maximum allowed using the setrlimit() function during compilation. This reduces the chance that the compiler will run out of stack when processing complex input sources. The stack size is reset to the previous value when compilation is completed. Because setrlimit() changes the stack size for the entire process, it will also affect other application threads that may be executing concurrently. The command line flag -modify-stack-limit=false will prevent NVRTC from modifying the stack limit.", "keywords": []}, {"id": 138, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#supported-compile-options", "display_name": "Supported Compile Options", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-compile-options", "priority": -1, "content": "NVRTC supports the compile options below. Option names with two preceding dashs ( -- ) are long option names and option names with one preceding dash ( - ) are short option names. Short option names can be used instead of long option names. When a compile option takes an argument, an assignment operator ( = ) is used to separate the compile option argument from the compile option name, e.g., &quot;--gpu-architecture=compute_60&quot; . Alternatively, the compile option name and the argument can be specified in separate strings without an assignment operator, .e.g, &quot;--gpu-architecture&quot;  &quot;compute_60&quot; . Single-character short option names, such as -D , -U , and -I , do not require an assignment operator, and the compile option name and the argument can be present in the same string with or without spaces between them. For instance, &quot;-D=&lt;def&gt;&quot; , &quot;-D&lt;def&gt;&quot; , and &quot;-D &lt;def&gt;&quot; are all supported. The valid compiler options are: Compilation targets --gpu-architecture=&lt;arch&gt; ( -arch ) Specify the name of the class of GPU architectures for which the input must be compiled. Valid &lt;arch&gt; s: compute_50  compute_52  compute_53  compute_60  compute_61  compute_62  compute_70  compute_72  compute_75  compute_80  compute_87  compute_89  compute_90  compute_90a  sm_50  sm_52  sm_53  sm_60  sm_61  sm_62  sm_70  sm_72  sm_75  sm_80  sm_87  sm_89  sm_90  sm_90a  Default: compute_52  Separate compilation / whole-program compilation --device-c ( -dc ) Generate relocatable code that can be linked with other relocatable device code. It is equivalent to &amp;#8212;relocatable-device-code=true. --device-w ( -dw ) Generate non-relocatable code. It is equivalent to --relocatable-device-code=false . --relocatable-device-code={true|false} ( -rdc ) Enable (disable) the generation of relocatable device code. Default: false  --extensible-whole-program ( -ewp ) Do extensible whole program compilation of device code. Default: false  Debugging support --device-debug ( -G ) Generate debug information. If &amp;#8212;dopt is not specified, then turns off all optimizations. --generate-line-info ( -lineinfo ) Generate line-number information. Code generation --dopt on ( -dopt ) --dopt=on Enable device code optimization. When specified along with \u2018-G\u2019, enables limited debug information generation for optimized device code (currently, only line number information). When \u2018-G\u2019 is not specified, \u2018-dopt=on\u2019 is implicit. --ptxas-options &lt;options&gt; ( -Xptxas ) --ptxas-options=&lt;options&gt; Specify options directly to ptxas, the PTX optimizing assembler. --maxrregcount=&lt;N&gt; ( -maxrregcount ) Specify the maximum amount of registers that GPU functions can use. Until a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good maxrregcount value is the result of a trade-off. If this option is not specified, then no maximum is assumed. Value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit. --ftz={true|false} ( -ftz ) When performing single-precision floating-point operations, flush denormal values to zero or preserve denormal values. --use_fast_math implies --ftz=true . Default: false  --prec-sqrt={true|false} ( -prec-sqrt ) For single-precision floating-point square root, use IEEE round-to-nearest mode or use a faster approximation. --use_fast_math implies --prec-sqrt=false . Default: true  --prec-div={true|false} ( -prec-div ) For single-precision floating-point division and reciprocals, use IEEE round-to-nearest mode or use a faster approximation. --use_fast_math implies --prec-div=false . Default: true  --fmad={true|false} ( -fmad ) Enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA). --use_fast_math implies --fmad=true . Default: true  --use_fast_math ( -use_fast_math ) Make use of fast math operations. --use_fast_math implies --ftz=true  --prec-div=false  --prec-sqrt=false  --fmad=true . --extra-device-vectorization ( -extra-device-vectorization ) Enables more aggressive device code vectorization in the NVVM optimizer. --modify-stack-limit={true|false} ( -modify-stack-limit ) On Linux, during compilation, use setrlimit() to increase stack size to maximum allowed. The limit is reset to the previous value at the end of compilation. Note: setrlimit() changes the value for the entire process. Default: true  --dlink-time-opt ( -dlto ) Generate intermediate code for later link-time optimization. It implies -rdc=true . Note: when this option is used the nvrtcGetLTOIR API should be used, as PTX or Cubin will not be generated. --gen-opt-lto ( -gen-opt-lto ) Run the optimizer passes before generating the LTO IR. --optix-ir ( -optix-ir ) Generate OptiX IR. The Optix IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization ( -dlto ) . Note: when this option is used the nvrtcGetOptiX API should be used, as PTX or Cubin will not be generated. --jump-table-density= [0-101] ( -jtd ) Specify the case density percentage in switch statements, and use it as a minimal threshold to determine whether jump table(brx.idx instruction) will be used to implement a switch statement. Default value is 101. The percentage ranges from 0 to 101 inclusively. --device-stack-protector={true|false} ( -device-stack-protector ) Enable (disable) the generation of stack canaries in device code. Default: false  Preprocessing --define-macro=&lt;def&gt; ( -D ) &lt;def&gt; can be either &lt;name&gt; or &lt;name=definitions&gt; . &lt;name&gt; Predefine &lt;name&gt; as a macro with definition 1 . &lt;name&gt;=&lt;definition&gt; The contents of &lt;definition&gt; are tokenized and preprocessed as if they appeared during translation phase three in a #define directive. In particular, the definition will be truncated by embedded new line characters. --undefine-macro=&lt;def&gt; ( -U ) Cancel any previous definition of &lt;def&gt; . --include-path=&lt;dir&gt; ( -I ) Add the directory &lt;dir&gt; to the list of directories to be searched for headers. These paths are searched after the list of headers given to nvrtcCreateProgram . --pre-include=&lt;header&gt; ( -include ) Preinclude &lt;header&gt; during preprocessing. --no-source-include ( -no-source-include ) The preprocessor by default adds the directory of each input sources to the include path. This option disables this feature and only considers the path specified explicitly. Language Dialect --std={c++03|c++11|c++14|c++17|c++20} ( -std={c++11|c++14|c++17|c++20} ) Set language dialect to C++03, C++11, C++14, C++17 or C++20 Default: c++17  --builtin-move-forward={true|false} ( -builtin-move-forward ) Provide builtin definitions of std::move and std::forward , when C++11 or later language dialect is selected. Default: true  --builtin-initializer-list={true|false} ( -builtin-initializer-list ) Provide builtin definitions of std::initializer_list class and member functions when C++11 or later language dialect is selected. Default: true  Misc. --disable-warnings ( -w ) Inhibit all warning messages. --restrict ( -restrict ) Programmer assertion that all kernel pointer parameters are restrict pointers. --device-as-default-execution-space ( -default-device ) Treat entities with no execution space annotation as __device__ entities. --device-int128 ( -device-int128 ) Allow the __int128 type in device code. Also causes the macro __CUDACC_RTC_INT128__ to be defined. --optimization-info=&lt;kind&gt; ( -opt-info ) Provide optimization reports for the specified kind of optimization. The following kind tags are supported: inline : emit a remark when a function is inlined. --display-error-number ( -err-no ) Display diagnostic number for warning messages. (Default) --no-display-error-number ( -no-err-no ) Disables the display of a diagnostic number for warning messages. --diag-error=&lt;error-number&gt; ,\u2026 ( -diag-error ) Emit error for specified diagnostic message number(s). Message numbers can be separated by comma. --diag-suppress=&lt;error-number&gt; ,\u2026 ( -diag-suppress ) Suppress specified diagnostic message number(s). Message numbers can be separated by comma. --diag-warn=&lt;error-number&gt; ,\u2026 ( -diag-warn ) Emit warning for specified diagnostic message number(s). Message numbers can be separated by comma. --brief-diagnostics={true|false} ( -brief-diag ) This option disables or enables showing source line and column info in a diagnostic. The &amp;#8212;brief-diagnostics=true will not show the source line and column info. Default: false  --time=&lt;file-name&gt; ( -time ) Generate a comma separated value table with the time taken by each compilation phase, and append it at the end of the file given as the option argument. If the file does not exist, the column headings are generated in the first row of the table. If the file name is \u2018-\u2019, the timing data is written to the compilation log. --split-compile= &lt;number of threads&gt; ( -split-compile= &lt;number of threads&gt;) Perform compiler optimizations in parallel. Split compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. This option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting &amp;#8212;split-compile=0. Setting &amp;#8212;split-compile=1 will cause this option to be ignored. --fdevice-syntax-only ( -fdevice-syntax-only ) Ends device compilation after front-end syntax checking. This option does not generate valid device code. --minimal ( -minimal ) Omit certain language features to reduce compile time for small programs. In particular, the following are omitted: Texture and surface functions and associated types, e.g., cudaTextureObject_t . CUDA Runtime Functions that are provided by the cudadevrt device code library, typically named with prefix \u201ccuda\u201d, e.g., cudaMalloc . Kernel launch from device code. Types and macros associated with CUDA Runtime and Driver APIs, provided by cuda/tools/cudart/driver_types.h, typically named with prefix \u201ccuda\u201d, e.g., cudaError_t . --device-stack-protector ( -device-stack-protector ) Enable stack canaries in device code. Stack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables. The compiler uses heuristics to assess the risk of such a bug in each function. Only those functions which are deemed high-risk make use of a stack canary.", "keywords": []}, {"id": 139, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#system-requirements", "display_name": "System Requirements", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "system-requirements", "priority": -1, "content": "NVRTC is supported on the following platforms: Linux x86_64, Linux ppc64le, Linux aarch64, Windows x86_64. Note : NVRTC does not depend on any other libraries or headers from the CUDA toolkit, and can be run on a system without a GPU.", "keywords": []}, {"id": 140, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#template-host-code-example", "display_name": "Template Host Code Example", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "template-host-code-example", "priority": -1, "content": "Example: Using nvrtcGetTypeName lists a complete runnable example. Some relevant snippets: The GPU source code ( gpu_program ) contains definitions of a __global__ function template: const char *gpu_program = &quot; \\n\\ namespace N1 { struct S1_t { int i; double d; }; } \\n\\ template&lt;typename T&gt; \\n\\ __global__ void f3(int *result) { *result = sizeof(T); } \\n\\ \\n&quot;; The host code function getKernelNameForType creates the name expression for a __global__ function template instantiation based on the host template type T. The name of the type T is extracted using nvrtcGetTypeName : template &lt;typename T&gt; std::string getKernelNameForType(void) { // Look up the source level name string for the type &quot;T&quot; using // nvrtcGetTypeName() and use it to create the kernel name std::string type_name; NVRTC_SAFE_CALL(nvrtcGetTypeName&lt;T&gt;(&amp;type_name)); return std::string(&quot;f3&lt;&quot;) + type_name + &quot;&gt;&quot;; } The name expressions are presented to NVRTC using the nvrtcAddNameExpression function: name_vec.push_back(getKernelNameForType&lt;int&gt;()); .. name_vec.push_back(getKernelNameForType&lt;double&gt;()); .. name_vec.push_back(getKernelNameForType&lt;N1::S1_t&gt;()); .. for (size_t i = 0; i &lt; name_vec.size(); ++i) NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, name_vec[i].c_str())); The GPU program is then compiled with nvrtcCompileProgram . The generated PTX is loaded on the GPU. The mangled names of the __global__ function template instantiations are looked up: // note: this call must be made after NVRTC program has been // compiled and before it has been destroyed. NVRTC_SAFE_CALL(nvrtcGetLoweredName( prog, name_vec[i].c_str(), // name expression &amp;name // lowered name )); The mangled name is then used to launch the kernel using the CUDA Driver API: CUfunction kernel; CUDA_SAFE_CALL(cuModuleGetFunction(&amp;kernel, module, name)); ... CUDA_SAFE_CALL( cuLaunchKernel(kernel, 1, 1, 1, // grid dim 1, 1, 1, // block dim 0, NULL, // shared mem and stream args, 0));", "keywords": []}, {"id": 141, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#thread-safety", "display_name": "Thread Safety", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "thread-safety", "priority": -1, "content": "Multiple threads can invoke NVRTC API functions concurrently, as long as there is no race condition. In this context, a race condition is defined to occur if multiple threads concurrently invoke NVRTC API functions with the same nvrtcProgram argument, where at least one thread is invoking either nvrtcCompileProgram or nvrtcAddNameExpression  2 . Since CUDA 12.3, NVRTC allows concurrent invocations of nvrtcCompileProgram to potentially concurrently also invoke the embedded NVVM optimizer/codegen phase. Setting the environment variable NVRTC_DISABLE_CONCURRENT_NVVM disables this behavior, i.e., invocations of the embedded NVVM optimizer/codegen phase will be serialized.", "keywords": []}, {"id": 142, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trademarks", "priority": -1, "content": "NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated. 1 Changes to compiler optimizer heuristics in the newer NVRTC shared library may also potentially cause performance perturbations for generated code. 2 These API functions modify the state of the associated nvrtcProgram .", "keywords": []}, {"id": 143, "doc_id": 144, "filename": "index.html", "domain_name": "page", "name": "index#user-interface", "display_name": "User Interface", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "user-interface", "priority": -1, "content": "This chapter presents the API of NVRTC. Basic usage of the API is explained in Basic Usage . Error Handling General Information Query Compilation Supported Compile Options Host Helper", "keywords": []}, {"id": 144, "doc_id": 144, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "Introduction", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "nvrtc The User guide for the NVRTC library. NVRTC is a runtime compilation library for CUDA C++. It accepts CUDA C++ source code in character string form and creates handles that can be used to obtain the PTX. The PTX string generated by NVRTC can be loaded by cuModuleLoadData and cuModuleLoadDataEx , and linked with other modules by using the nvJitLink library or using cuLinkAddData of the CUDA Driver API. This facility can often provide optimizations and performance not possible in a purely offline static compilation. In the absence of NVRTC (or any runtime compilation support in CUDA), users needed to spawn a separate process to execute nvcc at runtime if they wished to implement runtime compilation in their applications or libraries, and, unfortunately, this approach has the following drawbacks: The compilation overhead tends to be higher than necessary. End users are required to install nvcc and related tools which make it complicated to distribute applications that use runtime compilation. NVRTC addresses these issues by providing a library interface that eliminates overhead associated with spawning separate processes, disk I/O,and so on, while keeping application deployment simple.", "keywords": []}]};