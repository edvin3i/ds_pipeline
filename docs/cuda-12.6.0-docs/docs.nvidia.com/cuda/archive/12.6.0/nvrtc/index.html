<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" type="text/javascript"
  data-document-language="true" charset="UTF-8" data-domain-script="3e2b62ff-7ae7-4ac5-87c8-d5949ecafff5">
</script>
<script type="text/javascript">
  function OptanonWrapper() {
    var event = new Event('bannerLoaded');
    window.dispatchEvent(event);
  }
</script>
<script src="https://images.nvidia.com/aem-dam/Solutions/ot-js/ot-custom.js" type="text/javascript">
</script>

  <meta charset="utf-8">
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/">
<meta content="The User guide for the NVRTC library" name="description">
<meta content="nvrtc" name="keywords">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NVRTC</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css">
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css">
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css">
      <link rel="stylesheet" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css">
      <link rel="stylesheet" href="../_static/omni-style.css" type="text/css">
      <link rel="stylesheet" href="../_static/api-styles.css" type="text/css">
    <link rel="shortcut icon" href="../_static/favicon.ico">
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/mermaid-init.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/design-tabs.js"></script>
        <script src="../_static/geoip/geoip.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html">
    <link rel="search" title="Search" href="search.html">
    <link rel="prev" title="Contents" href="contents.html">
 
<script src="https://assets.adobedtm.com/5d4962a43b79/c1061d2c5e7b/launch-191c2462b890.min.js"></script>
 

<link rel="stylesheet" href="../../../../common-libs/common.css">
<script src="../../../../common-libs/common.js"></script>
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="contents.html">
            <img src="../_static/Logo_and_CUDA.png" class="logo" alt="Logo">
          </a>

<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs">
    <input type="hidden" name="check_keywords" value="yes">
    <input type="hidden" name="area" value="default">
  </form>
</div>
        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="index.html#">1. Introduction</a></li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#getting-started">2. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#system-requirements">2.1. System Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#installation">2.2. Installation</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#user-interface">3. User Interface</a><ul>
<li class="toctree-l2">
<a class="reference internal" href="index.html#error-handling">3.1. Error Handling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#enumerations">3.1.1. Enumerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#functions">3.1.2. Functions</a></li>
</ul>
</li>
<li class="toctree-l2">
<a class="reference internal" href="index.html#general-information-query">3.2. General Information Query</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id1">3.2.1. Functions</a></li>
</ul>
</li>
<li class="toctree-l2">
<a class="reference internal" href="index.html#compilation">3.3. Compilation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id2">3.3.1. Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#typedefs">3.3.2. Typedefs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#supported-compile-options">3.4. Supported Compile Options</a></li>
<li class="toctree-l2">
<a class="reference internal" href="index.html#host-helper">3.5. Host Helper</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#id3">3.5.1. Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#language">4. Language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#execution-space">4.1. Execution Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#separate-compilation">4.2. Separate Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#dynamic-parallelism">4.3. Dynamic Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#integer-size">4.4. Integer Size</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#include-syntax">4.5. Include Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#predefined-macros">4.6. Predefined Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#predefined-types">4.7. Predefined Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#builtin-functions">4.8. Builtin Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#default-c-dialect">4.9. Default C++ Dialect</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#basic-usage">5. Basic Usage</a></li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#accessing-lowered-names">6. Accessing Lowered Names</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#example">6.1. Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#notes">6.2. Notes</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#interfacing-with-template-host-code">7. Interfacing With Template Host Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#template-host-code-example">7.1. Template Host Code Example</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#versioning-scheme">8. Versioning Scheme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#nvrtc-shared-library-versioning">8.1. NVRTC Shared Library Versioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nvrtc-builtins-library">8.2. NVRTC-builtins Library</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#miscellaneous-notes">9. Miscellaneous Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#thread-safety">9.1. Thread Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#stack-size">9.2. Stack Size</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nvrtc-static-library">9.3. NVRTC Static Library</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#example-saxpy">10. Example: SAXPY</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-saxpy-cpp">10.1. Code (saxpy.cpp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#host-type-name-build-instructions">10.2. Host Type Name Build Instructions</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#example-using-lowered-name">11. Example: Using Lowered Name</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-lowered-name-cpp">11.1. Code (lowered-name.cpp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#lowered-name-build-instructions">11.2. Lowered Name Build Instructions</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#example-using-nvrtcgettypename">12. Example: Using nvrtcGetTypeName</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-host-type-name-cpp">12.1. Code (host-type-name.cpp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#nvrtcgettypename-build-instructions">12.2. nvrtcGetTypeName Build Instructions</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#example-dynamic-parallelism">13. Example: Dynamic Parallelism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#dynamic-parallelism-build-instructions">13.1. Dynamic Parallelism Build Instructions</a></li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="index.html#example-device-lto-link-time-optimization">14. Example: Device LTO (link time optimization)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-offline-cu">14.1. Code (offline.cu)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-online-cpp">14.2. Code (online.cpp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#device-lto-build-instructions">14.3. Device LTO Build Instructions</a></li>
<li class="toctree-l2">
<a class="reference internal" href="index.html#notices">14.4. Notices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#notice">14.4.1. Notice</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#opencl">14.4.2. OpenCL</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#trademarks">14.4.3. Trademarks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html">NVRTC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">


  

<li>
<a href="../index.html" class="icon icon-home"></a> »</li>
  
<li>
<span class="section-number">1. </span>Introduction</li>

      <li class="wy-breadcrumbs-aside">
      </li>
<li class="wy-breadcrumbs-aside">


  <span>v12.6 |</span>



  <a href="../pdf/NVRTC_User_Guide.pdf" class="reference external">PDF</a>



  <span>|</span>



  <a href="https://developer.nvidia.com/cuda-toolkit-archive" class="reference external">Archive</a>


  <span> </span>
</li>

  </ul>
  <hr>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p class="rubric-h1 rubric">nvrtc</p>
<p>The User guide for the NVRTC library.</p>
<section id="introduction">
<span id="nvrtc-introduction"></span><h1>
<span class="section-number">1. </span>Introduction<a class="headerlink" href="index.html#introduction" title="Permalink to this headline"></a>
</h1>
<p>NVRTC is a runtime compilation library for CUDA C++. It accepts CUDA C++ source code in
character string form and creates handles that can be used to obtain the PTX. The PTX
string generated by NVRTC can be loaded by <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b">cuModuleLoadData</a> and <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12">cuModuleLoadDataEx</a>, and
linked with other modules by using the nvJitLink library or using <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77">cuLinkAddData</a> of the
CUDA Driver API. This facility can often provide optimizations and performance not
possible in a purely offline static compilation.</p>
<p>In the absence of NVRTC (or any runtime compilation support in CUDA), users needed to
spawn a separate process to execute nvcc at runtime if they wished to implement runtime
compilation in their applications or libraries, and, unfortunately, this approach has
the following drawbacks:</p>
<ul class="simple">
<li><p>The compilation overhead tends to be higher than necessary.</p></li>
<li><p>End users are required to install nvcc and related tools which make it complicated to distribute applications that use runtime compilation.</p></li>
</ul>
<p>NVRTC addresses these issues by providing a library interface that eliminates overhead associated with spawning separate processes, disk I/O,and so on, while keeping application deployment simple.</p>
</section>
<section id="getting-started">
<h1>
<span class="section-number">2. </span>Getting Started<a class="headerlink" href="index.html#getting-started" title="Permalink to this headline"></a>
</h1>
<section id="system-requirements">
<h2>
<span class="section-number">2.1. </span>System Requirements<a class="headerlink" href="index.html#system-requirements" title="Permalink to this headline"></a>
</h2>
<p>NVRTC is supported on the following platforms: Linux x86_64, Linux ppc64le, Linux aarch64, Windows x86_64.</p>
<p><strong>Note</strong>: NVRTC does not depend on any other libraries or headers from the CUDA toolkit, and can be run on a system without a GPU.</p>
</section>
<section id="installation">
<h2>
<span class="section-number">2.2. </span>Installation<a class="headerlink" href="index.html#installation" title="Permalink to this headline"></a>
</h2>
<p>NVRTC is part of the CUDA Toolkit release and the components are organized as follows in the CUDA toolkit installation directory:</p>
<ul class="simple">
<li>
<p>On Windows:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">include\nvrtc.h</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bin\nvrtc64_Major</span> <span class="pre">Release</span> <span class="pre">VersionMinor</span> <span class="pre">Release</span> <span class="pre">Version_0.dll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bin\nvrtc-builtins64_Major</span> <span class="pre">Release</span> <span class="pre">VersionMinor</span> <span class="pre">Release</span> <span class="pre">Version.dll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib\x64\nvrtc.lib</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib\x64\nvrtc_static.lib</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib\x64\nvrtc-builtins_static.lib</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">doc\pdf\NVRTC_User_Guide.pdf</span></code></p></li>
</ul>
</li>
<li>
<p>On Linux:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">include/nvrtc.h</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc.so</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc.so.Major</span> <span class="pre">Release</span> <span class="pre">Version.Minor</span> <span class="pre">Release</span> <span class="pre">Version</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc.so.Major</span> <span class="pre">Release</span> <span class="pre">Version.Minor</span> <span class="pre">Release</span> <span class="pre">Version.&lt;build</span> <span class="pre">version&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc-builtins.so</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc-builtins.so.Major</span> <span class="pre">Release</span> <span class="pre">Version.Minor</span> <span class="pre">Release</span> <span class="pre">Version</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc-builtins.so.Major</span> <span class="pre">Release</span> <span class="pre">Version.Minor</span> <span class="pre">Release</span> <span class="pre">Version.&lt;build</span> <span class="pre">version&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc_static.a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib64/libnvrtc-builtins_static.a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">doc/pdf/NVRTC_User_Guide.pdf</span></code></p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="user-interface">
<h1>
<span class="section-number">3. </span>User Interface<a class="headerlink" href="index.html#user-interface" title="Permalink to this headline"></a>
</h1>
<p>This chapter presents the API of NVRTC. Basic usage of the API is explained in <a class="reference internal" href="index.html#basic-usage">Basic Usage</a>.</p>
<blockquote>
<div>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#error-handling">Error Handling</a></p></li>
<li><p><a class="reference internal" href="index.html#general-information-query">General Information Query</a></p></li>
<li><p><a class="reference internal" href="index.html#compilation">Compilation</a></p></li>
<li><p><a class="reference internal" href="index.html#supported-compile-options">Supported Compile Options</a></p></li>
<li><p><a class="reference internal" href="index.html#host-helper">Host Helper</a></p></li>
</ul>
</div>
</blockquote>
<section id="error-handling">
<h2>
<span class="section-number">3.1. </span>Error Handling<a class="headerlink" href="index.html#error-handling" title="Permalink to this headline"></a>
</h2>
<p id="group__error">NVRTC defines the following enumeration type and function for API call error handling. </p>
<p class="rubric-h2 rubric">Enumerations</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">nvrtcResult</span></a></dt>
<dd>
<p>The enumerated type nvrtcResult defines API call result codes.</p>
</dd>
</dl>
</div>
<p class="rubric-h2 rubric">Functions</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt>
<span class="tag-as-table-cell">const char *</span> <a class="reference internal" href="index.html#group__error_1gace77107f185310fb006e7f9a722009e6"><span class="std std-ref">nvrtcGetErrorString</span></a>(nvrtcResult result)</dt>
<dd>
<p>nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to <code class="docutils literal notranslate"><span class="pre">"NVRTC_SUCCESS"</span></code> .</p>
</dd>
</dl>
</div>
<section id="enumerations">
<h3>
<span class="section-number">3.1.1. </span>Enumerations<a class="headerlink" href="index.html#enumerations" title="Permalink to this headline"></a>
</h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv411nvrtcResult">
<span id="_CPPv311nvrtcResult"></span><span id="_CPPv211nvrtcResult"></span><span class="target" id="group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcResult</span></span></span><a class="headerlink" href="index.html#_CPPv411nvrtcResult" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>The enumerated type nvrtcResult defines API call result codes. </p>
<p>NVRTC API functions return nvrtcResult to indicate the call result. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult13NVRTC_SUCCESSE">
<span id="_CPPv3N11nvrtcResult13NVRTC_SUCCESSE"></span><span id="_CPPv2N11nvrtcResult13NVRTC_SUCCESSE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0afe8ab8635d5832644b7899a51ccf540a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_SUCCESS</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult13NVRTC_SUCCESSE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE">
<span id="_CPPv3N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE"></span><span id="_CPPv2N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0ab3c88942cdeca904fd5b2566009b27f2"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_OUT_OF_MEMORY</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE">
<span id="_CPPv3N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE"></span><span id="_CPPv2N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a831ec2e6d44b0f02395b9e2339509f3c"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_PROGRAM_CREATION_FAILURE</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE">
<span id="_CPPv3N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE"></span><span id="_CPPv2N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a9596aa7001252e96eab3b7535448f674"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_INVALID_INPUT</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME">
<span id="_CPPv3N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME"></span><span id="_CPPv2N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a844833cba59e2fdbe275ba630235c997"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_INVALID_PROGRAM</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE">
<span id="_CPPv3N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE"></span><span id="_CPPv2N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a8228099578f4368afe58c364e829d52a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_INVALID_OPTION</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult23NVRTC_ERROR_COMPILATIONE">
<span id="_CPPv3N11nvrtcResult23NVRTC_ERROR_COMPILATIONE"></span><span id="_CPPv2N11nvrtcResult23NVRTC_ERROR_COMPILATIONE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0ae5237d8392d77dcb20c906644b12bf8e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_COMPILATION</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult23NVRTC_ERROR_COMPILATIONE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE">
<span id="_CPPv3N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE"></span><span id="_CPPv2N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a780785702b6bb48a67fc171daae9ac1b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_BUILTIN_OPERATION_FAILURE</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE">
<span id="_CPPv3N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE"></span><span id="_CPPv2N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0ab8104539931ae101e8bd75843d007a6f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE">
<span id="_CPPv3N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE"></span><span id="_CPPv2N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0ad59536198cafac17ad28281d0d6afba1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE">
<span id="_CPPv3N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE"></span><span id="_CPPv2N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a5ecf0d80da6b27cecb6c7417fdf7ad75"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE">
<span id="_CPPv3N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE"></span><span id="_CPPv2N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a76e57f23b9a701f60130fa2764e657d6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_INTERNAL_ERROR</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE">
<span id="_CPPv3N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE"></span><span id="_CPPv2N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE"></span><span class="target" id="group__error_1gga31e41ef222c0ea75b4c48f715b3cd9f0a20831372ebaf6e2b6f0a119d574ef064"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NVRTC_ERROR_TIME_FILE_WRITE_FAILED</span></span></span><a class="headerlink" href="index.html#_CPPv4N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE" title="Permalink to this definition"></a><br>
</dt>
<dd></dd>
</dl>

</dd>
</dl>

</section>
<section id="functions">
<h3>
<span class="section-number">3.1.2. </span>Functions<a class="headerlink" href="index.html#functions" title="Permalink to this headline"></a>
</h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419nvrtcGetErrorString11nvrtcResult">
<span id="_CPPv319nvrtcGetErrorString11nvrtcResult"></span><span id="_CPPv219nvrtcGetErrorString11nvrtcResult"></span><span id="nvrtcGetErrorString__nvrtcResult"></span><span class="target" id="group__error_1gace77107f185310fb006e7f9a722009e6"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetErrorString</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv419nvrtcGetErrorString11nvrtcResult" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to <code class="docutils literal notranslate"><span class="pre">"NVRTC_SUCCESS"</span></code>. </p>
<p>For unrecognized enumeration values, it returns <code class="docutils literal notranslate"><span class="pre">"NVRTC_ERROR</span> <span class="pre">unknown"</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<p><strong>result</strong> – <strong>[in]</strong> CUDA Runtime Compilation API result code. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p>Message string for the given <a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">nvrtcResult</span></a> code. </p>
</dd>
</dl>
</dd>
</dl>

</section>
</section>
<section id="general-information-query">
<h2>
<span class="section-number">3.2. </span>General Information Query<a class="headerlink" href="index.html#general-information-query" title="Permalink to this headline"></a>
</h2>
<p id="group__query">NVRTC defines the following function for general information query. </p>
<p class="rubric-h2 rubric">Functions</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d"><span class="std std-ref">nvrtcGetNumSupportedArchs</span></a>(int *numArchs)</dt>
<dd>
<p>nvrtcGetNumSupportedArchs sets the output parameter <code class="docutils literal notranslate"><span class="pre">numArchs</span></code> with the number of architectures supported by NVRTC.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a"><span class="std std-ref">nvrtcGetSupportedArchs</span></a>(int *supportedArchs)</dt>
<dd>
<p>nvrtcGetSupportedArchs populates the array passed via the output parameter <code class="docutils literal notranslate"><span class="pre">supportedArchs</span></code> with the architectures supported by NVRTC.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__query_1ga7492ae22a599fc3a7cd654915b91d790"><span class="std std-ref">nvrtcVersion</span></a>(int *major, int *minor)</dt>
<dd>
<p>nvrtcVersion sets the output parameters <code class="docutils literal notranslate"><span class="pre">major</span></code> and <code class="docutils literal notranslate"><span class="pre">minor</span></code> with the CUDA Runtime Compilation version number.</p>
</dd>
</dl>
</div>
<section id="id1">
<h3>
<span class="section-number">3.2.1. </span>Functions<a class="headerlink" href="index.html#id1" title="Permalink to this headline"></a>
</h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425nvrtcGetNumSupportedArchsPi">
<span id="_CPPv325nvrtcGetNumSupportedArchsPi"></span><span id="_CPPv225nvrtcGetNumSupportedArchsPi"></span><span id="nvrtcGetNumSupportedArchs__iP"></span><span class="target" id="group__query_1gad02fe42a81d969c0efbeb8e4ec78450d"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetNumSupportedArchs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numArchs</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv425nvrtcGetNumSupportedArchsPi" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetNumSupportedArchs sets the output parameter <code class="docutils literal notranslate"><span class="pre">numArchs</span></code> with the number of architectures supported by NVRTC. </p>
<p>This can then be used to pass an array to <a class="reference internal" href="index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a"><span class="std std-ref">nvrtcGetSupportedArchs</span></a> to get the supported architectures.</p>
<p>
see <a class="reference internal" href="index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a"><span class="std std-ref">nvrtcGetSupportedArchs</span></a> </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<p><strong>numArchs</strong> – <strong>[out]</strong> number of supported architectures. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422nvrtcGetSupportedArchsPi">
<span id="_CPPv322nvrtcGetSupportedArchsPi"></span><span id="_CPPv222nvrtcGetSupportedArchsPi"></span><span id="nvrtcGetSupportedArchs__iP"></span><span class="target" id="group__query_1ga04c729958964c5e7b889a644f086ad4a"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetSupportedArchs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">supportedArchs</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv422nvrtcGetSupportedArchsPi" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetSupportedArchs populates the array passed via the output parameter <code class="docutils literal notranslate"><span class="pre">supportedArchs</span></code> with the architectures supported by NVRTC. </p>
<p>The array is sorted in the ascending order. The size of the array to be passed can be determined using <a class="reference internal" href="index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d"><span class="std std-ref">nvrtcGetNumSupportedArchs</span></a>.</p>
<p>
see <a class="reference internal" href="index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d"><span class="std std-ref">nvrtcGetNumSupportedArchs</span></a> </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<p><strong>supportedArchs</strong> – <strong>[out]</strong> sorted array of supported architectures. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412nvrtcVersionPiPi">
<span id="_CPPv312nvrtcVersionPiPi"></span><span id="_CPPv212nvrtcVersionPiPi"></span><span id="nvrtcVersion__iP.iP"></span><span class="target" id="group__query_1ga7492ae22a599fc3a7cd654915b91d790"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcVersion</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">major</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">minor</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv412nvrtcVersionPiPi" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcVersion sets the output parameters <code class="docutils literal notranslate"><span class="pre">major</span></code> and <code class="docutils literal notranslate"><span class="pre">minor</span></code> with the CUDA Runtime Compilation version number. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>major</strong> – <strong>[out]</strong> CUDA Runtime Compilation major version number. </p></li>
<li><p><strong>minor</strong> – <strong>[out]</strong> CUDA Runtime Compilation minor version number. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a> </p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

</section>
</section>
<section id="compilation">
<h2>
<span class="section-number">3.3. </span>Compilation<a class="headerlink" href="index.html#compilation" title="Permalink to this headline"></a>
</h2>
<p id="group__compilation">NVRTC defines the following type and functions for actual compilation. </p>
<p class="rubric-h2 rubric">Functions</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga0b07e4173b28a10682f21edc7140844e"><span class="std std-ref">nvrtcAddNameExpression</span></a>(nvrtcProgram prog, const char *const name_expression)</dt>
<dd>
<p>nvrtcAddNameExpression notes the given name expression denoting the address of a <strong>global</strong> function or <strong>device</strong> /__constant__ variable.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga1f3136029db1413e362154b567297e8b"><span class="std std-ref">nvrtcCompileProgram</span></a>(nvrtcProgram prog, int numOptions, const char *const *options)</dt>
<dd>
<p>nvrtcCompileProgram compiles the given program.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458"><span class="std std-ref">nvrtcCreateProgram</span></a>(nvrtcProgram *prog, const char *src, const char *name, int numHeaders, const char *const *headers, const char *const *includeNames)</dt>
<dd>
<p>nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code> with it.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gaaa237c59615b7d4f48d5b308b5c9b140"><span class="std std-ref">nvrtcDestroyProgram</span></a>(nvrtcProgram *prog)</dt>
<dd>
<p>nvrtcDestroyProgram destroys the given program.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga4ecc086d17712082178a241941efcd41"><span class="std std-ref">nvrtcGetCUBIN</span></a>(nvrtcProgram prog, char *cubin)</dt>
<dd>
<p>nvrtcGetCUBIN stores the cubin generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">cubin</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gaea4745f354b8768f3e9777490d87adf0"><span class="std std-ref">nvrtcGetCUBINSize</span></a>(nvrtcProgram prog, size_t *cubinSizeRet)</dt>
<dd>
<p>nvrtcGetCUBINSize sets the value of <code class="docutils literal notranslate"><span class="pre">cubinSizeRet</span></code> with the size of the cubin generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gaf177b85a16bd879ba5d814e7afd5e2a0"><span class="std std-ref">nvrtcGetLTOIR</span></a>(nvrtcProgram prog, char *LTOIR)</dt>
<dd>
<p>nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">LTOIR</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gac2343fbb195dec6a0c10de30e35f2371"><span class="std std-ref">nvrtcGetLTOIRSize</span></a>(nvrtcProgram prog, size_t *LTOIRSizeRet)</dt>
<dd>
<p>nvrtcGetLTOIRSize sets the value of <code class="docutils literal notranslate"><span class="pre">LTOIRSizeRet</span></code> with the size of the LTO IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga2543158bd0e25649254a9d86a81e4f50"><span class="std std-ref">nvrtcGetLoweredName</span></a>(nvrtcProgram prog, const char *const name_expression, const char **lowered_name)</dt>
<dd>
<p>nvrtcGetLoweredName extracts the lowered (mangled) name for a <strong>global</strong> function or <strong>device</strong> /__constant__ variable, and updates *lowered_name to point to it.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga398a540d5b4eb38492af9d0468b0145b"><span class="std std-ref">nvrtcGetNVVM</span></a>(nvrtcProgram prog, char *nvvm)</dt>
<dd>
<p>DEPRECATION NOTICE: This function will be removed in a future release.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga97df8ee486fb49370c34e3a831eafcfb"><span class="std std-ref">nvrtcGetNVVMSize</span></a>(nvrtcProgram prog, size_t *nvvmSizeRet)</dt>
<dd>
<p>DEPRECATION NOTICE: This function will be removed in a future release.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga475c7f5a59f9c69a03541e496942ed19"><span class="std std-ref">nvrtcGetOptiXIR</span></a>(nvrtcProgram prog, char *optixir)</dt>
<dd>
<p>nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">optixir</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga4b9ff77cc01b3ec20e73606fa9d8dd1e"><span class="std std-ref">nvrtcGetOptiXIRSize</span></a>(nvrtcProgram prog, size_t *optixirSizeRet)</dt>
<dd>
<p>nvrtcGetOptiXIRSize sets the value of <code class="docutils literal notranslate"><span class="pre">optixirSizeRet</span></code> with the size of the OptiX IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gac9a66bbbd47c256f4a8955517b3965da"><span class="std std-ref">nvrtcGetPTX</span></a>(nvrtcProgram prog, char *ptx)</dt>
<dd>
<p>nvrtcGetPTX stores the PTX generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">ptx</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1gac622d6ffb6fff71e209407da19612c1a"><span class="std std-ref">nvrtcGetPTXSize</span></a>(nvrtcProgram prog, size_t *ptxSizeRet)</dt>
<dd>
<p>nvrtcGetPTXSize sets the value of <code class="docutils literal notranslate"><span class="pre">ptxSizeRet</span></code> with the size of the PTX generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ).</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga74c550e5cab81efbd59e4f72579edbd1"><span class="std std-ref">nvrtcGetProgramLog</span></a>(nvrtcProgram prog, char *log)</dt>
<dd>
<p>nvrtcGetProgramLog stores the log generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">log</span></code> .</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__compilation_1ga59944bb118095ab53eec8994d056a18d"><span class="std std-ref">nvrtcGetProgramLogSize</span></a>(nvrtcProgram prog, size_t *logSizeRet)</dt>
<dd>
<p>nvrtcGetProgramLogSize sets <code class="docutils literal notranslate"><span class="pre">logSizeRet</span></code> with the size of the log generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ).</p>
</dd>
</dl>
</div>
<p class="rubric-h2 rubric">Typedefs</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt><a class="reference internal" href="index.html#group__compilation_1gaa64ec636c8e3e1e8ea10028866c4594b"><span class="std std-ref">nvrtcProgram</span></a></dt>
<dd>
<p>nvrtcProgram is the unit of compilation, and an opaque handle for a program.</p>
</dd>
</dl>
</div>
<section id="id2">
<h3>
<span class="section-number">3.3.1. </span>Functions<a class="headerlink" href="index.html#id2" title="Permalink to this headline"></a>
</h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc">
<span id="_CPPv322nvrtcAddNameExpression12nvrtcProgramPCKc"></span><span id="_CPPv222nvrtcAddNameExpression12nvrtcProgramPCKc"></span><span id="nvrtcAddNameExpression__nvrtcProgram.cCPC"></span><span class="target" id="group__compilation_1ga0b07e4173b28a10682f21edc7140844e"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcAddNameExpression</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">name_expression</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcAddNameExpression notes the given name expression denoting the address of a <strong>global</strong> function or <strong>device</strong>/__constant__ variable. </p>
<p>The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name. </p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga2543158bd0e25649254a9d86a81e4f50"><span class="std std-ref">nvrtcGetLoweredName</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>name_expression</strong> – <strong>[in]</strong> constant expression denoting the address of a <strong>global</strong> function or <strong>device</strong>/__constant__ variable. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc">
<span id="_CPPv319nvrtcCompileProgram12nvrtcProgramiPPCKc"></span><span id="_CPPv219nvrtcCompileProgram12nvrtcProgramiPPCKc"></span><span id="nvrtcCompileProgram__nvrtcProgram.i.cCPCP"></span><span class="target" id="group__compilation_1ga1f3136029db1413e362154b567297e8b"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcCompileProgram</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numOptions</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcCompileProgram compiles the given program. </p>
<p>
It supports compile options listed in <a class="reference internal" href="index.html#group__options"><span class="std std-ref">Supported Compile Options</span></a>. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>numOptions</strong> – <strong>[in]</strong> Number of compiler options passed. </p></li>
<li><p><strong>options</strong> – <strong>[in]</strong> Compiler options in the form of C string array.<code class="docutils literal notranslate"><span class="pre">options</span></code> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when <code class="docutils literal notranslate"><span class="pre">numOptions</span></code> is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_OUT_OF_MEMORY </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_OPTION </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_COMPILATION </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_BUILTIN_OPERATION_FAILURE </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_TIME_FILE_WRITE_FAILED </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc">
<span id="_CPPv318nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc"></span><span id="_CPPv218nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc"></span><span id="nvrtcCreateProgram__nvrtcProgramP.cCP.cCP.i.cCPCP.cCPCP"></span><span class="target" id="group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcCreateProgram</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">src</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numHeaders</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">headers</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">includeNames</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code> with it. </p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gaaa237c59615b7d4f48d5b308b5c9b140"><span class="std std-ref">nvrtcDestroyProgram</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[out]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>src</strong> – <strong>[in]</strong> CUDA program source. </p></li>
<li><p><strong>name</strong> – <strong>[in]</strong> CUDA program name.<code class="docutils literal notranslate"><span class="pre">name</span></code> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>; <code class="docutils literal notranslate"><span class="pre">"default_program"</span></code> is used when <code class="docutils literal notranslate"><span class="pre">name</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or “”. </p></li>
<li><p><strong>numHeaders</strong> – <strong>[in]</strong> Number of headers used.<code class="docutils literal notranslate"><span class="pre">numHeaders</span></code> must be greater than or equal to 0. </p></li>
<li><p><strong>headers</strong> – <strong>[in]</strong> Sources of the headers.<code class="docutils literal notranslate"><span class="pre">headers</span></code> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when <code class="docutils literal notranslate"><span class="pre">numHeaders</span></code> is 0. </p></li>
<li><p><strong>includeNames</strong> – <strong>[in]</strong> Name of each header by which they can be included in the CUDA program source.<code class="docutils literal notranslate"><span class="pre">includeNames</span></code> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when <code class="docutils literal notranslate"><span class="pre">numHeaders</span></code> is 0. These headers must be included with the exact names specified here. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_OUT_OF_MEMORY </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_PROGRAM_CREATION_FAILURE </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419nvrtcDestroyProgramP12nvrtcProgram">
<span id="_CPPv319nvrtcDestroyProgramP12nvrtcProgram"></span><span id="_CPPv219nvrtcDestroyProgramP12nvrtcProgram"></span><span id="nvrtcDestroyProgram__nvrtcProgramP"></span><span class="target" id="group__compilation_1gaaa237c59615b7d4f48d5b308b5c9b140"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcDestroyProgram</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">prog</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv419nvrtcDestroyProgramP12nvrtcProgram" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcDestroyProgram destroys the given program. </p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458"><span class="std std-ref">nvrtcCreateProgram</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413nvrtcGetCUBIN12nvrtcProgramPc">
<span id="_CPPv313nvrtcGetCUBIN12nvrtcProgramPc"></span><span id="_CPPv213nvrtcGetCUBIN12nvrtcProgramPc"></span><span id="nvrtcGetCUBIN__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1ga4ecc086d17712082178a241941efcd41"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetCUBIN</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cubin</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv413nvrtcGetCUBIN12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetCUBIN stores the cubin generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">cubin</span></code>. </p>
<p>No cubin is available if the value specified to <code class="docutils literal notranslate"><span class="pre">-arch</span></code> is a virtual architecture instead of an actual architecture.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gaea4745f354b8768f3e9777490d87adf0"><span class="std std-ref">nvrtcGetCUBINSize</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>cubin</strong> – <strong>[out]</strong> Compiled and assembled result. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t">
<span id="_CPPv317nvrtcGetCUBINSize12nvrtcProgramP6size_t"></span><span id="_CPPv217nvrtcGetCUBINSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetCUBINSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1gaea4745f354b8768f3e9777490d87adf0"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetCUBINSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cubinSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetCUBINSize sets the value of <code class="docutils literal notranslate"><span class="pre">cubinSizeRet</span></code> with the size of the cubin generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code>. </p>
<p>The value of cubinSizeRet is set to 0 if the value specified to <code class="docutils literal notranslate"><span class="pre">-arch</span></code> is a virtual architecture instead of an actual architecture.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga4ecc086d17712082178a241941efcd41"><span class="std std-ref">nvrtcGetCUBIN</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>cubinSizeRet</strong> – <strong>[out]</strong> Size of the generated cubin. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413nvrtcGetLTOIR12nvrtcProgramPc">
<span id="_CPPv313nvrtcGetLTOIR12nvrtcProgramPc"></span><span id="_CPPv213nvrtcGetLTOIR12nvrtcProgramPc"></span><span id="nvrtcGetLTOIR__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1gaf177b85a16bd879ba5d814e7afd5e2a0"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetLTOIR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">LTOIR</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv413nvrtcGetLTOIR12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">LTOIR</span></code>. </p>
<p>No LTO IR is available if the program was compiled without <code class="docutils literal notranslate"><span class="pre">-dlto</span></code>.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gac2343fbb195dec6a0c10de30e35f2371"><span class="std std-ref">nvrtcGetLTOIRSize</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>LTOIR</strong> – <strong>[out]</strong> Compiled result. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t">
<span id="_CPPv317nvrtcGetLTOIRSize12nvrtcProgramP6size_t"></span><span id="_CPPv217nvrtcGetLTOIRSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetLTOIRSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1gac2343fbb195dec6a0c10de30e35f2371"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetLTOIRSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">LTOIRSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetLTOIRSize sets the value of <code class="docutils literal notranslate"><span class="pre">LTOIRSizeRet</span></code> with the size of the LTO IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code>. </p>
<p>The value of LTOIRSizeRet is set to 0 if the program was not compiled with <code class="docutils literal notranslate"><span class="pre">-dlto</span></code>.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gaf177b85a16bd879ba5d814e7afd5e2a0"><span class="std std-ref">nvrtcGetLTOIR</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>LTOIRSizeRet</strong> – <strong>[out]</strong> Size of the generated LTO IR. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc">
<span id="_CPPv319nvrtcGetLoweredName12nvrtcProgramPCKcPPKc"></span><span id="_CPPv219nvrtcGetLoweredName12nvrtcProgramPCKcPPKc"></span><span id="nvrtcGetLoweredName__nvrtcProgram.cCPC.cCPP"></span><span class="target" id="group__compilation_1ga2543158bd0e25649254a9d86a81e4f50"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetLoweredName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">name_expression</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">lowered_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetLoweredName extracts the lowered (mangled) name for a <strong>global</strong> function or <strong>device</strong>/__constant__ variable, and updates *lowered_name to point to it. </p>
<p>The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga0b07e4173b28a10682f21edc7140844e"><span class="std std-ref">nvrtcAddNameExpression</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>name_expression</strong> – <strong>[in]</strong> constant expression denoting the address of a <strong>global</strong> function or <strong>device</strong>/__constant__ variable. </p></li>
<li><p><strong>lowered_name</strong> – <strong>[out]</strong> initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412nvrtcGetNVVM12nvrtcProgramPc">
<span id="_CPPv312nvrtcGetNVVM12nvrtcProgramPc"></span><span id="_CPPv212nvrtcGetNVVM12nvrtcProgramPc"></span><span id="nvrtcGetNVVM__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1ga398a540d5b4eb38492af9d0468b0145b"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetNVVM</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nvvm</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv412nvrtcGetNVVM12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>
 DEPRECATION NOTICE: This function will be removed in a future release. </p>
<p>Please use nvrtcGetLTOIR (and nvrtcGetLTOIRSize) instead. </p>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t">
<span id="_CPPv316nvrtcGetNVVMSize12nvrtcProgramP6size_t"></span><span id="_CPPv216nvrtcGetNVVMSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetNVVMSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1ga97df8ee486fb49370c34e3a831eafcfb"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetNVVMSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nvvmSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>
 DEPRECATION NOTICE: This function will be removed in a future release. </p>
<p>Please use nvrtcGetLTOIRSize (and nvrtcGetLTOIR) instead. </p>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc">
<span id="_CPPv315nvrtcGetOptiXIR12nvrtcProgramPc"></span><span id="_CPPv215nvrtcGetOptiXIR12nvrtcProgramPc"></span><span id="nvrtcGetOptiXIR__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1ga475c7f5a59f9c69a03541e496942ed19"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetOptiXIR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optixir</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">optixir</span></code>. </p>
<p>No OptiX IR is available if the program was compiled with options incompatible with OptiX IR generation.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga4b9ff77cc01b3ec20e73606fa9d8dd1e"><span class="std std-ref">nvrtcGetOptiXIRSize</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>Optix</strong> – <strong>[out]</strong> IR Compiled result. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t">
<span id="_CPPv319nvrtcGetOptiXIRSize12nvrtcProgramP6size_t"></span><span id="_CPPv219nvrtcGetOptiXIRSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetOptiXIRSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1ga4b9ff77cc01b3ec20e73606fa9d8dd1e"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetOptiXIRSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optixirSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetOptiXIRSize sets the value of <code class="docutils literal notranslate"><span class="pre">optixirSizeRet</span></code> with the size of the OptiX IR generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code>. </p>
<p>The value of nvrtcGetOptiXIRSize is set to 0 if the program was compiled with options incompatible with OptiX IR generation.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga475c7f5a59f9c69a03541e496942ed19"><span class="std std-ref">nvrtcGetOptiXIR</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>optixirSizeRet</strong> – <strong>[out]</strong> Size of the generated LTO IR. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411nvrtcGetPTX12nvrtcProgramPc">
<span id="_CPPv311nvrtcGetPTX12nvrtcProgramPc"></span><span id="_CPPv211nvrtcGetPTX12nvrtcProgramPc"></span><span id="nvrtcGetPTX__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1gac9a66bbbd47c256f4a8955517b3965da"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetPTX</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ptx</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv411nvrtcGetPTX12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetPTX stores the PTX generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">ptx</span></code>. </p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gac622d6ffb6fff71e209407da19612c1a"><span class="std std-ref">nvrtcGetPTXSize</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>ptx</strong> – <strong>[out]</strong> Compiled result. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t">
<span id="_CPPv315nvrtcGetPTXSize12nvrtcProgramP6size_t"></span><span id="_CPPv215nvrtcGetPTXSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetPTXSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1gac622d6ffb6fff71e209407da19612c1a"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetPTXSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ptxSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetPTXSize sets the value of <code class="docutils literal notranslate"><span class="pre">ptxSizeRet</span></code> with the size of the PTX generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). </p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1gac9a66bbbd47c256f4a8955517b3965da"><span class="std std-ref">nvrtcGetPTX</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>ptxSizeRet</strong> – <strong>[out]</strong> Size of the generated PTX (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418nvrtcGetProgramLog12nvrtcProgramPc">
<span id="_CPPv318nvrtcGetProgramLog12nvrtcProgramPc"></span><span id="_CPPv218nvrtcGetProgramLog12nvrtcProgramPc"></span><span id="nvrtcGetProgramLog__nvrtcProgram.cP"></span><span class="target" id="group__compilation_1ga74c550e5cab81efbd59e4f72579edbd1"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetProgramLog</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">log</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv418nvrtcGetProgramLog12nvrtcProgramPc" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetProgramLog stores the log generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> in the memory pointed by <code class="docutils literal notranslate"><span class="pre">log</span></code>. </p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga59944bb118095ab53eec8994d056a18d"><span class="std std-ref">nvrtcGetProgramLogSize</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>log</strong> – <strong>[out]</strong> Compilation log. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t">
<span id="_CPPv322nvrtcGetProgramLogSize12nvrtcProgramP6size_t"></span><span id="_CPPv222nvrtcGetProgramLogSize12nvrtcProgramP6size_t"></span><span id="nvrtcGetProgramLogSize__nvrtcProgram.sP"></span><span class="target" id="group__compilation_1ga59944bb118095ab53eec8994d056a18d"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetProgramLogSize</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="index.html#_CPPv412nvrtcProgram" title="nvrtcProgram"><span class="n"><span class="pre">nvrtcProgram</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">prog</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">logSizeRet</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetProgramLogSize sets <code class="docutils literal notranslate"><span class="pre">logSizeRet</span></code> with the size of the log generated by the previous compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). </p>
<p>Note that compilation log may be generated with warnings and informative messages, even when the compilation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> succeeds.</p>
<p></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="index.html#group__compilation_1ga74c550e5cab81efbd59e4f72579edbd1"><span class="std std-ref">nvrtcGetProgramLog</span></a> </p>
</div>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>prog</strong> – <strong>[in]</strong> CUDA Runtime Compilation program. </p></li>
<li><p><strong>logSizeRet</strong> – <strong>[out]</strong> Size of the compilation log (including the trailing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_INPUT </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INVALID_PROGRAM </span></a></p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

</section>
<section id="typedefs">
<h3>
<span class="section-number">3.3.2. </span>Typedefs<a class="headerlink" href="index.html#typedefs" title="Permalink to this headline"></a>
</h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412nvrtcProgram">
<span id="_CPPv312nvrtcProgram"></span><span id="_CPPv212nvrtcProgram"></span><span id="nvrtcProgram"></span><span class="target" id="group__compilation_1gaa64ec636c8e3e1e8ea10028866c4594b"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">_nvrtcProgram</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcProgram</span></span></span><a class="headerlink" href="index.html#_CPPv412nvrtcProgram" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcProgram is the unit of compilation, and an opaque handle for a program. </p>
<p>To compile a CUDA program string, an instance of nvrtcProgram must be created first with <a class="reference internal" href="index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458"><span class="std std-ref">nvrtcCreateProgram</span></a>, then compiled with <a class="reference internal" href="index.html#group__compilation_1ga1f3136029db1413e362154b567297e8b"><span class="std std-ref">nvrtcCompileProgram</span></a>. </p>
</dd>
</dl>

</section>
</section>
<section id="supported-compile-options">
<h2>
<span class="section-number">3.4. </span>Supported Compile Options<a class="headerlink" href="index.html#supported-compile-options" title="Permalink to this headline"></a>
</h2>
<p id="group__options">NVRTC supports the compile options below. </p>
<p>Option names with two preceding dashs (<code class="docutils literal notranslate"><span class="pre">--</span></code>) are long option names and option names with one preceding dash (<code class="docutils literal notranslate"><span class="pre">-</span></code>) are short option names. Short option names can be used instead of long option names. When a compile option takes an argument, an assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>) is used to separate the compile option argument from the compile option name, e.g., <code class="docutils literal notranslate"><span class="pre">"--gpu-architecture=compute_60"</span></code>. Alternatively, the compile option name and the argument can be specified in separate strings without an assignment operator, .e.g, <code class="docutils literal notranslate"><span class="pre">"--gpu-architecture"</span></code> <code class="docutils literal notranslate"><span class="pre">"compute_60"</span></code>. Single-character short option names, such as <code class="docutils literal notranslate"><span class="pre">-D</span></code>, <code class="docutils literal notranslate"><span class="pre">-U</span></code>, and <code class="docutils literal notranslate"><span class="pre">-I</span></code>, do not require an assignment operator, and the compile option name and the argument can be present in the same string with or without spaces between them. For instance, <code class="docutils literal notranslate"><span class="pre">"-D=&lt;def&gt;"</span></code>, <code class="docutils literal notranslate"><span class="pre">"-D&lt;def&gt;"</span></code>, and <code class="docutils literal notranslate"><span class="pre">"-D</span> <span class="pre">&lt;def&gt;"</span></code> are all supported.</p>
<p>The valid compiler options are:</p>
<p></p>
<ul class="simple">
<li>
<p>Compilation targets</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--gpu-architecture=&lt;arch&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-arch</span></code></p>
<p>)</p>
<p>Specify the name of the class of GPU architectures for which the input must be compiled.</p>
<ul>
<li>
<p>Valid <code class="docutils literal notranslate"><span class="pre">&lt;arch&gt;</span></code>s:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_50</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_52</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_53</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_60</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_61</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_62</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_70</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_72</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_75</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_80</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_87</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_89</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_90</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_90a</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_50</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_52</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_53</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_60</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_61</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_62</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_70</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_72</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_75</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_80</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_87</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_89</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_90</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sm_90a</span></code> </p></li>
</ul>
</li>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">compute_52</span></code> </p></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Separate compilation / whole-program compilation</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-c</span></code> (<code class="docutils literal notranslate"><span class="pre">-dc</span></code></p>
<p>)</p>
<p>Generate relocatable code that can be linked with other relocatable device code. It is equivalent to</p>
&amp;#8212;relocatable-device-code=true.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-w</span></code> (<code class="docutils literal notranslate"><span class="pre">-dw</span></code></p>
<p>)</p>
<p>Generate non-relocatable code. It is equivalent to</p>
<code class="docutils literal notranslate"><span class="pre">--relocatable-device-code=false</span></code>.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--relocatable-device-code={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-rdc</span></code></p>
<p>)</p>
<p>Enable (disable) the generation of relocatable device code.</p>
<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">false</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--extensible-whole-program</span></code> (<code class="docutils literal notranslate"><span class="pre">-ewp</span></code></p>
<p>)</p>
<p>Do extensible whole program compilation of device code.</p>
<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">false</span></code> </p></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Debugging support</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-debug</span></code> (<code class="docutils literal notranslate"><span class="pre">-G</span></code></p>
<p>)</p>
<p>Generate debug information. If</p>
&amp;#8212;dopt is not specified, then turns off all optimizations.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--generate-line-info</span></code> (<code class="docutils literal notranslate"><span class="pre">-lineinfo</span></code></p>
<p>)</p>
<p>Generate line-number information.</p>
</li>
</ul>
</li>
<li>
<p>Code generation</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">--dopt</span></code> on (<code class="docutils literal notranslate"><span class="pre">-dopt</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--dopt=on</span></code> 
 Enable device code optimization. When specified along with ‘-G’, enables limited debug information generation for optimized device code (currently, only line number information). When ‘-G’ is not specified, ‘-dopt=on’ is implicit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--ptxas-options</span></code> &lt;options&gt; (<code class="docutils literal notranslate"><span class="pre">-Xptxas</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--ptxas-options=&lt;options&gt;</span></code> 
 Specify options directly to ptxas, the PTX optimizing assembler.</p></li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--maxrregcount=&lt;N&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-maxrregcount</span></code></p>
<p>)</p>
<p>Specify the maximum amount of registers that GPU functions can use. Until a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good maxrregcount value is the result of a trade-off. If this option is not specified, then no maximum is assumed. Value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--ftz={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-ftz</span></code></p>
<p>)</p>
<p>When performing single-precision floating-point operations, flush denormal values to zero or preserve denormal values.</p>
<code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> implies <code class="docutils literal notranslate"><span class="pre">--ftz=true</span></code>.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">false</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--prec-sqrt={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-prec-sqrt</span></code></p>
<p>)</p>
<p>For single-precision floating-point square root, use IEEE round-to-nearest mode or use a faster approximation.</p>
<code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> implies <code class="docutils literal notranslate"><span class="pre">--prec-sqrt=false</span></code>.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--prec-div={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-prec-div</span></code></p>
<p>)</p>
<p>For single-precision floating-point division and reciprocals, use IEEE round-to-nearest mode or use a faster approximation.</p>
<code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> implies <code class="docutils literal notranslate"><span class="pre">--prec-div=false</span></code>.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--fmad={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-fmad</span></code></p>
<p>)</p>
<p>Enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).</p>
<code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> implies <code class="docutils literal notranslate"><span class="pre">--fmad=true</span></code>.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> (<code class="docutils literal notranslate"><span class="pre">-use_fast_math</span></code></p>
<p>)</p>
<p>Make use of fast math operations.</p>
<code class="docutils literal notranslate"><span class="pre">--use_fast_math</span></code> implies <code class="docutils literal notranslate"><span class="pre">--ftz=true</span></code> <code class="docutils literal notranslate"><span class="pre">--prec-div=false</span></code> <code class="docutils literal notranslate"><span class="pre">--prec-sqrt=false</span></code> <code class="docutils literal notranslate"><span class="pre">--fmad=true</span></code>.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--extra-device-vectorization</span></code> (<code class="docutils literal notranslate"><span class="pre">-extra-device-vectorization</span></code></p>
<p>)</p>
<p>Enables more aggressive device code vectorization in the NVVM optimizer.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--modify-stack-limit={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-modify-stack-limit</span></code></p>
<p>)</p>
<p>On Linux, during compilation, use</p>
<code class="docutils literal notranslate"><span class="pre">setrlimit()</span></code> to increase stack size to maximum allowed. The limit is reset to the previous value at the end of compilation. Note: <code class="docutils literal notranslate"><span class="pre">setrlimit()</span></code> changes the value for the entire process.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--dlink-time-opt</span></code> (<code class="docutils literal notranslate"><span class="pre">-dlto</span></code></p>
<p>)</p>
<p>Generate intermediate code for later link-time optimization. It implies</p>
<code class="docutils literal notranslate"><span class="pre">-rdc=true</span></code>. Note: when this option is used the nvrtcGetLTOIR API should be used, as PTX or Cubin will not be generated.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--gen-opt-lto</span></code> (<code class="docutils literal notranslate"><span class="pre">-gen-opt-lto</span></code></p>
<p>)</p>
<p>Run the optimizer passes before generating the LTO IR.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--optix-ir</span></code> (<code class="docutils literal notranslate"><span class="pre">-optix-ir</span></code></p>
<p>)</p>
<p>Generate OptiX IR. The Optix IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization (</p>
<code class="docutils literal notranslate"><span class="pre">-dlto</span></code><p>)</p>
<p>. Note: when this option is used the nvrtcGetOptiX API should be used, as PTX or Cubin will not be generated.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--jump-table-density=</span></code>[0-101] (<code class="docutils literal notranslate"><span class="pre">-jtd</span></code></p>
<p>)</p>
<p>Specify the case density percentage in switch statements, and use it as a minimal threshold to determine whether jump table(brx.idx instruction) will be used to implement a switch statement. Default value is 101. The percentage ranges from 0 to 101 inclusively.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-stack-protector={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-device-stack-protector</span></code></p>
<p>)</p>
<p>Enable (disable) the generation of stack canaries in device code.</p>
<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">false</span></code> </p></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Preprocessing</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--define-macro=&lt;def&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-D</span></code>)<code class="docutils literal notranslate"><span class="pre">&lt;def&gt;</span></code> can be either <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;name=definitions&gt;</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> 
 Predefine <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> as a macro with definition <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;name&gt;=&lt;definition&gt;</span></code> 
 The contents of <code class="docutils literal notranslate"><span class="pre">&lt;definition&gt;</span></code> are tokenized and preprocessed as if they appeared during translation phase three in a <code class="docutils literal notranslate"><span class="pre">#define</span></code> directive. In particular, the definition will be truncated by embedded new line characters.</p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--undefine-macro=&lt;def&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-U</span></code></p>
<p>)</p>
<p>Cancel any previous definition of</p>
<code class="docutils literal notranslate"><span class="pre">&lt;def&gt;</span></code>.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--include-path=&lt;dir&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-I</span></code></p>
<p>)</p>
<p>Add the directory</p>
<code class="docutils literal notranslate"><span class="pre">&lt;dir&gt;</span></code> to the list of directories to be searched for headers. These paths are searched after the list of headers given to <a class="reference internal" href="index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458"><span class="std std-ref">nvrtcCreateProgram</span></a>.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--pre-include=&lt;header&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-include</span></code></p>
<p>)</p>
<p>Preinclude</p>
<code class="docutils literal notranslate"><span class="pre">&lt;header&gt;</span></code> during preprocessing.</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--no-source-include</span></code> (<code class="docutils literal notranslate"><span class="pre">-no-source-include</span></code>) The preprocessor by default adds the directory of each input sources to the include path. This option disables this feature and only considers the path specified explicitly.</p></li>
</ul>
</li>
<li>
<p>Language Dialect</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--std={c++03|c++11|c++14|c++17|c++20}</span></code> (<code class="docutils literal notranslate"><span class="pre">-std={c++11|c++14|c++17|c++20}</span></code></p>
<p>)</p>
<p>Set language dialect to C++03, C++11, C++14, C++17 or C++20</p>
<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">c++17</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--builtin-move-forward={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-builtin-move-forward</span></code></p>
<p>)</p>
<p>Provide builtin definitions of</p>
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> and <code class="docutils literal notranslate"><span class="pre">std::forward</span></code>, when C++11 or later language dialect is selected.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--builtin-initializer-list={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-builtin-initializer-list</span></code></p>
<p>)</p>
<p>Provide builtin definitions of</p>
<code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> class and member functions when C++11 or later language dialect is selected.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">true</span></code> </p></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Misc.</p>
<ul>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--disable-warnings</span></code> (<code class="docutils literal notranslate"><span class="pre">-w</span></code></p>
<p>)</p>
<p>Inhibit all warning messages.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--restrict</span></code> (<code class="docutils literal notranslate"><span class="pre">-restrict</span></code></p>
<p>)</p>
<p>Programmer assertion that all kernel pointer parameters are restrict pointers.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-as-default-execution-space</span></code> (<code class="docutils literal notranslate"><span class="pre">-default-device</span></code></p>
<p>)</p>
<p>Treat entities with no execution space annotation as</p>
<code class="docutils literal notranslate"><span class="pre">__device__</span></code> entities.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-int128</span></code> (<code class="docutils literal notranslate"><span class="pre">-device-int128</span></code></p>
<p>)</p>
<p>Allow the</p>
<code class="docutils literal notranslate"><span class="pre">__int128</span></code> type in device code. Also causes the macro <code class="docutils literal notranslate"><span class="pre">__CUDACC_RTC_INT128__</span></code> to be defined.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--optimization-info=&lt;kind&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-opt-info</span></code></p>
<p>)</p>
<p>Provide optimization reports for the specified kind of optimization. The following kind tags are supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inline</span></code> : emit a remark when a function is inlined.</p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--display-error-number</span></code> (<code class="docutils literal notranslate"><span class="pre">-err-no</span></code></p>
<p>)</p>
<p>Display diagnostic number for warning messages. (Default)</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--no-display-error-number</span></code> (<code class="docutils literal notranslate"><span class="pre">-no-err-no</span></code></p>
<p>)</p>
<p>Disables the display of a diagnostic number for warning messages.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--diag-error=&lt;error-number&gt;</span></code>,… (<code class="docutils literal notranslate"><span class="pre">-diag-error</span></code></p>
<p>)</p>
<p>Emit error for specified diagnostic message number(s). Message numbers can be separated by comma.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--diag-suppress=&lt;error-number&gt;</span></code>,… (<code class="docutils literal notranslate"><span class="pre">-diag-suppress</span></code></p>
<p>)</p>
<p>Suppress specified diagnostic message number(s). Message numbers can be separated by comma.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--diag-warn=&lt;error-number&gt;</span></code>,… (<code class="docutils literal notranslate"><span class="pre">-diag-warn</span></code></p>
<p>)</p>
<p>Emit warning for specified diagnostic message number(s). Message numbers can be separated by comma.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--brief-diagnostics={true|false}</span></code> (<code class="docutils literal notranslate"><span class="pre">-brief-diag</span></code></p>
<p>)</p>
<p>This option disables or enables showing source line and column info in a diagnostic. The</p>
&amp;#8212;brief-diagnostics=true will not show the source line and column info.<ul>
<li><p>Default: <code class="docutils literal notranslate"><span class="pre">false</span></code> </p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--time=&lt;file-name&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">-time</span></code></p>
<p>)</p>
<p>Generate a comma separated value table with the time taken by each compilation phase, and append it at the end of the file given as the option argument. If the file does not exist, the column headings are generated in the first row of the table. If the file name is ‘-’, the timing data is written to the compilation log.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--split-compile=</span></code> &lt;number of threads&gt; (<code class="docutils literal notranslate"><span class="pre">-split-compile=</span></code></p>
<p>&lt;number of threads&gt;)</p>
<p>Perform compiler optimizations in parallel. Split compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. This option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting</p>
&amp;#8212;split-compile=0. Setting &amp;#8212;split-compile=1 will cause this option to be ignored.</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--fdevice-syntax-only</span></code> (<code class="docutils literal notranslate"><span class="pre">-fdevice-syntax-only</span></code></p>
<p>)</p>
<p>Ends device compilation after front-end syntax checking. This option does not generate valid device code.</p>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--minimal</span></code> (<code class="docutils literal notranslate"><span class="pre">-minimal</span></code></p>
<p>)</p>
<p>Omit certain language features to reduce compile time for small programs. In particular, the following are omitted:</p>
<ul>
<li><p>Texture and surface functions and associated types, e.g., <code class="docutils literal notranslate"><span class="pre">cudaTextureObject_t</span></code>.</p></li>
<li><p>CUDA Runtime Functions that are provided by the cudadevrt device code library, typically named with prefix “cuda”, e.g., <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code>.</p></li>
<li><p>Kernel launch from device code.</p></li>
<li><p>Types and macros associated with CUDA Runtime and Driver APIs, provided by cuda/tools/cudart/driver_types.h, typically named with prefix “cuda”, e.g., <code class="docutils literal notranslate"><span class="pre">cudaError_t</span></code>.</p></li>
</ul>
</li>
<li>
<p><code class="docutils literal notranslate"><span class="pre">--device-stack-protector</span></code> (<code class="docutils literal notranslate"><span class="pre">-device-stack-protector</span></code></p>
<p>)</p>
<p>Enable stack canaries in device code. Stack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables. The compiler uses heuristics to assess the risk of such a bug in each function. Only those functions which are deemed high-risk make use of a stack canary.</p>
</li>
</ul>
</li>
</ul>

</section>
<section id="host-helper">
<h2>
<span class="section-number">3.5. </span>Host Helper<a class="headerlink" href="index.html#host-helper" title="Permalink to this headline"></a>
</h2>
<p id="group__hosthelper">NVRTC defines the following functions for easier interaction with host code. </p>
<p class="rubric-h2 rubric">Functions</p>
<div class="dl-as-table docutils container">
<dl class="simple">
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7"><span class="std std-ref">nvrtcGetTypeName</span></a>(const std::type_info &amp;tinfo, std::string *result)</dt>
<dd>
<p>nvrtcGetTypeName stores the source level name of a type in the given std::string location.</p>
</dd>
<dt>
<span class="tag-as-table-cell">nvrtcResult</span> <a class="reference internal" href="index.html#group__hosthelper_1ga793010cbd3f789a26ca956fd463d73cb"><span class="std std-ref">nvrtcGetTypeName</span></a>(std::string *result)</dt>
<dd>
<p>nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location.</p>
</dd>
</dl>
</div>
<section id="id3">
<h3>
<span class="section-number">3.5.1. </span>Functions<a class="headerlink" href="index.html#id3" title="Permalink to this headline"></a>
</h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE">
<span id="_CPPv316nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE"></span><span id="_CPPv216nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE"></span><span id="nvrtcGetTypeName__std::type_infoCR.ssP"></span><span class="target" id="group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetTypeName</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">type_info</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">tinfo</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetTypeName stores the source level name of a type in the given std::string location. </p>
<p>This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name.</p>
<p>Windows-specific notes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7"><span class="std std-ref">nvrtcGetTypeName()</span></a> is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe.</p></li>
<li><p>The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl.</p></li>
</ul>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<ul class="simple">
<li><p><strong>tinfo</strong> – <strong>[in]</strong> reference to object of type std::type_info for a given type. </p></li>
<li><p><strong>result</strong> – <strong>[in]</strong> pointer to std::string in which to store the type name. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INTERNAL_ERROR </span></a> </p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE">
<span id="_CPPv3I0E16nvrtcGetTypeNamePNSt6stringE"></span><span id="_CPPv2I0E16nvrtcGetTypeNamePNSt6stringE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br><span class="target" id="group__hosthelper_1ga793010cbd3f789a26ca956fd463d73cb"></span><a class="reference internal" href="index.html#_CPPv411nvrtcResult" title="nvrtcResult"><span class="n"><span class="pre">nvrtcResult</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nvrtcGetTypeName</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="index.html#_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE" title="Permalink to this definition"></a><br>
</dt>
<dd>
<p>nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location. </p>
<p>This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name.</p>
<p>Windows-specific notes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7"><span class="std std-ref">nvrtcGetTypeName()</span></a> is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe.</p></li>
<li><p>The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl.</p></li>
</ul>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd">
<p><strong>result</strong> – <strong>[in]</strong> pointer to std::string in which to store the type name. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even">
<p></p>
<ul class="simple">
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_SUCCESS </span></a></p></li>
<li><p><a class="reference internal" href="index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0"><span class="std std-ref">NVRTC_ERROR_INTERNAL_ERROR </span></a> </p></li>
</ul>

</dd>
</dl>
</dd>
</dl>

</section>
</section>
</section>
<section id="language">
<h1>
<span class="section-number">4. </span>Language<a class="headerlink" href="index.html#language" title="Permalink to this headline"></a>
</h1>
<p>Unlike the offline nvcc compiler, NVRTC is meant for compiling only device CUDA C++ code. It does not accept host code or host compiler extensions in the input code, unless otherwise noted.</p>
<section id="execution-space">
<h2>
<span class="section-number">4.1. </span>Execution Space<a class="headerlink" href="index.html#execution-space" title="Permalink to this headline"></a>
</h2>
<p>NVRTC uses <code class="docutils literal notranslate"><span class="pre">__host__</span></code> as the default execution space, and it generates an error if it encounters any host code in the input. That is, if the input contains entities with explicit <code class="docutils literal notranslate"><span class="pre">__host__</span></code> annotations or no execution space annotation, NVRTC will emit an error. <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> functions are treated as device functions.</p>
<p>NVRTC provides a compile option, <code class="docutils literal notranslate"><span class="pre">--device-as-default-execution-space</span></code> (refer to <a class="reference internal" href="index.html#supported-compile-options">Supported Compile Options</a>), that enables an alternative compilation mode, in which entities with no execution space annotations are treated as <code class="docutils literal notranslate"><span class="pre">__device__</span> <span class="pre">entities</span></code>.</p>
</section>
<section id="separate-compilation">
<h2>
<span class="section-number">4.2. </span>Separate Compilation<a class="headerlink" href="index.html#separate-compilation" title="Permalink to this headline"></a>
</h2>
<p>NVRTC itself does not provide any linker. Users can, however, use the nvJitLink library or <code class="docutils literal notranslate"><span class="pre">cuLinkAddData</span></code> in the CUDA Driver API to link the generated relocatable PTX code with other relocatable code. To generate relocatable PTX code, the compile option <code class="docutils literal notranslate"><span class="pre">--relocatable-device-code=true</span></code> or <code class="docutils literal notranslate"><span class="pre">--device-c</span></code> is required.</p>
</section>
<section id="dynamic-parallelism">
<h2>
<span class="section-number">4.3. </span>Dynamic Parallelism<a class="headerlink" href="index.html#dynamic-parallelism" title="Permalink to this headline"></a>
</h2>
<p>NVRTC supports dynamic parallelism under the following conditions:</p>
<ul class="simple">
<li><p>Compilation target must be compute 35 or higher.</p></li>
<li><p>Either separate compilation (<code class="docutils literal notranslate"><span class="pre">--relocatable-device-code=true</span></code> or <code class="docutils literal notranslate"><span class="pre">--device-c</span></code>) or extensible whole program compilation (<code class="docutils literal notranslate"><span class="pre">--extensible-whole-program</span></code>) must be enabled.</p></li>
<li><p>Generated PTX must be linked against the CUDA device runtime (cudadevrt) library (refer to <a class="reference internal" href="index.html#separate-compilation">Separate Compilation</a>).</p></li>
</ul>
<p>Example: <a class="reference internal" href="index.html#dynamic-parallelism">Dynamic Parallelism</a> provides a simple example.</p>
</section>
<section id="integer-size">
<h2>
<span class="section-number">4.4. </span>Integer Size<a class="headerlink" href="index.html#integer-size" title="Permalink to this headline"></a>
</h2>
<p>Different operating systems define integer type sizes differently.
Linux x86_64 implements LP64, and Windows x86_64 implements LLP64.</p>
<table class="docutils align-default" id="id9">
<caption>
<span class="caption-text">Table 1. Integer sizes in bits for LLP64 and LP64</span><a class="headerlink" href="index.html#id9" title="Permalink to this table"></a>
</caption>
<colgroup>
<col style="width: 9%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 12%">
<col style="width: 24%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="row-odd">
<th class="head"></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">short</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></th>
<th class="head"><p>pointers and <code class="docutils literal notranslate"><span class="pre">size_t</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even">
<td><p>LLP64</p></td>
<td><p>16</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd">
<td><p>LP64</p></td>
<td><p>16</p></td>
<td><p>32</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
</tr>
</tbody>
</table>
<p>NVRTC implements LP64 on Linux and LLP64 on Windows.</p>
<p>NVRTC supports 128-bit integer types through the <code class="docutils literal notranslate"><span class="pre">__int128</span></code> type. This can be enabled with the <code class="docutils literal notranslate"><span class="pre">--device-int128</span></code> flag. 128-bit integer support is not available on Windows.</p>
</section>
<section id="include-syntax">
<h2>
<span class="section-number">4.5. </span>Include Syntax<a class="headerlink" href="index.html#include-syntax" title="Permalink to this headline"></a>
</h2>
<p>When <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram()</span></code> is called, the current working directory is added to the header search path used for locating files included with the quoted syntax (for example, <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">"foo.h"</span></code>), before the code is compiled.</p>
</section>
<section id="predefined-macros">
<h2>
<span class="section-number">4.6. </span>Predefined Macros<a class="headerlink" href="index.html#predefined-macros" title="Permalink to this headline"></a>
</h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_RTC__</span></code>: useful for distinguishing between runtime and offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation in user code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_RDC__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_EWP__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_DEBUG__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_LIST__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_VER_MAJOR__</span></code>: defined with the major version number as returned by <code class="docutils literal notranslate"><span class="pre">nvrtcVersion</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_VER_MINOR__</span></code>: defined with the minor version number as returned by <code class="docutils literal notranslate"><span class="pre">nvrtcVersion</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_VER_BUILD__</span></code>: defined with the build version number.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__NVCC_DIAG_PRAGMA_SUPPORT__</span></code>: defined with same semantics as with offline <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compilation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_RTC_INT128__</span></code>: defined when <code class="docutils literal notranslate"><span class="pre">-device-int128</span></code> flag is specified during compilation, and indicates that <code class="docutils literal notranslate"><span class="pre">__int128</span></code> type is supported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code>: null pointer constant.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">va_start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">va_end</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">va_arg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">va_copy</span></code> : defined when language dialect C++11 or later is selected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__cplusplus</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_WIN64</span></code> : defined on Windows platforms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__LP64__</span></code> : defined on non-Windows platforms where <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">int</span></code> and pointer types are 64-bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__cdecl</span></code> : defined to empty on all platforms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__ptr64</span></code> : defined to empty on Windows platforms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDACC_RTC_MINIMAL__</span></code>: defined when <code class="docutils literal notranslate"><span class="pre">-minimal</span></code> flag is specified during compilation (since CUDA 12.4).</p></li>
<li><p>Macros defined in nv/target header are implicitly provided, e.g., <code class="docutils literal notranslate"><span class="pre">NV_IF_TARGET</span></code>.</p></li>
</ul>
</section>
<section id="predefined-types">
<h2>
<span class="section-number">4.7. </span>Predefined Types<a class="headerlink" href="index.html#predefined-types" title="Permalink to this headline"></a>
</h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">clock_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">va_list</span></code>: Note that the definition of this type may be different than the one selected by nvcc when compiling CUDA code.</p></li>
<li><p>Predefined types such as <code class="docutils literal notranslate"><span class="pre">dim3</span></code>, <code class="docutils literal notranslate"><span class="pre">char4</span></code>, etc., that are  available in the CUDA Runtime headers when compiling offline with  <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> are also available, unless otherwise noted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;T&gt;</span></code>: implicitly provided in C++11 and later dialects, unless <code class="docutils literal notranslate"><span class="pre">-builtin-initializer-list=false</span></code> is specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::move&lt;T&gt;,</span> <span class="pre">std::forward&lt;T&gt;</span></code>: implicitly provided in C++11 and later dialects, unless <code class="docutils literal notranslate"><span class="pre">-builtin-move-forward=false</span></code> is specified.</p></li>
</ul>
</section>
<section id="builtin-functions">
<h2>
<span class="section-number">4.8. </span>Builtin Functions<a class="headerlink" href="index.html#builtin-functions" title="Permalink to this headline"></a>
</h2>
<p>Builtin functions provided by the CUDA Runtime headers when compiling offline with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> are available, unless otherwise noted.</p>
</section>
<section id="default-c-dialect">
<h2>
<span class="section-number">4.9. </span>Default C++ Dialect<a class="headerlink" href="index.html#default-c-dialect" title="Permalink to this headline"></a>
</h2>
<p>The default C++ dialect is C++17. Other dialects can be selected using the <code class="docutils literal notranslate"><span class="pre">-std</span></code> flag.</p>
</section>
</section>
<section id="basic-usage">
<h1>
<span class="section-number">5. </span>Basic Usage<a class="headerlink" href="index.html#basic-usage" title="Permalink to this headline"></a>
</h1>
<p>This section of the document uses a simple example, <em>Single-Precision α⋅X Plus Y</em> (SAXPY), shown in <a class="reference external" href="index.html#basic-usage__cuda-source-string-for-saxpy">Figure 1</a> to explain what is involved in runtime compilation with NVRTC. For brevity and readability, error checks on the API return values are not shown. The complete code listing is available in <a class="reference external" href="index.html#example-saxpy">Example: SAXPY</a>.</p>
<p>Figure 1. CUDA source string for SAXPY</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">saxpy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                                          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                        </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)  </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = a * x[tid] + y[tid];                          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                              </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>First, an instance of <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code> needs to be created.  Figure 2 shows creation of <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code> for SAXPY. As SAXPY does not require any header, 0 is passed as <code class="docutils literal notranslate"><span class="pre">numHeaders</span></code>, and NULL as <code class="docutils literal notranslate"><span class="pre">headers</span></code> and <code class="docutils literal notranslate"><span class="pre">includeNames</span></code>.</p>
<p>Figure 2. nvrtcProgram creation for SAXPY</p>
<blockquote>
<div>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="c1">// prog</span>
<span class="w">        </span><span class="n">saxpy</span><span class="p">,</span><span class="w">         </span><span class="c1">// buffer</span>
<span class="w">        </span><span class="s">"saxpy.cu"</span><span class="p">,</span><span class="w">    </span><span class="c1">// name</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w">             </span><span class="c1">// numHeaders</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">,</span><span class="w">          </span><span class="c1">// headers</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span><span class="w">         </span><span class="c1">// includeNames</span>
</pre></div>
</div>
</div>
</blockquote>
<p>If SAXPY had any #include directives, the contents of the files that are
#include’d can be passed as elements of headers, and their names as elements
of includeNames. For example, <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;foo.h&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;bar.h&gt;</span></code> would
require 2 as <code class="docutils literal notranslate"><span class="pre">numHeaders</span></code>, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">"&lt;contents</span> <span class="pre">of</span> <span class="pre">foo.h&gt;",</span> <span class="pre">"&lt;contents</span> <span class="pre">of</span> <span class="pre">bar.h&gt;"</span> <span class="pre">}</span></code>
as headers, and <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">"foo.h",</span> <span class="pre">"bar.h"</span> <span class="pre">}</span></code> as <code class="docutils literal notranslate"><span class="pre">includeNames</span></code> (<code class="docutils literal notranslate"><span class="pre">&lt;contents</span> <span class="pre">of</span> <span class="pre">foo.h&gt;</span></code>
and <code class="docutils literal notranslate"><span class="pre">&lt;contents</span> <span class="pre">of</span> <span class="pre">bar.h&gt;</span></code> must be replaced by the actual contents of <code class="docutils literal notranslate"><span class="pre">foo.h</span></code>
and <code class="docutils literal notranslate"><span class="pre">bar.h</span></code>). Alternatively, the compile option <code class="docutils literal notranslate"><span class="pre">-I</span></code> can be used if the header
is guaranteed to exist in the file system at runtime.</p>
<p>Once the instance of <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code> for compilation is created, it can be
compiled by <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code> as shown in Figure 3. Two compile options
are used in this example, <code class="docutils literal notranslate"><span class="pre">--gpu-architecture=compute_80</span></code> and <code class="docutils literal notranslate"><span class="pre">--fmad=false</span></code>,
to generate code for the compute_80 architecture and to disable the
contraction of floating-point multiplies and adds/subtracts into
floating-point multiply-add operations. Other combinations of compile
options can be used as needed and Supported Compile Options lists valid
compile options.</p>
<p>Figure 3. Compilation of SAXPY for compute_80 with FMAD enabled</p>
<blockquote>
<div>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"--gpu-architecture=compute_80"</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="s">"--fmad=false"</span><span class="p">};</span><span class="w"></span>
<span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">     </span><span class="c1">// prog</span>
<span class="w">         </span><span class="mi">2</span><span class="p">,</span><span class="w">        </span><span class="c1">// numOptions</span>
<span class="w">         </span><span class="n">opts</span><span class="p">);</span><span class="w">    </span><span class="c1">// options</span>
</pre></div>
</div>
</div>
</blockquote>
<p>After the compilation completes, users can obtain the program compilation
log and the generated PTX as Figure 4 shows. NVRTC does not generate valid
PTX when the compilation fails, and it may generate program compilation log
even when the compilation succeeds if needed.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code> can be compiled by <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code> multiple times with
different compile options, and users can only retrieve the PTX and the log
generated by the last compilation.</p>
<blockquote>
<div>
<p>Figure 4. Obtaining generated PTX and program compilation log</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="c1">// Obtain compilation log from the program.</span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>

<span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">);</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">;</span><span class="w"></span>
<span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">);</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span><span class="w"></span>
<span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</blockquote>
<p>When the instance of <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code> is no longer needed, it can be destroyed by <code class="docutils literal notranslate"><span class="pre">nvrtcDestroyProgram</span></code> as shown in Figure 5.</p>
<p>Figure 5. Destruction of nvrtcProgram</p>
<blockquote>
<div>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</blockquote>
<p>The generated PTX can be further manipulated by the CUDA Driver API for execution or linking. Figure 6 shows an example code sequence for execution of the generated PTX.</p>
<p>Figure 6. Execution of SAXPY using the PTX generated by NVRTC</p>
<blockquote>
<div>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">);</span><span class="w"></span>
<span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="s">"saxpy"</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUM_THREADS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">hX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="o">*</span><span class="n">hY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="o">*</span><span class="n">hOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">hX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">hY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">NUM_THREADS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="c1">// grid dim</span>
<span class="w">            </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// block dim</span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">             </span><span class="c1">// shared mem and stream</span>
<span class="w">            </span><span class="n">args</span><span class="p">,</span><span class="w">                </span><span class="c1">// arguments</span>
<span class="w">            </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuCtxSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</blockquote>
</section>
<section id="accessing-lowered-names">
<h1>
<span class="section-number">6. </span>Accessing Lowered Names<a class="headerlink" href="index.html#accessing-lowered-names" title="Permalink to this headline"></a>
</h1>
<p>NVRTC will mangle <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function names and names of <code class="docutils literal notranslate"><span class="pre">__device__</span></code>
and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables as specified by the IA64 ABI. If the generated
PTX is being loaded using the CUDA Driver API, the kernel function or
<code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable must be looked up by name, but this
is hard to do when the name has been mangled. To address this problem,
NVRTC provides API functions that map source level <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function
or <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable names to the mangled names present
in the generated PTX.</p>
<p>The two API functions <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> and <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code>
work together to provide this functionality. First, a ‘name expression’
string denoting the address for the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or
<code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable is provided to <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code>.
Then, the program is compiled with <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>. During compilation,
NVRTC will parse the name expression string as a C++ constant expression at
the end of the user program. The constant expression must provide the address
of the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable. Finally,
the function <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code> is called with the original name expression
and it returns a pointer to the lowered name. The lowered name can be used
to refer to the kernel or variable in the CUDA Driver API.</p>
<p>NVRTC guarantees that any <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or <code class="docutils literal notranslate"><span class="pre">__device__/__constant__</span></code>
variable referenced in a call to <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> will be present in
the generated PTX (if the definition is available in the input source code).</p>
<section id="example">
<h2>
<span class="section-number">6.1. </span>Example<a class="headerlink" href="index.html#example" title="Permalink to this headline"></a>
</h2>
<p><cite>Example: Using Lowered Name`_</cite> lists a complete runnable example. Some relevant snippets:</p>
<ol class="arabic">
<li>
<p>The GPU source code (‘gpu_program’) contains definitions of various <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions/function templates and <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">gpu_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__device__ int V1; // set from host code                        </span><span class="se">\n</span><span class="s">\</span>
<span class="s">static __global__ void f1(int *result) { *result = V1 + 10; }   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 {                                                  </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   namespace N2 {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      __constant__ int V2; // set from host code                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      __global__ void f2(int *result) { *result = V2 + 20; }    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt;                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); }        </span><span class="se">\n</span><span class="s">\</span>
</pre></div>
</div>
</li>
<li>
<p>The host source code invokes <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> with various name expressions referring to the address of <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions and <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;f1"</span><span class="p">);</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"N1::N2::f2"</span><span class="p">);</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;int&gt;"</span><span class="p">);</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;double&gt;"</span><span class="p">);</span><span class="w"></span>

<span class="c1">// add name expressions to NVRTC. Note this must be done before</span>
<span class="c1">// the program is compiled.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="c1">// add expressions for  __device__ / __constant__ variables to NVRTC</span>
<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;V1"</span><span class="p">);</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;N1::N2::V2"</span><span class="p">);</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The GPU program is then compiled with <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>. The generated PTX is loaded on the GPU. The mangled names of the <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables and <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions are looked up:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="w">                         </span><span class="c1">// lowered name</span>
<span class="p">));</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="w"> </span><span class="c1">// lowered name</span>
<span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The mangled name of the <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/<code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable is then used to lookup the variable in the module and update its value using the CUDA Driver API:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">variable_addr</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetGlobal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">variable_addr</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">variable_addr</span><span class="p">,</span><span class="w"></span>
<span class="o">&amp;</span><span class="n">initial_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)));</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The mangled name of the kernel is then used to launch it using the CUDA Driver API:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="notes">
<h2>
<span class="section-number">6.2. </span>Notes<a class="headerlink" href="index.html#notes" title="Permalink to this headline"></a>
</h2>
<ul>
<li><p>Sequence of calls: All name expressions must be added using <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code>
before the NVRTC program is compiled with <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>. This is required
because the name expressions are parsed at the end of the user program, and may
trigger template instantiations. The lowered names must be looked up by calling
<code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code> only after the NVRTC program has been compiled, and before it
has been destroyed. The pointer returned by <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code> points to memory
owned by NVRTC, and this memory is freed when the NVRTC program has been destroyed
(<code class="docutils literal notranslate"><span class="pre">nvrtcDestroyProgram</span></code>). Thus the correct sequence of calls is: <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code>,
<code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>, <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code>, <code class="docutils literal notranslate"><span class="pre">nvrtcDestroyProgram</span></code>.</p></li>
<li><p>Identical Name Expressions: The name expression string passed to <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code>
and <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code> must have identical characters. For example, “foo” and “foo ”
are not identical strings, even though semantically they refer to the same entity (foo),
because the second string has a extra whitespace character.</p></li>
<li><p>Constant Expressions: The characters in the name expression string are parsed as a C++
constant expression at the end of the user program. Any errors during parsing will cause
compilation failure and compiler diagnostics will be generated in the compilation log.
The constant expression must refer to the address of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or
<code class="docutils literal notranslate"><span class="pre">__device__/__constant__</span></code> variable.</p></li>
<li>
<p>Address of overloaded function: If the NVRTC source code has multiple overloaded
<code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions, then the name expression must use a cast operation to disambiguate.
However, casts are not allowed in constant expression for C++ dialects before C++11.
If using such name expressions, please compile the code in C++11 or later dialect
using the <code class="docutils literal notranslate"><span class="pre">-std</span></code> command line flag. Example: Consider that the GPU code string contains:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The name expression <code class="docutils literal notranslate"><span class="pre">(void(*)(int))foo</span></code> correctly disambiguates <code class="docutils literal notranslate"><span class="pre">foo(int)</span></code>, but the program must be compiled in C++11 or later dialect (such as <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code>) because casts are not allowed in pre-C++11 constant expressions.</p>
</li>
</ul>
</section>
</section>
<section id="interfacing-with-template-host-code">
<h1>
<span class="section-number">7. </span>Interfacing With Template Host Code<a class="headerlink" href="index.html#interfacing-with-template-host-code" title="Permalink to this headline"></a>
</h1>
<p>In some scenarios, it is useful to instantiate <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function templates in device
code based on template arguments in host code. The NVRTC helper function nvrtcGetTypeName
can be used to extract the source level name of a type in host code, and this string can be
used to instantiate a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template and get the mangled name of the
instantiation using the <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> and <code class="docutils literal notranslate"><span class="pre">nvrtcGetLoweredName</span></code> functions.</p>
<p><code class="docutils literal notranslate"><span class="pre">nvrtcGetTypeName</span></code> is defined inline in the NVRTC header file, and is available when the
macro <code class="docutils literal notranslate"><span class="pre">NVRTC_GET_TYPE_NAME</span></code> is defined with a non-zero value. It uses the <code class="docutils literal notranslate"><span class="pre">abi::__cxa_demangle</span></code>
and <code class="docutils literal notranslate"><span class="pre">UnDecorateSymbolName</span></code> host code functions when using gcc/clang and cl.exe compilers,
respectively. Users may need to specify additional header paths and libraries to find the
host functions used (<code class="docutils literal notranslate"><span class="pre">abi::__cxa_demangle</span> <span class="pre">/</span> <span class="pre">UnDecorateSymbolName</span></code>). Refer to the build instructions
for the example below for reference (<a class="reference internal" href="index.html#nvrtcgettypename-build-instructions">nvrtcGetTypeName Build Instructions</a>).</p>
<section id="template-host-code-example">
<h2>
<span class="section-number">7.1. </span>Template Host Code Example<a class="headerlink" href="index.html#template-host-code-example" title="Permalink to this headline"></a>
</h2>
<p><a class="reference internal" href="index.html#example-using-nvrtcgettypename">Example: Using nvrtcGetTypeName</a> lists a complete runnable example. Some relevant snippets:</p>
<ol class="arabic">
<li>
<p>The GPU source code (<code class="docutils literal notranslate"><span class="pre">gpu_program</span></code>) contains definitions of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">gpu_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">" </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 { struct S1_t { int i; double d; }; } </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt; </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); } </span><span class="se">\n</span><span class="s">\</span>
<span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The host code function <code class="docutils literal notranslate"><span class="pre">getKernelNameForType</span></code> creates the name expression for a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiation based on the host template type T. The name of the type T is extracted using <code class="docutils literal notranslate"><span class="pre">nvrtcGetTypeName</span></code>:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getKernelNameForType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="c1">// Look up the source level name string for the type "T" using</span>
<span class="c1">// nvrtcGetTypeName() and use it to create the kernel name</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">type_name</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetTypeName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_name</span><span class="p">));</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"f3&lt;"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&gt;"</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The name expressions are presented to NVRTC using the <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> function:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="p">..</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The GPU program is then compiled with <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>. The generated PTX is loaded on the GPU. The mangled names of the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiations are looked up:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="w"> </span><span class="c1">// lowered name</span>
<span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</li>
<li>
<p>The mangled name is then used to launch the kernel using the CUDA Driver API:</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="versioning-scheme">
<h1>
<span class="section-number">8. </span>Versioning Scheme<a class="headerlink" href="index.html#versioning-scheme" title="Permalink to this headline"></a>
</h1>
<section id="nvrtc-shared-library-versioning">
<h2>
<span class="section-number">8.1. </span>NVRTC Shared Library Versioning<a class="headerlink" href="index.html#nvrtc-shared-library-versioning" title="Permalink to this headline"></a>
</h2>
<p>In the following, MAJOR and MINOR denote the major and minor versions of the CUDA Toolkit. For example, for CUDA 11.2, MAJOR is “11” and MINOR is “2”.</p>
<ul class="simple">
<li>
<p>Linux:</p>
<ul>
<li><p>In CUDA toolkits prior to CUDA 11.3, the soname was set to “MAJOR.MINOR”.</p></li>
<li><p>In CUDA 11.3 and later 11.x toolkits, the soname field is set to “11.2”.</p></li>
<li><p>In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the soname field is set to “MAJOR”.</p></li>
</ul>
</li>
<li>
<p>Windows:</p>
<ul>
<li><p>In CUDA toolkits prior to cuda 11.3, the DLL name was of the form “nvrtc64_XY_0.dll”, where X = MAJOR, Y = MINOR.</p></li>
<li><p>In CUDA 11.3 and later 11.x toolkits, the DLL name is “nvrtc64_112_0.dll”.</p></li>
<li><p>In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the DLL name is of the form “nvrtc64_X0_0.dll” where X = MAJOR.</p></li>
</ul>
</li>
</ul>
<p>Consider a CUDA toolkit with major version &gt; 11. The NVRTC shared library in this CUDA  toolkit will have the same soname (Linux) or DLL name (Windows) as an NVRTC shared library  in a previous minor version of the same CUDA toolkit. Similarly, the NVRTC shared library in CUDA 11.3 and later 11.x releases will have the same soname (Linux) or DLL name (Windows) as the NVRTC shared library in CUDA 11.2.</p>
<p>As a consequence of the versioning scheme described above, an NVRTC client that links
against a particular NVRTC shared library will continue to work with a future NVRTC shared
library with a matching soname (Linux) or DLL name (Windows). This allows the NVRTC client
to take advantage of bug fixes and enhancements available in the more recent NVRTC shared
library <a class="footnote-reference brackets" href="index.html#id7" id="id4">1</a>. However, the more recent NVRTC shared library may generate PTX with a version that
is not accepted by the CUDA Driver API functions of an older CUDA driver, as explained in the
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#dynamic-code-generation">Best Practices Guide</a>.</p>
<p>Some approaches to resolving this issue:</p>
<ul class="simple">
<li><p>Install a more recent CUDA driver that is compatible with the CUDA toolkit containing the NVRTC library being used.</p></li>
<li><p>Compile directly to SASS instead of PTX with NVRTC (refer to <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#dynamic-code-generation">Best Practices Guide</a>).</p></li>
</ul>
<p>Alternately, an NVRTC client can either link against the static NVRTC library or redistribute
a specific version of the NVRTC shared library and use dlopen (Linux) or LoadLibrary (Windows)
functions to use that library at run time. Either approach allows the NVRTC client to maintain
control over the version of NVRTC being used during deployment, to ensure predictable functionality and performance.</p>
</section>
<section id="nvrtc-builtins-library">
<h2>
<span class="section-number">8.2. </span>NVRTC-builtins Library<a class="headerlink" href="index.html#nvrtc-builtins-library" title="Permalink to this headline"></a>
</h2>
<p>The NVRTC-builtins library contains helper code that is part of the NVRTC package.
It is only used by the NVRTC library internally. Each NVRTC library is only compatible
with the NVRTC-builtins library from the same CUDA toolkit.</p>
</section>
</section>
<section id="miscellaneous-notes">
<h1>
<span class="section-number">9. </span>Miscellaneous Notes<a class="headerlink" href="index.html#miscellaneous-notes" title="Permalink to this headline"></a>
</h1>
<section id="thread-safety">
<h2>
<span class="section-number">9.1. </span>Thread Safety<a class="headerlink" href="index.html#thread-safety" title="Permalink to this headline"></a>
</h2>
<p>Multiple threads can invoke NVRTC API functions concurrently, as long as there is no race
condition. In this context, a race condition is defined to occur if multiple threads
concurrently invoke NVRTC API functions with the same nvrtcProgram argument, where at
least one thread is invoking either <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code> or <code class="docutils literal notranslate"><span class="pre">nvrtcAddNameExpression</span></code> <a class="footnote-reference brackets" href="index.html#id8" id="id6">2</a>.</p>
<p>Since CUDA 12.3, NVRTC allows concurrent invocations of <code class="docutils literal notranslate"><span class="pre">nvrtcCompileProgram</span></code>
to potentially concurrently also invoke the embedded NVVM optimizer/codegen phase.
Setting the environment variable <code class="docutils literal notranslate"><span class="pre">NVRTC_DISABLE_CONCURRENT_NVVM</span></code> disables this behavior,
i.e., invocations of the embedded NVVM optimizer/codegen phase will be serialized.</p>
</section>
<section id="stack-size">
<h2>
<span class="section-number">9.2. </span>Stack Size<a class="headerlink" href="index.html#stack-size" title="Permalink to this headline"></a>
</h2>
<p>On Linux, NVRTC will increase the stack size to the maximum allowed using the <code class="docutils literal notranslate"><span class="pre">setrlimit()</span></code> function during compilation. This reduces the chance that the compiler will run out of stack when processing complex input sources. The stack size is reset to the previous value when compilation is completed.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">setrlimit()</span></code> changes the stack size for the entire process, it will also affect
other application threads that may be executing concurrently. The command line flag
<code class="docutils literal notranslate"><span class="pre">-modify-stack-limit=false</span></code> will prevent NVRTC from modifying the stack limit.</p>
</section>
<section id="nvrtc-static-library">
<h2>
<span class="section-number">9.3. </span>NVRTC Static Library<a class="headerlink" href="index.html#nvrtc-static-library" title="Permalink to this headline"></a>
</h2>
<p>The NVRTC static library references functions defined in the NVRTC-builtins static library and the PTX compiler static library. Please see Build Instructions for an example.</p>
</section>
</section>
<section id="example-saxpy">
<h1>
<span class="section-number">10. </span>Example: SAXPY<a class="headerlink" href="index.html#example-saxpy" title="Permalink to this headline"></a>
</h1>
<section id="code-saxpy-cpp">
<h2>
<span class="section-number">10.1. </span>Code (saxpy.cpp)<a class="headerlink" href="index.html#code-saxpy-cpp" title="Permalink to this headline"></a>
</h2>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvrtc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#define NUM_THREADS 128</span>
<span class="cp">#define NUM_BLOCKS 32</span>
<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">  do {                                                            \</span>
<span class="cp">    nvrtcResult result = x;                                       \</span>
<span class="cp">    if (result != NVRTC_SUCCESS) {                                \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">    }                                                             \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">  do {                                                            \</span>
<span class="cp">    CUresult result = x;                                          \</span>
<span class="cp">    if (result != CUDA_SUCCESS) {                                 \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">    }                                                             \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">saxpy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  size_t tid = blockIdx.x * blockDim.x + threadIdx.x;           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  if (tid &lt; n) {                                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">    out[tid] = a * x[tid] + y[tid];                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  }                                                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Create an instance of nvrtcProgram with the SAXPY code string.</span>
<span class="w">   </span><span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w">         </span><span class="c1">// prog</span>
<span class="w">                        </span><span class="n">saxpy</span><span class="p">,</span><span class="w">         </span><span class="c1">// buffer</span>
<span class="w">                        </span><span class="s">"saxpy.cu"</span><span class="p">,</span><span class="w">    </span><span class="c1">// name</span>
<span class="w">                        </span><span class="mi">0</span><span class="p">,</span><span class="w">             </span><span class="c1">// numHeaders</span>
<span class="w">                        </span><span class="nb">NULL</span><span class="p">,</span><span class="w">          </span><span class="c1">// headers</span>
<span class="w">                        </span><span class="nb">NULL</span><span class="p">));</span><span class="w">        </span><span class="c1">// includeNames</span>
<span class="w">   </span><span class="c1">// Compile the program with fmad disabled.</span>
<span class="w">   </span><span class="c1">// Note: Can specify GPU target architecture explicitly with '-arch' flag.</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"--fmad=false"</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">nvrtcResult</span><span class="w"> </span><span class="n">compileResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">  </span><span class="c1">// prog</span>
<span class="w">                                                   </span><span class="mi">1</span><span class="p">,</span><span class="w">     </span><span class="c1">// numOptions</span>
<span class="w">                                                   </span><span class="n">opts</span><span class="p">);</span><span class="w"> </span><span class="c1">// options</span>
<span class="w">   </span><span class="c1">// Obtain compilation log from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compileResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Obtain PTX from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Destroy the program.</span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Load the generated PTX and get a handle to the SAXPY kernel.</span>
<span class="w">   </span><span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="s">"saxpy"</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUM_THREADS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.1f</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">hX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">hY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">hOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">hX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">hY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Execute SAXPY.</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// grid dim</span>
<span class="w">                     </span><span class="n">NUM_THREADS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="c1">// block dim</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">             </span><span class="c1">// shared mem and stream</span>
<span class="w">                     </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">           </span><span class="c1">// arguments</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Retrieve and print output.</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" * "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" + "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">               </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Release resources.</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dX</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dY</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hX</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hY</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hOut</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">ptx</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="host-type-name-build-instructions">
<h2>
<span class="section-number">10.2. </span>Host Type Name Build Instructions<a class="headerlink" href="index.html#host-type-name-build-instructions" title="Permalink to this headline"></a>
</h2>
<p>Assuming the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_PATH</span></code> points to the CUDA Toolkit installation directory, build this example as:</p>
<ul>
<li>
<p>With NVRTC shared library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe saxpy.cpp /Fesaxpy ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ saxpy.cpp -o saxpy \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>With NVRTC static library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe saxpy.cpp /Fesaxpy  ^
    /I "%CUDA_PATH%"\include ^
    "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
    "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
    "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
    "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ saxpy.cpp -o saxpy \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="example-using-lowered-name">
<h1>
<span class="section-number">11. </span>Example: Using Lowered Name<a class="headerlink" href="index.html#example-using-lowered-name" title="Permalink to this headline"></a>
</h1>
<section id="code-lowered-name-cpp">
<h2>
<span class="section-number">11.1. </span>Code (lowered-name.cpp)<a class="headerlink" href="index.html#code-lowered-name-cpp" title="Permalink to this headline"></a>
</h2>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvrtc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';            \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; msg &lt;&lt; '\n';                                    \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">gpu_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"</span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">V1</span><span class="p">;</span><span class="w"> </span><span class="c1">// set from host code                        \n\</span>
<span class="c1">  static __global__ void f1(int *result) { *result = V1 + 10; }   \n\</span>
<span class="c1">  namespace N1 {                                                  \n\</span>
<span class="c1">    namespace N2 {                                                \n\</span>
<span class="c1">       __constant__ int V2; // set from host code                 \n\</span>
<span class="c1">       __global__ void f2(int *result) { *result = V2 + 20; }     \n\</span>
<span class="c1">      }                                                           \n\</span>
<span class="c1">   }                                                              \n\</span>
<span class="c1">   template&lt;typename T&gt;                                           \n\</span>
<span class="c1">   __global__ void f3(int *result) { *result = sizeof(T); }       \n\</span>
<span class="c1">                                                                  \n";</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Create an instance of nvrtcProgram</span>
<span class="w">   </span><span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w">         </span><span class="c1">// prog</span>
<span class="w">                                       </span><span class="n">gpu_program</span><span class="p">,</span><span class="w">   </span><span class="c1">// buffer</span>
<span class="w">                                       </span><span class="s">"prog.cu"</span><span class="p">,</span><span class="w">     </span><span class="c1">// name</span>
<span class="w">                                       </span><span class="mi">0</span><span class="p">,</span><span class="w">             </span><span class="c1">// numHeaders</span>
<span class="w">                                       </span><span class="nb">NULL</span><span class="p">,</span><span class="w">          </span><span class="c1">// headers</span>
<span class="w">                                       </span><span class="nb">NULL</span><span class="p">));</span><span class="w">        </span><span class="c1">// includeNames</span>

<span class="w">   </span><span class="c1">// add all name expressions for kernels</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">variable_name_vec</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">variable_initial_value</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expected_result</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// note the name expressions are parsed as constant expressions</span>
<span class="w">   </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;f1"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"N1::N2::f2"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">20</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;int&gt;"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;double&gt;"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// add kernel name expressions to NVRTC. Note this must be done before</span>
<span class="w">   </span><span class="c1">// the program is compiled.</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// add expressions for  __device__ / __constant__ variables to NVRTC</span>
<span class="w">   </span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;V1"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">variable_initial_value</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;N1::N2::V2"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">variable_initial_value</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>

<span class="w">   </span><span class="n">nvrtcResult</span><span class="w"> </span><span class="n">compileResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">  </span><span class="c1">// prog</span>
<span class="w">                                                   </span><span class="mi">0</span><span class="p">,</span><span class="w">     </span><span class="c1">// numOptions</span>
<span class="w">                                                   </span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="c1">// options</span>
<span class="w">   </span><span class="c1">// Obtain compilation log from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compileResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Obtain PTX from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Load the generated PTX</span>
<span class="w">   </span><span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dResult</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">hResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// for each of the __device__/__constant__ variable address</span>
<span class="w">   </span><span class="c1">// expressions provided to NVRTC, extract the lowered name for the</span>
<span class="w">   </span><span class="c1">// corresponding variable, and set its value</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="w">      </span><span class="c1">// compiled and before it has been destroyed.</span>
<span class="w">      </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="w">                           </span><span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">name</span><span class="w">                         </span><span class="c1">// lowered name</span>
<span class="w">                                          </span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">initial_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">variable_initial_value</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="c1">// get pointer to variable using lowered name, and set its</span>
<span class="w">      </span><span class="c1">// initial value</span>
<span class="w">      </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">variable_addr</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetGlobal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">variable_addr</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">variable_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">initial_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)));</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>


<span class="w">   </span><span class="c1">// for each of the kernel name expressions previously provided to NVRTC,</span>
<span class="w">   </span><span class="c1">// extract the lowered name for corresponding __global__ function,</span>
<span class="w">   </span><span class="c1">// and launch it.</span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="w">      </span><span class="c1">// compiled and before it has been destroyed.</span>
<span class="w">      </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="w">                           </span><span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">name</span><span class="w">                </span><span class="c1">// lowered name</span>
<span class="w">                                          </span><span class="p">));</span><span class="w"></span>

<span class="w">      </span><span class="c1">// get pointer to kernel from loaded PTX</span>
<span class="w">      </span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>

<span class="w">      </span><span class="c1">// launch the kernel</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">launching "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" ("</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dResult</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">         </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">             </span><span class="c1">// grid dim</span>
<span class="w">            </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">             </span><span class="c1">// block dim</span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">             </span><span class="c1">// shared mem and stream</span>
<span class="w">            </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">           </span><span class="c1">// arguments</span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Retrieve the result</span>
<span class="w">      </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="w"> </span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>

<span class="w">      </span><span class="c1">// check against expected value</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hResult</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s"> Error: expected result = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" , actual result = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hResult</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w">  </span><span class="c1">// for</span>

<span class="w">   </span><span class="c1">// Release resources.</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dResult</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">ptx</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Destroy the program.</span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="lowered-name-build-instructions">
<h2>
<span class="section-number">11.2. </span>Lowered Name Build Instructions<a class="headerlink" href="index.html#lowered-name-build-instructions" title="Permalink to this headline"></a>
</h2>
<p>Assuming the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_PATH</span></code> points to CUDA Toolkit installation directory, build this example as:</p>
<ul>
<li>
<p>With NVRTC shared library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe lowered-name.cpp /Felowered-name ^
/I "%CUDA_PATH%"\include ^
"%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ lowered-name.cpp -o lowered-name \
-I $CUDA_PATH/include \
-L $CUDA_PATH/lib64 \
-lnvrtc -lcuda \
-Wl,-rpath,$CUDA_PATH/lib64
</pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>With NVRTC static library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe lowered-name.cpp /Felowered-name  ^
/I "%CUDA_PATH%"\include ^
"%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
"%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
"%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
"%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ lowered-name.cpp -o lowered-name \
-I $CUDA_PATH/include \
-L $CUDA_PATH/lib64 \
-lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \
-lcuda -lpthread
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="example-using-nvrtcgettypename">
<h1>
<span class="section-number">12. </span>Example: Using nvrtcGetTypeName<a class="headerlink" href="index.html#example-using-nvrtcgettypename" title="Permalink to this headline"></a>
</h1>
<section id="code-host-type-name-cpp">
<h2>
<span class="section-number">12.1. </span>Code (host-type-name.cpp)<a class="headerlink" href="index.html#code-host-type-name-cpp" title="Permalink to this headline"></a>
</h2>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvrtc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                            \</span>
<span class="cp">   nvrtcResult result = x;                                       \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                             \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                            \</span>
<span class="cp">   CUresult result = x;                                          \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                 \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                             \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">gpu_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 { struct S1_t { int i; double d; }; }              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt;                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); }        </span><span class="se">\n</span><span class="s">\</span>
<span class="s">                                                               </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>


<span class="c1">// note: this structure is also defined in GPU code string. Should ideally</span>
<span class="c1">// be in a header file included by both GPU code string and by CPU code.</span>
<span class="n">namespace</span><span class="w"> </span><span class="n">N1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getKernelNameForType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Look up the source level name string for the type "T" using</span>
<span class="w">   </span><span class="c1">// nvrtcGetTypeName() and use it to create the kernel name</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">type_name</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetTypeName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_name</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"f3&lt;"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&gt;"</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="c1">// Create an instance of nvrtcProgram</span>
<span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w">         </span><span class="c1">// prog</span>
<span class="w">                     </span><span class="n">gpu_program</span><span class="p">,</span><span class="w">   </span><span class="c1">// buffer</span>
<span class="w">                     </span><span class="s">"gpu_program.cu"</span><span class="p">,</span><span class="w">    </span><span class="c1">// name</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w">             </span><span class="c1">// numHeaders</span>
<span class="w">                     </span><span class="nb">NULL</span><span class="p">,</span><span class="w">          </span><span class="c1">// headers</span>
<span class="w">                     </span><span class="nb">NULL</span><span class="p">));</span><span class="w">        </span><span class="c1">// includeNames</span>

<span class="c1">// add all name expressions for kernels</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expected_result</span><span class="p">;</span><span class="w"></span>

<span class="c1">// note the name expressions are parsed as constant expressions</span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>

<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="p">));</span><span class="w"></span>


<span class="c1">// add name expressions to NVRTC. Note this must be done before</span>
<span class="c1">// the program is compiled.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span><span class="w"></span>

<span class="n">nvrtcResult</span><span class="w"> </span><span class="n">compileResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">  </span><span class="c1">// prog</span>
<span class="w">                                                </span><span class="mi">0</span><span class="p">,</span><span class="w">     </span><span class="c1">// numOptions</span>
<span class="w">                                                </span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">));</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compileResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">));</span><span class="w"></span>


<span class="c1">// Load the generated PTX</span>
<span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>

<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dResult</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">hResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>

<span class="c1">// for each of the name expressions previously provided to NVRTC,</span>
<span class="c1">// extract the lowered name for corresponding __global__ function,</span>
<span class="c1">// and launch it.</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="w">   </span><span class="c1">// compiled and before it has been destroyed.</span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span><span class="w"></span>
<span class="w">                        </span><span class="n">prog</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="c1">// name expression</span>
<span class="w">         </span><span class="o">&amp;</span><span class="n">name</span><span class="w">                </span><span class="c1">// lowered name</span>
<span class="w">                                       </span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// get pointer to kernel from loaded PTX</span>
<span class="w">   </span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// launch the kernel</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s">launching "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" ("</span><span class="w"></span>
<span class="w">         </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dResult</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">             </span><span class="c1">// grid dim</span>
<span class="w">         </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">             </span><span class="c1">// block dim</span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">             </span><span class="c1">// shared mem and stream</span>
<span class="w">         </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">           </span><span class="c1">// arguments</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Retrieve the result</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="w"> </span><span class="n">dResult</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// check against expected value</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hResult</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"</span><span class="se">\n</span><span class="s"> Error: expected result = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" , actual result = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hResult</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w">  </span><span class="c1">// for</span>

<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dResult</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span><span class="w"></span>
<span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">ptx</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="nvrtcgettypename-build-instructions">
<h2>
<span class="section-number">12.2. </span>nvrtcGetTypeName Build Instructions<a class="headerlink" href="index.html#nvrtcgettypename-build-instructions" title="Permalink to this headline"></a>
</h2>
<p>Assuming the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_PATH</span></code> points to CUDA Toolkit installation
directory, build this example as:</p>
<ul>
<li>
<p>With NVRTC shared library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib DbgHelp.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>With NVRTC static library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib DbgHelp.lib user32.lib Ws2_32.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \
   -lcuda -lpthread
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="example-dynamic-parallelism">
<h1>
<span class="section-number">13. </span>Example: Dynamic Parallelism<a class="headerlink" href="index.html#example-dynamic-parallelism" title="Permalink to this headline"></a>
</h1>
<p>Code (dynamic-parallelism.cpp)</p>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvrtc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dynamic_parallelism</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void child(float *out, size_t n)                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = tid;                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">                                                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void parent(float *out, size_t n,                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">            size_t numBlocks, size_t numThreads)                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   child&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(out, n);                    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   cudaDeviceSynchronize();                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Usage: dynamic-parallelism &lt;path to cudadevrt library&gt;</span><span class="se">\n\n</span><span class="s">"</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"&lt;path to cudadevrt library&gt; must include the cudadevrt</span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"library name itself, e.g., Z:</span><span class="se">\\</span><span class="s">path</span><span class="se">\\</span><span class="s">to</span><span class="se">\\</span><span class="s">cudadevrt.lib on </span><span class="se">\n</span><span class="s">"</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Windows and /path/to/libcudadevrt.a on Linux.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">numBlocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">numThreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Create an instance of nvrtcProgram with the code string.</span>
<span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w">                       </span><span class="c1">// prog</span>
<span class="w">                     </span><span class="n">dynamic_parallelism</span><span class="p">,</span><span class="w">          </span><span class="c1">// buffer</span>
<span class="w">                     </span><span class="s">"dynamic_parallelism.cu"</span><span class="p">,</span><span class="w">     </span><span class="c1">// name</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w">                            </span><span class="c1">// numHeaders</span>
<span class="w">                     </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                         </span><span class="c1">// headers</span>
<span class="w">                     </span><span class="nb">NULL</span><span class="p">));</span><span class="w">                       </span><span class="c1">// includeNames</span>
<span class="c1">// Compile the program for compute_35 with rdc enabled.</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"--gpu-architecture=compute_35"</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="s">"--relocatable-device-code=true"</span><span class="p">};</span><span class="w"></span>
<span class="n">nvrtcResult</span><span class="w"> </span><span class="n">compileResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">  </span><span class="c1">// prog</span>
<span class="w">                                                </span><span class="mi">2</span><span class="p">,</span><span class="w">     </span><span class="c1">// numOptions</span>
<span class="w">                                                </span><span class="n">opts</span><span class="p">);</span><span class="w"> </span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">));</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compileResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">;</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span><span class="w"></span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Load the generated PTX and get a handle to the parent kernel.</span>
<span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="n">CUlinkState</span><span class="w"> </span><span class="n">linkState</span><span class="p">;</span><span class="w"></span>
<span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkCreate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linkState</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkAddFile</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="n">CU_JIT_INPUT_LIBRARY</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"></span>
<span class="w">                              </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkAddData</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="n">CU_JIT_INPUT_PTX</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="n">ptxSize</span><span class="p">,</span><span class="w"> </span><span class="s">"dynamic_parallelism.ptx"</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">cubinSize</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cubin</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkComplete</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubinSize</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">cubin</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="s">"parent"</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numBlocks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numThreads</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">hOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Execute parent kernel.</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">numThreads</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// grid dim</span>
<span class="w">                  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// block dim</span>
<span class="w">                  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">    </span><span class="c1">// shared mem and stream</span>
<span class="w">                  </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">  </span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span><span class="w"></span>
<span class="c1">// Retrieve and print output.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkDestroy</span><span class="p">(</span><span class="n">linkState</span><span class="p">));</span><span class="w"></span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span><span class="w"></span>
<span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hOut</span><span class="p">;</span><span class="w"></span>
<span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">ptx</span><span class="p">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="dynamic-parallelism-build-instructions">
<h2>
<span class="section-number">13.1. </span>Dynamic Parallelism Build Instructions<a class="headerlink" href="index.html#dynamic-parallelism-build-instructions" title="Permalink to this headline"></a>
</h2>
<p>Assuming the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_PATH</span></code> points to CUDA Toolkit installation directory, build this example as:</p>
<ul>
<li>
<p>With NVRTC shared library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism ^
   /I "%CUDA_PATH%\include" ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ dynamic-parallelism.cpp -o dynamic-parallelism \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>With NVRTC static library:</p>
<blockquote>
<div>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
  "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<blockquote>
<div>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ dynamic-parallelism.cpp -o dynamic-parallelism \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre></div>
</div>
</div>
</blockquote>
</li>
</ul>
</div>
</blockquote>
</li>
</ul>
</section>
</section>
<section id="example-device-lto-link-time-optimization">
<h1>
<span class="section-number">14. </span>Example: Device LTO (link time optimization)<a class="headerlink" href="index.html#example-device-lto-link-time-optimization" title="Permalink to this headline"></a>
</h1>
<p>This section demonstrates device link time optimization (LTO).
There are two units of LTO IR. The first unit is generated offline using nvcc, by specifying the architecture as <code class="docutils literal notranslate"><span class="pre">-arch</span> <span class="pre">lto_XX</span></code> (refer to <a class="reference internal" href="index.html#code-offline-cu">Code (offline.cu)</a>).
The generated LTO IR is packaged in a fatbinary.</p>
<p>The second unit is generated online using NVRTC, by specifying the flag <code class="docutils literal notranslate"><span class="pre">-dlto</span></code> (refer to <a class="reference internal" href="index.html#code-online-cpp">Code (online.cpp)</a>).</p>
<p>These two units are then passed to <code class="docutils literal notranslate"><span class="pre">libnvJitLink*</span></code> API functions, which link together the LTO IR, run the optimizer on the linked IR and generate a cubin (refer to <a class="reference internal" href="index.html#code-online-cpp">Code (online.cpp)</a>). The cubin is then loaded on the GPU and executed.</p>
<section id="code-offline-cu">
<h2>
<span class="section-number">14.1. </span>Code (offline.cu)<a class="headerlink" href="index.html#code-offline-cu" title="Permalink to this headline"></a>
</h2>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="code-online-cpp">
<h2>
<span class="section-number">14.2. </span>Code (online.cpp)<a class="headerlink" href="index.html#code-online-cpp" title="Permalink to this headline"></a>
</h2>
<div class="highlight-c notranslate">
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvrtc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvJitLink.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#define NUM_THREADS 128</span>
<span class="cp">#define NUM_BLOCKS 32</span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="cp">#define NVJITLINK_SAFE_CALL(h,x)                                  \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvJitLinkResult result = x;                                    \</span>
<span class="cp">   if (result != NVJITLINK_SUCCESS) {                             \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; result &lt;&lt; '\n';                                \</span>
<span class="cp">      size_t lsize;                                               \</span>
<span class="cp">      result = nvJitLinkGetErrorLogSize(h, &amp;lsize);               \</span>
<span class="cp">      if (result == NVJITLINK_SUCCESS &amp;&amp; lsize &gt; 0) {             \</span>
<span class="cp">         char *log = (char*)malloc(lsize);                        \</span>
<span class="cp">         result = nvJitLinkGetErrorLog(h, log);                   \</span>
<span class="cp">         if (result == NVJITLINK_SUCCESS) {                       \</span>
<span class="cp">            std::cerr &lt;&lt; "error: " &lt;&lt; log &lt;&lt; '\n';                \</span>
<span class="cp">            free(log);                                            \</span>
<span class="cp">         }                                                        \</span>
<span class="cp">      }                                                           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">lto_saxpy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"                                       </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern __device__ float compute(float a, float x, float y);     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">                                                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = compute(a, x[tid], y[tid]);                    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">} </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numBlocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numThreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Create an instance of nvrtcProgram with the code string.</span>
<span class="w">   </span><span class="n">nvrtcProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="w">                      </span><span class="c1">// prog</span>
<span class="w">                        </span><span class="n">lto_saxpy</span><span class="p">,</span><span class="w">                   </span><span class="c1">// buffer</span>
<span class="w">                        </span><span class="s">"lto_saxpy.cu"</span><span class="p">,</span><span class="w">              </span><span class="c1">// name</span>
<span class="w">                        </span><span class="mi">0</span><span class="p">,</span><span class="w">                           </span><span class="c1">// numHeaders</span>
<span class="w">                        </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                        </span><span class="c1">// headers</span>
<span class="w">                        </span><span class="nb">NULL</span><span class="p">));</span><span class="w">                      </span><span class="c1">// includeNames</span>

<span class="w">   </span><span class="c1">// specify that LTO IR should be generated for LTO operation</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"-dlto"</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="s">"--relocatable-device-code=true"</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">nvrtcResult</span><span class="w"> </span><span class="n">compileResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w">  </span><span class="c1">// prog</span>
<span class="w">                                                   </span><span class="mi">2</span><span class="p">,</span><span class="w">     </span><span class="c1">// numOptions</span>
<span class="w">                                                   </span><span class="n">opts</span><span class="p">);</span><span class="w"> </span><span class="c1">// options</span>
<span class="w">   </span><span class="c1">// Obtain compilation log from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">logSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compileResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Obtain generated LTO IR from the program.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">LTOIRSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLTOIRSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LTOIRSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">LTOIR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">LTOIRSize</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLTOIR</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">LTOIR</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Destroy the program.</span>
<span class="w">   </span><span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUmodule</span><span class="w"> </span><span class="n">module</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUfunction</span><span class="w"> </span><span class="n">kernel</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Load the generated LTO IR and the LTO IR generated offline</span>
<span class="w">   </span><span class="c1">// and link them together.</span>
<span class="w">   </span><span class="n">nvJitLinkHandle</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Dynamically determine the arch to link for</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">major</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">major</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">arch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">major</span><span class="o">*</span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="n">smbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">sprintf</span><span class="p">(</span><span class="n">smbuf</span><span class="p">,</span><span class="w"> </span><span class="s">"-arch=sm_%d"</span><span class="p">,</span><span class="w"> </span><span class="n">arch</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">lopts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">"-dlto"</span><span class="p">,</span><span class="w"> </span><span class="n">smbuf</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">lopts</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// NOTE: assumes "offline.fatbin" is in the current directory</span>
<span class="w">   </span><span class="c1">// The fatbinary contains LTO IR generated offline using nvcc</span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkAddFile</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">NVJITLINK_INPUT_FATBIN</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="s">"offline.fatbin"</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkAddData</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">NVJITLINK_INPUT_LTOIR</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">LTOIR</span><span class="p">,</span><span class="w"> </span><span class="n">LTOIRSize</span><span class="p">,</span><span class="w"> </span><span class="s">"lto_online"</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// The call to nvJitLinkComplete causes linker to link together the two</span>
<span class="w">   </span><span class="c1">// LTO IR modules (offline and online), do optimization on the linked LTO IR,</span>
<span class="w">   </span><span class="c1">// and generate cubin from it.</span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkComplete</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cubinSize</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkGetLinkedCubinSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubinSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cubin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">cubinSize</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkGetLinkedCubin</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">cubin</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">nvJitLinkDestroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">));</span><span class="w"></span>


<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">cubin</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="s">"saxpy"</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUM_THREADS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.1f</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">hX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">hY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">hOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="n">hX</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="n">hY</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Execute SAXPY.</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1">// grid dim</span>
<span class="w">                     </span><span class="n">NUM_THREADS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="c1">// block dim</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">             </span><span class="c1">// shared mem and stream</span>
<span class="w">                     </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">           </span><span class="c1">// arguments</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Retrieve and print output.</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="w"> </span><span class="n">dOut</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" * "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" + "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">               </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Release resources.</span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dX</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dY</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">cubin</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hX</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hY</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">hOut</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">LTOIR</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="device-lto-build-instructions">
<h2>
<span class="section-number">14.3. </span>Device LTO Build Instructions<a class="headerlink" href="index.html#device-lto-build-instructions" title="Permalink to this headline"></a>
</h2>
<p>Assuming the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_PATH</span></code> points to the CUDA Toolkit installation directory, build this example as:</p>
<ul>
<li>
<p>Compile offline.cu to fatbinary containing LTO IR (change <code class="docutils literal notranslate"><span class="pre">lto_52</span></code> to a different lto_XX architecture as appropriate).</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>nvcc -arch lto_52 -rdc=true -fatbin offline.cu
</pre></div>
</div>
</li>
<li>
<p>With NVRTC shared library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe online.cpp /Feonline ^
   /I "%CUDA_PATH%\include" ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib ^
   "%CUDA_PATH%"\lib\x64\nvJitLink.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ online.cpp -o online \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lnvJitLink -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>With NVRTC static library:</p>
<ul>
<li>
<p>Windows:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>cl.exe online.cpp /Feonline  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvJitLink_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre></div>
</div>
</li>
<li>
<p>Linux:</p>
<div class="highlight-text notranslate">
<div class="highlight"><pre><span></span>g++ online.cpp -o online \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvJitLink_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</section>
<section id="notices">
<h2>
<span class="section-number">14.4. </span>Notices<a class="headerlink" href="index.html#notices" title="Permalink to this headline"></a>
</h2>
<section id="notice">
<h3>
<span class="section-number">14.4.1. </span>Notice<a class="headerlink" href="index.html#notice" title="Permalink to this headline"></a>
</h3>
<p>This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (“NVIDIA”) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.</p>
<p>NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.</p>
<p>Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.</p>
<p>NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (“Terms of Sale”). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.</p>
<p>NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer’s own risk.</p>
<p>NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer’s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer’s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.</p>
<p>No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.</p>
<p>Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.</p>
<p>THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, “MATERIALS”) ARE BEING PROVIDED “AS IS.” NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA’s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.</p>
</section>
<section id="opencl">
<h3>
<span class="section-number">14.4.2. </span>OpenCL<a class="headerlink" href="index.html#opencl" title="Permalink to this headline"></a>
</h3>
<p>OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.</p>
</section>
<section id="trademarks">
<h3>
<span class="section-number">14.4.3. </span>Trademarks<a class="headerlink" href="index.html#trademarks" title="Permalink to this headline"></a>
</h3>
<p>NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="index.html#id4">1</a></span></dt>
<dd>
<p>Changes to compiler optimizer heuristics in the newer NVRTC shared library may also potentially cause performance perturbations for generated code.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="index.html#id6">2</a></span></dt>
<dd>
<p>These API functions modify the state of the associated <code class="docutils literal notranslate"><span class="pre">nvrtcProgram</span></code>.</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr>

  <div role="contentinfo">
<img src="../_static/NVIDIA-LogoBlack.svg" class="only-light">
<img src="../_static/NVIDIA-LogoWhite.svg" class="only-dark">

<p class="notices">
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">Privacy Policy</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">Manage My Privacy</a>
|
<a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">Do Not Sell or Share My Data</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">Terms of Service</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">Accessibility</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">Corporate Policies</a>
|
<a href="https://www.nvidia.com/en-us/product-security/" target="_blank">Product Security</a>
|
<a href="https://www.nvidia.com/en-us/contact/" target="_blank">Contact</a>
</p>

<p>
  Copyright © 2014-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
</p>

    <p>
      <span class="lastupdated">Last updated on Aug 1, 2024.
      </span></p>

  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
 
<script type="text/javascript">if (typeof _satellite !== "undefined"){_satellite.pageBottom();}</script>
 


<script type="text/javascript">_satellite.pageBottom();</script>
</body>
</html>
