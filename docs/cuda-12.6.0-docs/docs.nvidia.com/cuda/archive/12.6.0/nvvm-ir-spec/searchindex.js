const searchData = {"envversion": {"sphinx.domains.c": 2, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 5, "sphinx.domains.index": 1, "sphinx.domains.javascript": 2, "sphinx.domains.math": 2, "sphinx.domains.python": 3, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.mermaid": 1, "repo_docs.ext.enhanced_search": 2, "sphinx": 56}, "data": [{"id": 0, "doc_id": 0, "filename": "contents.html", "domain_name": "std", "name": "contents", "display_name": "Contents", "type": "doc", "display_type": "Page", "docname": "contents", "anchor": "", "priority": -1, "content": "Introduction Identifiers High Level Structure Linkage Types Calling Conventions Rules and Restrictions Visibility Styles DLL Storage Classes Thread Local Storage Models Runtime Preemption Specifiers Structure Types Non-Integral Pointer Type Comdats source_filename Global Variables Functions Aliases Ifuncs Named Metadata Parameter Attributes Garbage Collector Strategy Names Prefix Data Prologue Data Attribute Groups Function Attributes Global Attributes Operand Bundles Module-Level Inline Assembly Data Layout Target Triple Pointer Aliasing Rules Volatile Memory Access Memory Model for Concurrent Operations Atomic Memory Ordering Constraints Fast-Math Flags Use-list Order Directives Type System Constants Other Values Inline Assembler Expressions Metadata Metadata Nodes and Metadata Strings ThinLTO Summary Intrinsic Global Variables Instructions Terminator Instructions Binary Operations Bitwise Binary Operations Vector Operations Aggregate Operations Memory Access and Addressing Operations alloca Instruction load Instruction store Instruction fence Instruction cmpxchg Instruction atomicrmw Instruction getelementptr Instruction Conversion Operations Other Operations Intrinsic Functions Variable Argument Handling Intrinsics Accurate Garbage Collection Intrinsics Code Generator Intrinsics Standard C Library Intrinsics Bit Manipulations Intrinsics Specialised Arithmetic Intrinsics Arithmetic with Overflow Intrinsics Half Precision Floating Point Intrinsics Debugger Intrinsics Exception Handling Intrinsics Trampoline Intrinsics Masked Vector Load and Store Intrinsics Masked Vector Expanding Load and Compressing Store Intrinsics Experimental Vector Reduction Intrinsics Constrained Floating Point Intrinsics Constrained libm-equivalent Intrinsics Masked Vector Gather and Scatter Intrinsics Memory Use Markers General Intrinsics Element Wise Atomic Memory Intrinsics Stack Map Intrinsics Address Space Address Spaces Generic Pointers and Non-Generic Pointers Generic Pointers vs. Non-generic Pointers Conversion No Aliasing between Two Different Specific Address Spaces The alloca Instruction Global Property Annotation Overview Representation of Properties Supported Properties Texture and Surface Texture Variable and Surface Variable Accessing Texture Memory or Surface Memory NVVM Specific Intrinsic Functions Atomic Barrier and Memory Fence Address space conversion Special Registers Texture/Surface Access Texture Reads Surface Loads Surface Stores Warp-level Operations Barrier Synchronization Data Movement Vote Match Matrix Operation Load Fragments Store Fragments Matrix Multiply-and-Accumulate Source Level Debugging Support NVVM ABI for PTX Linkage Types Parameter Passing and Return Revision History Notices Notice OpenCL Trademarks", "keywords": []}, {"id": 1, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#accessing-texture-memory-or-surface-memory", "display_name": "Accessing Texture Memory or Surface Memory", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "accessing-texture-memory-or-surface-memory", "priority": -1, "content": "Texture memory and surface memory can be accessed using texture or surface handles. NVVM provides the following intrinsic function to get a texture or surface handle from a texture or surface variable. delcare i64 %llvm.nvvm.texsurf.handle.p1i64(metadata, i64 addrspace(1)*) The first argument to the intrinsic is a metadata holding the texture or surface variable. Such a metadata may hold only one texture or one surface variable. The second argument to the intrinsic is the texture or surface variable itself. The intrinsic returns a handle of i64 type. The returned handle value from the intrinsic call can be used as an operand (with a constraint of l) in a PTX inline asm to access the texture or surface memory.", "keywords": []}, {"id": 2, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#accurate-garbage-collection-intrinsics", "display_name": "Accurate Garbage Collection Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "accurate-garbage-collection-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 3, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#address-space-conversion", "display_name": "Address space conversion", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "address-space-conversion", "priority": -1, "content": "Attention: Please use the addrspacecast IR instruction for address space conversion.", "keywords": []}, {"id": 4, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#address-spaces", "display_name": "Address Spaces", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "address-spaces", "priority": -1, "content": "NVVM IR has a set of predefined memory address spaces, whose semantics are similar to those defined in CUDA C/C++, OpenCL C and PTX. Any address space not listed below is not supported . Name Address Space Number Semantics/Example code 0 functions, code CUDA C/C++ function OpenCL C function generic 0 Can only be used to qualify the pointee of a pointer Pointers in CUDA C/C++ global 1 CUDA C/C++ __device__ OpenCL C global shared 3 CUDA C/C++ __shared__ OpenCL C local constant 4 CUDA C/C++ __constant__ OpenCL C constant local 5 CUDA C/C++ local OpenCL C private &lt;reserved&gt; 2, 101 and above Each global variable, that is not an intrinsic global variable, can be declared to reside in a specific non-zero address space, which can only be one of the following: global , shared or constant . If a non-intrinsic global variable is declared without any address space number or with the address space number 0, then this global variable resides in address space global and the pointer of this global variable holds a generic pointer value. The predefined NVVM memory spaces are needed for the language front-ends to model the memory spaces in the source languages. For example, // CUDA C/C++ __constant__ int c; __device__ int g; ; NVVM IR @c = addrspace(4) global i32 0, align 4 @g = addrspace(1) global [2 x i32] zeroinitializer, align 4 Address space numbers 2 and 101 or higher are reserved for NVVM compiler internal use only. No language front-end should generate code that uses these address spaces directly.", "keywords": []}, {"id": 5, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#aggregate-operations", "display_name": "Aggregate Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "aggregate-operations", "priority": -1, "content": "Supported: extractvalue insertvalue", "keywords": []}, {"id": 6, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#aliases", "display_name": "Aliases", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "aliases", "priority": -1, "content": "Supported only as aliases of non-kernel functions.", "keywords": []}, {"id": 7, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#alloca-instruction", "display_name": "alloca Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "alloca-instruction", "priority": -1, "content": "The alloca instruction returns a generic pointer to the local address space. The inalloca attribute is not supported. Maximum alignment supported is 2^23. The addrspace(&lt;num&gt;) specifier is supported only if num is 0.", "keywords": []}, {"id": 8, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#arithmetic-with-overflow-intrinsics", "display_name": "Arithmetic with Overflow Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "arithmetic-with-overflow-intrinsics", "priority": -1, "content": "Supported for i16 , i32 , and i64 .", "keywords": []}, {"id": 9, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#atomic", "display_name": "Atomic", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "atomic", "priority": -1, "content": "Besides the atomic instructions, the following extra atomic intrinsic functions are supported. declare float @llvm.nvvm.atomic.load.add.f32.p0f32(float* address, float val) declare float @llvm.nvvm.atomic.load.add.f32.p1f32(float addrspace(1)* address, float val) declare float @llvm.nvvm.atomic.load.add.f32.p3f32(float addrspace(3)* address, float val) declare double @llvm.nvvm.atomic.load.add.f64.p0f64(double* address, double val) declare double @llvm.nvvm.atomic.load.add.f64.p1f64(double addrspace(1)* address, double val) declare double @llvm.nvvm.atomic.load.add.f64.p3f64(double addrspace(3)* address, double val) reads the single/double precision floating point value old located at the address address , computes old+val , and stores the result back to memory at the same address. These operations are performed in one atomic transaction. The function returns old . declare i32 @llvm.nvvm.atomic.load.inc.32.p0i32(i32* address, i32 val) declare i32 @llvm.nvvm.atomic.load.inc.32.p1i32(i32 addrspace(1)* address, i32 val) declare i32 @llvm.nvvm.atomic.load.inc.32.p3i32(i32 addrspace(3)* address, i32 val) reads the 32-bit word old located at the address address , computes ((old &gt;= val) ? 0 : (old+1)) , and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old . declare i32 @llvm.nvvm.atomic.load.dec.32.p0i32(i32* address, i32 val) declare i32 @llvm.nvvm.atomic.load.dec.32.p1i32(i32 addrspace(1)* address, i32 val) declare i32 @llvm.nvvm.atomic.load.dec.32.p3i32(i32 addrspace(3)* address, i32 val) reads the 32-bit word old located at the address address , computes (((old == 0) | (old &gt; val)) ? val : (old-1) ) , and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old .", "keywords": []}, {"id": 10, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#atomic-memory-ordering-constraints", "display_name": "Atomic Memory Ordering Constraints", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "atomic-memory-ordering-constraints", "priority": -1, "content": "Atomic loads and stores are not supported. Other atomic operations on other than 32-bit or 64-bit operands are not supported.", "keywords": []}, {"id": 11, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#atomicrmw-instruction", "display_name": "atomicrmw Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "atomicrmw-instruction", "priority": -1, "content": "nand is not supported. The other keywords are supported for i32 , i64 , and i128 types, with the following restrictions. The pointer must be either a global pointer, a shared pointer, or a generic pointer that points to either the global address space or the shared address space. For i128 , only xchg is supported, and only on compute_90 and above.", "keywords": []}, {"id": 12, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#attribute-groups", "display_name": "Attribute Groups", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "attribute-groups", "priority": -1, "content": "Fully supported. The set of supported attributes is equal to the set of attributes accepted where the attribute group is used.", "keywords": []}, {"id": 13, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#barrier-and-memory-fence", "display_name": "Barrier and Memory Fence", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "barrier-and-memory-fence", "priority": -1, "content": "declare void @llvm.nvvm.barrier0() waits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to llvm.nvvm.barrier0() are visible to all threads in the block. declare i32 @llvm.nvvm.barrier0.popc(i32) is identical to llvm.nvvm.barrier0() with the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non-zero. declare i32 @llvm.nvvm.barrier0.and(i32) is identical to llvm.nvvm.barrier0() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for all of them. declare i32 @llvm.nvvm.barrier0.or(i32) is identical to llvm.nvvm.barrier0() with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for any of them. declare void @llvm.nvvm.cluster.barrier(i32 %flags) Synchronize and communicate among threads in the same cluster. This intrinsic is only supported for Hopper+. The %flags is encoded according to the following table: %flags bits Meaning 31-8 Reserved 7-4 Memory ordering (See Cluster Barrier Memory Ordering Encoding below) 3-0 Operation mode (See Cluster Barrier Operation Mode Encoding below) Cluster Barrier Operation Mode Encoding Encoding Mode Description 0 Arrive Arrive at cluster barrier 1 Wait Wait at cluster barrier 2-15 RESERVED RESERVED Cluster Barrier Memory Ordering Encoding Encoding Mode Description 0 Default All synchronous memory accesses requested by the executing entry prior to arrive are performed and are visible to all the entrys in the cluster after wait. 1 Relaxed All previously fenced memory accesses requested by the executing entry prior to arrive are performed and are visible to all the entrys in the cluster after wait. This ordering is only supported when the operation mode is Arrive. 2-15 RESERVED RESERVED declare void @llvm.nvvm.membar.cta() is a memory fence at the thread block level. This intrinsic is deprecated. Please use nvvm.membar with flags as argument instead. declare void @llvm.nvvm.membar.gl() is a memory fence at the device level. This intrinsic is deprecated. Please use nvvm.membar with flags as argument instead. declare void @llvm.nvvm.membar.sys() is a memory fence at the system level. This intrinsic is deprecated. Please use nvvm.membar with flags as argument instead. declare void @llvm.nvvm.membar(i32 %flags) Wait for all prior memory accesses requested by this thread to be performed at a membar level defined by the membar mode below. The memory barrier enforces vertical ordering only. It makes no guarantees as to execution synchronization with other threads. For horizontal synchronization, a barrier should be used instead, or in addition to membar. The %flags is encoded according to the following table: %flags bits Meaning 31-4 Reserved 3-0 Membar modes (See Membar Mode Encoding.) Membar Mode Encoding Encoding Mode Description 0 GLOBAL Membar at the global level 1 CTA Membar at the CTA level 2 SYSTEM Membar at the system level 3 RESERVED RESERVED 4 CLUSTER Membar at the cluster level, only on Hopper+ 5-15 RESERVED RESERVED", "keywords": []}, {"id": 14, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#barrier-synchronization", "display_name": "Barrier Synchronization", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "barrier-synchronization", "priority": -1, "content": "The following intrinsic performs a barrier synchronization among a subset of threads in a warp. declare void @llvm.nvvm.bar.warp.sync(i32 %membermask) This intrinsic causes executing thread to wait until all threads corresponding to %membermask have executed the same intrinsic with the same %membermask value before resuming execution. The argument %membership is a 32bit mask, with each bit corresponding to a lane in the warp. 1 means the thread is in the subset. The behavior of this intrinsic is undefined if the executing thread is not in the %membermask . For compute_62 or below, all threads in %membermask must call the same @llvm.nvvm.bar.warp.sync() in convergence, and only threads belonging to the %membermask can be active when the intrinsic is called. Otherwise, the behavior is undefined.", "keywords": []}, {"id": 15, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#binary-operations", "display_name": "Binary Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "binary-operations", "priority": -1, "content": "Supported: add fadd sub fsub mul fmul udiv sdiv fdiv urem srem frem", "keywords": []}, {"id": 16, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#bit-manipulations-intrinsics", "display_name": "Bit Manipulations Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "bit-manipulations-intrinsics", "priority": -1, "content": "llvm.bitreverse Supported for i8 , i16 , i32 , and i64 . llvm.bswap Supported for i16 , i32 , and i64 . llvm.ctpop Supported for i8 , i16 , i32 , i64 , and vectors of these types. llvm.ctlz Supported for i8 , i16 , i32 , i64 , and vectors of these types. llvm.cttz Supported for i8 , i16 , i32 , i64 , and vectors of these types. llvm.fshl Supported for i8 , i16 , i32 , and i64 . llvm.fshr Supported for i8 , i16 , i32 , and i64 .", "keywords": []}, {"id": 17, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#bitwise-binary-operations", "display_name": "Bitwise Binary Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "bitwise-binary-operations", "priority": -1, "content": "Supported: shl lshr ashr and or xor", "keywords": []}, {"id": 18, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#calling-conventions", "display_name": "Calling Conventions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "calling-conventions", "priority": -1, "content": "All LLVM calling convention markings are accepted and ignored. Functions and calls are generated according to the PTX calling convention.", "keywords": []}, {"id": 19, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#cmpxchg-instruction", "display_name": "cmpxchg Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cmpxchg-instruction", "priority": -1, "content": "Supported for i32 , i64 , and i128 types, with the following restrictions: The pointer must be either a global pointer, a shared pointer, or a generic pointer that points to either the global address space or the shared address space. The weak marker and the failure ordering are accepted and ignored. The i128 type is only supported on compute_90 and above.", "keywords": []}, {"id": 20, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#code-generator-intrinsics", "display_name": "Code Generator Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-generator-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 21, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#comdats", "display_name": "Comdats", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "comdats", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 22, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#constants", "display_name": "Constants", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "constants", "priority": -1, "content": "Fully supported, except for the following: Token constants is not supported. blockaddress(@function, %block) is not supported. For a constant expression that is used as the initializer of a global variable @g1 , if the constant expression contains a global identifier @g2 , then the constant expression is supported if it can be reduced to the form of bitcast+offset , where offset is an integer number (including 0 )", "keywords": []}, {"id": 23, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#constrained-floating-point-intrinsics", "display_name": "Constrained Floating Point Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "constrained-floating-point-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 24, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#constrained-libm-equivalent-intrinsics", "display_name": "Constrained libm-equivalent Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "constrained-libm-equivalent-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 25, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#conversion", "display_name": "Conversion", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "conversion", "priority": -1, "content": "The bit value of a generic pointer that points to a specific object may be different from the bit value of a specific pointer that points to the same object. The addrspacecast IR instruction should be used to perform pointer casts across address spaces (generic to non-generic or non-generic to generic). Casting a non-generic pointer to a different non-generic pointer is not supported. Casting from a generic to a non-generic pointer is undefined if the generic pointer does not point to an object in the target non-generic address space. inttoptr and ptrtoint are supported. inttoptr and ptrtoint are value preserving instructions when the two operands are of the same size. In general, using ptrtoint and inttoptr to implement an address space cast is undefined. The following intrinsic can be used to query if the argument pointer was derived from the address of a kernel function parameter that has the grid_constant property: i1 @llvm.nvvm.isspacep.grid_const(i8*) The following intrinsic can be used to query if the input generic pointer was derived from the address of a variable allocated in the shared address space, in a CTA that is part of the same cluster as the parent CTA of the invoking thread. This intrinsic is only supported for Hopper+. i1 @llvm.nvvm.isspacep.cluster_shared(i8*) The following intrinsics can be used to query if a generic pointer can be safely cast to a specific non-generic address space: i1 @llvm.nvvm.isspacep.const(i8*) i1 @llvm.nvvm.isspacep.global(i8*) i1 @llvm.nvvm.isspacep.local(i8*) i1 @llvm.nvvm.isspacep.shared(i8*) bitcast on pointers is supported, though LLVM IR forbids bitcast from being used to change the address space of a pointer.", "keywords": []}, {"id": 26, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#conversion-operations", "display_name": "Conversion Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "conversion-operations", "priority": -1, "content": "Supported: trunc .. to zext .. to sext .. to fptrunc .. to fpext .. to fptoui .. to fptosi .. to uitofp .. to sitofp .. to ptrtoint .. to inttoptr .. to addrspacecast .. to bitcast .. to See Conversion for a special use case of bitcast .", "keywords": []}, {"id": 27, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#data-layout", "display_name": "Data Layout", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "data-layout", "priority": -1, "content": "Only the following data layout is supported: 64-bit e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-i128:128:128-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64 The following data layouts are deprecated and will be removed in a future release. 32-bit e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-i128:128:128-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64 e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64 64-bit e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64", "keywords": []}, {"id": 28, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#data-movement", "display_name": "Data Movement", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "data-movement", "priority": -1, "content": "The following intrinsic synchronizes a subset of threads in a warp and then performs data movement among these threads. declare {i32, i1} @llvm.nvvm.shfl.sync.i32(i32 %membermask, i32 %mode, i32 %a, i32 %b, i32 %c) This intrinsic causes executing thread to wait until all threads corresponding to %membermask have executed the same intrinsic with the same %membermask value before reading data from other threads in the same warp. The argument %membership is a 32bit mask, with each bit corresponding to a lane in the warp. 1 means the thread is in the subset. Each thread in the currently executing warp will compute a source lane index j based on input arguments %b , %c , and %mode . If the computed source lane index j is in range, the returned i32 value will be the value of %a from lane j; otherwise, it will be the the value of %a from the current thread. If the thread corresponding to lane j is inactive, then the returned i32 value is undefined. The returned i1 value is set to 1 if the source lane j is in range, and otherwise set to 0. The argument %mode must be a constant and its encoding is specified in the following table. Encoding Meaning 0 IDX 1 UP 2 DOWN 3 BFLY Argument %b specifies a source lane or source lane offset, depending on %mode . Argument %c contains two packed values specifying a mask for logically splitting warps into sub-segments and an upper bound for clamping the source lane index. The following pseudo code illustrates the semantics of this intrinsic. wait until all threads in %membermask have arrived; %lane[4:0] = current_lane_id; // position of thread in warp %bval[4:0] = %b[4:0]; // source lane or lane offset (0..31) %cval[4:0] = %c[4:0]; // clamp value %mask[4:0] = %c[12:8]; %maxLane = (%lane[4:0] &amp; %mask[4:0]) | (%cval[4:0] &amp; ~%mask[4:0]); %minLane = (%lane[4:0] &amp; %mask[4:0]); switch (%mode) { case UP: %j = %lane - %bval; %pval = (%j &gt;= %maxLane); break; case DOWN: %j = %lane + %bval; %pval = (%j &lt;= %maxLane); break; case BFLY: %j = %lane ^ %bval; %pval = (%j &lt;= %maxLane); break; case IDX: %j = %minLane | (%bval[4:0] &amp; ~%mask[4:0]); %pval = (%j &lt;= %maxLane); break; } if (!%pval) %j = %lane; // copy from own lane if (thread at lane %j is active) %d = %a from lane %j else %d = undef return {%d, %pval} Note that the return values are undefined if the thread at the source lane is not in %membermask . The behavior of this intrinsic is undefined if the executing thread is not in the %membermask . For compute_62 or below, all threads in %membermask must call the same @llvm.nvvm.shfl.sync.i32() in convergence, and only threads belonging to the %membermask can be active when the intrinsic is called. Otherwise, the behavior is undefined.", "keywords": []}, {"id": 29, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#debugger-intrinsics", "display_name": "Debugger Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "debugger-intrinsics", "priority": -1, "content": "llvm.dbg.addr Supported. llvm.dbg.declare Supported. llvm.dbg.value Supported.", "keywords": []}, {"id": 30, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#dll-storage-classes", "display_name": "DLL Storage Classes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dll-storage-classes", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 31, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#element-wise-atomic-memory-intrinsics", "display_name": "Element Wise Atomic Memory Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "element-wise-atomic-memory-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 32, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#exception-handling-intrinsics", "display_name": "Exception Handling Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "exception-handling-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 33, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#experimental-vector-reduction-intrinsics", "display_name": "Experimental Vector Reduction Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "experimental-vector-reduction-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 34, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#fast-math-flags", "display_name": "Fast-Math Flags", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fast-math-flags", "priority": -1, "content": "Supported.", "keywords": []}, {"id": 35, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#fence-instruction", "display_name": "fence Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fence-instruction", "priority": -1, "content": "Not supported. Use NVVM intrinsic functions instead.", "keywords": []}, {"id": 36, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#function-attributes", "display_name": "Function Attributes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "function-attributes", "priority": -1, "content": "Supported: allocsize alwaysinline cold convergent inaccessiblememonly inaccessiblemem_or_argmemonly inlinehint minsize no-jump-tables noduplicate noinline noreturn norecurse nounwind &quot;null-pointer-is-valid&quot; optforfuzzing optnone optsize readnone readonly writeonly argmemonly speculatable strictfp Not Supported: alignstack builtin nonlazybind naked nobuiltin noimplicitfloat noredzone &quot;patchable-function&quot; probe-stack returns_twice sanitize_address sanitize_memory sanitize_thread sanitize_hwaddress ssp sspreq sspstrong &quot;stack-probe-size&quot; &quot;no-stack-arg-probe&quot; uwtable jumptable safestack &quot;thunk&quot; nocf_check shadowcallstack", "keywords": []}, {"id": 37, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#functions", "display_name": "Functions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "functions", "priority": -1, "content": "The following are not supported on functions: Alignment Explicit section Garbage collector name Prefix data Prologue Personality", "keywords": []}, {"id": 38, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#garbage-collector-strategy-names", "display_name": "Garbage Collector Strategy Names", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "garbage-collector-strategy-names", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 39, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#general-intrinsics", "display_name": "General Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "general-intrinsics", "priority": -1, "content": "llvm.var.annotation Accepted and ignored. llvm.ptr.annotation Accepted and ignored. llvm.annotation Accepted and ignored. llvm.codeview.annotation Not supported. llvm.trap Supported. llvm.debugtrap Not supported. llvm.stackguard Not supported. llvm.stackprotector Not supported. llvm.objectsize Not supported. llvm.expect Supported. llvm.assume Supported. llvm.ssa_copy Not supported. llvm.type.test Not supported. llvm.type.checked.load Not supported. llvm.donothing Supported. llvm.experimental.deoptimize Not supported. llvm.experimental.guard Not supported. llvm.load.relative Not supported. llvm.sideeffect Supported.", "keywords": []}, {"id": 40, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#generic-pointers-vs-non-generic-pointers", "display_name": "Generic Pointers vs. Non-generic Pointers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generic-pointers-vs-non-generic-pointers", "priority": -1, "content": "There are generic pointers and non-generic pointers in NVVM IR. A generic pointer is a pointer that may point to memory in any address space. A non-generic pointer points to memory in a specific address space. In NVVM IR, a generic pointer has a pointer type with the address space generic , while a non-generic pointer has a pointer type with a non-generic address space. Note that the address space number for the generic address space is 0\u2014the default in both NVVM IR and LLVM IR. The address space number for the code address space is also 0. Function pointers are qualified by address space code ( addrspace(0) ). Loads/stores via generic pointers are supported, as well as loads/stores via non-generic pointers. Loads/stores via function pointers are not supported @a = addrspace(1) global i32 0, align 4 ; &#x27;global&#x27; addrspace, @a holds a specific value @b = global i32 0, align 4 ; &#x27;global&#x27; addrspace, @b holds a generic value @c = addrspace(4) global i32 0, align 4 ; &#x27;constant&#x27; addrspace, @c holds a specific value ... = load i32 addrspace(1)* @a, align 4 ; Correct ... = load i32* @a, align 4 ; Wrong ... = load i32* @b, align 4 ; Correct ... = load i32 addrspace(1)* @b, align 4 ; Wrong ... = load i32 addrspace(4)* @c, align4 ; Correct ... = load i32* @c, align 4 ; Wrong", "keywords": []}, {"id": 41, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#getelementptr-instruction", "display_name": "getelementptr Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "getelementptr-instruction", "priority": -1, "content": "Fully supported.", "keywords": []}, {"id": 42, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#global-attributes", "display_name": "Global Attributes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "global-attributes", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 43, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#global-variables", "display_name": "Global Variables", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "global-variables", "priority": -1, "content": "A global variable, that is not an intrinsic global variable, may be optionally declared to reside in one of the following address spaces: global shared constant If no address space is explicitly specified, the global variable is assumed to reside in the global address space with a generic address value. See Address Space for details. thread_local variables are not supported. No explicit section (except for the metadata section) is allowed. Initializations of shared variables are not supported. Use undef initialization.", "keywords": []}, {"id": 44, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#half-precision-floating-point-intrinsics", "display_name": "Half Precision Floating Point Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "half-precision-floating-point-intrinsics", "priority": -1, "content": "Supported: llvm.convert.to.fp16 , llvm.convert.from.fp16", "keywords": []}, {"id": 45, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#id1", "display_name": "Linkage Types", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "id1", "priority": -1, "content": "The following table provides the mapping of NVVM IR linkage types associated with functions and global variables to PTX linker directives . LLVM Linkage Type PTX Linker Directive private , internal This is the default linkage type and does not require a linker directive. external Function with definition .visible Global variable with initialization Function without definition .extern Global variable without initialization common .common for the global address space, otherwise .weak available_externally , linkonce , linkonce_odr , weak , weak_odr .weak All other linkage types Not supported.", "keywords": []}, {"id": 46, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#identifiers", "display_name": "Identifiers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "identifiers", "priority": -1, "content": "The name of a named global identifier must have the form: @[a-zA-Z$_][a-zA-Z$_0-9]* Note that it cannot contain the . character. [@%]llvm.nvvm.* and [@%]nvvm.* are reserved words.", "keywords": []}, {"id": 47, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#ifuncs", "display_name": "Ifuncs", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ifuncs", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 48, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#inline-assembler-expressions", "display_name": "Inline Assembler Expressions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "inline-assembler-expressions", "priority": -1, "content": "Inline assembler of PTX instructions is supported, with the following supported constraints: Constraint Type c i8 h i16 r i32 l i64 f f32 d f64 The inline asm metadata !srcloc is accepted and ignored. The inline asm dialect inteldialect is not supported.", "keywords": []}, {"id": 49, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#intrinsic-global-variables", "display_name": "Intrinsic Global Variables", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "intrinsic-global-variables", "priority": -1, "content": "The llvm.used global variable is supported. The llvm.compiler.used global variable is supported The llvm.global_ctors global variable is not supported The llvm.global_dtors global variable is not supported", "keywords": []}, {"id": 50, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#linkage-types", "display_name": "Linkage Types", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "linkage-types", "priority": -1, "content": "Supported: private internal available_externally linkonce weak common linkonce_odr weak_odr external Not supported: appending extern_weak See NVVM ABI for PTX for details on how linkage types are translated to PTX.", "keywords": []}, {"id": 51, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#load-fragments", "display_name": "Load Fragments", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "load-fragments", "priority": -1, "content": "The following intrinsics synchronize all threads in a warp and then load a fragment of a matrix for each thread. ; load fragment A declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m16n16k16.ld.a.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m32n8k16.ld.a.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m8n32k16.ld.a.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); ; load fragment B declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m16n16k16.ld.b.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m32n8k16.ld.b.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32, i32, i32, i32, i32} @llvm.nvvm.hmma.m8n32k16.ld.b.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); ; load fragment C declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m16n16k16.ld.c.f32.p&lt;n&gt;f32(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m32n8k16.ld.c.f32.p&lt;n&gt;f32(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m8n32k16.ld.c.f32.p&lt;n&gt;f32(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); ; load fragment C declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m16n16k16.ld.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m32n8k16.ld.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m8n32k16.ld.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol); These intrinsics load and return a matrix fragment from memory at location %ptr . The matrix in memory must be in a canonical matrix layout with leading dimension %ldm . %rowcol specifies which the matrix in memory is row-major (0) or column-major (1). %rowcol must be a constant value. The returned sequence of values represent the fragment held by the calling thread. How the elements of a matrix are distributed among the fragments is opaque to the user and is different for matrix A , B and the accumulator. Therefore, three variants (i.e. ld.a , ld.b , and ld.c ) are provided. These intrinsics are overloaded based on the address spaces. The address space number &lt;n&gt; must be either 0 (generic), 1 (global) or 3 (shared). The behavior of this intrinsic is undefined if any thread in the warp has exited. These intrinsics are only available on compute_70 or higher.", "keywords": []}, {"id": 52, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#load-instruction", "display_name": "load Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "load-instruction", "priority": -1, "content": "load atomic is not supported.", "keywords": []}, {"id": 53, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#masked-vector-expanding-load-and-compressing-store-intrinsics", "display_name": "Masked Vector Expanding Load and Compressing Store Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "masked-vector-expanding-load-and-compressing-store-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 54, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#masked-vector-gather-and-scatter-intrinsics", "display_name": "Masked Vector Gather and Scatter Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "masked-vector-gather-and-scatter-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 55, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#masked-vector-load-and-store-intrinsics", "display_name": "Masked Vector Load and Store Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "masked-vector-load-and-store-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 56, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#match", "display_name": "Match", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "match", "priority": -1, "content": "The following intrinsics synchronize a subset of threads in a warp and then broadcast and compare a value across threads in the subset. declare i32 @llvm.nvvm.match.any.sync.i32(i32 %membermask, i32 %value) declare i32 @llvm.nvvm.match.any.sync.i64(i32 %membermask, i64 %value) declare {i32, i1} @llvm.nvvm.match.all.sync.i32(i32 %membermask, i32 %value) declare {i32, i1} @llvm.nvvm.match.all.sync.i64(i32 %membermask, i64 %value) These intrinsics cause executing thread to wait until all threads corresponding to %membermask have executed the same intrinsic with the same %membermask value before performing broadcast and compare of operand %value across all threads in the subset. The argument %membership is a 32bit mask, with each bit corresponding to a lane in the warp. 1 means the thread is in the subset. The i32 return value is a 32-bit mask where bit position in mask corresponds to thread\u2019s laneid. In the any version, the i32 return value is set to the mask of active threads in %membermask that have same value as operand %value . In the all version, if all active threads in %membermask have same value as operand %value , the i32 return value is set to %membermask , and the i1 value is set to 1. Otherwise, the i32 return value is set to 0 and the i1 return value is also set to 0. The behavior of this intrinsic is undefined if the executing thread is not in the %membermask . These intrinsics are only available on compute_70 or higher.", "keywords": []}, {"id": 57, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#matrix-multiply-and-accumulate", "display_name": "Matrix Multiply-and-Accumulate", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "matrix-multiply-and-accumulate", "priority": -1, "content": "The following intrinsics synchronize all threads in a warp and then perform a matrix multiply-and-accumulate operation. declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m16n16k16.mma.f16.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m32n8k16.mma.f16.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m8n32k16.mma.f16.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m16n16k16.mma.f32.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m32n8k16.mma.f32.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m8n32k16.mma.f32.f16(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, i32 %c0, i32 %c1, i32 %c2, i32 %c3); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m16n16k16.mma.f32.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m32n8k16.mma.f32.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); declare {float, float, float, float, float, float, float, float} @llvm.nvvm.hmma.m8n32k16.mma.f32.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m16n16k16.mma.f16.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m32n8k16.mma.f16.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); declare {i32, i32, i32, i32} @llvm.nvvm.hmma.m8n32k16.mma.f16.f32(i32 %rowcol, i32 %satf, i32 %a0, i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %b0, i32 %b1, i32 %b2, i32 %b3, i32 %b4, i32 %b5, i32 %b6, i32 %b7, float %c0, float %c1, float %c2, float %c3, float %c4, float %c5, float %c6, float %c7); These intrinsics perform a matrix multiply-and-accumulate operation. %rowcol specifies the layout of A and B fragments. It must be a constant value, which can have the following values and semantics. Encoding Meaning 0 A fragment is row-major, B fragment is row-major 1 A fragment is row-major, B fragment is column-major 2 A fragment is column-major, B fragment is row-major 3 A fragment is column-major, B fragment is column-major Support for %satf has been removed and this operand must be a constant zero. The behavior of these intrinsics are undefined if any thread in the warp has exited. These intrinsics are only available on compute_70 or higher.", "keywords": []}, {"id": 58, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#matrix-operation", "display_name": "Matrix Operation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "matrix-operation", "priority": -1, "content": "THIS IS PREVIEW FEATURE. SUPPORT MAY BE REMOVED IN FUTURE RELEASES. NVVM provides warp-level intrinsics for matrix multiply operations. The core operation is a matrix multiply and accumulate of the form: D = A*B + C, or C = A*B + C where A is an MxK matrix, B is a KxN matrix, while C and D are MxN matrices. C and D are also called accumulators. The element type of the A and B matrices is 16-bit floating point. The element type of the accumulators can be either 32-bit floating point or 16-bit floating point. All threads in a warp will collectively hold the contents of each matrix A , B , C and D . Each thread will hold only a fragment of matrix A , a fragment of matrix B , a fragment of matrix C , and a fragment of the result matrix D . How the elements of a matrix are distributed among the fragments is opaque to the user and is different for matrix A , B and the accumulator. A fragment is represented by a sequence of element values. For fp32 matrices, the element type is float . For fp16 matrices, the element type is i32 (each i32 value holds two fp16 values). The number of elements varies with the shape of the matrix.", "keywords": []}, {"id": 59, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#memory-model-for-concurrent-operations", "display_name": "Memory Model for Concurrent Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "memory-model-for-concurrent-operations", "priority": -1, "content": "Not applicable. Threads in an NVVM IR program must use atomic operations or barrier synchronization to communicate.", "keywords": []}, {"id": 60, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#memory-use-markers", "display_name": "Memory Use Markers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "memory-use-markers", "priority": -1, "content": "Supported: llvm.lifetime.start , llvm.lifetime.end , llvm.invariant.start , and llvm.invariant.end . Not supported: llvm.launder.invariant.group , llvm.strip.invariant.group .", "keywords": []}, {"id": 61, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#metadata-nodes-and-metadata-strings", "display_name": "Metadata Nodes and Metadata Strings", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "metadata-nodes-and-metadata-strings", "priority": -1, "content": "Fully supported. The following metadata are understood by the NVVM compiler: Specialized Metadata Nodes llvm.loop.unroll.count llvm.loop.unroll.disable llvm.loop.unroll.full callalign (see Rules and Restrictions for Calling Conventions) Module flags metadata ( llvm.module.flags ) is supported and verified, but the metadata values will be ignored. All other metadata is accepted and ignored.", "keywords": []}, {"id": 62, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#module-level-inline-assembly", "display_name": "Module-Level Inline Assembly", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "module-level-inline-assembly", "priority": -1, "content": "Supported.", "keywords": []}, {"id": 63, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#named-metadata", "display_name": "Named Metadata", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "named-metadata", "priority": -1, "content": "Accepted and ignored, except for the following: !nvvm.annotations : see Global Property Annotation !nvvmir.version !llvm.dbg.cu !llvm.module.flags The NVVM IR version is specified using a named metadata called !nvvmir.version . The !nvvmir.version named metadata may have one metadata node that contains the NVVM IR version for that module. If multiple such modules are linked together, the named metadata in the linked module may have more than one metadata node with each node containing a version. A metadata node with NVVM IR version takes either of the following forms: It may consist of two i32 values\u2014the first denotes the NVVM IR major version number and the second denotes the minor version number. If absent, the version number is assumed to be 1.0, which can be specified as: !nvvmir.version = !{!0} !0 = !{i32 1, i32 0} It may consist of four i32 values\u2014the first two denote the NVVM IR major and minor versions respectively. The third value denotes the NVVM IR debug metadata major version number, and the fourth value denotes the corresponding minor version number. If absent, the version number is assumed to be 1.0, which can be specified as: !nvvmir.version = !{!0} !0 = !{i32 1, i32 0, i32 1, i32 0} The version of NVVM IR described in this document is 2.0. The version of NVVM IR debug metadata described in this document is 3.1.", "keywords": []}, {"id": 64, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#no-aliasing-between-two-different-specific-address-spaces", "display_name": "No Aliasing between Two Different Specific Address Spaces", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-aliasing-between-two-different-specific-address-spaces", "priority": -1, "content": "Two different specific address spaces do not overlap. NVVM compiler assumes two memory accesses via non-generic pointers that point to different address spaces are not aliased.", "keywords": []}, {"id": 65, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#non-integral-pointer-type", "display_name": "Non-Integral Pointer Type", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "non-integral-pointer-type", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 66, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notice", "priority": -1, "content": "This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (\u201cNVIDIA\u201d) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (\u201cTerms of Sale\u201d). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer\u2019s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer\u2019s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer\u2019s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201cMATERIALS\u201d) ARE BEING PROVIDED \u201cAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA\u2019s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.", "keywords": []}, {"id": 67, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#opencl", "display_name": "OpenCL", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opencl", "priority": -1, "content": "OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.", "keywords": []}, {"id": 68, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#operand-bundles", "display_name": "Operand Bundles", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "operand-bundles", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 69, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#other-operations", "display_name": "Other Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "other-operations", "priority": -1, "content": "Supported: icmp fcmp phi select va_arg call (See Calling Conventions for other rules and restrictions.) Unsupported: landingpad catchpad cleanuppad", "keywords": []}, {"id": 70, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#overview", "display_name": "Overview", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "overview", "priority": -1, "content": "NVVM uses Named Metadata to annotate IR objects with properties that are otherwise not representable in the IR. The NVVM IR producers can use the Named Metadata to annotate the IR with properties, which the NVVM compiler can process.", "keywords": []}, {"id": 71, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#parameter-attributes", "display_name": "Parameter Attributes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameter-attributes", "priority": -1, "content": "Fully supported, except the following: Accepted and ignored: inreg nest Not supported: inalloca swiftself swifterror See Calling Conventions for the use of the attributes.", "keywords": []}, {"id": 72, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#parameter-passing-and-return", "display_name": "Parameter Passing and Return", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "parameter-passing-and-return", "priority": -1, "content": "The following table shows the mapping of function argument and return types in NVVM IR to PTX types. Source Type Size in Bits PTX Type Integer types &lt;= 32 .u32 or .b32 (zero-extended if unsigned) .s32 or .b32 (sign-extended if signed) 64 .u64 or .b64 (if unsigned) .s64 or .b64 (if signed) Pointer types (without byval attribute) 32 .u32 or .b32 64 .u64 or .b64 Floating-point types 32 .f32 or .b32 64 .f64 or .b64 Aggregate types Any size .align  align  .b8  name [ size ] Where align is overall aggregate or vector alignment in bytes, name is variable name associated with aggregate or vector, and size is the aggregate or vector size in bytes. Pointer types to aggregate with byval attribute 32 or 64 Vector type Any size", "keywords": []}, {"id": 73, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#pointer-aliasing-rules", "display_name": "Pointer Aliasing Rules", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "pointer-aliasing-rules", "priority": -1, "content": "Fully supported.", "keywords": []}, {"id": 74, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#prefix-data", "display_name": "Prefix Data", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "prefix-data", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 75, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#prologue-data", "display_name": "Prologue Data", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "prologue-data", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 76, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#representation-of-properties", "display_name": "Representation of Properties", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "representation-of-properties", "priority": -1, "content": "For each translation unit (that is, per bitcode file), there is a named metadata called nvvm.annotations . This named metadata contains a list of MDNodes. The first operand of each MDNode is an entity that the node is annotating using the remaining operands. Multiple MDNodes may provide annotations for the same entity, in which case their first operands will be same. The remaining operands of the MDNode are organized in order as &lt;property-name, value&gt;. The property-name operand is MDString, while the value is i32 . Starting with the operand after the annotated entity, every alternate operand specifies a property. The operand after a property is its value. The following is an example. !nvvm.annotations = !{!12, !13} !12 = !{void (i32, i32)* @_Z6kernelii, !&quot;kernel&quot;, i32 1} !13 = !{void ()* @_Z7kernel2v, !&quot;kernel&quot;, i32 1, !&quot;maxntidx&quot;, i32 16} If two bitcode files are being linked and both have a named metadata nvvm.annotations , the linked file will have a single merged named metadata. If both files define properties for the same entity foo , the linked file will have two MDNodes defining properties for foo . It is illegal for the files to have conflicting properties for the same entity.", "keywords": []}, {"id": 77, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#revision-history", "display_name": "Revision History", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "revision-history", "priority": -1, "content": "Version 1.0 Initial Release. Version 1.1 Added support for UVM managed variables in global property annotation. See Supported Properties . Version 1.2 Update to LLVM 3.4 for CUDA 7.0. Remove address space intrinsics in favor of addrspacecast . Add information about source level debugging support. Version 1.3 Add support for LLVM 3.8 for CUDA 8.0. Version 1.4 Add support for warp-level intrinsics. Version 1.5 Add support for LLVM 5.0 for CUDA 9.2. Version 1.6 Update to LLVM 7.0.1 for CUDA 11.2. Version 1.7 Add support for alloca with dynamic size. Version 1.8 Add support for i128 in data layout. Version 1.9 Modified text about ignoring shared variable initializations. Version 1.10 Added support for grid_constant kernel parameters for CUDA 11.7. Version 1.11 Added support for Hopper+ cluster intrinsics and max_blocks_per_cluster kernel property for CUDA 11.8. Deprecated support for 32-bit compilation. Version 2.0 Updated the NVVM IR to version 2.0 which is incompatible with NVVM IR version 1.x Removed address space conversion intrinsics. The IR verifier on 2.0 IR will give an error when these intrinsics are present. Clients of libNVVM are advised to use addrspacecast instruction instead. Stricter error checking on the supported datalayouts. Older style loop unroll pragma metadata on loop backedges is no longer supported. Clients are advised to use the newer loop pragma metadata defined by the LLVM framework. Shared variable initialization with non-undef values is no longer supported. In 1.x versions these initializers were ignored silently. This feature makes the 2.0 version incompatible with 1.x versions.", "keywords": []}, {"id": 78, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#rules-and-restrictions", "display_name": "Rules and Restrictions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "rules-and-restrictions", "priority": -1, "content": "When an argument with width less than 32-bit is passed, the zeroext/signext parameter attribute should be set. zeroext will be assumed if not set. When a value with width less than 32-bit is returned, the zeroext/signext parameter attribute should be set. zeroext will be assumed if not set. Arguments of aggregate or vector types that are passed by value can be passed by pointer with the byval attribute set (referred to as the by-pointer-byval case below). The align attribute must be set if the type requires a non-natural alignment (natural alignment is the alignment inferred for the aggregate type according to the Data Layout section). If a function has an argument of aggregate or vector type that is passed by value directly and the type has a non-natural alignment requirement, the alignment must be annotated by the global property annotation &lt; align , alignment&gt;, where alignment is a 32-bit integer whose upper 16 bits represent the argument position (starting from 1) and the lower 16 bits represent the alignment. If the return type of a function is an aggregate or a vector that has a non-natural alignment, then the alignment requirement must be annotated by the global property annotation &lt; align , alignment&gt;, where the upper 16 bits is 0, and the lower 16 bits represent the alignment. It is not required to annotate a function with &lt; align , alignment&gt; otherwise. If annotated, the alignment must match the natural alignment or the align attribute in the by-pointer-byval case. For an indirect call instruction of a function that has a non-natural alignment for its return value or one of its arguments that is not expressed in alignment in the by-pointer-byval case, the call instruction must have an attached metadata of kind callalign . The metadata contains a sequence of i32 fields each of which represents a non-natural alignment requirement. The upper 16 bits of an i32 field represent the argument position (0 for return value, 1 for the first argument, and so on) and the lower 16 bits represent the alignment. The i32 fields must be sorted in the increasing order. For example, %call = call %struct.S %fp1(%struct.S* byval align 8 %arg1p, %struct.S %arg2),!callalign !10 !10 = !{i32 8, i32 520}; It is not required to have an i32 metadata field for the other arguments or the return value otherwise. If presented, the alignment must match the natural alignment or the align attribute in the by-pointer-byval case . It is not required to have a callalign metadata attached to a direct call instruction. If attached, the alignment must match the natural alignment or the alignment in the by-pointer-byval case. The absence of the metadata in an indirect call instruction means using natural alignment or the align attribute in the by-pointer-byval case.", "keywords": []}, {"id": 79, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#runtime-preemption-specifiers", "display_name": "Runtime Preemption Specifiers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "runtime-preemption-specifiers", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 80, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#source-filename", "display_name": "source_filename", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "source-filename", "priority": -1, "content": "Accepted and ignored.", "keywords": []}, {"id": 81, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#source-level-debugging-support", "display_name": "Source Level Debugging Support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "source-level-debugging-support", "priority": -1, "content": "To enable source level debugging of an IR module, NVVM IR supports debug intrinsics and debug information descriptors to express the debugging information. Debug information descriptors are represented using specialized metadata nodes. The current NVVM IR debug metadata version is 3.1. The current NVVM IR debugging support is based on that in LLVM 7.0.1. For the complete semantics of the IR, readers of this chapter should check the official LLVM IR specialized metadata nodes documentation ( https://releases.llvm.org/7.0.1/docs/LangRef.html#specialized-metadata-nodes ) and the Source Level Debugging with LLVM Manual ( https://releases.llvm.org/7.0.1/docs/SourceLevelDebugging.html ). The following metadata nodes need to be present in the module when debugging support is requested: Named metadata node !llvm.dbg.cu Module flags metadata for &quot;Debug Info Version&quot; flag: The behavior flag should be Error . The value of the flag should be DEBUG_METADATA_VERSION in LLVM 7.0.1, which is 3. Named metadata !nvvmir.version containing a metadata node with the NVVM IR major and minor version values followed by the NVVM IR debug metadata major and minor version values. The current NVVM IR debug metadata version is 3.1. The debug resolution (e.g., full, line info only) is controlled by the DICompileUnit\u2019s emissionKind field: FullDebug (value: 1) : Generate symbolic debug and line information. This requires the libNVVM -g option to be specified at compile time. DebugDirectivesOnly (value: 3) : Generate line information. Source level debugging is supported only for a single debug compile unit. If there are multiple input NVVM IR modules, at most one module may have a single debug compile unit.", "keywords": []}, {"id": 82, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#special-registers", "display_name": "Special Registers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "special-registers", "priority": -1, "content": "The following intrinsic functions are provided to support reading special PTX registers: declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() declare i32 @llvm.nvvm.read.ptx.sreg.tid.y() declare i32 @llvm.nvvm.read.ptx.sreg.tid.z() declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x() declare i32 @llvm.nvvm.read.ptx.sreg.ntid.y() declare i32 @llvm.nvvm.read.ptx.sreg.ntid.z() declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x() declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.y() declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.z() declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x() declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.y() declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.z() declare i32 @llvm.nvvm.read.ptx.sreg.warpsize()", "keywords": []}, {"id": 83, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#specialised-arithmetic-intrinsics", "display_name": "Specialised Arithmetic Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "specialised-arithmetic-intrinsics", "priority": -1, "content": "llvm.fmuladd Supported. llvm.canonicalize Not supported.", "keywords": []}, {"id": 84, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#stack-map-intrinsics", "display_name": "Stack Map Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "stack-map-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 85, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#standard-c-library-intrinsics", "display_name": "Standard C Library Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "standard-c-library-intrinsics", "priority": -1, "content": "llvm.memcpy Supported. Note that the constant address space cannot be used as the destination since it is read-only. llvm.memmove Supported. Note that the constant address space cannot be used since it is read-only. llvm.memset Supported. Note that the constant address space cannot be used since it is read-only. llvm.sqrt Supported for float/double and vector of float/double. Mapped to PTX sqrt.rn.f32 and sqrt.rn.f64 . llvm.powi Not supported. llvm.sin Not supported. llvm.cos Not supported. llvm.pow Not supported. llvm.exp Not supported. llvm.exp2 Not supported. llvm.log Not supported. llvm.log10 Not supported. llvm.log2 Not supported. llvm.fma Supported for float/double and vector of float/double. Mapped to PTX fma.rn.f32 and fma.rn.f64 llvm.fabs Not supported. llvm.copysign Not supported. llvm.floor Not supported. llvm.ceil Not supported. llvm.trunc Not supported. llvm.rint Not supported. llvm.nearbyint Not supported. llvm.round Not supported. llvm.minnum Not supported. llvm.maxnum Not supported.", "keywords": []}, {"id": 86, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#store-fragments", "display_name": "Store Fragments", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "store-fragments", "priority": -1, "content": "The following intrinsics synchronize all threads in a warp and then store a fragment of a matrix for each thread. ; The last 8 arguments are the elements of the C fragment declare void @llvm.nvvm.hmma.m16n16k16.st.c.f32.p&lt;n&gt;float(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, float, float, float, float, float, float, float, float); declare void @llvm.nvvm.hmma.m32n8k16.st.c.f32.p&lt;n&gt;float(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, float, float, float, float, float, float, float, float); declare void @llvm.nvvm.hmma.m8n32k16.st.c.f32.p&lt;n&gt;float(float addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, float, float, float, float, float, float, float, float); ; The last 4 arguments are the elements of the C fragment declare void @llvm.nvvm.hmma.m16n16k16.st.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, i32, i32, i32, i32); declare void @llvm.nvvm.hmma.m32n8k16.st.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, i32, i32, i32, i32); declare void @llvm.nvvm.hmma.m8n32k16.st.c.f16.p&lt;n&gt;i32(i32 addrspace(&lt;n&gt;)* %ptr, i32 %ldm, i32 %rowcol, i32, i32, i32, i32); These intrinsics store an accumulator fragment to memory at location %ptr . The matrix in memory must be in a canonical matrix layout with leading dimension %ldm . %rowcol specifies which the matrix in memory is row-major (0) or column-major (1). %rowcol must be a constant value. These intrinsics are overloaded based on the address spaces. The address space number &lt;n&gt; must be either 0 (generic), 1 (global) or 3 (shared). The behavior of this intrinsic is undefined if any thread in the warp has exited. These intrinsics are only available on compute_70 or higher.", "keywords": []}, {"id": 87, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#store-instruction", "display_name": "store Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "store-instruction", "priority": -1, "content": "store atomic is not supported.", "keywords": []}, {"id": 88, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#structure-types", "display_name": "Structure Types", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "structure-types", "priority": -1, "content": "Fully supported.", "keywords": []}, {"id": 89, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#supported-properties", "display_name": "Supported Properties", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-properties", "priority": -1, "content": "Property Name Annotated On Description maxntid{x, y, z} kernel function Maximum expected CTA size from any launch. reqntid{x, y, z} kernel function Minimum expected CTA size from any launch. cluster_dim_{x,y,z} kernel function Support for cluster dimensions for Hopper+. If any dimension is specified as 0, then all dimensions must be specified as 0. cluster_max_blocks kernel function Maximum number of blocks per cluster. Must be non-zero. Only supported for Hopper+. minctasm kernel function Hint/directive to the compiler/driver, asking it to put at least these many CTAs on an SM. grid_constant kernel function The argument is a metadata node, which contains a list of integers, where each integer n denotes that the nth parameter has the grid_constant annotation (numbering from 1). The parameter\u2019s type must be of pointer type with byval attribute set. It is undefined behavior to write to memory pointed to by the parameter. This property is only supported for Volta+. maxnreg function Maximum number of registers for function. kernel function Signifies that this function is a kernel function. align function Signifies that the value in low 16-bits of the 32-bit value contains alignment of n th parameter type if its alignment is not the natural alignment. n is specified by high 16-bits of the value. For return type, n is 0. texture global variable Signifies that variable is a texture. surface global variable Signifies that variable is a surface. managed global variable Signifies that variable is a UVM managed variable.", "keywords": []}, {"id": 90, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#surface-loads", "display_name": "Surface Loads", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "surface-loads", "priority": -1, "content": "In the following intrinsics, &lt;clamp&gt; represents the surface clamp mode and can be one of the following: clamp , trap , or zero . For surface load instructions that operate on 8-bit data channels, the output operands are of type i16 . The high-order eight bits are undefined. Reading a 1D surface: i16 @llvm.nvvm.suld.1d.i8.&lt;clamp&gt;(i64 %tex, i32 %x) i16 @llvm.nvvm.suld.1d.i16.&lt;clamp&gt;(i64 %tex, i32 %x) i32 @llvm.nvvm.suld.1d.i32.&lt;clamp&gt;(i64 %tex, i32 %x) i64 @llvm.nvvm.suld.1d.i64.&lt;clamp&gt;(i64 %tex, i32 %x) %short2 @llvm.nvvm.suld.1d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x) %short2 @llvm.nvvm.suld.1d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x) %int2 @llvm.nvvm.suld.1d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x) %long2 @llvm.nvvm.suld.1d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x) %short4 @llvm.nvvm.suld.1d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x) %short4 @llvm.nvvm.suld.1d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x) %int4 @llvm.nvvm.suld.1d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x) Reading a 1D surface array: i16 @llvm.nvvm.suld.1d.array.i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) i16 @llvm.nvvm.suld.1d.array.i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) i32 @llvm.nvvm.suld.1d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) i64 @llvm.nvvm.suld.1d.array.i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %short2 @llvm.nvvm.suld.1d.array.v2i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %short2 @llvm.nvvm.suld.1d.array.v2i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %int2 @llvm.nvvm.suld.1d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %long2 @llvm.nvvm.suld.1d.array.v2i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %short4 @llvm.nvvm.suld.1d.array.v4i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %short4 @llvm.nvvm.suld.1d.array.v4i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) %int4 @llvm.nvvm.suld.1d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x) Reading a 2D surface: i16 @llvm.nvvm.suld.2d.i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) i16 @llvm.nvvm.suld.2d.i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) i32 @llvm.nvvm.suld.2d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) i64 @llvm.nvvm.suld.2d.i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %short2 @llvm.nvvm.suld.2d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %short2 @llvm.nvvm.suld.2d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %int2 @llvm.nvvm.suld.2d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %long2 @llvm.nvvm.suld.2d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %short4 @llvm.nvvm.suld.2d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %short4 @llvm.nvvm.suld.2d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) %int4 @llvm.nvvm.suld.2d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y) Reading a 2D surface array: i16 @llvm.nvvm.suld.2d.array.i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) i16 @llvm.nvvm.suld.2d.array.i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) i32 @llvm.nvvm.suld.2d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) i64 @llvm.nvvm.suld.2d.array.i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %short2 @llvm.nvvm.suld.2d.array.v2i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %short2 @llvm.nvvm.suld.2d.array.v2i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %int2 @llvm.nvvm.suld.2d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %long2 @llvm.nvvm.suld.2d.array.v2i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %short4 @llvm.nvvm.suld.2d.array.v4i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %short4 @llvm.nvvm.suld.2d.array.v4i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) %int4 @llvm.nvvm.suld.2d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y) Reading a 3D surface: i16 @llvm.nvvm.suld.3d.i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) i16 @llvm.nvvm.suld.3d.i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) i32 @llvm.nvvm.suld.3d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) i64 @llvm.nvvm.suld.3d.i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %short2 @llvm.nvvm.suld.3d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %short2 @llvm.nvvm.suld.3d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %int2 @llvm.nvvm.suld.3d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %long2 @llvm.nvvm.suld.3d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %short4 @llvm.nvvm.suld.3d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %short4 @llvm.nvvm.suld.3d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z) %int4 @llvm.nvvm.suld.3d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z)", "keywords": []}, {"id": 91, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#surface-stores", "display_name": "Surface Stores", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "surface-stores", "priority": -1, "content": "In the following intrinsics, &lt;clamp&gt; represents the surface clamp mode. It is trap for the formatted stores, and can be one of the following for unformatted stores: clamp , trap , or zero . For surface store instructions that operate on 8-bit data channels, the input operands are of type i16 . The high-order eight bits are ignored. Writing a 1D surface: ;; Unformatted void @llvm.nvvm.sust.b.1d.i8.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r) void @llvm.nvvm.sust.b.1d.i16.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r) void @llvm.nvvm.sust.b.1d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r) void @llvm.nvvm.sust.b.1d.i64.&lt;clamp&gt;(i64 %tex, i32 %x, i64 %r) void @llvm.nvvm.sust.b.1d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r, i16 %g) void @llvm.nvvm.sust.b.1d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r, i16 %g) void @llvm.nvvm.sust.b.1d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r, i32 %g) void @llvm.nvvm.sust.b.1d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x, i64 %r, i64 %g) void @llvm.nvvm.sust.b.1d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.1d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.1d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r, i32 %g, i32 %b, i32 %a) ;; Formatted void @llvm.nvvm.sust.p.1d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r) void @llvm.nvvm.sust.p.1d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r, i32 %g) void @llvm.nvvm.sust.p.1d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %r, i32 %g, i32 %b, i32 %a) Writing a 1D surface array: ;; Unformatted void @llvm.nvvm.sust.b.1d.array.i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r) void @llvm.nvvm.sust.b.1d.array.i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r) void @llvm.nvvm.sust.b.1d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r) void @llvm.nvvm.sust.b.1d.array.i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i64 %r) void @llvm.nvvm.sust.b.1d.array.v2i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r, i16 %g) void @llvm.nvvm.sust.b.1d.array.v2i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r, i16 %g) void @llvm.nvvm.sust.b.1d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r, i32 %g) void @llvm.nvvm.sust.b.1d.array.v2i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i64 %r, i64 %g) void @llvm.nvvm.sust.b.1d.array.v4i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.1d.array.v4i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.1d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r, i32 %g, i32 %b, i32 %a) ;; Formatted void @llvm.nvvm.sust.p.1d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r) void @llvm.nvvm.sust.p.1d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r, i32 %g) void @llvm.nvvm.sust.p.1d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %r, i32 %g, i32 %b, i32 %a) Writing a 2D surface: ;; Unformatted void @llvm.nvvm.sust.b.2d.i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r) void @llvm.nvvm.sust.b.2d.i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r) void @llvm.nvvm.sust.b.2d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r) void @llvm.nvvm.sust.b.2d.i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i64 %r) void @llvm.nvvm.sust.b.2d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r, i16 %g) void @llvm.nvvm.sust.b.2d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r, i16 %g) void @llvm.nvvm.sust.b.2d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r, i32 %g) void @llvm.nvvm.sust.b.2d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i64 %r, i64 %g) void @llvm.nvvm.sust.b.2d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.2d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.2d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r, i32 %g, i32 %b, i32 %a) ;; Formatted void @llvm.nvvm.sust.p.2d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r) void @llvm.nvvm.sust.p.2d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r, i32 %g) void @llvm.nvvm.sust.p.2d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %r, i32 %g, i32 %b, i32 %a) Writing a 2D surface array: ;; Unformatted void @llvm.nvvm.sust.b.2d.array.i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r) void @llvm.nvvm.sust.b.2d.array.i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r) void @llvm.nvvm.sust.b.2d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r) void @llvm.nvvm.sust.b.2d.array.i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i64 %r) void @llvm.nvvm.sust.b.2d.array.v2i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r, i16 %g) void @llvm.nvvm.sust.b.2d.array.v2i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r, i16 %g) void @llvm.nvvm.sust.b.2d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r, i32 %g) void @llvm.nvvm.sust.b.2d.array.v2i64.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i64 %r, i64 %g) void @llvm.nvvm.sust.b.2d.array.v4i8.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.2d.array.v4i16.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.2d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r, i32 %g, i32 %b, i32 %a) ;; Formatted void @llvm.nvvm.sust.p.2d.array.i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r) void @llvm.nvvm.sust.p.2d.array.v2i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r, i32 %g) void @llvm.nvvm.sust.p.2d.array.v4i32.&lt;clamp&gt;(i64 %tex, i32 %idx, i32 %x, i32 %y, i32 %r, i32 %g, i32 %b, i32 %a) Writing a 3D surface: ;; Unformatted void @llvm.nvvm.sust.b.3d.i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r) void @llvm.nvvm.sust.b.3d.i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r) void @llvm.nvvm.sust.b.3d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r) void @llvm.nvvm.sust.b.3d.i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i64 %r) void @llvm.nvvm.sust.b.3d.v2i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r, i16 %g) void @llvm.nvvm.sust.b.3d.v2i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r, i16 %g) void @llvm.nvvm.sust.b.3d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r, i32 %g) void @llvm.nvvm.sust.b.3d.v2i64.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i64 %r, i64 %g) void @llvm.nvvm.sust.b.3d.v4i8.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.3d.v4i16.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i16 %r, i16 %g, i16 %b, i16 %a) void @llvm.nvvm.sust.b.3d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r, i32 %g, i32 %b, i32 %a) ;; Formatted void @llvm.nvvm.sust.p.3d.i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r) void @llvm.nvvm.sust.p.3d.v2i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r, i32 %g) void @llvm.nvvm.sust.p.3d.v4i32.&lt;clamp&gt;(i64 %tex, i32 %x, i32 %y, i32 %z, i32 %r, i32 %g, i32 %b, i32 %a)", "keywords": []}, {"id": 92, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#target-triple", "display_name": "Target Triple", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "target-triple", "priority": -1, "content": "Only the following target triple is supported, where * can be any name: 64-bit: nvptx64-*-cuda The following target triple is deprecated, and will be removed in future release: 32-bit: nvptx-*-cuda", "keywords": []}, {"id": 93, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#terminator-instructions", "display_name": "Terminator Instructions", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "terminator-instructions", "priority": -1, "content": "Supported: ret br switch unreachable Unsupported: indirectbr invoke resume catchswitch catchret cleanupret", "keywords": []}, {"id": 94, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#texture-reads", "display_name": "Texture Reads", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "texture-reads", "priority": -1, "content": "Sampling a 1D texture: %float4 @llvm.nvvm.tex.unified.1d.v4f32.s32(i64 %tex, i32 %x) %float4 @llvm.nvvm.tex.unified.1d.v4f32.f32(i64 %tex, float %x) %float4 @llvm.nvvm.tex.unified.1d.level.v4f32.f32(i64 %tex, float %x, float %level) %float4 @llvm.nvvm.tex.unified.1d.grad.v4f32.f32(i64 %tex, float %x, float %dPdx, float %dPdy) %int4 @llvm.nvvm.tex.unified.1d.v4s32.s32(i64 %tex, i32 %x) %int4 @llvm.nvvm.tex.unified.1d.v4s32.f32(i64 %tex, float %x) %int4 @llvm.nvvm.tex.unified.1d.level.v4s32.f32(i64 %tex, float %x, float %level) %int4 @llvm.nvvm.tex.unified.1d.grad.v4s32.f32(i64 %tex, float %x, float %dPdx, float %dPdy) %int4 @llvm.nvvm.tex.unified.1d.v4u32.s32(i64 %tex, i32 %x) %int4 @llvm.nvvm.tex.unified.1d.v4u32.f32(i64 %tex, float %x) %int4 @llvm.nvvm.tex.unified.1d.level.v4u32.f32(i64 %tex, float %x, float %level) %int4 @llvm.nvvm.tex.unified.1d.grad.v4u32.f32(i64 %tex, float %x, float %dPdx, float %dPdy) Sampling a 1D texture array: %float4 @llvm.nvvm.tex.unified.1d.array.v4f32.s32(i64 %tex, i32 %idx, i32 %x) %float4 @llvm.nvvm.tex.unified.1d.array.v4f32.f32(i64 %tex, i32 %idx, float %x) %float4 @llvm.nvvm.tex.unified.1d.array.level.v4f32.f32(i64 %tex, i32 %idx, float %x, float %level) %float4 @llvm.nvvm.tex.unified.1d.array.grad.v4f32.f32(i64 %tex, i32 %idx, float %x, float %dPdx, float %dPdy) %int4 @llvm.nvvm.tex.unified.1d.array.v4s32.s32(i64 %tex, i32 %idx, i32 %x) %int4 @llvm.nvvm.tex.unified.1d.array.v4s32.f32(i64 %tex, i32 %idx, float %x) %int4 @llvm.nvvm.tex.unified.1d.array.level.v4s32.f32(i64 %tex, i32 %idx, float %x, float %level) %int4 @llvm.nvvm.tex.unified.1d.array.grad.v4s32.f32(i64 %tex, i32 %idx, float %x, float %dPdx, float %dPdy) %int4 @llvm.nvvm.tex.unified.1d.array.v4u32.s32(i64 %tex, i32 %idx, i32 %x) %int4 @llvm.nvvm.tex.unified.1d.array.v4u32.f32(i64 %tex, i32 %idx, float %x) %int4 @llvm.nvvm.tex.unified.1d.array.level.v4u32.f32(i64 %tex, i32 %idx, float %x, float %level) %int4 @llvm.nvvm.tex.unified.1d.array.grad.v4u32.f32(i64 %tex, i32 %idx, float %x, float %dPdx, float %dPdy) Sampling a 2D texture: %float4 @llvm.nvvm.tex.unified.2d.v4f32.s32(i64 %tex, i32 %x, i32 %y) %float4 @llvm.nvvm.tex.unified.2d.v4f32.f32(i64 %tex, float %x, float %y) %float4 @llvm.nvvm.tex.unified.2d.level.v4f32.f32(i64 %tex, float %x, float %y, float %level) %float4 @llvm.nvvm.tex.unified.2d.grad.v4f32.f32(i64 %tex, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) %int4 @llvm.nvvm.tex.unified.2d.v4s32.s32(i64 %tex, i32 %x, i32 %y) %int4 @llvm.nvvm.tex.unified.2d.v4s32.f32(i64 %tex, float %x, float %y,) %int4 @llvm.nvvm.tex.unified.2d.level.v4s32.f32(i64 %tex, float %x, float %y, float %level) %int4 @llvm.nvvm.tex.unified.2d.grad.v4s32.f32(i64 %tex, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) %int4 @llvm.nvvm.tex.unified.2d.v4u32.s32(i64 %tex, i32 %x i32 %y) %int4 @llvm.nvvm.tex.unified.2d.v4u32.f32(i64 %tex, float %x float %y) %int4 @llvm.nvvm.tex.unified.2d.level.v4u32.f32(i64 %tex, float %x, float %y, float %level) %int4 @llvm.nvvm.tex.unified.2d.grad.v4u32.f32(i64 %tex, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) Sampling a 2D texture array: %float4 @llvm.nvvm.tex.unified.2d.array.v4f32.s32(i64 %tex, i32 %idx, i32 %x, i32 %y) %float4 @llvm.nvvm.tex.unified.2d.array.v4f32.f32(i64 %tex, i32 %idx, float %x, float %y) %float4 @llvm.nvvm.tex.unified.2d.array.level.v4f32.f32(i64 %tex, i32 %idx, float %x, float %y, float %level) %float4 @llvm.nvvm.tex.unified.2d.array.grad.v4f32.f32(i64 %tex, i32 %idx, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) %int4 @llvm.nvvm.tex.unified.2d.array.v4s32.s32(i64 %tex, i32 %idx, i32 %x, i32 %y) %int4 @llvm.nvvm.tex.unified.2d.array.v4s32.f32(i64 %tex, i32 %idx, float %x, float %y) %int4 @llvm.nvvm.tex.unified.2d.array.level.v4s32.f32(i64 %tex, i32 %idx, float %x, float %y, float %level) %int4 @llvm.nvvm.tex.unified.2d.array.grad.v4s32.f32(i64 %tex, i32 %idx, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) %int4 @llvm.nvvm.tex.unified.2d.array.v4u32.s32(i64 %tex, i32 %idx, i32 %x i32 %y) %int4 @llvm.nvvm.tex.unified.2d.array.v4u32.f32(i64 %tex, i32 %idx, float %x float %y) %int4 @llvm.nvvm.tex.unified.2d.array.level.v4u32.f32(i64 %tex, i32 %idx, float %x, float %y, float %level) %int4 @llvm.nvvm.tex.unified.2d.array.grad.v4u32.f32(i64 %tex, i32 %idx, float %x, float %y, float %dPdx_x, float %dPdx_y, float %dPdy_x, float %dPdy_y) Sampling a 3D texture: %float4 @llvm.nvvm.tex.unified.3d.v4f32.s32(i64 %tex, i32 %x, i32 %y, i32 %z) %float4 @llvm.nvvm.tex.unified.3d.v4f32.f32(i64 %tex, float %x, float %y, float %z) %float4 @llvm.nvvm.tex.unified.3d.level.v4f32.f32(i64 %tex,float %x, float %y, float %z, float %level) %float4 @llvm.nvvm.tex.unified.3d.grad.v4f32.f32(i64 %tex, float %x, float %y, float %z, float %dPdx_x, float %dPdx_y, float %dPdx_z, float %dPdy_x, float %dPdy_y, float %dPdy_z) %int4 @llvm.nvvm.tex.unified.3d.v4s32.s32(i64 %tex, i32 %x, i32 %y, i32 %z) %int4 @llvm.nvvm.tex.unified.3d.v4s32.f32(i64 %tex, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.3d.level.v4s32.f32(i64 %tex, float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.3d.grad.v4s32.f32(i64 %tex, float %x, float %y, float %z, float %dPdx_x, float %dPdx_y, float %dPdx_z, float %dPdy_x, float %dPdy_y, float %dPdy_z) %int4 @llvm.nvvm.tex.unified.3d.v4u32.s32(i64 %tex, i32 %x i32 %y, i32 %z) %int4 @llvm.nvvm.tex.unified.3d.v4u32.f32(i64 %tex, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.3d.level.v4u32.f32(i64 %tex, float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.3d.grad.v4u32.f32(i64 %tex, float %x, float %y, float %z, float %dPdx_x, float %dPdx_y, float %dPdx_z, float %dPdy_x, float %dPdy_y, float %dPdy_z) Sampling a cube texture: %float4 @llvm.nvvm.tex.unified.cube.v4f32.f32(i64 %tex, float %x, float %y, float %z) %float4 @llvm.nvvm.tex.unified.cube.level.v4f32.f32(i64 %tex,float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.cube.v4s32.f32(i64 %tex, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.cube.level.v4s32.f32(i64 %tex, float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.cube.v4u32.f32(i64 %tex, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.cube.level.v4u32.f32(i64 %tex, float %x, float %y, float %z, float %level) Sampling a cube texture array: %float4 @llvm.nvvm.tex.unified.cube.array.v4f32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z) %float4 @llvm.nvvm.tex.unified.cube.array.level.v4f32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.cube.array.v4s32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.cube.array.level.v4s32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z, float %level) %int4 @llvm.nvvm.tex.unified.cube.array.v4u32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z) %int4 @llvm.nvvm.tex.unified.cube.array.level.v4u32.f32(i64 %tex, i32 %idx, float %x, float %y, float %z, float %level) Fetching a four-texel bilerp footprint: %float4 @llvm.nvvm.tld4.unified.r.2d.v4f32.f32(i64 %tex, float %x, float %y) %float4 @llvm.nvvm.tld4.unified.g.2d.v4f32.f32(i64 %tex, float %x, float %y) %float4 @llvm.nvvm.tld4.unified.b.2d.v4f32.f32(i64 %tex, float %x, float %y) %float4 @llvm.nvvm.tld4.unified.a.2d.v4f32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.r.2d.v4s32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.g.2d.v4s32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.b.2d.v4s32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.a.2d.v4s32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.r.2d.v4u32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.g.2d.v4u32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.b.2d.v4u32.f32(i64 %tex, float %x, float %y) %int4 @llvm.nvvm.tld4.unified.a.2d.v4u32.f32(i64 %tex, float %x, float %y)", "keywords": []}, {"id": 95, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#texture-surface-access", "display_name": "Texture/Surface Access", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "texture-surface-access", "priority": -1, "content": "The following intrinsic function is provided to convert a global texture/surface variable into a texture/surface handle. declare i64 %llvm.nvvm.texsurf.handle.p1i64(metadata, i64 addrspace(1)*) See Accessing Texture Memory or Surface Memory for details. The following IR definitions apply to all intrinsics in this section: type %float4 = { float, float, float, float } type %long2 = { i64, i64 } type %int4 = { i32, i32, i32, i32 } type %int2 = { i32, i32 } type %short4 = { i16, i16, i16, i16 } type %short2 = { i16, i16 }", "keywords": []}, {"id": 96, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#texture-variable-and-surface-variable", "display_name": "Texture Variable and Surface Variable", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "texture-variable-and-surface-variable", "priority": -1, "content": "A texture or a surface variable can be declared/defined as a global variable of i64 type with annotation texture or surface in the global address space. A texture or surface variable must have a name, which must follow identifier naming conventions. It is illegal to store to or load from the address of a texture or surface variable. A texture or a surface variable may only have the following uses: In a metadata node As an intrinsic function argument as shown below In llvm.used Global Variable", "keywords": []}, {"id": 97, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#the-alloca-instruction", "display_name": "The alloca Instruction", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "the-alloca-instruction", "priority": -1, "content": "The alloca instruction returns a generic pointer that only points to address space local .", "keywords": []}, {"id": 98, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#thinlto-summary", "display_name": "ThinLTO Summary", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "thinlto-summary", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 99, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#thread-local-storage-models", "display_name": "Thread Local Storage Models", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "thread-local-storage-models", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 100, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trademarks", "priority": -1, "content": "NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "keywords": []}, {"id": 101, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#trampoline-intrinsics", "display_name": "Trampoline Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trampoline-intrinsics", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 102, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#type-system", "display_name": "Type System", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "type-system", "priority": -1, "content": "Fully supported, except for the following: Floating point types half , fp128 , x86_fp80 and ppc_fp128 are not supported. The x86_mmx type is not supported. The token type is not supported. The non-integral pointer type is not supported.", "keywords": []}, {"id": 103, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#use-list-order-directives", "display_name": "Use-list Order Directives", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "use-list-order-directives", "priority": -1, "content": "Not supported.", "keywords": []}, {"id": 104, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#variable-argument-handling-intrinsics", "display_name": "Variable Argument Handling Intrinsics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "variable-argument-handling-intrinsics", "priority": -1, "content": "llvm.va_start Supported. llvm.va_end Supported. llvm.va_copy Supported.", "keywords": []}, {"id": 105, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#vector-operations", "display_name": "Vector Operations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "vector-operations", "priority": -1, "content": "Supported: extractelement insertelement shufflevector", "keywords": []}, {"id": 106, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#visibility-styles", "display_name": "Visibility Styles", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "visibility-styles", "priority": -1, "content": "All styles\u2014default, hidden, and protected\u2014are accepted and ignored.", "keywords": []}, {"id": 107, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#volatile-memory-access", "display_name": "Volatile Memory Access", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "volatile-memory-access", "priority": -1, "content": "Fully supported. Note that for code generation: ld.volatile and st.volatile will be generated.", "keywords": []}, {"id": 108, "doc_id": 109, "filename": "index.html", "domain_name": "page", "name": "index#vote", "display_name": "Vote", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "vote", "priority": -1, "content": "The following intrinsic synchronizes a subset of threads in a warp and then performs a reduce-and-broadcast of a predicate over all threads in the subset. declare {i32, i1} @llvm.nvvm.vote.sync(i32 %membermask, i32 %mode, i1 %predicate) This intrinsic causes executing thread to wait until all threads corresponding to %membermask have executed the same intrinsic with the same %membermask value before performing a reduce-and-broadcast of a predicate over all threads in the subset. The argument %membermask is a 32-bit mask, with each bit corresponding to a lane in the warp. 1 means the thread is in the subset. @llvm.nvvm.vote.sync() performs a reduction of the source %predicate across all threads in %membermask after the synchronization. The return value is the same across all threads in the %membermask . The element in the returned aggregate that holds the return value depends on %mode . The argument %mode must be a constant and its encoding is specified in the following table. Encoding Meaning return value 0 ALL i1: 1 if the source predicates is 1 for all thread in %membermask , 0 otherwise 1 ANY i1: 1 if the source predicate is 1 for any thread in %membermask , 0 otherwise 2 EQ i1: 1 if the source predicates are the same for all thread in %membermask , 0 otherwise 3 BALLOT i32: ballot data, containing the %predicate value from each thread in %membermask For the BALLOT mode, the i32 value represents the ballot data, which contains the %predicate value from each thread in %membermask in the bit position corresponding to the thread\u2019s land id. The bit value corresponding to a thread not in %membermask is 0. Note that the return values are undefined if the thread at the source lane is not in %membermask . The behavior of this intrinsic is undefined if the executing thread is not in the %membermask . For compute_62 or below, all threads in %membermask must call the same @llvm.nvvm.vote.sync() in convergence, and only threads belonging to the %membermask can be active when the intrinsic is called. Otherwise, the behavior is undefined.", "keywords": []}, {"id": 109, "doc_id": 109, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "Introduction", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "NVVM IR Specification Reference guide to the NVVM compiler (intermediate representation) based on the LLVM IR. NVVM IR is a compiler IR (intermediate representation) based on the LLVM IR. The NVVM IR is designed to represent GPU compute kernels (for example, CUDA kernels). High-level language front-ends, like the CUDA C compiler front-end, can generate NVVM IR. The NVVM compiler (which is based on LLVM) generates PTX code from NVVM IR. NVVM IR and NVVM compilers are mostly agnostic about the source language being used. The PTX codegen part of a NVVM compiler needs to know the source language because of the difference in DCI (driver/compiler interface). NVVM IR is a binary format and is based on a subset of LLVM IR bitcode format. This document uses only human-readable form to describe NVVM IR. Technically speaking, NVVM IR is LLVM IR with a set of rules, restrictions, and conventions, plus a set of supported intrinsic functions. A program specified in NVVM IR is always a legal LLVM program. A legal LLVM program may not be a legal NVVM program. There are three levels of support for NVVM IR. Supported: The feature is fully supported. Most IR features should fall into this category. Accepted and ignored: The NVVM compiler will accept this IR feature, but will ignore the required semantics. This applies to some IR features that do not have meaningful semantics on GPUs and that can be ignored. Calling convention markings are an example. Illegal, not supported: The specified semantics is not supported, such as a fence instruction. Future versions of NVVM may either support or accept and ignore IRs that are illegal in the current version. This document describes version 2.0 of the NVVM IR and version 3.1 of the NVVM debug metadata (see Source Level Debugging Support ). The 2.0 version of NVVM IR is incompatible with the previous version 1.11. Linking of NVVM IR Version 1.11 with 2.0 will result in compiler error. The current NVVM IR is based on LLVM 7.0.1. For the complete semantics of the IR, readers of this document should check the official LLVM Language Reference Manual ( https://releases.llvm.org/7.0.1/docs/LangRef.html ).", "keywords": []}]};