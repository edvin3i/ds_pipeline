const searchData = {"envversion": {"sphinx.domains.c": 2, "sphinx.domains.changeset": 1, "sphinx.domains.citation": 1, "sphinx.domains.cpp": 5, "sphinx.domains.index": 1, "sphinx.domains.javascript": 2, "sphinx.domains.math": 2, "sphinx.domains.python": 3, "sphinx.domains.rst": 2, "sphinx.domains.std": 2, "sphinx.ext.intersphinx": 1, "repo_docs.ext.toctree": 2, "repo_docs.ext.mermaid": 1, "repo_docs.ext.enhanced_search": 2, "sphinx": 56}, "data": [{"id": 0, "doc_id": 0, "filename": "contents.html", "domain_name": "std", "name": "contents", "display_name": "Contents", "type": "doc", "display_type": "Page", "docname": "contents", "anchor": "", "priority": -1, "content": "Introduction Overview CUDA Programming Model CUDA Sources Purpose of NVCC Supported Host Compilers Compilation Phases NVCC Identification Macro NVCC Phases Supported Input File Suffixes Supported Phases The CUDA Compilation Trajectory NVCC Command Options Command Option Types and Notation Command Option Description File and Path Specifications --output-file file ( -o ) --objdir-as-tempdir ( -objtemp ) --pre-include file,... ( -include ) --library library,... ( -l ) --define-macro def,... ( -D ) --undefine-macro def,... ( -U ) --include-path path,... ( -I ) --system-include path,... ( -isystem ) --library-path path,... ( -L ) --output-directory directory ( -odir ) --dependency-output file ( -MF ) --generate-dependency-targets ( -MP ) --compiler-bindir directory ( -ccbin ) --allow-unsupported-compiler ( -allow-unsupported-compiler ) --archiver-binary executable ( -arbin ) --cudart { none | shared | static } ( -cudart ) --cudadevrt { none | static } ( -cudadevrt ) --libdevice-directory directory ( -ldir ) --target-directory string ( -target-dir ) Options for Specifying the Compilation Phase --link ( -link ) --lib ( -lib ) --device-link ( -dlink ) --device-c ( -dc ) --device-w ( -dw ) --cuda ( -cuda ) --compile ( -c ) --fatbin ( -fatbin ) --cubin ( -cubin ) --ptx ( -ptx ) --preprocess ( -E ) --generate-dependencies ( -M ) --generate-nonsystem-dependencies ( -MM ) --generate-dependencies-with-compile ( -MD ) --generate-nonsystem-dependencies-with-compile ( -MMD ) --optix-ir ( -optix-ir ) --run ( -run ) Options for Specifying Behavior of Compiler/Linker --profile ( -pg ) --debug ( -g ) --device-debug ( -G ) --extensible-whole-program ( -ewp ) --no-compress ( -no-compress ) --generate-line-info ( -lineinfo ) --optimization-info kind,... ( -opt-info ) --optimize level ( -O ) --dopt kind ( -dopt ) --dlink-time-opt ( -dlto ) --gen-opt-lto ( -gen-opt-lto ) --split-compile number ( -split-compile ) --split-compile-extended number ( -split-compile-extended ) --ftemplate-backtrace-limit limit ( -ftemplate-backtrace-limit ) --ftemplate-depth limit ( -ftemplate-depth ) --no-exceptions ( -noeh ) --shared ( -shared ) --x { c | c++ | cu } ( -x ) --std { c++03 | c++11 | c++14 | c++17 | c++20 } ( -std ) --no-host-device-initializer-list ( -nohdinitlist ) --expt-relaxed-constexpr ( -expt-relaxed-constexpr ) --extended-lambda ( -extended-lambda ) --expt-extended-lambda ( -expt-extended-lambda ) --machine { 64 } ( -m ) --m64 ( -m64 ) --host-linker-script { use-lcs | gen-lcs } ( -hls ) --augment-host-linker-script ( -aug-hls ) --host-relocatable-link ( -r ) Options for Passing Specific Phase Options --compiler-options options,... ( -Xcompiler ) --linker-options options,... ( -Xlinker ) --archive-options options,... ( -Xarchive ) --ptxas-options options,... ( -Xptxas ) --nvlink-options options,... ( -Xnvlink ) Options for Guiding the Compiler Driver --forward-unknown-to-host-compiler ( -forward-unknown-to-host-compiler ) --forward-unknown-to-host-linker ( -forward-unknown-to-host-linker ) --forward-unknown-opts ( -forward-unknown-opts ) --forward-slash-prefix-opts ( -forward-slash-prefix-opts ) --dont-use-profile ( -noprof ) --threads number ( -t ) --dryrun ( -dryrun ) --verbose ( -v ) --keep ( -keep ) --keep-dir directory ( -keep-dir ) --save-temps ( -save-temps ) --clean-targets ( -clean ) --run-args arguments,... ( -run-args ) --use-local-env ( -use-local-env ) --input-drive-prefix prefix ( -idp ) --dependency-drive-prefix prefix ( -ddp ) --drive-prefix prefix ( -dp ) --dependency-target-name target ( -MT ) --no-align-double --no-device-link ( -nodlink ) --allow-unsupported-compiler ( -allow-unsupported-compiler ) Options for Steering CUDA Compilation --default-stream { legacy | null | per-thread } ( -default-stream ) Options for Steering GPU Code Generation --gpu-architecture ( -arch ) --gpu-code code,... ( -code ) --generate-code specification ( -gencode ) --relocatable-device-code { true | false } ( -rdc ) --entries entry,... ( -e ) --maxrregcount amount ( -maxrregcount ) --use_fast_math ( -use_fast_math ) --ftz { true | false } ( -ftz ) --prec-div { true | false } ( -prec-div ) --prec-sqrt { true | false } ( -prec-sqrt ) --fmad { true | false } ( -fmad ) --extra-device-vectorization ( -extra-device-vectorization ) --compile-as-tools-patch ( -astoolspatch ) --keep-device-functions ( -keep-device-functions ) --jump-table-density percentage ( -jtd ) Generic Tool Options --disable-warnings ( -w ) --source-in-ptx ( -src-in-ptx ) --restrict ( -restrict ) --Wno-deprecated-gpu-targets ( -Wno-deprecated-gpu-targets ) --Wno-deprecated-declarations ( -Wno-deprecated-declarations ) --Wreorder ( -Wreorder ) --Wdefault-stream-launch ( -Wdefault-stream-launch ) --Wmissing-launch-bounds ( -Wmissing-launch-bounds ) --Wext-lambda-captures-this ( -Wext-lambda-captures-this ) --Werror kind,... ( -Werror ) --display-error-number ( -err-no ) --no-display-error-number ( -no-err-no ) --diag-error errNum,... ( -diag-error ) --diag-suppress errNum,... ( -diag-suppress ) --diag-warn errNum,... ( -diag-warn ) --resource-usage ( -res-usage ) --device-stack-protector { true | false } ( -device-stack-protector ) --help ( -h ) --version ( -V ) --options-file file,... ( -optf ) --time filename ( -time ) --qpp-config config ( -qpp-config ) --list-gpu-code ( -code-ls ) --list-gpu-arch ( -arch-ls ) Phase Options Ptxas Options --allow-expensive-optimizations ( -allow-expensive-optimizations ) --compile-only ( -c ) --def-load-cache ( -dlcm ) --def-store-cache ( -dscm ) --device-debug ( -g ) --disable-optimizer-constants ( -disable-optimizer-consts ) --entry entry,... ( -e ) --fmad ( -fmad ) --force-load-cache ( -flcm ) --force-store-cache ( -fscm ) --generate-line-info ( -lineinfo ) --gpu-name gpuname ( -arch ) --help ( -h ) --machine ( -m ) --maxrregcount amount ( -maxrregcount ) --opt-level N ( -O ) --options-file file,... ( -optf ) --position-independent-code ( -pic ) --preserve-relocs ( -preserve-relocs ) --sp-bound-check ( -sp-bound-check ) --suppress-async-bulk-multicast-advisory-warning ( -suppress-async-bulk-multicast-advisory-warning ) --verbose ( -v ) --version ( -V ) --warning-as-error ( -Werror ) --warn-on-double-precision-use ( -warn-double-usage ) --warn-on-local-memory-usage ( -warn-lmem-usage ) --warn-on-spills ( -warn-spills ) --compile-as-tools-patch ( -astoolspatch ) --maxntid ( -maxntid ) --minnctapersm ( -minnctapersm ) --override-directive-values ( -override-directive-values ) --make-errors-visible-at-exit ( -make-errors-visible-at-exit ) --oFast-compile ( -Ofc ) --device-stack-protector { true | false } ( -device-stack-protector ) NVLINK Options --disable-warnings ( -w ) --preserve-relocs ( -preserve-relocs ) --verbose ( -v ) --warning-as-error ( -Werror ) --suppress-arch-warning ( -suppress-arch-warning ) --suppress-stack-size-warning ( -suppress-stack-size-warning ) --dump-callgraph ( -dump-callgraph ) --dump-callgraph-no-demangle ( -dump-callgraph-no-demangle ) --Xptxas ( -Xptxas ) --cpu-arch ( -cpu-arch ) --extra-warnings ( -extrawarn ) --gen-host-linker-script ( -ghls ) --ignore-host-info ( -ignore-host-info ) --keep-system-libraries ( -keep-system-libraries ) --kernels-used ( -kernels-used ) --options-file ( -optf ) --report-arch ( -report-arch ) --suppress-debug-info ( -suppress-debug-info ) --variables-used ( -variables used ) --device-stack-protector { true | false } ( -device-stack-protector ) NVCC Environment Variables GPU Compilation GPU Generations GPU Feature List Application Compatibility Virtual Architectures Virtual Architecture Feature List Further Mechanisms Just-in-Time Compilation Fatbinaries NVCC Examples Base Notation Shorthand Shorthand 1 Shorthand 2 Shorthand 3 Extended Notation Virtual Architecture Macros Using Separate Compilation in CUDA Code Changes for Separate Compilation NVCC Options for Separate Compilation Libraries Examples Optimization Of Separate Compilation Potential Separate Compilation Issues Object Compatibility JIT Linking Support Implicit CUDA Host Code Using __CUDA_ARCH__ Device Code in Libraries Miscellaneous NVCC Usage Cross Compilation Keeping Intermediate Phase Files Cleaning Up Generated Files Printing Code Generation Statistics Notices Notice OpenCL Trademarks", "keywords": []}, {"id": 1, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#allow-expensive-optimizations-allow-expensive-optimizations", "display_name": "--allow-expensive-optimizations (-allow-expensive-optimizations)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "allow-expensive-optimizations-allow-expensive-optimizations", "priority": -1, "content": "Enable (disable) to allow compiler to perform expensive optimizations using maximum available resources (memory and compile-time). If unspecified, default behavior is to enable this feature for optimization level &gt;= O2 .", "keywords": []}, {"id": 2, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#allow-unsupported-compiler-allow-unsupported-compiler", "display_name": "--allow-unsupported-compiler (-allow-unsupported-compiler)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "allow-unsupported-compiler-allow-unsupported-compiler", "priority": -1, "content": "Disable nvcc check for supported host compiler versions. Using an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.", "keywords": []}, {"id": 3, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#application-compatibility", "display_name": "Application Compatibility", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "application-compatibility", "priority": -1, "content": "Binary code compatibility over CPU generations, together with a published instruction set architecture is the usual mechanism for ensuring that distributed applications out there in the field will continue to run on newer versions of the CPU when these become mainstream. This situation is different for GPUs, because NVIDIA cannot guarantee binary compatibility without sacrificing regular opportunities for GPU improvements. Rather, as is already conventional in the graphics programming domain, nvcc relies on a two stage compilation model for ensuring application compatibility with future GPU generations.", "keywords": []}, {"id": 4, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#archive-options-options-xarchive", "display_name": "--archive-options options,... (-Xarchive)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "archive-options-options-xarchive", "priority": -1, "content": "Specify options directly to the library manager.", "keywords": []}, {"id": 5, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#archiver-binary-executable-arbin", "display_name": "--archiver-binary executable (-arbin)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "archiver-binary-executable-arbin", "priority": -1, "content": "Specify the path of the archiver tool used create static library with --lib .", "keywords": []}, {"id": 6, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#augment-host-linker-script-aug-hls", "display_name": "--augment-host-linker-script (-aug-hls)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "augment-host-linker-script-aug-hls", "priority": -1, "content": "Enables generation of host linker script that augments an existing host linker script (GNU/Linux only). See option --host-linker-script for more details.", "keywords": []}, {"id": 7, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#base-notation", "display_name": "Base Notation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "base-notation", "priority": -1, "content": "nvcc provides the options --gpu-architecture and --gpu-code for specifying the target architectures for both translation stages. Except for allowed short hands described below, the --gpu-architecture option takes a single value, which must be the name of a virtual compute architecture, while option --gpu-code takes a list of values which must all be the names of actual GPUs. nvcc performs a stage 2 translation for each of these GPUs, and will embed the result in the result of compilation (which usually is a host object file or executable). Example nvcc x.cu --gpu-architecture=compute_50 --gpu-code=sm_50,sm_52", "keywords": []}, {"id": 8, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#clean-targets-clean", "display_name": "--clean-targets (-clean)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "clean-targets-clean", "priority": -1, "content": "Delete all the non-temporary files that the same nvcc command would generate without this option. This option reverses the behavior of nvcc . When specified, none of the compilation phases will be executed. Instead, all of the non-temporary files that nvcc would otherwise create will be deleted.", "keywords": []}, {"id": 9, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cleaning-up-generated-files", "display_name": "Cleaning Up Generated Files", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cleaning-up-generated-files", "priority": -1, "content": "All files generated by a particular nvcc command can be cleaned up by repeating the command, but with additional option --clean-targets . This option is particularly useful after using --keep , because the --keep option usually leaves quite an amount of intermediate files around. Because using --clean-targets will remove exactly what the original nvcc command created, it is important to exactly repeat all of the options in the original command. For instance, in the following example, omitting --keep , or adding --compile will have different cleanup effects. nvcc acos.cu --keep nvcc acos.cu --keep --clean-targets", "keywords": []}, {"id": 10, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#code-changes-for-separate-compilation", "display_name": "Code Changes for Separate Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "code-changes-for-separate-compilation", "priority": -1, "content": "The code changes required for separate compilation of device code are the same as what you already do for host code, namely using extern and static to control the visibility of symbols. Note that previously extern was ignored in CUDA code; now it will be honored. With the use of static it is possible to have multiple device symbols with the same name in different files. For this reason, the CUDA API calls that referred to symbols by their string name are deprecated; instead the symbol should be referenced by its address.", "keywords": []}, {"id": 11, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#command-option-description", "display_name": "Command Option Description", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "command-option-description", "priority": -1, "content": "This section presents tables of nvcc options. The option type in the tables can be recognized as follows: Boolean options do not have arguments specified in the first column, while the other two types do. List options can be recognized by the repeat indicator ,... at the end of the argument. Long options are described in the first column of the options table, and short options occupy the second column.", "keywords": []}, {"id": 12, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#command-option-types-and-notation", "display_name": "Command Option Types and Notation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "command-option-types-and-notation", "priority": -1, "content": "Each nvcc option has a long name and a short name, which are interchangeable with each other. These two variants are distinguished by the number of hyphens that must precede the option name: long names must be preceded by two hyphens, while short names must be preceded by a single hyphen. For example, -I is the short name of --include-path . Long options are intended for use in build scripts, where the size of the option is less important than the descriptive value. In contrast, short options are intended for interactive use. nvcc recognizes three types of command options: boolean options, single value options, and list options. Boolean options do not have an argument; they are either specified on the command line or not. Single value options must be specified at most once, but list options may be repeated. Examples of each of these option types are, respectively: --verbose (switch to verbose mode), --output-file (specify output file), and --include-path (specify include path). Single value options and list options must have arguments, which must follow the name of the option itself by either one of more spaces or an equals character. When a one-character short name such as -I , -l , and -L is used, the value of the option may also immediately follow the option itself without being seperated by spaces or an equal character. The individual values of list options may be separated by commas in a single instance of the option, or the option may be repeated, or any combination of these two cases. Hence, for the two sample options mentioned above that may take values, the following notations are legal: -o file -o=file -Idir1,dir2 -I=dir3 -I dir4,dir5 Unless otherwise specified, long option names are used throughout this document. However, short names can be used instead of long names for the same effect.", "keywords": []}, {"id": 13, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#compile-as-tools-patch-astoolspatch", "display_name": "--compile-as-tools-patch (-astoolspatch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compile-as-tools-patch-astoolspatch", "priority": -1, "content": "Compile patch code for CUDA tools. Implies \u2013keep-device-functions . May only be used in conjunction with --ptx or --cubin or --fatbin . Shall not be used in conjunction with -rdc=true or -ewp . Some PTX ISA features may not be usable in this compilation mode.", "keywords": []}, {"id": 14, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#compile-c", "display_name": "--compile (-c)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compile-c", "priority": -1, "content": "Compile each .c , .cc , .cpp , .cxx , and .cu input file into an object file. Default Output File Name The source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "keywords": []}, {"id": 15, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#compile-only-c", "display_name": "--compile-only (-c)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compile-only-c", "priority": -1, "content": "Generate relocatable object.", "keywords": []}, {"id": 16, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#compiler-bindir-directory-ccbin", "display_name": "--compiler-bindir directory (-ccbin)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compiler-bindir-directory-ccbin", "priority": -1, "content": "Specify the directory in which the default host compiler executable resides. The host compiler executable name can be also specified to ensure that the correct host compiler is selected. In addition, driver prefix options ( --input-drive-prefix , --dependency-drive-prefix , or --drive-prefix ) may need to be specified, if nvcc is executed in a Cygwin shell or a MinGW shell on Windows.", "keywords": []}, {"id": 17, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#compiler-options-options-xcompiler", "display_name": "--compiler-options options,... (-Xcompiler)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "compiler-options-options-xcompiler", "priority": -1, "content": "Specify options directly to the compiler/preprocessor.", "keywords": []}, {"id": 18, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cpu-arch-cpu-arch", "display_name": "--cpu-arch (-cpu-arch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cpu-arch-cpu-arch", "priority": -1, "content": "Specify the name of the cpu target architecture.", "keywords": []}, {"id": 19, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cross-compilation", "display_name": "Cross Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cross-compilation", "priority": -1, "content": "Cross compilation is controlled by using the following nvcc command line option: --compiler-bindir is used for cross compilation, where the underlying host compiler is capable of generating objects for the target platform. On an x86 system, if a CUDA toolkit installation has been configured to support cross compilation to both Tegra and non-Tegra ARM targets, then nvcc will use the non-Tegra configuration by default, when an ARM host cross compiler has been specified. To use the Tegra configuration instead, pass \u201c -target-dir aarch64-linux \u201d to nvcc.", "keywords": []}, {"id": 20, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cubin-cubin", "display_name": "--cubin (-cubin)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cubin-cubin", "priority": -1, "content": "Compile all .cu and .ptx input files to device-only .cubin files. nvcc discards the host code for each .cu input file with this option. Default Output File Name The source file name extension is replaced by .cubin to create the default output file name. For example, the default output file name for x.cu is x.cubin .", "keywords": []}, {"id": 21, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cuda-cuda", "display_name": "--cuda (-cuda)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cuda-cuda", "priority": -1, "content": "Compile each .cu input file to a .cu.cpp.ii file. Default Output File Name .cu.cpp.ii is appended to the basename of the source file name to create the default output file name. For example, the default output file name for x.cu is x.cu.cpp.ii .", "keywords": []}, {"id": 22, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cuda-programming-model", "display_name": "CUDA Programming Model", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cuda-programming-model", "priority": -1, "content": "The CUDA Toolkit targets a class of applications whose control part runs as a process on a general purpose computing device, and which use one or more NVIDIA GPUs as coprocessors for accelerating single program, multiple data (SPMD) parallel jobs. Such jobs are self-contained, in the sense that they can be executed and completed by a batch of GPU threads entirely without intervention by the host process, thereby gaining optimal benefit from the parallel graphics hardware. The GPU code is implemented as a collection of functions in a language that is essentially C++, but with some annotations for distinguishing them from the host code, plus annotations for distinguishing different types of data memory that exists on the GPU. Such functions may have parameters, and they can be called using a syntax that is very similar to regular C function calling, but slightly extended for being able to specify the matrix of GPU threads that must execute the called function. During its life time, the host process may dispatch many parallel GPU tasks. For more information on the CUDA programming model, consult the CUDA C++ Programming Guide .", "keywords": []}, {"id": 23, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cuda-sources", "display_name": "CUDA Sources", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cuda-sources", "priority": -1, "content": "Source files for CUDA applications consist of a mixture of conventional C++ host code, plus GPU device functions. The CUDA compilation trajectory separates the device functions from the host code, compiles the device functions using the proprietary NVIDIA compilers and assembler, compiles the host code using a C++ host compiler that is available, and afterwards embeds the compiled GPU functions as fatbinary images in the host object file. In the linking stage, specific CUDA runtime libraries are added for supporting remote SPMD procedure calling and for providing explicit GPU manipulation such as allocation of GPU memory buffers and host-GPU data transfer.", "keywords": []}, {"id": 24, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cudadevrt-none-static-cudadevrt", "display_name": "--cudadevrt {none|static} (-cudadevrt)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cudadevrt-none-static-cudadevrt", "priority": -1, "content": "Specify the type of CUDA device runtime library to be used: no CUDA device runtime library, or static CUDA device runtime library. Allowed Values none static Default The static CUDA device runtime library is used by default.", "keywords": []}, {"id": 25, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#cudart-none-shared-static-cudart", "display_name": "--cudart {none|shared|static} (-cudart)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "cudart-none-shared-static-cudart", "priority": -1, "content": "Specify the type of CUDA runtime library to be used: no CUDA runtime library, shared/dynamic CUDA runtime library, or static CUDA runtime library. Allowed Values none shared static Default The static CUDA runtime library is used by default.", "keywords": []}, {"id": 26, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#debug-g", "display_name": "--debug (-g)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "debug-g", "priority": -1, "content": "Generate debug information for host code.", "keywords": []}, {"id": 27, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#def-load-cache-dlcm", "display_name": "--def-load-cache (-dlcm)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "def-load-cache-dlcm", "priority": -1, "content": "Default cache modifier on global/generic load.", "keywords": []}, {"id": 28, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#def-store-cache-dscm", "display_name": "--def-store-cache (-dscm)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "def-store-cache-dscm", "priority": -1, "content": "Default cache modifier on global/generic store.", "keywords": []}, {"id": 29, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#default-stream-legacy-null-per-thread-default-stream", "display_name": "--default-stream {legacy|null|per-thread} (-default-stream)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "default-stream-legacy-null-per-thread-default-stream", "priority": -1, "content": "Specify the stream that CUDA commands from the compiled program will be sent to by default. Allowed Values legacy The CUDA legacy stream (per context, implicitly synchronizes with other streams) per-thread Normal CUDA stream (per thread, does not implicitly synchronize with other streams) null Deprecated alias for legacy Default legacy is used as the default stream.", "keywords": []}, {"id": 30, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#define-macro-def-d", "display_name": "--define-macro def,... (-D)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "define-macro-def-d", "priority": -1, "content": "Define macros to be used during preprocessing. def can be either name or name = definition . name - Predefine name as a macro. name = definition - The contents of definition are tokenized and preprocessed as if they appear during translation phase three in a #define directive. The definition will be truncated by embedded new line characters.", "keywords": []}, {"id": 31, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dependency-drive-prefix-prefix-ddp", "display_name": "--dependency-drive-prefix prefix (-ddp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dependency-drive-prefix-prefix-ddp", "priority": -1, "content": "Specify the dependency drive prefix. On Windows, when generating dependency files (see --generate-dependencies ), all file names must be converted appropriately for the instance of make that is used. Some instances of make have trouble with the colon in absolute paths in the native Windows format, which depends on the environment in which the make instance has been compiled. Use /cygwin/ as prefix for a Cygwin make , and / as prefix for MinGW. Or leave these file names in the native Windows format by specifying nothing.", "keywords": []}, {"id": 32, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dependency-output-file-mf", "display_name": "--dependency-output file (-MF)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dependency-output-file-mf", "priority": -1, "content": "Specify the dependency output file. This option specifies the output file for the dependency generation step (see --generate-dependencies ). The option --generate-dependencies or --generate-nonystem-dependencies must be specified if a dependency output file is set.", "keywords": []}, {"id": 33, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dependency-target-name-target-mt", "display_name": "--dependency-target-name target (-MT)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dependency-target-name-target-mt", "priority": -1, "content": "Specify the target name of the generated rule when generating a dependency file (see --generate-dependencies ).", "keywords": []}, {"id": 34, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-c-dc", "display_name": "--device-c (-dc)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-c-dc", "priority": -1, "content": "Compile each .c , .cc , .cpp , .cxx , and .cu input file into an object file that contains relocatable device code. It is equivalent to --relocatable-device-code=true --compile . Default Output File Name The source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "keywords": []}, {"id": 35, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-code-in-libraries", "display_name": "Device Code in Libraries", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-code-in-libraries", "priority": -1, "content": "If a device function with non-weak external linkage is defined in a library as well as a non-library object (or another library), the device linker will complain about the multiple definitions (this differs from traditional host linkers that may ignore the function definition from the library object, if it was already found in an earlier object).", "keywords": []}, {"id": 36, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-debug-g", "display_name": "--device-debug (-G)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-debug-g", "priority": -1, "content": "Generate debug information for device code. If --dopt is not specified, then this option turns off all optimizations on device code. It is not intended for profiling; use --generate-line-info instead for profiling.", "keywords": []}, {"id": 37, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-link-dlink", "display_name": "--device-link (-dlink)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-link-dlink", "priority": -1, "content": "Link object files with relocatable device code and .ptx , .cubin , and .fatbin files into an object file with executable device code, which can be passed to the host linker. Default Output File Name a_dlink.obj on Windows or a_dlink.o on other platforms is used as the default output file name. When this option is used in conjunction with --fatbin , a_dlink.fatbin is used as the default output file name. When this option is used in conjunction with --cubin , a_dlink.cubin is used as the default output file name.", "keywords": []}, {"id": 38, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-stack-protector-true-false-device-stack-protector", "display_name": "--device-stack-protector {true|false} (-device-stack-protector)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-stack-protector-true-false-device-stack-protector", "priority": -1, "content": "Enable or disable the generation of stack canaries in device code. Stack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables. The compiler uses heuristics to assess the risk of such a bug in each function. Only those functions which are deemed high-risk make use of a stack canary. Allowed Values true false Default The generation of stack canaries in device code is disabled.", "keywords": []}, {"id": 39, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#device-w-dw", "display_name": "--device-w (-dw)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "device-w-dw", "priority": -1, "content": "Compile each .c , .cc , .cpp , .cxx , and .cu input file into an object file that contains executable device code. It is equivalent to --relocatable-device-code=false --compile . Default Output File Name The source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "keywords": []}, {"id": 40, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#diag-error-errnum-diag-error", "display_name": "--diag-error errNum,... (-diag-error)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "diag-error-errnum-diag-error", "priority": -1, "content": "Emit error for specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).", "keywords": []}, {"id": 41, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#diag-suppress-errnum-diag-suppress", "display_name": "--diag-suppress errNum,... (-diag-suppress)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "diag-suppress-errnum-diag-suppress", "priority": -1, "content": "Suppress specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).", "keywords": []}, {"id": 42, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#diag-warn-errnum-diag-warn", "display_name": "--diag-warn errNum,... (-diag-warn)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "diag-warn-errnum-diag-warn", "priority": -1, "content": "Emit warning for specified diagnostic message(s) generated by the CUDA frontend compiler (note: does not affect diagnostics generated by the host compiler/preprocessor).", "keywords": []}, {"id": 43, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#disable-optimizer-constants-disable-optimizer-consts", "display_name": "--disable-optimizer-constants (-disable-optimizer-consts)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "disable-optimizer-constants-disable-optimizer-consts", "priority": -1, "content": "Disable use of optimizer constant bank.", "keywords": []}, {"id": 44, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#disable-warnings-w", "display_name": "--disable-warnings (-w)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "disable-warnings-w", "priority": -1, "content": "Inhibit all warning messages.", "keywords": []}, {"id": 45, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#display-error-number-err-no", "display_name": "--display-error-number (-err-no)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "display-error-number-err-no", "priority": -1, "content": "This option displays a diagnostic number for any message generated by the CUDA frontend compiler (note: not the host compiler).", "keywords": []}, {"id": 46, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dlink-time-opt-dlto", "display_name": "--dlink-time-opt (-dlto)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dlink-time-opt-dlto", "priority": -1, "content": "Perform link-time optimization of device code. The option \u2018-lto\u2019 is also an alias to \u2018-dlto\u2019. Link-time optimization must be specified at both compile and link time; at compile time it stores high-level intermediate code, then at link time it links together and optimizes the intermediate code. If that intermediate is not found at link time then nothing happens. Intermediate code is also stored at compile time with the --gpu-code=&#x27;lto_NN&#x27; target. The options -dlto -arch=sm_NN will add a lto_NN target; if you want to only add a lto_NN target and not the compute_NN that -arch=sm_NN usually generates, use -arch=lto_NN .", "keywords": []}, {"id": 47, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dont-use-profile-noprof", "display_name": "--dont-use-profile (-noprof)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dont-use-profile-noprof", "priority": -1, "content": "Do not use configurations from the nvcc.profile file for compilation.", "keywords": []}, {"id": 48, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dopt-kind-dopt", "display_name": "--dopt kind (-dopt)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dopt-kind-dopt", "priority": -1, "content": "Enable device code optimization. When specified along with -G , enables limited debug information generation for optimized device code (currently, only line number information). When -G is not specified, -dopt=on is implicit. Allowed Values on : enable device code optimization.", "keywords": []}, {"id": 49, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#drive-prefix-prefix-dp", "display_name": "--drive-prefix prefix (-dp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "drive-prefix-prefix-dp", "priority": -1, "content": "Specify the drive prefix. This option specifies prefix as both --input-drive-prefix and --dependency-drive-prefix .", "keywords": []}, {"id": 50, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dryrun-dryrun", "display_name": "--dryrun (-dryrun)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dryrun-dryrun", "priority": -1, "content": "List the compilation sub-commands without executing them.", "keywords": []}, {"id": 51, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dump-callgraph-dump-callgraph", "display_name": "--dump-callgraph (-dump-callgraph)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dump-callgraph-dump-callgraph", "priority": -1, "content": "Dump information about the callgraph and register usage.", "keywords": []}, {"id": 52, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#dump-callgraph-no-demangle-dump-callgraph-no-demangle", "display_name": "--dump-callgraph-no-demangle (-dump-callgraph-no-demangle)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "dump-callgraph-no-demangle-dump-callgraph-no-demangle", "priority": -1, "content": "Dump callgraph information without demangling.", "keywords": []}, {"id": 53, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#entries-entry-e", "display_name": "--entries entry,... (-e)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "entries-entry-e", "priority": -1, "content": "Specify the global entry functions for which code must be generated. PTX generated for all entry functions, but only the selected entry functions are assembled. Entry function names for this option must be specified in the mangled name. Default nvcc generates code for all entry functions.", "keywords": []}, {"id": 54, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#entry-entry-e", "display_name": "--entry entry,... (-e)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "entry-entry-e", "priority": -1, "content": "Semantics same as nvcc option --entries .", "keywords": []}, {"id": 55, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#examples", "display_name": "Examples", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "examples", "priority": -1, "content": "Suppose we have the following files: //---------- b.h ---------- #define N 8 extern __device__ int g[N]; extern __device__ void bar(void); //---------- b.cu ---------- #include &quot;b.h&quot; __device__ int g[N]; __device__ void bar (void) { g[threadIdx.x]++; } //---------- a.cu ---------- #include &lt;stdio.h&gt; #include &quot;b.h&quot; __global__ void foo (void) { __shared__ int a[N]; a[threadIdx.x] = threadIdx.x; __syncthreads(); g[threadIdx.x] = a[blockDim.x - threadIdx.x - 1]; bar(); } int main (void) { unsigned int i; int *dg, hg[N]; int sum = 0; foo&lt;&lt;&lt;1, N&gt;&gt;&gt;(); if(cudaGetSymbolAddress((void**)&amp;dg, g)){ printf(&quot;couldn&#x27;t get the symbol addr\\n&quot;); return 1; } if(cudaMemcpy(hg, dg, N * sizeof(int), cudaMemcpyDeviceToHost)){ printf(&quot;couldn&#x27;t memcpy\\n&quot;); return 1; } for (i = 0; i &lt; N; i++) { sum += hg[i]; } if (sum == 36) { printf(&quot;PASSED\\n&quot;); } else { printf(&quot;FAILED (%d)\\n&quot;, sum); } return 0; } These can be compiled with the following commands (these examples are for Linux): nvcc --gpu-architecture=sm_50 --device-c a.cu b.cu nvcc --gpu-architecture=sm_50 a.o b.o If you want to invoke the device and host linker separately, you can do: nvcc --gpu-architecture=sm_50 --device-c a.cu b.cu nvcc --gpu-architecture=sm_50 --device-link a.o b.o --output-file link.o g++ a.o b.o link.o --library-path=&lt;path&gt; --library=cudart Note that all desired target architectures must be passed to the device linker, as that specifies what will be in the final executable (some objects or libraries may contain device code for multiple architectures, and the link step can then choose what to put in the final executable). If you want to use the driver API to load a linked cubin, you can request just the cubin: nvcc --gpu-architecture=sm_50 --device-link a.o b.o \\ --cubin --output-file link.cubin The objects could be put into a library and used with: nvcc --gpu-architecture=sm_50 --device-c a.cu b.cu nvcc --lib a.o b.o --output-file test.a nvcc --gpu-architecture=sm_50 test.a Note that only static libraries are supported by the device linker. A PTX file can be compiled to a host object file and then linked by using: nvcc --gpu-architecture=sm_50 --device-c a.ptx An example that uses libraries, host linker, and dynamic parallelism would be: nvcc --gpu-architecture=sm_50 --device-c a.cu b.cu nvcc --gpu-architecture=sm_50 --device-link a.o b.o --output-file link.o nvcc --lib --output-file libgpu.a a.o b.o link.o g++ host.o --library=gpu --library-path=&lt;path&gt; \\ --library=cudadevrt --library=cudart It is possible to do multiple device links within a single host executable, as long as each device link is independent of the other. This requirement of independence means that they cannot share code across device executables, nor can they share addresses (e.g., a device function address can be passed from host to device for a callback only if the device link sees both the caller and potential callback callee; you cannot pass an address from one device executable to another, as those are separate address spaces).", "keywords": []}, {"id": 56, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#expt-extended-lambda-expt-extended-lambda", "display_name": "--expt-extended-lambda (-expt-extended-lambda)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "expt-extended-lambda-expt-extended-lambda", "priority": -1, "content": "Alias for --extended-lambda .", "keywords": []}, {"id": 57, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#expt-relaxed-constexpr-expt-relaxed-constexpr", "display_name": "--expt-relaxed-constexpr (-expt-relaxed-constexpr)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "expt-relaxed-constexpr-expt-relaxed-constexpr", "priority": -1, "content": "Experimental flag  : Allow host code to invoke ``__device__ constexpr`` functions, and device code to invoke ``__host__ constexpr`` functions. Note that the behavior of this flag may change in future compiler releases.", "keywords": []}, {"id": 58, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#extended-lambda-extended-lambda", "display_name": "--extended-lambda (-extended-lambda)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "extended-lambda-extended-lambda", "priority": -1, "content": "Allow __host__ , __device__ annotations in lambda declarations.", "keywords": []}, {"id": 59, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#extended-notation", "display_name": "Extended Notation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "extended-notation", "priority": -1, "content": "The options --gpu-architecture and --gpu-code can be used in all cases where code is to be generated for one or more GPUs using a common virtual architecture. This will cause a single invocation of nvcc stage 1 (that is, preprocessing and generation of virtual PTX assembly code), followed by a compilation stage 2 (binary code generation) repeated for each specified GPU. Using a common virtual architecture means that all assumed GPU features are fixed for the entire nvcc compilation. For instance, the following nvcc command assumes no half-precision floating-point operation support for both the sm_50 code and the sm_53 code: nvcc x.cu --gpu-architecture=compute_50 --gpu-code=compute_50,sm_50,sm_53 Sometimes it is necessary to perform different GPU code generation steps, partitioned over different architectures. This is possible using nvcc option --generate-code , which then must be used instead of a --gpu-architecture and --gpu-code combination. Unlike option --gpu-architecture option --generate-code , may be repeated on the nvcc command line. It takes sub-options arch and code , which must not be confused with their main option equivalents, but behave similarly. If repeated architecture compilation is used, then the device code must use conditional compilation based on the value of the architecture identification macro __CUDA_ARCH__ , which is described in the next section. For example, the following assumes absence of half-precision floating-point operation support for the sm_50 and sm_52 code, but full support on sm_53 : nvcc x.cu \\ --generate-code arch=compute_50,code=sm_50 \\ --generate-code arch=compute_50,code=sm_52 \\ --generate-code arch=compute_53,code=sm_53 Or, leaving actual GPU code generation to the JIT compiler in the CUDA driver: nvcc x.cu \\ --generate-code arch=compute_50,code=compute_50 \\ --generate-code arch=compute_53,code=compute_53 The code sub-options can be combined with a slightly more complex syntax: nvcc x.cu \\ --generate-code arch=compute_50,code=[sm_50,sm_52] \\ --generate-code arch=compute_53,code=sm_53", "keywords": []}, {"id": 60, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#extensible-whole-program-ewp", "display_name": "--extensible-whole-program (-ewp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "extensible-whole-program-ewp", "priority": -1, "content": "Generate extensible whole program device code, which allows some calls to not be resolved until linking with libcudadevrt.", "keywords": []}, {"id": 61, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#extra-device-vectorization-extra-device-vectorization", "display_name": "--extra-device-vectorization (-extra-device-vectorization)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "extra-device-vectorization-extra-device-vectorization", "priority": -1, "content": "This option enables more aggressive device code vectorization.", "keywords": []}, {"id": 62, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#extra-warnings-extrawarn", "display_name": "--extra-warnings (-extrawarn)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "extra-warnings-extrawarn", "priority": -1, "content": "Emit extra warnings about possible problems.", "keywords": []}, {"id": 63, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#fatbin-fatbin", "display_name": "--fatbin (-fatbin)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fatbin-fatbin", "priority": -1, "content": "Compile all .cu , .ptx , and .cubin input files to device-only .fatbin files. nvcc discards the host code for each .cu input file with this option. Default Output File Name The source file name extension is replaced by .fatbin to create the default output file name. For example, the default output file name for x.cu is x.fatbin .", "keywords": []}, {"id": 64, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#fatbinaries", "display_name": "Fatbinaries", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fatbinaries", "priority": -1, "content": "A different solution to overcome startup delay by JIT while still allowing execution on newer GPUs is to specify multiple code instances, as in nvcc x.cu --gpu-architecture=compute_50 --gpu-code=compute_50,sm_50,sm_52 This command generates exact code for two Maxwell variants, plus PTX code for use by JIT in case a next-generation GPU is encountered. nvcc organizes its device code in fatbinaries, which are able to hold multiple translations of the same GPU source code. At runtime, the CUDA driver will select the most appropriate translation when the device function is launched.", "keywords": []}, {"id": 65, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#fmad-fmad", "display_name": "--fmad (-fmad)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fmad-fmad", "priority": -1, "content": "Semantics same as nvcc option --fmad .", "keywords": []}, {"id": 66, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#fmad-true-false-fmad", "display_name": "--fmad {true|false} (-fmad)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "fmad-true-false-fmad", "priority": -1, "content": "This option enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA). --use_fast_math implies --fmad=true . Allowed Values true false Default This option is set to true and nvcc enables the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).", "keywords": []}, {"id": 67, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#force-load-cache-flcm", "display_name": "--force-load-cache (-flcm)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "force-load-cache-flcm", "priority": -1, "content": "Force specified cache modifier on global/generic load.", "keywords": []}, {"id": 68, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#force-store-cache-fscm", "display_name": "--force-store-cache (-fscm)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "force-store-cache-fscm", "priority": -1, "content": "Force specified cache modifier on global/generic store.", "keywords": []}, {"id": 69, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#forward-slash-prefix-opts-forward-slash-prefix-opts", "display_name": "--forward-slash-prefix-opts (-forward-slash-prefix-opts)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "forward-slash-prefix-opts-forward-slash-prefix-opts", "priority": -1, "content": "If this flag is specified, and forwarding unknown options to host toolchain is enabled ( -forward-unknown-opts or -forward-unknown-to-host-linker or -forward-unknown-to-host-compiler ), then a command line argument beginning with \u2018/\u2019 is forwarded to the host toolchain. For example: nvcc -forward-slash-prefix-opts -forward-unknown-opts /T foo.cu will forward the flag /T to the host compiler and linker. When this flag is not specified, a command line argument beginning with \u2018/\u2019 is treated as an input file. For example: nvcc /T foo.cu will treat \u2018/T\u2019 as an input file, and the Windows API function GetFullPathName() is used to determine the full path name. Note: This flag is only supported on Windows.", "keywords": []}, {"id": 70, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#forward-unknown-opts-forward-unknown-opts", "display_name": "--forward-unknown-opts (-forward-unknown-opts)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "forward-unknown-opts-forward-unknown-opts", "priority": -1, "content": "Implies the combination of options -forward-unknown-to-host-linker and -forward-unknown-to-host-compiler . For example: nvcc -forward-unknown-opts -foo=bar a.cu will forward -foo=bar to the host linker and compiler. nvcc -forward-unknown-opts -foo bar a.cu will report an error for bar argument. nvcc -forward-unknown-opts -foo -bar a.cu will forward -foo and -bar to the host linker and compiler. Note: On Windows, also see option -forward-slash-prefix-opts for forwarding options that begin with \u2018/\u2019.", "keywords": []}, {"id": 71, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#forward-unknown-to-host-compiler-forward-unknown-to-host-compiler", "display_name": "--forward-unknown-to-host-compiler (-forward-unknown-to-host-compiler)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "forward-unknown-to-host-compiler-forward-unknown-to-host-compiler", "priority": -1, "content": "Forward unknown options to the host compiler. An \u2018unknown option\u2019 is a command line argument that starts with - followed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag. If the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the - character. For example: nvcc -forward-unknown-to-host-compiler -foo=bar a.cu will forward -foo=bar to host compiler. nvcc -forward-unknown-to-host-compiler -foo bar a.cu will report an error for bar argument. nvcc -forward-unknown-to-host-compiler -foo -bar a.cu will forward -foo and -bar to host compiler. Note: On Windows, also see option -forward-slash-prefix-opts for forwarding options that begin with \u2018/\u2019.", "keywords": []}, {"id": 72, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#forward-unknown-to-host-linker-forward-unknown-to-host-linker", "display_name": "--forward-unknown-to-host-linker (-forward-unknown-to-host-linker)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "forward-unknown-to-host-linker-forward-unknown-to-host-linker", "priority": -1, "content": "Forward unknown options to the host linker. An \u2018unknown option\u2019 is a command line argument that starts with - followed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag. If the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the - character. For example: nvcc -forward-unknown-to-host-linker -foo=bar a.cu will forward -foo=bar to host linker. nvcc -forward-unknown-to-host-linker -foo bar a.cu will report an error for bar argument. nvcc -forward-unknown-to-host-linker -foo -bar a.cu will forward -foo and -bar to host linker. Note: On Windows, also see option -forward-slash-prefix-opts for forwarding options that begin with \u2018/\u2019.", "keywords": []}, {"id": 73, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ftemplate-backtrace-limit-limit-ftemplate-backtrace-limit", "display_name": "--ftemplate-backtrace-limit limit (-ftemplate-backtrace-limit)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ftemplate-backtrace-limit-limit-ftemplate-backtrace-limit", "priority": -1, "content": "Set the maximum number of template instantiation notes for a single warning or error to limit. A value of 0 is allowed, and indicates that no limit should be enforced. This value is also passed to the host compiler if it provides an equivalent flag.", "keywords": []}, {"id": 74, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ftemplate-depth-limit-ftemplate-depth", "display_name": "--ftemplate-depth limit (-ftemplate-depth)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ftemplate-depth-limit-ftemplate-depth", "priority": -1, "content": "Set the maximum instantiation depth for template classes to limit. This value is also passed to the host compiler if it provides an equivalent flag.", "keywords": []}, {"id": 75, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ftz-true-false-ftz", "display_name": "--ftz {true|false} (-ftz)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ftz-true-false-ftz", "priority": -1, "content": "Control single-precision denormals support. --ftz=true flushes denormal values to zero and --ftz=false preserves denormal values. --use_fast_math implies --ftz=true . Allowed Values true false Default This option is set to false and nvcc preserves denormal values.", "keywords": []}, {"id": 76, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#further-mechanisms", "display_name": "Further Mechanisms", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "further-mechanisms", "priority": -1, "content": "Clearly, compilation staging in itself does not help towards the goal of application compatibility with future GPUs. For this we need two other mechanisms: just-in-time compilation (JIT) and fatbinaries.", "keywords": []}, {"id": 77, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gen-host-linker-script-ghls", "display_name": "--gen-host-linker-script (-ghls)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gen-host-linker-script-ghls", "priority": -1, "content": "Specify the type of host linker script to be generated.", "keywords": []}, {"id": 78, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gen-opt-lto-gen-opt-lto", "display_name": "--gen-opt-lto (-gen-opt-lto)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gen-opt-lto-gen-opt-lto", "priority": -1, "content": "Run the optimizer passes before generating the LTO IR.", "keywords": []}, {"id": 79, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-code-specification-gencode", "display_name": "--generate-code specification (-gencode)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-code-specification-gencode", "priority": -1, "content": "This option provides a generalization of the --gpu-architecture=arch --gpu-code=code,... option combination for specifying nvcc behavior with respect to code generation. Where use of the previous options generates code for different real architectures with the PTX for the same virtual architecture, option --generate-code allows multiple PTX generations for different virtual architectures. In fact, --gpu-architecture=arch --gpu-code=code,... is equivalent to --generate-code=arch=arch,code=code,... . --generate-code options may be repeated for different virtual architectures. See Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures.", "keywords": []}, {"id": 80, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-dependencies-m", "display_name": "--generate-dependencies (-M)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-dependencies-m", "priority": -1, "content": "Generate a dependency file that can be included in a Makefile for the .c , .cc , .cpp , .cxx , and .cu input file. nvcc uses a fixed prefix to identify dependencies in the preprocessed file ( \u2018 #line 1 \u2019 on Linux and \u2018 # 1 \u2019 on Windows). The files mentioned in source location directives starting with this prefix will be included in the dependency list. Default Output File Name The output is generated in stdout by default.", "keywords": []}, {"id": 81, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-dependencies-with-compile-md", "display_name": "--generate-dependencies-with-compile (-MD)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-dependencies-with-compile-md", "priority": -1, "content": "Generate a dependency file and compile the input file. The dependency file can be included in a Makefile for the .c , .cc , .cpp , .cxx , and .cu input file. This option cannot be specified together with -E . The dependency file name is computed as follows: If -MF is specified, then the specified file is used as the dependency file name. If -o is specified, the dependency file name is computed from the specified file name by replacing the suffix with \u2018.d\u2019. Otherwise, the dependency file name is computed by replacing the input file names\u2019s suffix with \u2018.d\u2019. If the dependency file name is computed based on either -MF or -o , then multiple input files are not supported.", "keywords": []}, {"id": 82, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-dependency-targets-mp", "display_name": "--generate-dependency-targets (-MP)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-dependency-targets-mp", "priority": -1, "content": "Add an empty target for each dependency. This option adds phony targets to the dependency generation step (see --generate-dependencies ) intended to avoid makefile errors if old dependencies are deleted. The input files are not emitted as phony targets.", "keywords": []}, {"id": 83, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-line-info-lineinfo", "display_name": "--generate-line-info (-lineinfo)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-line-info-lineinfo", "priority": -1, "content": "Generate line-number information for device code.", "keywords": []}, {"id": 84, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-nonsystem-dependencies-mm", "display_name": "--generate-nonsystem-dependencies (-MM)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-nonsystem-dependencies-mm", "priority": -1, "content": "Same as --generate-dependencies but skip header files found in system directories (Linux only). Default Output File Name The output is generated in stdout by default.", "keywords": []}, {"id": 85, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#generate-nonsystem-dependencies-with-compile-mmd", "display_name": "--generate-nonsystem-dependencies-with-compile (-MMD)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "generate-nonsystem-dependencies-with-compile-mmd", "priority": -1, "content": "Same as --generate-dependencies-with-compile but skip header files found in system directories (Linux only).", "keywords": []}, {"id": 86, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-architecture-arch", "display_name": "--gpu-architecture (-arch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-architecture-arch", "priority": -1, "content": "Specify the name of the class of NVIDIA virtual GPU architecture for which the CUDA input files must be compiled. With the exception as described for the shorthand below, the architecture specified with this option must be a virtual architecture (such as compute_50). Normally, this option alone does not trigger assembly of the generated PTX for a real architecture (that is the role of nvcc option --gpu-code , see below); rather, its purpose is to control preprocessing and compilation of the input to PTX. For convenience, in case of simple nvcc compilations, the following shorthand is supported. If no value for option --gpu-code is specified, then the value of this option defaults to the value of --gpu-architecture . In this situation, as the only exception to the description above, the value specified for --gpu-architecture may be a real architecture (such as a sm_50), in which case nvcc uses the specified real architecture and its closest virtual architecture as the effective architecture values. For example, nvcc --gpu-architecture=sm_50 is equivalent to nvcc --gpu-architecture=compute_50 --gpu-code=sm_50,compute_50 . If the accelerated real gpu (such as -arch=sm_90a ) is specified, then both accelerated and non-accelerated virtual code are added to the code list: --gpu-architecture=compute_90a --gpu-code=sm_90a,compute_90,compute_90a . When -arch=native is specified, nvcc detects the visible GPUs on the system and generates codes for them, no PTX program will be generated for this option. It is a warning if there are no visible supported GPU on the system, and the default architecture will be used. If -arch=all is specified, nvcc embeds a compiled code image for all supported architectures (sm_*) , and a PTX program for the highest major virtual architecture. For -arch=all-major , nvcc embeds a compiled code image for all supported major versions (sm_*0) , plus the earliest supported, and adds a PTX program for the highest major virtual architecture. See Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures. Default sm_52 is used as the default value; PTX is generated for compute_52 then assembled and optimized for sm_52 .", "keywords": []}, {"id": 87, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-code-code-code", "display_name": "--gpu-code code,... (-code)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-code-code-code", "priority": -1, "content": "Specify the name of the NVIDIA GPU to assemble and optimize PTX for. nvcc embeds a compiled code image in the resulting executable for each specified code architecture, which is a true binary load image for each real architecture (such as sm_50), and PTX code for the virtual architecture (such as compute_50). During runtime, such embedded PTX code is dynamically compiled by the CUDA runtime system if no binary load image is found for the current GPU. Architectures specified for options --gpu-architecture and --gpu-code may be virtual as well as real , but the code architectures must be compatible with the arch architecture. When the --gpu-code option is used, the value for the --gpu-architecture option must be a virtual PTX architecture. For instance, --gpu-architecture=compute_60 is not compatible with --gpu-code=sm_52 , because the earlier compilation stages will assume the availability of compute_60 features that are not present on sm_52 . See Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures.", "keywords": []}, {"id": 88, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-compilation", "display_name": "GPU Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-compilation", "priority": -1, "content": "This chapter describes the GPU compilation model that is maintained by nvcc , in cooperation with the CUDA driver. It goes through some technical sections, with concrete examples at the end.", "keywords": []}, {"id": 89, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-feature-list", "display_name": "GPU Feature List", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-feature-list", "priority": -1, "content": "The following table lists the names of the current GPU architectures, annotated with the functional capabilities that they provide. There are other differences, such as amounts of register and processor clusters, that only affect execution performance. In the CUDA naming scheme, GPUs are named sm_xy , where x denotes the GPU generation number, and y the version in that generation. Additionally, to facilitate comparing GPU capabilities, CUDA attempts to choose its GPU names such that if x1y1 &lt;= x2y2 then all non-ISA related capabilities of sm_x1y1 are included in those of sm_x2y2 . From this it indeed follows that sm_50 is the base Maxwell model, and it also explains why higher entries in the tables are always functional extensions to the lower entries. Moreover, if we abstract from the instruction encoding, it implies that sm_50 \u2019s functionality will continue to be included in all later GPU generations. As we will see next, this property will be the foundation for application compatibility support by nvcc . sm_50 , sm_52 and sm_53 Maxwell support sm_60 , sm_61 , and sm_62 Pascal support sm_70 and sm_72 Volta support sm_75 Turing support sm_80 , sm_86 and sm_87 NVIDIA Ampere GPU architecture support sm_89 Ada support sm_90 , sm_90a Hopper support", "keywords": []}, {"id": 90, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-generations", "display_name": "GPU Generations", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-generations", "priority": -1, "content": "In order to allow for architectural evolution, NVIDIA GPUs are released in different generations. New generations introduce major improvements in functionality and/or chip architecture, while GPU models within the same generation show minor configuration differences that moderately affect functionality, performance, or both. Binary compatibility of GPU applications is not guaranteed across different generations. For example, a CUDA application that has been compiled for a Fermi GPU will very likely not run on a Kepler GPU (and vice versa). This is because the instruction set and instruction encodings of a generation is different from those of other generations. Binary compatibility within one GPU generation can be guaranteed under certain conditions because they share the basic instruction set. This is the case when two GPU versions do not show functional differences (for instance when one version is a scaled down version of the other), or when one version is functionally included in the other. An example of the latter is the base Maxwell version sm_50 whose functionality is a subset of all other Maxwell versions: any code compiled for sm_50 will run on all other Maxwell GPUs.", "keywords": []}, {"id": 91, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#gpu-name-gpuname-arch", "display_name": "--gpu-name gpuname (-arch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "gpu-name-gpuname-arch", "priority": -1, "content": "Specify name of NVIDIA GPU to generate code for. This option also takes virtual compute architectures, in which case code generation is suppressed. This can be used for parsing only. Allowed values for this option: compute_50 , compute_52 , compute_53 , compute_60 , compute_61 , compute_62 , compute_70 , compute_72 , compute_75 , compute_80 , compute_86 , compute_87 , compute_89 , compute_90 , lto_50 , lto_52 , lto_53 , lto_60 , lto_61 , lto_62 , lto_70 , lto_72 , lto_75 , lto_80 , lto_86 , lto_87 , lto_89 , lto_90 , sm_50 , sm_52 , sm_53 , sm_60 , sm_61 , sm_62 , sm_70 , sm_72 , sm_75 , sm_80 , sm_86 , sm_87 , sm_89 , sm_90 Default value: sm_52 .", "keywords": []}, {"id": 92, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#help-h", "display_name": "--help (-h)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "help-h", "priority": -1, "content": "Print help information on this tool.", "keywords": []}, {"id": 93, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#host-linker-script-use-lcs-gen-lcs-hls", "display_name": "--host-linker-script {use-lcs|gen-lcs} (-hls)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "host-linker-script-use-lcs-gen-lcs-hls", "priority": -1, "content": "Use the host linker script (GNU/Linux only) to enable support for certain CUDA specific requirements, while building executable files or shared libraries. Allowed Values use-lcs Prepares a host linker script and enables host linker to support relocatable device object files that are larger in size, that would otherwise, in certain cases, cause the host linker to fail with relocation truncation error. gen-lcs Generates a host linker script that can be passed to host linker manually, in the case where host linker is invoked separately outside of nvcc. This option can be combined with -shared or -r option to generate linker scripts that can be used while generating host shared libraries or host relocatable links respectively. The file generated using this options must be provided as the last input file to the host linker. The output is generated to stdout by default. Use the option -o filename to specify the output filename. A linker script may already be in used and passed to the host linker using the host linker option --script (or -T ), then the generated host linker script must augment the existing linker script. In such cases, the option -aug-hls must be used to generate linker script that contains only the augmentation parts. Otherwise, the host linker behaviour is undefined. A host linker option, such as -z with a non-default argument, that can modify the default linker script internally, is incompatible with this option and the behavior of any such usage is undefined. Default Value use-lcs is used as the default type.", "keywords": []}, {"id": 94, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#host-relocatable-link-r", "display_name": "--host-relocatable-link (-r)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "host-relocatable-link-r", "priority": -1, "content": "When used in combination with -hls=gen-lcs , controls the behaviour of -hls=gen-lcs and sets it to generate host linker script that can be used in host relocatable link ( ld -r linkage). See option -hls=gen-lcs for more information. This option currently is effective only when used with -hls=gen-lcs ; in all other cases, this option is ignored currently.", "keywords": []}, {"id": 95, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ignore-host-info-ignore-host-info", "display_name": "--ignore-host-info (-ignore-host-info)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ignore-host-info-ignore-host-info", "priority": -1, "content": "Ignore information about host references, so don\u2019t remove device code that could potentially be referenced by host.", "keywords": []}, {"id": 96, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#implicit-cuda-host-code", "display_name": "Implicit CUDA Host Code", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "implicit-cuda-host-code", "priority": -1, "content": "A file like b.cu above only contains CUDA device code, so one might think that the b.o object doesn\u2019t need to be passed to the host linker. But actually there is implicit host code generated whenever a device symbol can be accessed from the host side, either via a launch or an API call like cudaGetSymbolAddress() . This implicit host code is put into b.o , and needs to be passed to the host linker. Plus, for JIT linking to work all device code must be passed to the host linker, else the host executable will not contain device code needed for the JIT link. So a general rule is that the device linker and host linker must see the same host object files (if the object files have any device references in them\u2014if a file is pure host then the device linker doesn\u2019t need to see it). If an object file containing device code is not passed to the host linker, then you will see an error message about the function __cudaRegisterLinkedBinary_name calling an undefined or unresolved symbol __fatbinwrap_name .", "keywords": []}, {"id": 97, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#include-path-path-i", "display_name": "--include-path path,... (-I)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "include-path-path-i", "priority": -1, "content": "Specify include search paths.", "keywords": []}, {"id": 98, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#input-drive-prefix-prefix-idp", "display_name": "--input-drive-prefix prefix (-idp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "input-drive-prefix-prefix-idp", "priority": -1, "content": "Specify the input drive prefix. On Windows, all command line arguments that refer to file names must be converted to the Windows native format before they are passed to pure Windows executables. This option specifies how the current development environment represents absolute paths. Use /cygwin/ as prefix for Cygwin build environments and / as prefix for MinGW.", "keywords": []}, {"id": 99, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#jit-linking-support", "display_name": "JIT Linking Support", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "jit-linking-support", "priority": -1, "content": "JIT linking means doing an implicit relink of the code at load time. If the cubin does not match the target architecture at load time, the driver re-invokes the device linker to generate cubin for the target architecture, by first JIT\u2019ing the PTX for each object to the appropriate cubin, and then linking together the new cubin. If PTX or cubin for the target architecture is not found for an object, then the link will fail. Implicit JIT linking of the LTO intermediates is not supported at this time, although they can be explicitly linked with the nvJitLink library.", "keywords": []}, {"id": 100, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#jump-table-density-percentage-jtd", "display_name": "--jump-table-density percentage (-jtd)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "jump-table-density-percentage-jtd", "priority": -1, "content": "Specify the case density percentage in switch statements, and use it as a minimal threshold to determine whether jump table(brx.idx instruction) will be used to implement a switch statement. The percentage ranges from 0 to 101 inclusively. Default This option is set to 101 and nvcc disables jump table generation for switch statements.", "keywords": []}, {"id": 101, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#just-in-time-compilation", "display_name": "Just-in-Time Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "just-in-time-compilation", "priority": -1, "content": "The compilation step to an actual GPU binds the code to one generation of GPUs. Within that generation, it involves a choice between GPU coverage and possible performance. For example, compiling to sm_50 allows the code to run on all Maxwell generation GPUs, but compiling to sm_53 would probably yield better code if Maxwell GM206 and later are the only targets. Just-in-Time Compilation of Device Code By specifying a virtual code architecture instead of a real GPU, nvcc postpones the assembly of PTX code until application runtime, at which time the target GPU is exactly known. For instance, the command below allows generation of exactly matching GPU binary code, when the application is launched on an sm_50 or later architecture. nvcc x.cu --gpu-architecture=compute_50 --gpu-code=compute_50 The disadvantage of just-in-time compilation is increased application startup delay, but this can be alleviated by letting the CUDA driver use a compilation cache (refer to \u201cSection 3.1.1.2. Just-in-Time Compilation\u201d of CUDA C++ Programming Guide ) which is persistent over multiple runs of the applications.", "keywords": []}, {"id": 102, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#keep-device-functions-keep-device-functions", "display_name": "--keep-device-functions (-keep-device-functions)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "keep-device-functions-keep-device-functions", "priority": -1, "content": "In whole program compilation mode, preserve user defined external linkage __device__ function definitions in generated PTX.", "keywords": []}, {"id": 103, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#keep-dir-directory-keep-dir", "display_name": "--keep-dir directory (-keep-dir)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "keep-dir-directory-keep-dir", "priority": -1, "content": "Keep all intermediate files that are generated during internal compilation steps in this directory.", "keywords": []}, {"id": 104, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#keep-keep", "display_name": "--keep (-keep)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "keep-keep", "priority": -1, "content": "Keep all intermediate files that are generated during internal compilation steps.", "keywords": []}, {"id": 105, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#keep-system-libraries-keep-system-libraries", "display_name": "--keep-system-libraries (-keep-system-libraries)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "keep-system-libraries-keep-system-libraries", "priority": -1, "content": "Don\u2019t optimize away system library (e.g. cudadevrt) code.", "keywords": []}, {"id": 106, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#keeping-intermediate-phase-files", "display_name": "Keeping Intermediate Phase Files", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "keeping-intermediate-phase-files", "priority": -1, "content": "nvcc stores intermediate results by default into temporary files that are deleted immediately before it completes. The location of the temporary file directories used are, depending on the current platform, as follows: Windows Value of environment variable TEMP is used. If it is not set, C:\\Windows\\temp is used instead. Other Platforms Value of environment variable TMPDIR is used. If it is not set, /tmp is used instead. Option --keep makes nvcc store these intermediate files in the current directory or in the directory specified by --keep-dir instead, with names as described in Supported Phases .", "keywords": []}, {"id": 107, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#kernels-used-kernels-used", "display_name": "--kernels-used (-kernels-used)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "kernels-used-kernels-used", "priority": -1, "content": "Specify kernels that are used. Can be part of a kernel name so any kernels with that string in name are matched. If this option is used, then any other kernels are considered dead-code and removed.", "keywords": []}, {"id": 108, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#lib-lib", "display_name": "--lib (-lib)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "lib-lib", "priority": -1, "content": "Compile all input files into object files, if necessary, and add the results to the specified library output file. Default Output File Name a.lib on Windows or a.a on other platforms is used as the default output file name.", "keywords": []}, {"id": 109, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#libdevice-directory-directory-ldir", "display_name": "--libdevice-directory directory (-ldir)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "libdevice-directory-directory-ldir", "priority": -1, "content": "Specify the directory that contains the libdevice library files. Libdevice library files are located in the nvvm/libdevice directory in the CUDA Toolkit.", "keywords": []}, {"id": 110, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#libraries", "display_name": "Libraries", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "libraries", "priority": -1, "content": "The device linker has the ability to read the static host library formats ( .a on Linux and Mac OS X, .lib on Windows). It ignores any dynamic ( .so or .dll ) libraries. The --library and --library-path options can be used to pass libraries to both the device and host linker. The library name is specified without the library file extension when the --library option is used. nvcc --gpu-architecture=sm_50 a.o b.o --library-path=&lt;path&gt; --library=foo Alternatively, the library name, including the library file extension, can be used without the --library option on Windows. nvcc --gpu-architecture=sm_50 a.obj b.obj foo.lib --library-path=&lt;path&gt; Note that the device linker ignores any objects that do not have relocatable device code.", "keywords": []}, {"id": 111, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#library-library-l", "display_name": "--library library,... (-l)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "library-library-l", "priority": -1, "content": "Specify libraries to be used in the linking stage without the library file extension. The libraries are searched for on the library search paths that have been specified using option --library-path (see Libraries ).", "keywords": []}, {"id": 112, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#library-path-path-l", "display_name": "--library-path path,... (-L)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "library-path-path-l", "priority": -1, "content": "Specify library search paths (see Libraries ).", "keywords": []}, {"id": 113, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#link-link", "display_name": "--link (-link)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "link-link", "priority": -1, "content": "Specify the default behavior: compile and link all input files. Default Output File Name a.exe on Windows or a.out on other platforms is used as the default output file name.", "keywords": []}, {"id": 114, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#linker-options-options-xlinker", "display_name": "--linker-options options,... (-Xlinker)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "linker-options-options-xlinker", "priority": -1, "content": "Specify options directly to the host linker.", "keywords": []}, {"id": 115, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#list-gpu-arch-arch-ls", "display_name": "--list-gpu-arch (-arch-ls)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "list-gpu-arch-arch-ls", "priority": -1, "content": "List the non-accelerated virtual device architectures (compute_XX) supported by the tool and exit. If both \u2013list-gpu-arch and \u2013list-gpu-code are set, the list is displayed using the same format as the \u2013generate-code value.", "keywords": []}, {"id": 116, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#list-gpu-code-code-ls", "display_name": "--list-gpu-code (-code-ls)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "list-gpu-code-code-ls", "priority": -1, "content": "List the non-accelerated gpu architectures (sm_XX) supported by the tool and exit. If both \u2013list-gpu-code and \u2013list-gpu-arch are set, the list is displayed using the same format as the \u2013generate-code value.", "keywords": []}, {"id": 117, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#m64-m64", "display_name": "--m64 (-m64)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "m64-m64", "priority": -1, "content": "Alias for --machine=64", "keywords": []}, {"id": 118, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#machine-64-m", "display_name": "--machine {64} (-m)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "machine-64-m", "priority": -1, "content": "Specify 64-bit architecture. Allowed Values 64 Default This option is set based on the host platform on which nvcc is executed.", "keywords": []}, {"id": 119, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#machine-m", "display_name": "--machine (-m)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "machine-m", "priority": -1, "content": "Semantics same as nvcc option --machine .", "keywords": []}, {"id": 120, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#make-errors-visible-at-exit-make-errors-visible-at-exit", "display_name": "--make-errors-visible-at-exit (-make-errors-visible-at-exit)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "make-errors-visible-at-exit-make-errors-visible-at-exit", "priority": -1, "content": "Generate required instructions at exit point to make memory faults and errors visible at exit.", "keywords": []}, {"id": 121, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#maxntid-maxntid", "display_name": "--maxntid (-maxntid)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "maxntid-maxntid", "priority": -1, "content": "Specify the maximum number of threads that a thread block can have. This option will be ignored if used along with -maxrregcount option. This option is also ignored for entry functions that have .maxntid directive specified.", "keywords": []}, {"id": 122, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#maxrregcount-amount-maxrregcount", "display_name": "--maxrregcount amount (-maxrregcount)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "maxrregcount-amount-maxrregcount", "priority": -1, "content": "Specify the maximum amount of registers that GPU functions can use. Until a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good maxrregcount value is the result of a trade-off. A value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit. User program may not be able to make use of all registers as some registers are reserved by compiler. Default No maximum is assumed.", "keywords": []}, {"id": 123, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#minnctapersm-minnctapersm", "display_name": "--minnctapersm (-minnctapersm)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "minnctapersm-minnctapersm", "priority": -1, "content": "Specify the minimum number of CTAs to be mapped to an SM. This option will be ignored if used along with -maxrregcount option. This option is also ignored for entry functions that have .minnctapersm directive specified.", "keywords": []}, {"id": 124, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-align-double", "display_name": "--no-align-double", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-align-double", "priority": -1, "content": "Specify that -malign-double should not be passed as a compiler argument on 32-bit platforms. WARNING: this makes the ABI incompatible with the CUDA\u2019s kernel ABI for certain 64-bit types.", "keywords": []}, {"id": 125, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-compress-no-compress", "display_name": "--no-compress (-no-compress)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-compress-no-compress", "priority": -1, "content": "Do not compress device code in fatbinary.", "keywords": []}, {"id": 126, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-device-link-nodlink", "display_name": "--no-device-link (-nodlink)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-device-link-nodlink", "priority": -1, "content": "Skip the device link step when linking object files.", "keywords": []}, {"id": 127, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-display-error-number-no-err-no", "display_name": "--no-display-error-number (-no-err-no)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-display-error-number-no-err-no", "priority": -1, "content": "This option disables the display of a diagnostic number for any message generated by the CUDA frontend compiler (note: not the host compiler).", "keywords": []}, {"id": 128, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-exceptions-noeh", "display_name": "--no-exceptions (-noeh)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-exceptions-noeh", "priority": -1, "content": "Disable exception handling for host code. Disable exception handling for host code, by passing \u201c-EHs-c-\u201d (for cl.exe) and \u201c\u2013fno-exceptions\u201d (for other host compilers) during host compiler invocation. These flags are added to the host compiler invocation before any flags passed directly to the host compiler with \u201c-Xcompiler\u201d Default (on Windows) On Windows, nvcc passes /EHsc to the host compiler by default. Example (on Windows) nvcc --no-exceptions -Xcompiler /EHa x.cu", "keywords": []}, {"id": 129, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#no-host-device-initializer-list-nohdinitlist", "display_name": "--no-host-device-initializer-list (-nohdinitlist)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "no-host-device-initializer-list-nohdinitlist", "priority": -1, "content": "Do not consider member functions of std::initializer_list as __host__ __device__ functions implicitly.", "keywords": []}, {"id": 130, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#notice", "display_name": "Notice", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "notice", "priority": -1, "content": "This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (\u201cNVIDIA\u201d) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality. NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice. Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete. NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (\u201cTerms of Sale\u201d). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document. NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customer\u2019s own risk. NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customer\u2019s sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customer\u2019s product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs. No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA. Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices. THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, \u201cMATERIALS\u201d) ARE BEING PROVIDED \u201cAS IS.\u201d NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIA\u2019s aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.", "keywords": []}, {"id": 131, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvcc-environment-variables", "display_name": "NVCC Environment Variables", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvcc-environment-variables", "priority": -1, "content": "NVCC_PREPEND_FLAGS and NVCC_APPEND_FLAGS: The nvcc command line flags can be augmented using the following environment variables, if set: NVCC_PREPEND_FLAGS Flags to be injected before the normal nvcc command line. NVCC_APPEND_FLAGS Flags to be injected after the normal nvcc command line. For example, after setting: export NVCC_PREPEND_FLAGS=&#x27;-G -keep -arch=sm_60&#x27; export NVCC_APPEND_FLAGS=&#x27;-DNAME=&quot; foo &quot;&#x27; The following invocation: nvcc foo.cu -o foo Becomes equivalent to: nvcc -G -keep -arch=sm_60 foo.cu -o foo -DNAME=&quot; foo &quot; These environment variables can be useful for injecting nvcc flags globally without modifying build scripts. The additional flags coming from either NVCC_PREPEND_FLAGS or NVCC_APPEND_FLAGS will be listed in the verbose log ( --verbose ). NVCC_CCBIN: A default host compiler can be set using the environment variable NVCC_CCBIN . For example, after setting: export NVCC_CCBIN=&#x27;gcc&#x27; nvcc will choose gcc as the host compiler if --compiler-bindir is not set. NVCC_CCBIN can be useful for controlling the default host compiler globally. If NVCC_CCBIN and --compiler-bindir are both set, nvcc will choose the host compiler specified by --compiler-bindir . For example: export NVCC_CCBIN=&#x27;gcc&#x27; nvcc foo.cu -ccbin=&#x27;clang&#x27; -o foo In this case, nvcc will choose clang as the host compiler.", "keywords": []}, {"id": 132, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvcc-identification-macro", "display_name": "NVCC Identification Macro", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvcc-identification-macro", "priority": -1, "content": "nvcc predefines the following macros: __NVCC__ Defined when compiling C/C++/CUDA source files. __CUDACC__ Defined when compiling CUDA source files. __CUDACC_RDC__ Defined when compiling CUDA source files in relocatable device code mode (see NVCC Options for Separate Compilation ). __CUDACC_EWP__ Defined when compiling CUDA source files in extensible whole program mode (see Options for Specifying Behavior of Compiler/Linker ). __CUDACC_DEBUG__ Defined when compiling CUDA source files in the device-debug mode (see Options for Specifying Behavior of Compiler/Linker ). __CUDACC_RELAXED_CONSTEXPR__ Defined when the --expt-relaxed-constexpr flag is specified on the command line. Refer to the CUDA C++ Programming Guide for more details. __CUDACC_EXTENDED_LAMBDA__ Defined when the --expt-extended-lambda or --extended-lambda flag is specified on the command line. Refer to the CUDA C++ Programming Guide for more details. __CUDACC_VER_MAJOR__ Defined with the major version number of nvcc . __CUDACC_VER_MINOR__ Defined with the minor version number of nvcc . __CUDACC_VER_BUILD__ Defined with the build version number of nvcc . __NVCC_DIAG_PRAGMA_SUPPORT__ Defined when the CUDA frontend compiler supports diagnostic control with the nv_diag_suppress , nv_diag_error , nv_diag_warning , nv_diag_default , nv_diag_once , and nv_diagnostic pragmas.", "keywords": []}, {"id": 133, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvcc-options-for-separate-compilation", "display_name": "NVCC Options for Separate Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvcc-options-for-separate-compilation", "priority": -1, "content": "CUDA works by embedding device code into host objects. In whole program compilation, it embeds executable device code into the host object. In separate compilation, we embed relocatable device code into the host object, and run nvlink , the device linker, to link all the device code together. The output of nvlink is then linked together with all the host objects by the host linker to form the final executable. The generation of relocatable vs executable device code is controlled by the --relocatable-device-code option. The --compile option is already used to control stopping a compile at a host object, so a new option --device-c is added that simply does --relocatable-device-code=true --compile . To invoke just the device linker, the --device-link option can be used, which emits a host object containing the embedded executable device code. The output of that must then be passed to the host linker. Or: nvcc &lt;objects&gt; can be used to implicitly call both the device and host linkers. This works because if the device linker does not see any relocatable code it does not do anything. The following figure shows the flow. CUDA Separate Compilation Trajectory", "keywords": []}, {"id": 134, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvcc-phases", "display_name": "NVCC Phases", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvcc-phases", "priority": -1, "content": "A compilation phase is a logical translation step that can be selected by command line options to nvcc . A single compilation phase can still be broken up by nvcc into smaller steps, but these smaller steps are just implementations of the phase: they depend on seemingly arbitrary capabilities of the internal tools that nvcc uses, and all of these internals may change with a new release of the CUDA Toolkit. Hence, only compilation phases are stable across releases, and although nvcc provides options to display the compilation steps that it executes, these are for debugging purposes only and must not be copied and used in build scripts. nvcc phases are selected by a combination of command line options and input file name suffixes, and the execution of these phases may be modified by other command line options. In phase selection, the input file suffix defines the phase input, while the command line option defines the required output of the phase. The following paragraphs list the recognized file name suffixes and the supported compilation phases. A full explanation of the nvcc command line options can be found in NVCC Command Options .", "keywords": []}, {"id": 135, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options", "display_name": "NVLINK Options", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options", "priority": -1, "content": "The following is a list of some useful nvlink options which can be specified with nvcc option --nvlink-options .", "keywords": []}, {"id": 136, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-device-stack-protector", "display_name": "--device-stack-protector {true|false} (-device-stack-protector)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-device-stack-protector", "priority": -1, "content": "Enable or disable the generation of stack canaries in device code (only used with LTO). Stack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables. The compiler uses heuristics to assess the risk of such a bug in each function. Only those functions which are deemed high-risk make use of a stack canary. Allowed Values true false Default The generation of stack canaries in device code is disabled.", "keywords": []}, {"id": 137, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-disable-warnings", "display_name": "--disable-warnings (-w)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-disable-warnings", "priority": -1, "content": "Inhibit all warning messages.", "keywords": []}, {"id": 138, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-options-xnvlink", "display_name": "--nvlink-options options,... (-Xnvlink)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-options-xnvlink", "priority": -1, "content": "Specify options directly to nvlink , the device linker.", "keywords": []}, {"id": 139, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-preserve-relocs", "display_name": "--preserve-relocs (-preserve-relocs)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-preserve-relocs", "priority": -1, "content": "Preserve resolved relocations in linked executable.", "keywords": []}, {"id": 140, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-verbose", "display_name": "--verbose (-v)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-verbose", "priority": -1, "content": "Enable verbose mode which prints code generation statistics.", "keywords": []}, {"id": 141, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#nvlink-options-warning-as-error", "display_name": "--warning-as-error (-Werror)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "nvlink-options-warning-as-error", "priority": -1, "content": "Make all warnings into errors.", "keywords": []}, {"id": 142, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#objdir-as-tempdir-objtemp", "display_name": "--objdir-as-tempdir (-objtemp)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "objdir-as-tempdir-objtemp", "priority": -1, "content": "Create all intermediate files in the same directory as the object file. These intermediate files are deleted when the compilation is finished. This option will take effect only if -c, -dc or -dw is also used. Using this option will ensure that the intermediate file name that is embedded in the object file will not change in multiple compiles of the same file. However, this is not guaranteed if the input is stdin. If the same file is compiled with two different options, ex., \u2018nvcc -c t.cu\u2019 and \u2018nvcc -c -ptx t.cu\u2019, then the files should be compiled in different directories. Compiling them in the same directory can either cause the compilation to fail or produce incorrect results.", "keywords": []}, {"id": 143, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#object-compatibility", "display_name": "Object Compatibility", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "object-compatibility", "priority": -1, "content": "Only relocatable device code with the same ABI version, link-compatible SM target architecture, and same pointer size (32 or 64) can be linked together. The toolkit version of the linker must be &gt;= the toolkit version of the objects. Incompatible objects will produce a link error. Link-compatible SM architectures are ones that have compatible SASS binaries that can combine without translating, e.g. sm_52 and sm_50. An object could have been compiled for a different architecture but also have PTX available, in which case the device linker will JIT the PTX to cubin for the desired architecture and then link. Relocatable device code requires CUDA 5.0 or later Toolkit. If Link Time Optimization is used with -dlto , the intermediate LTOIR is only guaranteed to be compatible within a major release (e.g. can link together 12.0 and 12.1 LTO intermediates, but not 12.1 and 11.6). If a kernel is limited to a certain number of registers with the launch_bounds attribute or the --maxrregcount option, then all functions that the kernel calls must not use more than that number of registers; if they exceed the limit, then a link error will be given.", "keywords": []}, {"id": 144, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ofast-compile-ofc", "display_name": "--oFast-compile (-Ofc)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ofast-compile-ofc", "priority": -1, "content": "Specify level to prefer device code compilation speed. Default value: 0 .", "keywords": []}, {"id": 145, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#opencl", "display_name": "OpenCL", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opencl", "priority": -1, "content": "OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.", "keywords": []}, {"id": 146, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#opt-level-n-o", "display_name": "--opt-level N (-O)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "opt-level-n-o", "priority": -1, "content": "Specify optimization level. Default value: 3 .", "keywords": []}, {"id": 147, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#optimization-info-kind-opt-info", "display_name": "--optimization-info kind,... (-opt-info)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "optimization-info-kind-opt-info", "priority": -1, "content": "Provide optimization reports for the specified kind of optimization. The following tags are supported: inline Emit remarks related to function inlining. Inlining pass may be invoked multiple times by the compiler and a function not inlined in an earlier pass may be inlined in a subsequent pass.", "keywords": []}, {"id": 148, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#optimization-of-separate-compilation", "display_name": "Optimization Of Separate Compilation", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "optimization-of-separate-compilation", "priority": -1, "content": "Separately compiled code may not have as high of performance as whole program code because of the inability to inline code across files. A way to still get optimal performance is to use link-time optimization, which stores intermediate code which is then linked together to perform high level optimizations. This can be done with the --dlink-time-opt or -dlto option. This option must be specified at both compile and link time. If only some of the files are compiled with -dlto , then those will be linked and optimized together while the rest uses the normal separate compilation. A side effect is that this shifts some of the compile time to the link phase, and there may be some scalability issues with really large codes. If you want to compile using -gencode to build for multiple arch, use -dc -gencode arch=compute_NN,code=lto_NN to specify the intermediate IR to be stored (where NN is the SM architecture version). Then use -dlto option to link for a specific architecture. As of CUDA 12.0 there is support for runtime LTO via the nvJitLink library.", "keywords": []}, {"id": 149, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#optimize-level-o", "display_name": "--optimize level (-O)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "optimize-level-o", "priority": -1, "content": "Specify optimization level for host code.", "keywords": []}, {"id": 150, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#options-file-file-optf", "display_name": "--options-file file,... (-optf)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "options-file-file-optf", "priority": -1, "content": "Include command line options from specified file.", "keywords": []}, {"id": 151, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#options-file-optf", "display_name": "--options-file (-optf)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "options-file-optf", "priority": -1, "content": "Include command line options from the specified file.", "keywords": []}, {"id": 152, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#options-for-guiding-compiler-driver-allow-unsupported-compiler", "display_name": "--allow-unsupported-compiler (-allow-unsupported-compiler)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "options-for-guiding-compiler-driver-allow-unsupported-compiler", "priority": -1, "content": "Disable nvcc check for supported host compiler versions. Using an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.", "keywords": []}, {"id": 153, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#options-for-passing-specific-phase-options", "display_name": "Options for Passing Specific Phase Options", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "options-for-passing-specific-phase-options", "priority": -1, "content": "These flags allow for passing specific options directly to the internal compilation tools that nvcc encapsulates, without burdening nvcc with too-detailed knowledge on these tools.", "keywords": []}, {"id": 154, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#options-for-specifying-the-compilation-phase", "display_name": "Options for Specifying the Compilation Phase", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "options-for-specifying-the-compilation-phase", "priority": -1, "content": "Options of this category specify up to which stage the input files must be compiled.", "keywords": []}, {"id": 155, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#optix-ir-optix-ir", "display_name": "--optix-ir (-optix-ir)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "optix-ir-optix-ir", "priority": -1, "content": "Compile CUDA source to OptiX IR (.optixir) output. The OptiX IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization ( -dlto ), the lto_NN -arch target, or with -gencode . Default Output File Name The source file name extension is replaced by .optixir to create the default output file name. For example, the default output file name for x.cu is x.optixir .", "keywords": []}, {"id": 156, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#output-directory-directory-odir", "display_name": "--output-directory directory (-odir)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "output-directory-directory-odir", "priority": -1, "content": "Specify the directory of the output file. This option is intended for letting the dependency generation step (see --generate-dependencies ) generate a rule that defines the target object file in the proper directory.", "keywords": []}, {"id": 157, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#output-file-file-o", "display_name": "--output-file file (-o)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "output-file-file-o", "priority": -1, "content": "Specify name and location of the output file.", "keywords": []}, {"id": 158, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#override-directive-values-override-directive-values", "display_name": "--override-directive-values (-override-directive-values)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "override-directive-values-override-directive-values", "priority": -1, "content": "Override the PTX directives values by the corresponding option values. This option is effective only for -minnctapersm , -maxntid and -maxrregcount options.", "keywords": []}, {"id": 159, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#phase-options", "display_name": "Phase Options", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "phase-options", "priority": -1, "content": "The following sections lists some useful options to lower level compilation tools.", "keywords": []}, {"id": 160, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#position-independent-code-pic", "display_name": "--position-independent-code (-pic)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "position-independent-code-pic", "priority": -1, "content": "Generate position-independent code. Default value: For whole-program compilation: true Otherwise: false", "keywords": []}, {"id": 161, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#pre-include-file-include", "display_name": "--pre-include file,... (-include)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "pre-include-file-include", "priority": -1, "content": "Specify header files that must be pre-included during preprocessing.", "keywords": []}, {"id": 162, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#prec-div-true-false-prec-div", "display_name": "--prec-div {true|false} (-prec-div)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "prec-div-true-false-prec-div", "priority": -1, "content": "This option controls single-precision floating-point division and reciprocals. --prec-div=true enables the IEEE round-to-nearest mode and --prec-div=false enables the fast approximation mode. --use_fast_math implies --prec-div=false . Allowed Values true false Default This option is set to true and nvcc enables the IEEE round-to-nearest mode.", "keywords": []}, {"id": 163, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#prec-sqrt-true-false-prec-sqrt", "display_name": "--prec-sqrt {true|false} (-prec-sqrt)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "prec-sqrt-true-false-prec-sqrt", "priority": -1, "content": "This option controls single-precision floating-point square root. --prec-sqrt=true enables the IEEE round-to-nearest mode and --prec-sqrt=false enables the fast approximation mode. --use_fast_math implies --prec-sqrt=false . Allowed Values true false Default This option is set to true and nvcc enables the IEEE round-to-nearest mode.", "keywords": []}, {"id": 164, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#preprocess-e", "display_name": "--preprocess (-E)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "preprocess-e", "priority": -1, "content": "Preprocess all .c , .cc , .cpp , .cxx , and .cu input files. Default Output File Name The output is generated in stdout by default.", "keywords": []}, {"id": 165, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#preserve-relocs-preserve-relocs", "display_name": "--preserve-relocs (-preserve-relocs)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "preserve-relocs-preserve-relocs", "priority": -1, "content": "This option will make ptxas to generate relocatable references for variables and preserve relocations generated for them in linked executable.", "keywords": []}, {"id": 166, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#printing-code-generation-statistics", "display_name": "Printing Code Generation Statistics", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "printing-code-generation-statistics", "priority": -1, "content": "A summary on the amount of used registers and the amount of memory needed per compiled device function can be printed by passing option --resource-usage to nvcc : $ nvcc --resource-usage acos.cu -arch sm_80 ptxas info : 1536 bytes gmem ptxas info : Compiling entry function &#x27;acos_main&#x27; for &#x27;sm_80&#x27; ptxas info : Function properties for acos_main 0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loads ptxas info : Used 6 registers, 1536 bytes smem, 32 bytes cmem[0] As shown in the above example, the amount of statically allocated global memory (gmem) is listed. Global memory and some of the constant banks are module scoped resources and not per kernel resources. Allocation of constant variables to constant banks is profile specific. Followed by this, per kernel resource information is printed. Stack frame is per thread stack usage used by this function. Spill stores and loads represent stores and loads done on stack memory which are being used for storing variables that couldn\u2019t be allocated to physical registers. Similarly number of registers, amount of shared memory and total space in constant bank allocated is shown.", "keywords": []}, {"id": 167, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#profile-pg", "display_name": "--profile (-pg)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "profile-pg", "priority": -1, "content": "Instrument generated code/executable for use by gprof .", "keywords": []}, {"id": 168, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptx-ptx", "display_name": "--ptx (-ptx)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptx-ptx", "priority": -1, "content": "Compile all .cu input files to device-only .ptx files. nvcc discards the host code for each .cu input file with this option. Default Output File Name The source file name extension is replaced by .ptx to create the default output file name. For example, the default output file name for x.cu is x.ptx .", "keywords": []}, {"id": 169, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options", "display_name": "Ptxas Options", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options", "priority": -1, "content": "The following table lists some useful ptxas options which can be specified with nvcc option -Xptxas .", "keywords": []}, {"id": 170, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-compile-as-tools-patch", "display_name": "--compile-as-tools-patch (-astoolspatch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-compile-as-tools-patch", "priority": -1, "content": "Compile patch code for CUDA tools. Shall not be used in conjunction with -Xptxas -c or -ewp . Some PTX ISA features may not be usable in this compilation mode.", "keywords": []}, {"id": 171, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-device-debug", "display_name": "--device-debug (-g)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-device-debug", "priority": -1, "content": "Semantics same as nvcc option --device-debug .", "keywords": []}, {"id": 172, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-device-stack-protector", "display_name": "--device-stack-protector {true|false} (-device-stack-protector)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-device-stack-protector", "priority": -1, "content": "Enable or disable the generation of stack canaries in device code. Stack canaries make it more difficult to exploit certain types of memory safety bugs involving stack-local variables. The compiler uses heuristics to assess the risk of such a bug in each function. Only those functions which are deemed high-risk make use of a stack canary. Allowed Values true false Default The generation of stack canaries in device code is disabled.", "keywords": []}, {"id": 173, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-generate-line-info", "display_name": "--generate-line-info (-lineinfo)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-generate-line-info", "priority": -1, "content": "Semantics same as nvcc option --generate-line-info .", "keywords": []}, {"id": 174, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-help", "display_name": "--help (-h)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-help", "priority": -1, "content": "Semantics same as nvcc option --help .", "keywords": []}, {"id": 175, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-maxrregcount", "display_name": "--maxrregcount amount (-maxrregcount)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-maxrregcount", "priority": -1, "content": "Semantics same as nvcc option --maxrregcount .", "keywords": []}, {"id": 176, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-options-file", "display_name": "--options-file file,... (-optf)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-options-file", "priority": -1, "content": "Semantics same as nvcc option --options-file .", "keywords": []}, {"id": 177, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-options-xptxas", "display_name": "--ptxas-options options,... (-Xptxas)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-options-xptxas", "priority": -1, "content": "Specify options directly to ptxas , the PTX optimizing assembler.", "keywords": []}, {"id": 178, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-verbose", "display_name": "--verbose (-v)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-verbose", "priority": -1, "content": "Enable verbose mode which prints code generation statistics.", "keywords": []}, {"id": 179, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#ptxas-options-version", "display_name": "--version (-V)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "ptxas-options-version", "priority": -1, "content": "Semantics same as nvcc option --version .", "keywords": []}, {"id": 180, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#purpose-of-nvcc", "display_name": "Purpose of NVCC", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "purpose-of-nvcc", "priority": -1, "content": "The compilation trajectory involves several splitting, compilation, preprocessing, and merging steps for each CUDA source file. It is the purpose of nvcc , the CUDA compiler driver, to hide the intricate details of CUDA compilation from developers. It accepts a range of conventional compiler options, such as for defining macros and include/library paths, and for steering the compilation process. All non-CUDA compilation steps are forwarded to a C++ host compiler that is supported by nvcc , and nvcc translates its options to appropriate host compiler command line options.", "keywords": []}, {"id": 181, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#qpp-config-config-qpp-config", "display_name": "--qpp-config config (-qpp-config)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "qpp-config-config-qpp-config", "priority": -1, "content": "Specify the configuration ([[compiler/]version,][target]) when using q++ host compiler. The argument will be forwarded to the q++ compiler with its -V flag.", "keywords": []}, {"id": 182, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#relocatable-device-code-true-false-rdc", "display_name": "--relocatable-device-code {true|false} (-rdc)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "relocatable-device-code-true-false-rdc", "priority": -1, "content": "Enable or disable the generation of relocatable device code. If disabled, executable device code is generated. Relocatable device code must be linked before it can be executed. Allowed Values true false Default The generation of relocatable device code is disabled.", "keywords": []}, {"id": 183, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#report-arch-report-arch", "display_name": "--report-arch (-report-arch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "report-arch-report-arch", "priority": -1, "content": "Report SM target arch in error messages.", "keywords": []}, {"id": 184, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#resource-usage-res-usage", "display_name": "--resource-usage (-res-usage)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "resource-usage-res-usage", "priority": -1, "content": "Show resource usage such as registers and memory of the GPU code. This option implies --nvlink-options=--verbose when --relocatable-device-code=true is set. Otherwise, it implies --ptxas-options=--verbose .", "keywords": []}, {"id": 185, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#restrict-restrict", "display_name": "--restrict (-restrict)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "restrict-restrict", "priority": -1, "content": "Assert that all kernel pointer parameters are restrict pointers.", "keywords": []}, {"id": 186, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#run-args-arguments-run-args", "display_name": "--run-args arguments,... (-run-args)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "run-args-arguments-run-args", "priority": -1, "content": "Specify command line arguments for the executable when used in conjunction with --run .", "keywords": []}, {"id": 187, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#run-run", "display_name": "--run (-run)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "run-run", "priority": -1, "content": "Compile and link all input files into an executable, and executes it. When the input is a single executable, it is executed without any compilation or linking. This step is intended for developers who do not want to be bothered with setting the necessary environment variables; these are set temporarily by nvcc .", "keywords": []}, {"id": 188, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#save-temps-save-temps", "display_name": "--save-temps (-save-temps)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "save-temps-save-temps", "priority": -1, "content": "This option is an alias of --keep .", "keywords": []}, {"id": 189, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#shared-shared", "display_name": "--shared (-shared)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "shared-shared", "priority": -1, "content": "Generate a shared library during linking. Use option --linker-options when other linker options are required for more control.", "keywords": []}, {"id": 190, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#shorthand", "display_name": "Shorthand", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "shorthand", "priority": -1, "content": "nvcc allows a number of shorthands for simple cases.", "keywords": []}, {"id": 191, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#shorthand-1", "display_name": "Shorthand 1", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "shorthand-1", "priority": -1, "content": "--gpu-code arguments can be virtual architectures. In this case the stage 2 translation will be omitted for such virtual architecture, and the stage 1 PTX result will be embedded instead. At application launch, and in case the driver does not find a better alternative, the stage 2 compilation will be invoked by the driver with the PTX as input. Example nvcc x.cu --gpu-architecture=compute_50 --gpu-code=compute_50,sm_50,sm_52", "keywords": []}, {"id": 192, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#shorthand-2", "display_name": "Shorthand 2", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "shorthand-2", "priority": -1, "content": "The --gpu-code option can be omitted. Only in this case, the --gpu-architecture value can be a non-virtual architecture. The --gpu-code values default to the closest virtual architecture that is implemented by the GPU specified with --gpu-architecture , plus the --gpu-architecture , value itself. The closest virtual architecture is used as the effective --gpu-architecture , value. If the --gpu-architecture value is a virtual architecture, it is also used as the effective --gpu-code value. Example nvcc x.cu --gpu-architecture=sm_52 nvcc x.cu --gpu-architecture=compute_50 are equivalent to nvcc x.cu --gpu-architecture=compute_52 --gpu-code=sm_52,compute_52 nvcc x.cu --gpu-architecture=compute_50 --gpu-code=compute_50", "keywords": []}, {"id": 193, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#shorthand-3", "display_name": "Shorthand 3", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "shorthand-3", "priority": -1, "content": "Both --gpu-architecture and --gpu-code options can be omitted. Example nvcc x.cu is equivalent to nvcc x.cu --gpu-architecture=compute_52 --gpu-code=sm_52,compute_52", "keywords": []}, {"id": 194, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#source-in-ptx-src-in-ptx", "display_name": "--source-in-ptx (-src-in-ptx)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "source-in-ptx-src-in-ptx", "priority": -1, "content": "Interleave source in PTX. May only be used in conjunction with --device-debug or --generate-line-info .", "keywords": []}, {"id": 195, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#sp-bound-check-sp-bound-check", "display_name": "--sp-bound-check (-sp-bound-check)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "sp-bound-check-sp-bound-check", "priority": -1, "content": "Generate stack-pointer bounds-checking code sequence. This option is turned on automatically when --device-debug or --opt-level=0 is specified.", "keywords": []}, {"id": 196, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#split-compile-extended-number-split-compile-extended", "display_name": "--split-compile-extended number (-split-compile-extended)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "split-compile-extended-number-split-compile-extended", "priority": -1, "content": "A more aggressive form of -split-compile . Available in LTO mode only. Extended split compilation attempts to reduce compile time even further by extending concurrent compilation through to the back-end. This agressive form of split compilation can potentially impact performance of the compiled binary. The option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting --split-compile-extended=0 . Setting --split-compile-extended=1 will cause this option to be ignored. This option is only applicable with device Link Time Optimization ( -dlto ) and can work in conjunction with --threads .", "keywords": []}, {"id": 197, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#split-compile-number-split-compile", "display_name": "--split-compile number (-split-compile)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "split-compile-number-split-compile", "priority": -1, "content": "Perform compiler optimizations in parallel. Split compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. It does this by splitting the device code into smaller translation units, each containing one or more device functions, and running optimization passes on each unit concurrently across multiple threads. It will then link back the split units prior to code generation. The option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting --split-compile=0 . Setting --split-compile=1 will cause this option to be ignored. This option can work in conjunction with device Link Time Optimization ( -dlto ) as well as --threads .", "keywords": []}, {"id": 198, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#std-c-03-c-11-c-14-c-17-c-20-std", "display_name": "--std {c++03|c++11|c++14|c++17|c++20} (-std)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "std-c-03-c-11-c-14-c-17-c-20-std", "priority": -1, "content": "Select a particular C++ dialect. Allowed Values c++03 c++11 c++14 c++17 c++20 Default The default C++ dialect depends on the host compiler. nvcc matches the default C++ dialect that the host compiler uses.", "keywords": []}, {"id": 199, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#supported-host-compilers", "display_name": "Supported Host Compilers", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-host-compilers", "priority": -1, "content": "A general purpose C++ host compiler is needed by nvcc in the following situations: During non-CUDA phases (except the run phase), because these phases will be forwarded by nvcc to this compiler. During CUDA phases, for several preprocessing stages and host code compilation (see also The CUDA Compilation Trajectory ). nvcc assumes that the host compiler is installed with the standard method designed by the compiler provider. If the host compiler installation is non-standard, the user must make sure that the environment is set appropriately and use relevant nvcc compile options. The following documents provide detailed information about supported host compilers: NVIDIA CUDA Installation Guide for Linux NVIDIA CUDA Installation Guide for Microsoft Windows On all platforms, the default host compiler executable ( gcc and g++ on Linux and cl.exe on Windows) found in the current execution search path will be used, unless specified otherwise with appropriate options (see File and Path Specifications ). Note, nvcc does not support the compilation of file paths that exceed the maximum path length limitations of the host system. To support the compilation of long file paths, please refer to the documentation for your system.", "keywords": []}, {"id": 200, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#supported-input-file-suffixes", "display_name": "Supported Input File Suffixes", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-input-file-suffixes", "priority": -1, "content": "The following table defines how nvcc interprets its input files: Input File Suffix Description .cu CUDA source file, containing host code and device functions .c C source file .cc , .cxx , .cpp C++ source file .ptx PTX intermediate assembly file (see Figure 1 ) .cubin CUDA device code binary file (CUBIN) for a single GPU architecture (see Figure 1 ) .fatbin CUDA fat binary file that may contain multiple PTX and CUBIN files (see Figure 1 ) .o , .obj Object file .a , .lib Library file .res Resource file .so Shared object file Note that nvcc does not make any distinction between object, library or resource files. It just passes files of these types to the linker when the linking phase is executed.", "keywords": []}, {"id": 201, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#supported-phases", "display_name": "Supported Phases", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "supported-phases", "priority": -1, "content": "The following table specifies the supported compilation phases, plus the option to nvcc that enables the execution of each phase. It also lists the default name of the output file generated by each phase, which takes effect when no explicit output file name is specified using the option --output-file : Phase nvcc Option Default Output File Name Long Name Short Name CUDA compilation to C/C++ source file --cuda -cuda .cpp.ii appended to source file name, as in x.cu.cpp.ii . This output file can be compiled by the host compiler that was used by nvcc to preprocess the .cu file. C/C++ preprocessing --preprocess -E &lt; result on standard output &gt; C/C++ compilation to object file --compile -c Source file name with suffix replaced by o on Linux or obj on Windows Cubin generation from CUDA source files --cubin -cubin Source file name with suffix replaced by cubin Cubin generation from PTX intermediate files. --cubin -cubin Source file name with suffix replaced by cubin PTX generation from CUDA source files --ptx -ptx Source file name with suffix replaced by ptx Fatbinary generation from source, PTX or cubin files --fatbin -fatbin Source file name with suffix replaced by fatbin Linking relocatable device code. --device-link -dlink a_dlink.obj on Windows or a_dlink.o on other platforms Cubin generation from linked relocatable device code. --device-link  --cubin -dlink  -cubin a_dlink.cubin Fatbinary generation from linked relocatable device code --device-link  --fatbin -dlink  -fatbin a_dlink.fatbin Linking an executable &lt; no phase option &gt; a.exe on Windows or a.out on other platforms Constructing an object file archive, or library --lib -lib a.lib on Windows or a.a on other platforms make dependency generation --generate-dependencies -M &lt; result on standard output &gt; make dependency generation without headers in system paths. --generate-nonsystem-dependencies -MM &lt; result on standard output &gt; Compile CUDA source to OptiX IR output. --optix-ir -optix-ir Source file name with suffix replaced by optixir Running an executable --run -run Notes: The last phase in this list is more of a convenience phase. It allows running the compiled and linked executable without having to explicitly set the library path to the CUDA dynamic libraries. Unless a phase option is specified, nvcc will compile and link all its input files.", "keywords": []}, {"id": 202, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#suppress-arch-warning-suppress-arch-warning", "display_name": "--suppress-arch-warning (-suppress-arch-warning)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "suppress-arch-warning-suppress-arch-warning", "priority": -1, "content": "Suppress the warning that otherwise is printed when object does not contain code for target arch.", "keywords": []}, {"id": 203, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#suppress-async-bulk-multicast-advisory-warning-suppress-async-bulk-multicast-advisory-warning", "display_name": "--suppress-async-bulk-multicast-advisory-warning (-suppress-async-bulk-multicast-advisory-warning)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "suppress-async-bulk-multicast-advisory-warning-suppress-async-bulk-multicast-advisory-warning", "priority": -1, "content": "Suppress the warning on use of .multicast::cluster modifier on cp.async.bulk{.tensor} instruction with sm_90 .", "keywords": []}, {"id": 204, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#suppress-debug-info-suppress-debug-info", "display_name": "--suppress-debug-info (-suppress-debug-info)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "suppress-debug-info-suppress-debug-info", "priority": -1, "content": "Do not preserve debug symbols in output. This option is ignored if used without \u2013debug option.", "keywords": []}, {"id": 205, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#suppress-stack-size-warning-suppress-stack-size-warning", "display_name": "--suppress-stack-size-warning (-suppress-stack-size-warning)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "suppress-stack-size-warning-suppress-stack-size-warning", "priority": -1, "content": "Suppress the warning that otherwise is printed when stack size cannot be determined.", "keywords": []}, {"id": 206, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#system-include-path-isystem", "display_name": "--system-include path,... (-isystem)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "system-include-path-isystem", "priority": -1, "content": "Specify system include search paths.", "keywords": []}, {"id": 207, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#target-directory-string-target-dir", "display_name": "--target-directory string (-target-dir)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "target-directory-string-target-dir", "priority": -1, "content": "Specify the subfolder name in the targets directory where the default include and library paths are located.", "keywords": []}, {"id": 208, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#the-cuda-compilation-trajectory", "display_name": "The CUDA Compilation Trajectory", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "the-cuda-compilation-trajectory", "priority": -1, "content": "CUDA compilation works as follows: the input program is preprocessed for device compilation and is compiled to CUDA binary ( cubin ) and/or PTX intermediate code, which are placed in a fatbinary. The input program is preprocessed once again for host compilation and is synthesized to embed the fatbinary and transform CUDA specific C++ extensions into standard C++ constructs. Then the C++ host compiler compiles the synthesized host code with the embedded fatbinary into a host object. The exact steps that are followed to achieve this are displayed in Figure 1 . The embedded fatbinary is inspected by the CUDA runtime system whenever the device code is launched by the host program to obtain an appropriate fatbinary image for the current GPU. CUDA programs are compiled in the whole program compilation mode by default, i.e., the device code cannot reference an entity from a separate file. In the whole program compilation mode, device link steps have no effect. For more information on the separate compilation and the whole program compilation, see Using Separate Compilation in CUDA . CUDA Compilation Trajectory", "keywords": []}, {"id": 209, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#threads-number-t", "display_name": "--threads number (-t)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "threads-number-t", "priority": -1, "content": "Specify the maximum number of threads to be used to execute the compilation steps in parallel. This option can be used to improve the compilation speed when compiling for multiple architectures. The compiler creates number threads to execute the compilation steps in parallel. If number is 1, this option is ignored. If number is 0, the number of threads used is the number of CPUs on the machine.", "keywords": []}, {"id": 210, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#time-filename-time", "display_name": "--time  filename (-time)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "time-filename-time", "priority": -1, "content": "Generate a comma separated value table with the time taken by each compilation phase, and append it at the end of the file given as the option argument. If the file is empty, the column headings are generated in the first row of the table. If the file name is - , the timing data is generated in stdout.", "keywords": []}, {"id": 211, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#trademarks", "display_name": "Trademarks", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "trademarks", "priority": -1, "content": "NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.", "keywords": []}, {"id": 212, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#undefine-macro-def-u", "display_name": "--undefine-macro def,... (-U)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "undefine-macro-def-u", "priority": -1, "content": "Undefine an existing macro during preprocessing or compilation.", "keywords": []}, {"id": 213, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#use-fast-math-use-fast-math", "display_name": "--use_fast_math (-use_fast_math)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "use-fast-math-use-fast-math", "priority": -1, "content": "Make use of fast math library. --use_fast_math implies --ftz=true --prec-div=false --prec-sqrt=false --fmad=true .", "keywords": []}, {"id": 214, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#use-local-env-use-local-env", "display_name": "--use-local-env (-use-local-env)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "use-local-env-use-local-env", "priority": -1, "content": "Skip MSVC environment initialization. By default nvcc assumes that the MSVC environment needs to be initialized. This is done by executing the appropriate command file available for the MSVC installation detected or specified. Initializing the environment for each nvcc invocation can add noticeable overheads. If the environment used to invoke nvcc has already been configured, this option can be used to skip this step.", "keywords": []}, {"id": 215, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#using-cuda-arch", "display_name": "Using __CUDA_ARCH__", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "using-cuda-arch", "priority": -1, "content": "In separate compilation, __CUDA_ARCH__ must not be used in headers such that different objects could contain different behavior. Or, it must be guaranteed that all objects will compile for the same compute_arch. If a weak function or template function is defined in a header and its behavior depends on __CUDA_ARCH__ , then the instances of that function in the objects could conflict if the objects are compiled for different compute arch. For example, if an a.h contains: template&lt;typename T&gt; __device__ T* getptr(void) { #if __CUDA_ARCH__ == 500 return NULL; /* no address */ #else __shared__ T arr[256]; return arr; #endif } Then if a.cu and b.cu both include a.h and instantiate getptr for the same type, and b.cu expects a non-NULL address, and compile with: nvcc --gpu-architecture=compute_50 --device-c a.cu nvcc --gpu-architecture=compute_52 --device-c b.cu nvcc --gpu-architecture=sm_52 a.o b.o At link time only one version of the getptr is used, so the behavior would depend on which version is picked. To avoid this, either a.cu and b.cu must be compiled for the same compute arch, or __CUDA_ARCH__ should not be used in the shared header function.", "keywords": []}, {"id": 216, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#using-separate-compilation-in-cuda", "display_name": "Using Separate Compilation in CUDA", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "using-separate-compilation-in-cuda", "priority": -1, "content": "Prior to the 5.0 release, CUDA did not support separate compilation, so CUDA code could not call device functions or access variables across files. Such compilation is referred to as whole program compilation . We have always supported the separate compilation of host code, it was just the CUDA device code that needed to all be within one file. Starting with CUDA 5.0, separate compilation of device code is supported, but the old whole program mode is still the default, so there are new options to invoke separate compilation.", "keywords": []}, {"id": 217, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#variables-used-variables-used", "display_name": "--variables-used (-variables used)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "variables-used-variables-used", "priority": -1, "content": "Specify variables that are used. Can be part of a variable name so any variable with that string in name are matched. If this option is used, then any other variables are considered dead-code and potentially removed unless have other accesses from device code.", "keywords": []}, {"id": 218, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#verbose-v", "display_name": "--verbose (-v)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "verbose-v", "priority": -1, "content": "List the compilation sub-commands while executing them.", "keywords": []}, {"id": 219, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#version-v", "display_name": "--version (-V)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "version-v", "priority": -1, "content": "Print version information on this tool.", "keywords": []}, {"id": 220, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#virtual-architecture-feature-list", "display_name": "Virtual Architecture Feature List", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "virtual-architecture-feature-list", "priority": -1, "content": "compute_50 , compute_52 , and compute_53 Maxwell support compute_60 , compute_61 , and compute_62 Pascal support compute_70 and compute_72 Volta support compute_75 Turing support compute_80 , compute_86 and compute_87 NVIDIA Ampere GPU architecture support compute_89 Ada support compute_90 , compute_90a Hopper support The above table lists the currently defined virtual architectures. The virtual architecture naming scheme is the same as the real architecture naming scheme shown in Section GPU Feature List .", "keywords": []}, {"id": 221, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#virtual-architecture-macros", "display_name": "Virtual Architecture Macros", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "virtual-architecture-macros", "priority": -1, "content": "The architecture identification macro __CUDA_ARCH__ is assigned a three-digit value string xy0 (ending in a literal 0 ) for each stage 1 nvcc compilation that compiles for compute_xy . This macro can be used in the implementation of GPU functions for determining the virtual architecture for which it is currently being compiled. The host code (the non-GPU code) must not depend on it. The architecture list macro __CUDA_ARCH_LIST__ is a list of comma-separated __CUDA_ARCH__ values for each of the virtual architectures specified in the compiler invocation. The list is sorted in numerically ascending order. The macro __CUDA_ARCH_LIST__ is defined when compiling C, C++ and CUDA source files. For example, the following nvcc compilation command line will define __CUDA_ARCH_LIST__ as 500,530,800 : nvcc x.cu \\ --generate-code arch=compute_80,code=sm_80 \\ --generate-code arch=compute_50,code=sm_52 \\ --generate-code arch=compute_50,code=sm_50 \\ --generate-code arch=compute_53,code=sm_53", "keywords": []}, {"id": 222, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#virtual-architectures", "display_name": "Virtual Architectures", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "virtual-architectures", "priority": -1, "content": "GPU compilation is performed via an intermediate representation, PTX, which can be considered as assembly for a virtual GPU architecture. Contrary to an actual graphics processor, such a virtual GPU is defined entirely by the set of capabilities, or features, that it provides to the application. In particular, a virtual GPU architecture provides a (largely) generic instruction set, and binary instruction encoding is a non-issue because PTX programs are always represented in text format. Hence, a nvcc compilation command always uses two architectures: a virtual intermediate architecture, plus a real GPU architecture to specify the intended processor to execute on. For such an nvcc command to be valid, the real architecture must be an implementation of the virtual architecture. This is further explained below. The chosen virtual architecture is more of a statement on the GPU capabilities that the application requires: using a smaller virtual architecture still allows a wider range of actual architectures for the second nvcc stage. Conversely, specifying a virtual architecture that provides features unused by the application unnecessarily restricts the set of possible GPUs that can be specified in the second nvcc stage. From this it follows that the virtual architecture should always be chosen as low as possible, thereby maximizing the actual GPUs to run on. The real architecture should be chosen as high as possible (assuming that this always generates better code), but this is only possible with knowledge of the actual GPUs on which the application is expected to run on. As we will see later in the situation of just-in-time compilation, where the driver has this exact knowledge, the runtime GPU is the one on which the program is about to be launched/executed. Two-Staged Compilation with Virtual and Real Architectures", "keywords": []}, {"id": 223, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#warn-on-double-precision-use-warn-double-usage", "display_name": "--warn-on-double-precision-use (-warn-double-usage)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "warn-on-double-precision-use-warn-double-usage", "priority": -1, "content": "Warning if double(s) are used in an instruction.", "keywords": []}, {"id": 224, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#warn-on-local-memory-usage-warn-lmem-usage", "display_name": "--warn-on-local-memory-usage (-warn-lmem-usage)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "warn-on-local-memory-usage-warn-lmem-usage", "priority": -1, "content": "Warning if local memory is used.", "keywords": []}, {"id": 225, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#warn-on-spills-warn-spills", "display_name": "--warn-on-spills (-warn-spills)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "warn-on-spills-warn-spills", "priority": -1, "content": "Warning if registers are spilled to local memory.", "keywords": []}, {"id": 226, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#warning-as-error-werror", "display_name": "--warning-as-error (-Werror)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "warning-as-error-werror", "priority": -1, "content": "Make all warnings into errors.", "keywords": []}, {"id": 227, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wdefault-stream-launch-wdefault-stream-launch", "display_name": "--Wdefault-stream-launch (-Wdefault-stream-launch)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wdefault-stream-launch-wdefault-stream-launch", "priority": -1, "content": "Generate warning when an explicit stream argument is not provided in the &lt;&lt;&lt;...&gt;&gt;&gt; kernel launch syntax.", "keywords": []}, {"id": 228, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#werror-kind-werror", "display_name": "--Werror kind,... (-Werror)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "werror-kind-werror", "priority": -1, "content": "Make warnings of the specified kinds into errors. The following is the list of warning kinds accepted by this option: all-warnings Treat all warnings as errors. cross-execution-space-call Be more strict about unsupported cross execution space calls. The compiler will generate an error instead of a warning for a call from a __host__  __device__ to a __host__ function. reorder Generate errors when member initializers are reordered. default-stream-launch Generate error when an explicit stream argument is not provided in the &lt;&lt;&lt;...&gt;&gt;&gt; kernel launch syntax. missing-launch-bounds Generate warning when a __global__ function does not have an explicit __launch_bounds__ annotation. ext-lambda-captures-this Generate error when an extended lambda implicitly captures this . deprecated-declarations Generate error on use of a deprecated entity.", "keywords": []}, {"id": 229, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wext-lambda-captures-this-wext-lambda-captures-this", "display_name": "--Wext-lambda-captures-this (-Wext-lambda-captures-this)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wext-lambda-captures-this-wext-lambda-captures-this", "priority": -1, "content": "Generate warning when an extended lambda implicitly captures this .", "keywords": []}, {"id": 230, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wmissing-launch-bounds-wmissing-launch-bounds", "display_name": "--Wmissing-launch-bounds (-Wmissing-launch-bounds)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wmissing-launch-bounds-wmissing-launch-bounds", "priority": -1, "content": "Generate warning when a __global__ function does not have an explicit __launch_bounds__ annotation.", "keywords": []}, {"id": 231, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wno-deprecated-declarations-wno-deprecated-declarations", "display_name": "--Wno-deprecated-declarations (-Wno-deprecated-declarations)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wno-deprecated-declarations-wno-deprecated-declarations", "priority": -1, "content": "Suppress warning on use of a deprecated entity.", "keywords": []}, {"id": 232, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wno-deprecated-gpu-targets-wno-deprecated-gpu-targets", "display_name": "--Wno-deprecated-gpu-targets (-Wno-deprecated-gpu-targets)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wno-deprecated-gpu-targets-wno-deprecated-gpu-targets", "priority": -1, "content": "Suppress warnings about deprecated GPU target architectures.", "keywords": []}, {"id": 233, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#wreorder-wreorder", "display_name": "--Wreorder (-Wreorder)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "wreorder-wreorder", "priority": -1, "content": "Generate warnings when member initializers are reordered.", "keywords": []}, {"id": 234, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#x-c-c-cu-x", "display_name": "--x {c|c++|cu} (-x)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "x-c-c-cu-x", "priority": -1, "content": "Explicitly specify the language for the input files, rather than letting the compiler choose a default based on the file name suffix. Allowed Values c c++ cu Default The language of the source code is determined based on the file name suffix.", "keywords": []}, {"id": 235, "doc_id": 236, "filename": "index.html", "domain_name": "page", "name": "index#xptxas-xptxas", "display_name": "--Xptxas (-Xptxas)", "type": "section", "display_type": "Page section", "docname": "index", "anchor": "xptxas-xptxas", "priority": -1, "content": "Ptxas options (only used with LTO).", "keywords": []}, {"id": 236, "doc_id": 236, "filename": "index.html", "domain_name": "std", "name": "index", "display_name": "Introduction", "type": "doc", "display_type": "Page", "docname": "index", "anchor": "", "priority": -1, "content": "NVIDIA CUDA Compiler Driver NVCC The documentation for nvcc , the CUDA compiler driver.", "keywords": []}]};